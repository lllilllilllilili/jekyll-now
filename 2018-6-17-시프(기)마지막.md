---
post : layout
title : 시프(기)마지막
---
## 시프(기)마지막

## Changing the break value

# Process Address Space
글로벌 벨리어블 데이터로 들어가야되는데 이니셜라이즈 한거는 초기값이 있어야 되니까 컴파일 할때 a.out에 실행파일에 들어가야 되고 
bss는 이것은 이니셜라이즈를 안했기떄문에 크기만 알면 나중에 로드를 할때 디스크에서 읽어올필요가 없이 크기만큼 잡아주면ㄷ ㅚ기
떄문에 디스크 아이오를 할려고 이거를 나눠놨다고 얘기했고
버츄얼 메모리에서 상세하게 다루게 된다.

브레이크 
이거는 여기를 나타나는 글로벌 벨리어블 로 이제 프로그래머들이 쓸수가있는그런 베리어블이다 이거임
이거를 읽어보면 이 위치가 어딘지를 다 알수가 있다 이런얘기다.
이제 브레이크는 처음에 힙이 시작하는 공간에 잇다가 엠얼록 하면 힙에서 하는데 차츰차츰 자라난다.
브레이크 값은 변한다. 힙이 커지면 커질수록

둘다 이 힙에 끝을 가져다 설정하는건데 할필요가 없다.
엠멀럭 해서 힙이 필요하게 되면 자동으로 커지기 때문에 할필요는 없는데
인제 여러가지 이유에서 이거할떄가 있다 
이거는 힙의 끝주소, 포인터 주는방법
지금있는 힙에서 인크리먼트만큼 힙을 어떻게해라? 증가를 시켜달라 이런 얘기다.

## brk(2), sbrk(2) example(1)
쓰인애들 보면 먼저
변수에다가 sbrk(0) 
새로 할당만 메모리 블럭의 시작주소이므로
변수에는 메모리 블락 시작주소가 담긴다.
etext edata end 
이 글로벌 배리어블 인데 exten 인데 유니스트.h 가있겠죠
내 프로그램 이 돌아가면 텍스트 의 끝부분의 주소가 여기 들어간다 데이터의 끝부분의 주소가 여기들어가있고 
자기프로그램에 시그먼트 주소를 알수가 있다.
이거를 각각 찍어봤다
데시멀 포맷으로 그래서 이게 이제 주소가 나온다 
텍스트의 끝부분이 어딘가 데이터의 끝부분이 어딘가 end는 bss에 끝이 어딘가를 찍어보는 주소를
그리고  sbrk(0)라는건 원래 브레이크 포인트를 어떻게해? 증가시키는
0은 증가시키지 마 현재 있는값을 브레이크값 리턴
여기 뭐가 리턴? 힙의 끝주소가 리턴된다.
힙의 끝주소 찍어본것
프로그램을 돌릴때
이 각각의 주소 찍어봄

## 
breakv 
1024 를 더했으므로??
breakv 인데
브레이크 인데 
힙을 1k 늘려라 
이런것들 찍어본다 주소를 

## 
내프로그램에 코드 부분이 끝나는 자리에 주소를 찍어봄
그게 etext 
데이터가 
브레이크 이렇게 끝난ㄴ다고 가정
내 프로그램에 이메모리 로드된 자리임
메모리에 프로그램이 로드가 되있는데
텍스트끝나는자리 이거
찍어봤다
이거 지금 돌렸을때 나왔다
한참있다가 또 돌리면 똑같은 값이 나올까요?
같은값이 나옴
이 프로그래 ㅁ돌리면 
내프로그램이 돌아갈려면 메모리 올라가야댐
메모리 나혼자 쓰지 않음
프로세스 여러개 씀
메모리 빈자리 찾아서 내 프로그램이 올라가야 돌아감
메모리 어딘가 올라가서 찍힘
다음날 돌림
메모리 사정이 다름
빈자리가 다른자리임
다른 자리로 올라가면 값이 다르게 나올꺼임
결론부터 다른 자리로 올라가는건 다르지 않음
이거는 똑같이 나옴
매일 똑같이 나옴 이 주소는 가짜주소다.
다음학기 오에스 시간에 배우기
버츄어 메모리 라는걸 씀
버츄얼리얼리티 안에있는게 가짜다 메모리도 가짜메모리를 쓴다 os가
가짜 메모리 뜻은 cpu를 속이는것임
여러분들 속음
이거는 메모리 실제 어디로 들어가는지 상관없이 메모리에 커널하고 나만있다고 생각 버츄얼리티 가상메모리 처럼 생각해서 거기에 0번지서부터 프로그램이 올라간거임 프로세스 100 , 1000개 가 있든 얘를 돌려도 0번지에 로드가 됨
같은 자리 못올라감 , 가짜주소
가짜주소 cpu도 속음 여기에 1000 1080c 에서 그 자리에서 인스트럭션 가지고옴
중간에 다른 하드웨어가 진짜 메모리주소로 바꿔치기하는 메카니즘 이 존재
이 프로세스 하고 이 프로세스가 메모리 다른자리에 올라와있음에도 cpu는 똑같이 0번지에서 시작한다고 생각하는데 버츄얼 메모리 라고한다
버츄얼 메모리 는 무지하게 장점이 많아서 os에서 제일 많은 포션을 사용하는게 버츄얼 메모리 관리가 복잡
여기는 버츄얼 리얼리티 있는것처럼 가짜 주소다.
버츄얼 어드레스라서 상관없다 cpu도 속아넘어감 그리고 아까
여기 힙이있잔아요 힙은 우리가 뭐할때 사용? 엠얼럭 사용
엠얼럭 을 할때 어떤 사람은 천바이트 달라고 할때도 있고 500바이트 달라고할떄도 이고 2k
힙을 관리 하는 입장에서 곤란, 붙어있는 자리 줘야댐
이 힙의 공간이 엠얼럭 프리 막 구멍이 생김 거기서 이 2k짜리 달라고 하면 힙에서 2k라는 연속된 빈공간 찾아가야댐 그러니까 malloc이 간단한게 아님 빈공간이 찾아야 되는 메커니즘이 있다
실시간 프로그램, 리스판스 빠른 프로그램 데드라인 걸린프로그램 짤때는 커널의 힘을 의존하지 않고 자기가 힙을 만드는경우가있다.
프로그램 시작할때 엠얼럭을 자기가 엄청 받는다.
500k 엠얼럭 받아놓고 자기가 사이즈 벨리유? 자기가 구분해서 자기가 관리
엠얼럭 하는걸 자기가 힙 프로그램 가지고 돌릴수있다. 실제 실시간 프로그래밍은 그렇게 할수있다 이건 커널이 제공하는 힙에 관한 얘기다.
## dynamic memory allocation
엠얼록은 사이즈 만큼

calloc은 앞부분에 사이즈만큼 메모리 할당 대신 0으로 초기화된다.
10바이트 10개 달라고 하면 100바이트 해서줌 곱하기 해서줌

free 할당매모리 해제
동적할당해서 프로그램을
1년 365일 계속 짜는 프로그램 짤려고하는데 어디선가 불필요할때 free해야댐
malloc 하다보면 나중에 공간이 꽉차서 프로그램이 죽음
메모리릭
c++ malloc -> new
free -> delete 
## dynamic memory allocation example
주소를 찍어주는거임 힙에 어딘가 주소가 된다.
이주소도 맨날 똑같냐? 
이주소도 똑같을 것이다.
어플리케이션 디펜던트
//포인터주소 말하는듯

스트링 카피 통해서 복사한다.
출력을 하면 ppt에는 위에랑 아래가 다르게 나오는데 똑같았다.
이건 프리로 하면 다시 커널이 
포인터의 값은 변하지 않으니까
이렇게 하고 나서 이런짓을 하면 
이메모리로 커널이 반납이 하기 때문에 

## malloc vs calloc
초기화 시키는것 안시키는것

## memory resuse
크기를 변경하는 함수
ptr에 0을 써주면 앞에서 설명한 malloc 똑같은 의미
사이즈가 0이면 calloc 과 똑같음

이거는 왜쓸까요
내가 malloc을 1k할당
이 할당한것을 사용끝
free 할라고함
또 malloc을 가져다 500바이트 하고싶음
그런경우 이미 할당해놓은 재사용하면 커널로 갔다 찾는 시간이 줄어듬
이미 할당했음
커널의 할당받는 시간을 줄이기 위해 사용하기위함
다른 사이즈로 사용가능하다.

현재함수 스택영역에서 메모리형성
이건 alloca 
펑션 속에 로컬 벨리어블 잡는건 스택에 잡힘
펑션에서 리턴하면 스텍 프레임이 날라가니까 로컬 베리어블도 자동으로 업어지기때문에
그런 로컬베리어블 무슨 베리어블? 오토매틱 베리어블
이거는 이제 malloc은 스택에서 한거
펑션에서 리턴하면 스택에 없어지니까 자동빵으로 업어짐
쓰면 malloc 하면 free 하는번거로움 없음
에러 방지
펑션에서 쓰는거는 이걸 쓰면되겠다

## Memory Reuse Example(1)
ptr 크기 변경

22바이트 달라고하면 커널이 22바이트만 주는건아님
2의 배수다.
기본으로 아마 128바이트할당
이거 보다 더 크면 256 바이트 할당
이런식
22바이트 달라고 하면 더 큰 메모리 할당
여기서 50바이트 할당 해서 쓰겠다 신고
재할당 시간을 벌었다.

## 메모리맵트파일
디스크에 파일이 있으면 오프셋 떨어진 부분부터 
길이만큼 가지고 어드레스부터 그 다른 공간으로 맵핑

전에 오픈한 파일에 시작에서 부터 오프셋만큼 가서 
그다음에 이 길이만큼 파일에 있는것을 어디에 맵핑? 메모리에 이주소에다가 맵핑을 해서 그 메모리에다가 read/write 하면
메모리에서 read하면 파일에서 읽어오는것이고 메모리에서 write하면 파일에다가 쓰는것이다.
그런데 이 주소가 마땅치않을떄에는 null을 주면 적당한 데를 잡아서 그 맵핑된 주소값을 일로 돌려준다.
자기가 어디다 맵핑을 할지 모르니까
그런 경우에는 이거 메모리 맵트파일을 갖다 사용할때쓰는게 mmap 이다.
이거 어떨때 쓴다고 했음?
내가 예제를 
워게임 시뮬레이션 을지로 가디언 프리덤
워게임 시뮬레이션
들어오는거 전략적 움직이는게 아니라
근데 베리어블 몇천개 있을것이다.
이런 베리어블 값을 가져다가 자동으로 파일에 세이브 기를 원하잔아요 그런 베리어블들의 메모리공간을 파일에 맵핑해놓으면
시뮬레이션이 파일에 백업이 된다.
몇일씩 돌아가는 프로그램에 메모리 베리어블, 스트럭쳐 데이터 많이있으면 파일에 맵핑해서 자동으로 세이브 한다.이게 메모리 맵트파일이다.

## 아규먼트 플레그
공유할것인가안할껏인가
맵쉐어드 - 메모리 맵핑하고 메모리 write 하면 파일까지 가는데 만일에 파일이 하나있고 이 프로세스가 그 파일을 내메모리 공간에 맵핑을 했어 다른 프로세스가 이 파일을 자기공간에 맵핑을 했으면 이사람이 쓰면 나도 볼수가 있는거다 그래서 이런경우
맵쉐어드 하면 프로세스간에 통신에도 사용이된다.
맵 프라이빗 - 그냥 파일에서 카피본을 내 메모리로 맵핑해서 읽어오는게 끝나는거임 내가 파일에다가 메모리에다가 쓴다고 하더라도 그게 어디로가까지 가지 않습니까? 파일까지 가지 않는다. 
파일의 일부 메모리에다 맵핑해서 읽어오기 위한 수단으로서 사용하는게 맵 프라이빗 이다. 
그래서 맵 프라이빗 으로 맵핑하면 프로세스간에 통신이 아님 파일을 가져다 쓸수가 업으니까 그냥 나는 카피만 가지고온것이다.
맵픽스드 - 아까 여기서 내가 메모리에 몇번지에 맵핑할걸 주는데 이거가 마땅 치 않으면 커널이 적당한 주소가 맵핑을 해줌
맵 픽스드 반드시 내가 너 지정한 장소에다 맵핑을해라

## munmap()
그리고 이함수는 메모리 맵 
해제하는 함수
아까 어떤 메모리에다 맵핑을 하면 그자리에서부터 길이 만큼을 줘서 그것을 맵핑을 , 파일하고 맵핑을 해제하는것임
1000바이트 맵핑했는데 500바이트 언맵핑하면 500바이트 나머지 맵핑되있는거는 살아남아있는것이다.

## File Copy Example(1)
fdin 은 첫번째 입력한 값이 오픈되서 저장이 되고
fdout 두번쨰 입력한 값이 저장되어 오픈

파일 아규먼트 1 파일을 가져다 읽어가지고 아규먼트2 로 받은 파일에다가 뭐 할려고? 복사를 할려고
top - down 
여기서 아규먼트 벡터1 -> 벡터2 로 크리에이트 카피하는것임
뭘 이용해서 메모리 맵트 파일로 이용해서
그래서 소스에는 fdin에서 
인풋 파일 가져다 맵핑을 했다.
인풋 파일을 뭐만큼 맵핑? statbuf에 st_size 만큼 파일의 크기는 이걸로 읽어올수있음

파일의 크기를 알려면 파일의 크기만큼 메모리에다 맵핑을 하라 리드 모드로 
맵 쉐어드 이고 그다음에 조금전에 오픈한 파일을 맵핑을한다. 
주소는 나는 모른다 니가 커널이 알아서 메모리에 적당한데다가 카피를 , 맵핑을 해주고 그주소를 어디에 돌려줘? 소스에 돌려줘

여기 이게 디스크 파일이있으면 이게 st.size다. 
여기있으면 이거를 가져다 메모리에다 맵핑
이주소가 뭐가되는거에요 지난번에 얘기했지만 소스가 되는거고 이거는 커널이알려줌 
두번째 맵핑할려면 또 똑같은 크기만큼 맵핑을 한다. 이거를 가져다 파일을 하나 만들어서 이것도 맵핑하는데 
destination? 타겟이다. 타겟에 맵핑하는데 

전에 기억이 날꺼다 이 거는 원래 있었던 파일이고 지금 만든 파일이다. 새로 만든 파일이다. 크기가 없기떄문에 맵핑이 안된다. 그래서
이 끝으머리로 가서 이 끝자리 에다가 뭘 통해서 가죠 lseek 로 통해서 가야되지 
가가지고 여기다가 뭐 블랭크 가 됫던지 뭔 한글자를 써야됨 그래야지 파일의 크기가 이크기랑 똑같해 지기 떄문에 
and then we can map 맵핑을 할수있다. 

이거를 한다음에 맵핑해야댐
인풋 파일의 사이즈 만큼의 -1번지로 가잔아요 아웃풋 파일의 요기로 가잔아요 lseek을 통해서
거기에다가 뭘쓰냐 아무글자나 쓰고 나서 그래야지 파일의 크기가 커지기때문에 그리고 나서 뭘할수있냐? 맵핑을 한다. 
## 
복사해주는 함수 
메모리 카피니까 어디서 어디로 복사? 
메모리의 여기를 이 파일에다가 맵핑했고 이부분을 이 타켓파일에다가 맵핑을 했으니까 
여기에서 일로 메모리에서 메모리로 카피하는게 메모리 카피라고 
메모리에서 메모미로 카피하면 어떻게 됬단 얘기? 파일에서 파일로 카피가 일어났다 이거임 

## 메모리 카피
메모리의 요주소에서부터 요주소까지 
사이즈만큼 그냥 무식하게 복사를해라 
그러는게 메모리 카피 

그리고 이함수는

## Synchronization of mapped area to HDD
앞에 어드레스 부터 길이에 해당하는 크기 만큼을 그 계속 같이 동기화 시켜주는 함수이다.

요렇게 파일하고 메모리 맵핑했다 치자
내가 메모리에다 라이트 하면 그게 어디까지? 파일까지 가야댐
그런데 사실은 파일까지 간게 아니라 페이지 캐시 까지 감, 
버퍼링 하니까
그러니까 페이지 캐시 에서 디스크에서 갈수도 안갈수도 , 페이지 캐시는 디스크로 생각 메모리에 있지만 
그래서 그거를 완전히 디스크 에다 써주는거 싱크한다라고 하잔아
메모리 에 어느부분에 대해서 디스크에 대해서 확실하게 써라
에이 싱크라는건 기다리는게 아니라 안기다리겠다 너 그냥 싱크로나이즈해라 난 단일 하겠다 이건 디스크에 쓰지 못하더라도 리턴이된다.
디스크에 커널은 막하고 있고 난 단일 할수있음
싱크모드로 하면은 디스크 에 완벽하게 쓸때까지 나는 여기서 기다리겠다  라는 뜻이된다. 

목요일날 시험보고 프로그램 몇개 짜야댐 외워가지고 되는게 아님
외워야 되는것도 잇겟지만 