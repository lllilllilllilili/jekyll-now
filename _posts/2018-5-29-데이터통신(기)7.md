---
post : layout
title : 데이터통신(기)7
---
## 숙제
### 6번
n이라는 숫자가 필요하고 k 이 두가지만
k는 두번째 stage에 cross bar의 개수가 이런게 되고
그때 최소화할수있는 n은 루트2분에 n임
(이 관계는 앞에있음)
이거 이용해서푼다
먼저 이 k를 구하기 위해서는 먼저 n이 구해져야한다.
n이 구해져야 중간단계 stage 개수가 나온다.
n이 100이니까 
n을 8로 둬야한다.
n이 8이면 8개가 들어오면 몇개가 토탈 100개임
토탈 100개면은 인풋 
first stage에 13개가 필요함
13개를 쓰면은 그러다고 덜쓸수 없음 남길수밖에 없음 13개가 104개임 그러면 맨끝에있는 13번쨰 놈은 4개만 들어온다.
4개는 그냥 없는거임 인풋이
그렇게 활용한다.
여기까지 토탈이 100개가 만들어지고 그다음에 이 중간스테이지에 15개 굉장ㅎ ㅣ많음
15개인데 13개가 들어와야하니까 13 by 13 임 이런게 15개가 있음
마찬가지로 뒤에 똑같이 이 사이즈는 8 by 15 
15 by 8 
13개가 있어야댐 
입력단과 출력단은 동일해야함 13개가 있어야함 합이 100개 아웃풋이나와야댐
그리고 이들간에 커넥션은 얘들이 각각 한 stage씩 중간 stage에 연결하는 방식임
이렇게 
다 이 중간스테이지에 한줄씩 연결되는 형태로 그려진다 여기도 마찬가지로 한줄씩 연결되는 형태로 그리고 
이렇게 자 그러면 
쭉 그리면 토탈 크로스바 개수가 몇개나오고 해서 이렇게 6번에서 cros criterian 을 적용해서 구한 크로스바 개수와 
5번 에서 구한 크로스바의 개수를 비교를 해볼 수있다.
전체 하나의 그 크로스바 스위치를 쓴다고 하면 100 by 100 = 10000개가 필요한데
cros criterian을 적용했을때 몇개 
저것보다 적은지 확인을 해보고 
커넥션을 생각하면 이 개수만큼 온다.
k는 얘들의 개수 몇개

5번에 c번 - 이렇게 했다고 합시다. 5번에 c번 지금 이 여기 
## 5번에 c번
first stage 10개 중간에 4개 자 저거는 굉장히 간단한 구조를 보여주고 있음
10 by 10 이거는 4개 밖에 없는데 얘의 구조는 10 by 10 
10 각각 하나 씩 들어오니까 
크로스포인트 개수 뭐 c번
동시에 가능한 커넥션의 개수가 몇개냐?
동시에 가능한 커넥션의 개수 이놈이 좌우한다. 얘가지금 동시에 여기에 올 수 있는게 몇개야? 토탈 10개임
여기에도 토탈 10개 올 수 있다. 여기에 10개 여기에 10개
40개는 일단 10개가 어디서 오느냐 여기서 얘가 하나갖고
여기서 여기 하나가고 여기서 
한번 쭉 그 
여기서 이 열명중에 여기로 밖으로 나갈 수 있는 
여기로 올 수 있는건 하나밖에 없음 유일함
또 여기로 올 수있는건 하나밖에 없고
이중에 4개만이 4개만이 동시에 call을 (커넥션 말하는건가?) 만들수 있다.
중간 스테이지에 갈 수있는길이 4개밖에 없다. 이 스테이지가 4개밖에없어서 
그러니까 10명이 들어왔는데도 불구하고 
4명만이 지금 동시에 콜을 만들수가 있다.
그러면 여기도 마찬가지
여기도 10명이 들어왔는데 동시에는 4명만이 나갈 수있다.
모든 모듈이 4명만이 나갈수있어 동시에 
그러면 동시에 40명이 만들 수있다. 오로지 여기서 4명 4명 4명 해서 10개가 있으니까 
40명만이 동시에 나갈 수있고 걔들은 일단 이 중간스테이지 에서 온애들은 또 여기서 동시에 4개씩 나갈 수있다.
일단 들어온 애들은 똑같은 미러이미지니까 똑같은 패스가 다 이렇게 제공이 가능하다.
세번째 스테이지에서 
여기까지 과연 몇개가 올 수있는가를 따져보면 
동시에 40개가 올 수있다.
40개.
길이 40개 동시에 만들어질 수있는길이 40개 밖에안됨
그러면 아까 cros 로 하면 동시에 몇개가 될까?
이 문제를 다시 푸는데 cros criterian을 적용했을경우에 동시에 몇개가 나오냐
그문제를 가야됨 
요걸 또 바꿔서 이게 이제 15개 가 있는거임이게
여기는 8명으로 아까문제로 다시 돌아가고
cros 바꿧다 이거임 8명씩 
여기는 15개
이 토탈 15개 
그러면 어떻게되냐 
이 8명이있는데 갈 수있는길이 15개나 있어
여기 쭉 15개가 있단말이야 
이 ???? 블락이 저기 스테이지에 8명밖에 안들어왔다
8명 저기 15개가 있어 다 가능하단 말이야
여기도 다 가능하고
여기도  다 가능하고 우리가 기본적으로 이거를 구한 cros criterian에서 구한 이 원칙이 뭐였냐
모든 커넥션이 다 연결이 가능하다는 목표를 이루기 위해서 과연 
중간 스테이지 몇개필요하냐 이거 구하는거였음
당연히 이걸 통해서 만들어진 이 크로스 크라이테리언 적용해서 만든 이 스위치는 모든 커넥션이다 동시에 연결이 가능한것임
그래서 이거는 100개가 다 가능하다.
이스위치
여기8개가 다 가능하잔아 15개로 나갈수있고
모든 첫번쨰 블락에서 15개로 나갈 수있다. 8개밖에 없는데 인풋이
다 나갈수있다.
그리고 여기서 다
이 뒤에도 똑같은 이미지로 수용이되고 그래서 여기는 크로스 크라이테리언을 적용하니까 
아까 40개밖에 동시에 수용할 수없었던것이 100개가 된다. 
모든 가입자가 다 동시에 콜을 만들수가있다.(이게 중요한말인듯)

굉장히 그게 바로 우리가 원하던 것이었다.
구지 이걸 왜구했어
이걸 구한 이유가 모든 유저가 동시에 
항상 길이 있어야한다 라는게 보장이 되는 중간 스테이지 모듈의 개수 이것을 구함 목표가 그거였음 모든
모든 유저에게 패스가 제공되야 한다. 당연히 100 가입자가 다 동시에 어, 그 연결을 갖을 수있어야한다.

## 10장
9장은 끝남 지난시간에 
9장의 두벗째 파트 arp 라는 프로토콜을 이용해서 하나의 패킷이 목적지 까지 가는데 그 링크 바이 링크로 어떻게 전달이 되는지
에 대한 내용은 여러분들 다 배운것이다.
책에 내용을 잘 살펴봐라  이미 학교초에 이미 들여다 본 내용이다.

## 10, Error Detection and Correction
사실 이 10장은 그냥 10장에서 하고자 하는 내용이 뭔가
아주 한마디로 제목속에 다 들어있는데 
자 내가 그 언제 한번 얘기한적이있음
내기계에서 뭐 네트워크를 통해서 데이터를 b가 받았어 
그런데 받아보니까 1011011 자 이런 데이터가 왔다.
b가 받았다 a로부터
이게 지금 이게 a로부터 왔는지 틀린지 b가 어떻게 아냐 이거임
실제 정말 이게 a로부터 받았는데 아니면 여러분들이 이미 1학년떄 메모리 디지털 시스템 메모리 
메모리에서 쓰고 메모리에서 읽어왔을떄 데이터가 1011011 자, 메모리에서 읽었다 이거죠
저게 진짜 메모리에 담겨져 있는것인지 아니면 읽다가 어떤 오류가 발생한건지 어떻게 알아낼꺼냐 
내가 지금 취득한 데이터가 이게 이속에 에러가 있는지 없는지 알 방법은 실제 보낸 사람에게 문의해보는 방법 말고는 없다.
근데 문의하는 방법은 말도 안되는것이다.
그많은 데이터를 다 문의 불가
내가 받아서 이속에서 에러가 있는지 없는지를 알아내야 되는게 요 무엇보다도 중요한것이다. 통신이 여실히 이 중간에 잘되바야 뭘해 받아 봤더니 에러가 잔뜩 들어있는 데이터 더라 아무 소용없는 네트워크다 
그래서 10장의 내용이 굉장히 중요하다. 받은 데이터가 그게 옳바른 데이터 인지 에러가 발생한건지 
자그거를 알아내고자 하는게 지금 
알아내고자 하는 의도를 갖고 여러가지 방안들을 만들었는데
그내용을 살펴보는게 10장임
어떻게 이속에 에러가 있는지 없는지를 알아냈을까 굉장히 재미난일이다.
상식적으로 실행활 하고도 굉장히 동떨어져 있는 얘기도 아니고
굉장히 중요하다.
여러분들이 잘 아는 것중에 하나가 패리티 체크라는게 있다.
어떻게 하는거져 패리티 체크?

패리티 체크 어떻게 하는거지? 1의 개수를 a와 b를 서로 주고 받은 데이터속에 8개씩 끊었을때 뭐 1의 개수가 그속에 짝수개만 꼭 들어가도록 우리가 약속을 하자 뭐 이렇게 했다고 치자.
그러면 8개 끊었을때 항상 보낼 데이터가 1의 개수가 짝수일 수가 없다.
막 데이터가 다양한데
그래서 일단 7개만 일단 끊은다음에 여기에 1의개수가 짝수개가 되게 하나 둘 셋 넷 다섯 하나 패리티를 붙이는거다
여기에 1이 지금 홀수개 있으니까 
자 요렇게 넣어서 보내면 
받은 사람은 요렇게 8비트를 체크하는것이다. 
8비트를 체크해서 1의 개수가 짝수다 그러면 아 여기에 에러가 없구나 
가령 가다가 이게 에러가 발생했으면 당연히 1의 개수가 홀수개가 되는 바람에 에러체크되는거다.
자 이 아주 기본적인 에러 체크방법임
근데 이 기본적인 에러 체크 라고 한다면은 중요한것을 담고있는데 바로 이 redumdency 라는게 있다. 

원래 보낼 데이터는 요 7비트밖에 안되는데 보낼 비트는 7갠데 내가 추가로 extra bit를 하나 추가를 해야되
용도가 뭐냐 에러체크를 위해서 
그리고 여기에는 이 7개 중에 1의 개수가 홀수면 1 짝수면 0을 넣어서 전체 8비트에 1의개수가 짝수개를 만들기 위한 extra 비트임
단 한비트만 추가해서 우리가 이 에러 디텍션이 가능하다는것을 볼 수 있는 아주 기본적인 방법임 
근데 보다싶이 이런 방법은 두개 에러가 발생하면 대책이 없다.
2개가 발생하면 아까 여기도 에러가 발생하고 여기도 에러가 발생하면 두개가 발생하면 여전히 1의개수는 짝수임 
그러면 이거 ok라고 받아들인다 이거임 (아마도 두 비트를 의미하는듯)
자 그러면 대단히 심각한 문제임 에러가 발생 했음에도 불구하고 원래 두비트 둘다 1이었는데 둘다 0으로 바껴도 여전히 짝수이기떄문에
에러가 없다라고 생각하면은 너무 심각한 얘기가 된다.
그러면 왜 이거밖에 안되나? 바로 이 패리티 체크 라는 기능은 이것밖에안돼 성능이
홀수개만 에러가 발생하는거만 체크할 수있지, 짝수개가 발생하면 에러를 체크를 못한다.
그게 한계임 그러면 더 많은 에러는 여기다가 redundancy를 더 크게 붙여야 한다.
여기를 더 크게
한비트 만 추가해서 해결할려고 하니까 비용을 너무 적게들일려고 하다 보니까 에러체크 율이  50% 밖에 안된다.
홀수개 발생하는 케이스와 짝수개 발생하는 케이스 반만이라고 치면은 50% 밖에 안되는데
그 확률 을 더 높힐려고 하면은 이 extra 비트를 키워야댐
이거를 뭐 k bit, 큰 사이즈로 키우면 키울수록 내가 이 7bit 밖에 안되지만 이 속에 에러 홀수개 도 체크하고 이것저것 체크할 수 있는 성능을 키울려면 더붙여서 더큰 사이즈에 redundancy를 붙여야 된다는거임
그럼 7비트를 보내기 위해서 7 + k 라고 하는 오버헤더를 붙여서 보낼 수 밖에 없다.
이 k 비트를 더 붙여서 보낼 수밖에 없다.
그러면 이제 k 비트를 무슨 원칙을 갖고 붙이느냐?
아까 이 1bit 붙일때의 얘기는 1의 개수가 짝수개가 되게 한다는 룰을 가지고 저 1이냐 0이냐를 만들었다.
그리고 막상 이게 한비트는 너무 적게 들여다 보니까 성능이 너무 떨어져서 여러비트를 더 붙이려고 하는데 
더 붙일떄도 k bit 이 더붙이는 놈들을 어떻게 어떤 규칙을 갖고 만들까
자 이게 여러가지가 있다. 어떤 규칙을 갖고 덧붙이는 걔를 만들까 
덧붙이는 k bit를 만들까 이게 10장에서 배울 여러가지 에러 디텍션 메카니즘들에 특성들에 따라서 이걸 어떻게 만드느냐 이렇게 되는것임
이걸 어떻게 만들어? 다양할것이다
다양하지 않겠어 한비트는 실제로 너무 간단했음 
1 의 개수가 짝수개가 되게 0이냐 1이냐를 넣자 여기다가 3비트를 더 붙이자 
이거는 보내는 쪽이나 받는쪽이나 같은 규칙을 갖고 이 k비트를 대해야되 
그래야지 에러 발생한것을 디텍션할 수있음 

뒤에 어 제일 중요한 다루는게 crc 라고 하는건데 그래서 이 미리 이 crc 라고 하는건 애는 어떤 규칙을 갖고 만드느냐
어떤 규칙을 갖고 만드느냐 굉장히 그 재미있는 일임
여기에 k개를 붙였는데 그러면 n+k개 이 여기를 n개라고 하면 n+k bit가 나온다. 얘는 보내고자 하는 데이터고 얘는 extra 붙인것이다.  요 어떻게 붙인거냐 이 붙인놈이 어떤 그 어떤 일정한 패턴의 뭐 몇비트짜리 
일정한 패턴을 a나 b나 가지고 있으면 그거를 어 r 이라고 하자 이 바이너리 정보를 서로 공유하고 있는 r이라는 패턴으로 나눴을때 나머지가 0
요렇게 되게 이 k를 붙이겠다. 라고 하는 룰이 있다.
crc 라고 하는 에러디텍션 하는 방식에서 쓰는것이다. 무엇인가로 같이 공유하는 무엇인가로 나눴을때 나머지가 0가 되게 하는식으로 내가 k를 붙이겠다 라는거임 
그러면 그래서 내가 k를 붙여서 보냈음 b는 받았을때 받았을때 요거를 받았을때 b도 r로 나눠보는거임 
이 r이라는건 a랑 b랑 같이 공유하고 있는 어떤 일정한 패턴임 
그 b가 r로 내가 이 데이터를 나눴더니 나머지가 0더라
그러면 에러가 없다 이런식으로 체크하는거임
마치 여기 1의개수가 짝수냐 홀수냐 이렇게 너무 간단한 로직을 가지고 판단하는게 아니라
이거를 나눗셈으로 해서 나머지가 0냐 아니냐 이렇게 에러체크한다.
이 나눠서 나머지가 0냐 아니냐를 구하는 이 방식이 에러 디텍션 하는 성능이 어마어마 하다.
이 crc 회선 
이중간에 에러가 하나라도 발생하면 하나라도 발생하면은 가령 64는 8로 나누면 나머지다
근데 여기 가다가 하나 에러가 발생해서 63이됬다 그럼 안나눠진다 
이와같이 이게 에러가 하나가 발생했는데 안나눠지고 62가 됬다 그래도 안나눠진다.
이 8로 나눠서 나머지가 에러가 발생했는데도 불구하고 역시 나눠지게 할려면은 그 발생하는 에러패턴이 굉장히 독특해야된다.
그러니까 이 피해나갈 수 있는 방법이 굉장히 적다.이런 식으로 나눈 나머지가 0가 되게하는 방식으로 에러 디텍션하면 
그래서 crc 라는 방식이 일반적으로 이미 우리 현시점에 쓰이는 가장 많이 쓰이는 방식이 crc임
그리고  이 k라는 놈을 붙여서 보낸다. 우리가 지금 이 그 데이터 링크 레이어에서 지금 이걸 배우고 있다.
그러면 이렇게 해서 만들어진 이 k비트는 누가 그 데이터, 전체 내가 보내는 그 패킷속에 어디에 들어있느냐 
데이터링크레이어있는 헤더속에 들어있다.
가령, 이 네트워크 레이어에서 이 패킷이 내려오면 여기 데이터링크 레이어
내려오져 그러면 여기서 헤더를 씌운다. 데이터링크에서 이제 헤더를 씌우는데 여기에 어느 한 영역이
한 영역이 바로 요놈을 요놈을 여기다 가져다 놓는다.
에러 체크하라고 받은쪽에서 에러 체크하라고 헤더 속에 이 crc 라는 것을 통해서 만들어진 이 redundancy bit를 헤더 속에 집어 넣을 수 있게 하고 있다. 도대체 이거 만들어서 어떻게 보내는지 살펴보는 그래서 헤더들이 필요한거임 
데이터링크에서 내려온 이 ip 주소들어있고 뭐 이런거죠 여기에 데이터링크 레이어 에서 헤더를 더 붙이는데 바로 헤더속에 crc redundancy check 를 위한 이 extra bit를 저장하는 영역이 있다.

저런식으로 운영하는게 

그래서 보면은 지금 모든게 바로 redundamcy를 어떻게 붙이느냐 이얘기를 하고 있는것임
redundancy를 어떤 룰을 갖고 어떻게 붙이느냐 
그 여러가지를 우리가 살펴본다. 

근데 여기까지는 디텍션임
나눠서 나머지가 안떨어지면은 에러가 있다라는것만 알지 원래 그 데이터가 뭐였을까
이거 어떻게 알아 이건 뭐 보통어려운것이 아님
에러가 있다고 하는데 어떻게 뭐 원래데이터가 뭔지 
자그럼 원래 데이터가 무엇인지를 아는 방법이 우리 이미 1학년떄 본 기억이 있을것이다.
배운기억나죠
에러를 커넥션까지 하는 어 아주 멋진 아이디어가 있었음
1학년 디지털 시스템에서 배웠던 아까 메모리에서 이 1학기 디지털 시스템에 7장에가면 메모리 에 대한 얘기를 함
메모리를 얘기하면서 왜 에러디텍션 얘기가 나오느냐
아까 말했듯이 메모리 에서 데이터를 읽었는데 이거 읽어오는 사이에 에러가 발생할 수있다.
1101 가령 1101을 읽었는데 이속에 진짜 메모리에 들어있는 값인지 아니면 읽어오다가 뭐가 발생했는지
그래서 메모리 장에 이 에러디텍션이 기능이 내용이 하나 포함되어있다.
해밍코드라고
해밍, 해밍코드
기억나냐
해밍코드
기억안남

해밍코드가 우 리 10장에 중요한 말로 다시나온다.
다시나옴 10장에 가다보면은 해밍 디스턴스라는게 나오는데 이 
해밍이라는 사람이 에러 디텍션쪽에서 난입을 한거같아
해밍코드라는것을 얘는 이떄 역할이 뭐였냐면 이속에 에러가 있는지 없는지 판단을 하고 에러가 발생했다고 그러면 에러 커넥션까지 할 수있는 기능이 있었다 라는거임
에러 커넥션까지 했어
에러 커녁센 하려면 어떻게 해야되? 가령 저 데이터 사이즈가 11010 자 여기에 에러가 발생했다 이거임 
한 bit 에러가 발생했다. 여기 가령 에러가 발생했다.
디텍션이 된다 이거임 1bit 에러
자그러면 커넥션을 하고자 한다 이거임
커넥션 커넥션 하면은 지금 뭘 알아야될까? 바로 1학년떄배운 것을 기억을 더듬음
1bit 에러가 이속에 있다. 1bit 에러
근데 내가 그것을 고치고 싶어
원래값으로
뭘 알면될까?
원래 값으로 고치고 싶다
한 비트가 에러인데 그 그놈의 위치를 알면된다.
4번째 비트가 에러다 그러면 하나 둘 셋 넷 그러면 지금 1이니까 0이었구나 이렇게 위치만 알면 이 바이너리에서는 1아니면 0이니까
그게 에러라고 하면 그게 아닌 다른것을 쓰면된다.(1아니면 0)
그래서 위치를 알면된다. 4번째 자리다 그러면 4번쨰 자리에 1이면 0으로 바꾸고 0이면 1로 바꾼다.
이게 커넥션이 됨
커넥션이라는게 막상 앞으로 101111011 에 대한 데이터를 7비트는 내가 다시 원래데이터 7비트로 어떻게 아냐?
굉장히 어렵게 생각되지만 아이디어는 간단하다.
위치를 알면 커렉션이 가능하다.
correction 지금까지 connection 이라고썻는데 커렉션이다.
위치를 알면
그래서 해밍코드는 이걸 돌리면 이 내가 지금 갖고있는 이 데이터를 갖고 해밍코드를 적용시키면 에러가 디텍션되고 동시에 그 정보속에 뭐가있냐? 에러가 발생한 위치가 담고있다.
위치
가령 9111 해밍코드를 돌리면 4라는 숫자가 아웃풋으로 튀어나온다.
그러면 4번째 자리더라 라고 해서 1이면 0으로 바꾼다. 이게 바로 error correction이다(중요)

재미난 얘기가 해밍코드를 돌렸을때 어떻게 에러가 발생한 위치를 위치정보를 만들어내줄까
이게 저 해밍코드에 매칭임
해밍코드가 가지고 있는 매칭임
어떻게 에러가 발생한 위치를 찾아낼 수있을까?
이거 어떻게 찾아낼 수있어?
이미 1학년떄 이미 배웠는데

우리 여기 10장에도 그런 내용이 새버전에는 없어진거 같은데 엤날에는 있었음
위치를 찾아낸다 이거임
??에러의 위치, 자 뭐 미리 많은 얘기를 헀는데 이런 얘기들을 10장을 통해서 쭈욱
보여준다.
10-4 checksum이죠 바로 저 crc 아까 얘기한 crc가 10-4절에 나오는것이다.
10-4절
그리고 포워드 에러 커넥션 아까 해밍코드 지금 여기서다 포워드 에러 커넥션 에러를 커넥션 한다. 
1비트 에러를 커넥션 하는 방법 그게 10-5절
해서 이 쭉 10 장 전체 내용을 쭉 살펴보는것이다.
이 다른 절 내용을 보면 10장을 보면 블락 코딩

## 10 Error detection and correction
Block coding 을 앞에서 본적이있다.
4비트짜리 보느내는데 구지 5비트 만들어서 보낸다거나 
이게 다 에러 디텍션의 기능이 이 속에 들어있었다.
블락코딩
그다음에 Cyclic codes 라는게 나온다.
이 덧붙여서 만들어진 룰들에 대한 얘기를 하는거임
그리고 그걸 통해서 checksum 
cyclic codes가 crc다 
checksum 도 다 한얘기다
뭐 checksum은 이런거임 우리 이 데이터를 한 100비트를 보냈으면 100비트면 가령 
10비트씩 10줄로 쫙
10비트 단위로 쪼갠다음에 예들을 다 더하게 하는거임
더하면 sum이 나오는데 sum을 같이 실어서 보낸다
그러면 받은쪽에서 자 이거 error detection 하는 방법중에 하나임
받은 쪽에서 또다시 다 더해보는것이다
그래서 다더해서 sum이 나오는지 안나오는지
이것도 하나의 error detection하는 간단한 아이디어임 checksum
저거는 실제 이 아이피라고 하는 프로토콜들어보면 체크 섬 빌드가 있음
tcp 헤더에도 들어있고 저게 ip헤더에도 들어있음 체크섬 비트라고 
아이디어는 그거임 어떤 일정한 크기로 한덩어리 데이터를 보냈을때 일정한 크기로 쪼개서 16비트면 16비트로 
각각 쪼개서 이걸 다더해
더해서 여기서 sum을 같이 넣어서 보낸다
sum을 
받은쪽에서 sum을 넣어서 보낸다고 했는데
바로 이 sum을 헤더속에 넣어서 보낸다
헤더! 
헤더속에
그러면 받은쪽에서는 다 일일이 sum을 해두고 헤더와 한번 비교해본다.
받은 sum하고 sum이 같으면 에러가 없다 이거임
이 떄도 error detection 빠져나갈 방법이 뭐냐 sum을 해서 sum이 같다 
나누기 해서 나머지가 없다 이거하고 sum을 해서 sum이 같다 어느게 에러 디텍션 하는데 막강한 성능이 있을거 같아 여러분생각했을때 
나눗셈과 덧셈
어느게 성능이 있어보여?
덧셈이 더 있어보인다 덧셈이 나눗셈보다
덧셈은 간단하다 이거 에러만들기
여기서 마이너스 1 발생하고 여기서 플러스 1 발생하면 에러 없음 
에러 관리를 못함
그렇다 sum이 같으면 
이런게 수없이 나온다 합해서 -1 합해서 +1 또여기서 -1 +1 4개가 발생했는데도 에러를 못찾는다.
나중에 보면 알겠지만 체크섬은 약한 방법이다
나눗셈이 얼마나 막강한지는 crc를 배우게 되면 나눗셈을 통해서 나머지가 없게 만들어야 한다는 룰이 얼마나 막강한지 뒤에 살펴보자.
그래서 crc를 많이 쓴다.

여기쭉 개괄적인 설명을 했으니까 앞부분 쉽게 넘어갈수있다.

## 개요
데이터전송중에

자 이 뭐 여기 간단한 얘기다 데이터전송중에 에러가 발생할 수 있고
어 그래서 어떤 아주 그 에러가 전혀 허용하지 되지 않은 어플리케이션 이라고 하면 당연히 에러 디텍션 또는 케력션까지 요구할수있다. 그러면 우리 엔지니어들은 그기능을 제공해야한다.
에러 디텍션과 커렉션
어 그래서 뭐 여러가지 그 이 에러에 대한 기본적인 얘기들을
에러의 타입은 뭐고 
결국 에러를 디텍션하기 위해서 필요한 Redundancy 라는 개념
어 그리고 디텍션과 커렉션의 차이
뭐 포워드 에러 커넥션과 사실 에러를 커렉션하는 제일 좋은 
에러를 커렉션하는 제일 좋은 방법은 디텍션 한다음에 다시 보내라고 함
그 송신자에게 다시보내라고 요구하는게 커렉션의 방법임
그래서 포워드 에러 케력션은 받은 사람이 커렉션을 해볼려고 노력하는거고
리트랜스미션은 보낸사람에게 다시 보내라고 하는거임 
너무 간단한다 리트랜스미션
사실 커렉션은 상당히 어려운 기술임
우리가 이 해밍코드를 통해서 한 비트 에러 커렉션은 가능하다고 헀음
뭐 두비트 세비트 에러가 발생했다고 하면 과연 어떻게 커렉션을 할까?
굉장히 어려운 일이되고 결국은 리트랜스미션이라는 방법을
사실 많이 쓰고 있다.
커렉션에 관련한 그 쪽에서는 리트랜스미션을 요구, 너무 간단하니까 그냥 네가티브 에크를 보내면 센더는 다시 보내게 만든다.
코딩 모듈러스 
기본적인 얘기들이 있는데
보죠
에러는 에러 타입 한 비트 에러
싱글비트 에러 이 어려개 중에 한 비트만 발생하는 패턴이 있을 수있는데 그러면 이거말고 어떤 패턴이 있느냐
Burst Error 라는게 있다.
이렇게 한 10 비트 정도 될때 뭉쳐서 이렇게 반드시 연이어져서가 아니라 어떤 한부분에 몰려서 에러가 발생하는것을 Burst Error 라고 함
자 이런것은 굉장히 골치아픈 에러들임
그래서 이 버스트의 사이즈 (Length of burst error)
개념이 여기있다.
어떤 한 단위의 보내고자 하는 데이터(메시지가)있는데 에러가 이 덩이러로 발생된 그 에러의 사이즈를 Burst error 라고 부른다.
Burst error 가 8이라고 해서 반드시 8비트가 에러가 있는게 아니다
그 8비트속에 에러들이 쭉 산재되어있다 그런거임
버스트 에러라고 함
바로 저렇게 발생한 버스트 에러들을 디텍션하고 어쩌고 할때 이 나눗셈 이라고 하는 덧셈이 힘을 발휘할까 라는 생각해보면 나눗셈이 굉장히 힘을 발휘할수있다라는것을 나중에 본다 버스트 에러라는건 정의가 저렇다 이거고

그래서 결국은 redundant가 필요하다는 얘기다
패널티 비트 1비트 추가하듯이 더 추가해서 디텍션과 커렉션을 하기위해서는 extra bit를 우리가 보내야 한다
이거임
커렉션과 디텍션의 차이를 보면 당연히 커렉션은 디텍션보다 훨씬 어려운거고 음 
커렉션을 한단얘기는 커렉션 한단얘기는 일단 몇 개가 에러가 발생했는지 알아야하고
알아야 되고 그리고 커렉션하기위해서는 그 에러의 위치가 어디냐 이거임
어디냐를 알아야 커렉션이 가능함 위치를 알아야함 원래 데이터 전체값을 다시 추론하는게아니라 에러가 발생한 위치를 찾아내는 방식으로 에러커렉션을 하게됨

그래서 receive 쪽에서 에러 커렉션을 열심히 한다고 하면 그게 forward error correction(FEC) 라고 하고 이게 너무 어렵다 그러면 재구성하게 요청한다(리트랜스미션)
그래서 커렉션의 방법중에 하나가 리스트랜스미션임 우습게 보이지만 재전송하라고 하는게 커렉션의 방법이다.
TCP 라고 하는 프로토콜 은 에러 체크를 하고 그 에러가 발생하면 send 한테 재전송하라고 요구를 하게된다.
tcp는 그런데 그 같은 그 트랜스포트레이어에 udp라고 프로토콜은 에러가 발생햇음에도 불구하고 액션을 아무것도 취하지 않는다.
재전송 하라고 요구안하고 그냥 어플리케이션 레이어에 그냥 데이터를 올려줄뿐이다. 
단지 에러가 발생했다 라는것만 알려준다.
어플리케이션 레이어에서 뭔가 해결을 해야된다.
그 같은 계층에서 tcp, udp 간에 기능의 차이가 있다.
tcp는 재전송을 요구하는데 udp는 재전송을 요구하지 않고 그냥 처리해버린다. 
커렉션 기능이 없음 udp에서는

## Redundancy
여기에 중복이라고 표현되어있는데 잘못된 해석이 아님 이게 중복이 아니라 extra bit니까 잉여비트라고 해야됨
더추가해서 보내야 하는거임
중복이 아님
우리말이 잘못된거임 번역이
내가 보낼 데이터가 요만큼이다 이쪽에 보내는 쪽임 
요만큼이면 요만큼만 보내는게 아니라 무언가를 올려서 여기에  redundacny bit를 만들어서 보낸다 이거임
무슨 룰을 적용해서 받은쪽에서는 이 전체를 이용해서 에러 가 있는지 없는지를 체크하는데 
그떄 바로 이 redundancy가 요기나게 쓰인다.
같은 알고리즘으로 돌려서 에러가 발견되면 버리고 발견안되면 그냥 사용하면됨
이게 바로 redundacny라는 개념이고 
바로 이거임

그 redundancy를 만드는 회로를 generator 라고 하면은 리던던씨를 메시지에다가 제너레이트를 통해서 리던던씨를 붙여서 메시지와 리던던씨를 합해서 보내면 그러면 여기서는 체커라는 거임
리시버 쪽에서는 체커, 이 제너레이트에 대응되는 기능이 체커임
그럼 메시지 + 리던던씨가 이 입력이 되서 그것을 통해서 에러가 있는지 없는지를 체크하는게 체커임
그래서 에러가 없으면  메시지로 추출하고 에러가있으면 버리던지 커렉션하던지
이게 아주 가장 기본적인 어 블록 다이어그램 이라고 함
이게 에러 커렉션이나 에러 디텍션 측면에서 
그래서 우리가 배울 내용들이 이 제너레이터를 어떤 기능이 되도록 만들것인가
이거임
결국 이게 만들어지면 체커도 동시에 거기에 맞대응 되는 기능이니까 동시에 나오는거죠
바로 요거를 어떻게 만드느냐?
제너레이터를 바로 그 내용들을 우리가 쭉 배운다.

그게 바로 리던던씨를 구하는 방법이라고 했음 코딩 으로 코딩으로 그륩
여러가지 코딩 스킴을 이용해서 리던던씨를 만든다.
근데 그 코딩 방식이

## Coding
코딩 방식이 
블락 코딩과 컨볼루션 코딩 이 있음
벌써 이 뒤 컨볼루션 코딩은 듣기만 어려워보임
컨볼루션 코딩
다행이 인스트덕션 수준에서는 컨볼루션 코딩을 안배움
이책에서는 오로지 블락 코딩에만 관심을 둔다.
컨볼루션 코딩은 좀 다음번 다음 진도가 나간 다른 챕터에서 배운다.
다음 수준의 강의에서 배운다. 우리가 배우는건 블락 코딩임

아까 체크 섬 이든 나눗셈 이든
 뭐 이 런 연산들이 쓰이는데
 그 연산을 우리가 서로 
일상적으로 쓰는 동일한 연산이 아니고 모듈러 연산 하는데 쓰는것이다.
미리 모듈러 연산을 소개를 한다.
우리 바이너리 넘버니까 모듈러 2연산을 쓰게된다.
모듈러2연산

## 모듈러 2 연산
모듈러 연산은 
모듈러 n연산이라고 하면은
0부터 n-1까지 정수만 사용 하는 연산이다.
모듈러 2연산이면 0과 1만 사용하는 연산임
아주 간단하게 이거임
덧셈
뭐 0 더하기 0 
0 더하기 1 
1 더하기 0
1 더하기 1
모듈러 연산을 보면은 
저와 같은 연산이 이루어진다.
여기서 좀 생각에 1 더하기 1은 0이다.
1 더하기 1은 0임
1 빼고 1 도 0임
1 빼기 0 1
0 빼기 1 1 
0 뺴기 0 0
요 연산만 잘 알고있으면 앞으로 우리 덧셈이나 나눗셈하는 데 여러분들이 별 혼란이 없다. 저런 연산을 하는거다 모듈러 2연산

## 10.4 모듈러 2 연산
우리가 이미 모듈러 2 연산은 우리가 이미 알고있듯 xor operation 이라고 하는데
exclusive or 에 그 요 동그라미 안에 + 가 있는 그 연산이 exclusive or 연산임
exclusive or의 연산에 특징이 우리가 잘 알고있다싶이 
exclusive or gate는 이렇게 그린다.
그런데 여기에 a와 b가 있을때 이 아웃풋이 c가 갖는 특성은 뭐냐
a와 b속에 1이 홀수개 있으면 1이고 짝수개 있으면 0 라고 하는게 이 exclusive or에 
특성임
이미 알고있음 여기에 인풋이 몇개가 되던간에 
인풋이 몇개가 되던간에 이속에 1의 개수가 홀수개면 1 , 짝수개면 0 이게 exclusive or 에 기본적인 기능이고
그게 그대로 지금 적용되고 있다. 
두 비트 만 있다라고 하면 두 비트면 둘다 1이면 0가 됨
이게 바로 1+1 이 0라고 했는데 모듈러 2연산에서 
exclusive or 연산에서 왔다면 
일치되는것임
(그러니까 1의개수로 모듈러 연산을 정하는게 exclusive or 연산이랑 비슷하게 짜여있어서 뭐 그런얘기를 하나보다..)
예를들어서 10110 과 11100을 exclusive oring 모듈러2 연산을 하자
모듈러 2 연산
그러면 각 자릿수별로 0더하기 0은 0이고 1더하기 0은 1 1더하기 1은 0임
우리가 일반적으로 이 그 산술적인 덧셈을 하면은 여기서 carry 가 발생해서 여기 1을 더해야댐
그거 없음 모듈러에서는 그게 없음 1더하기 1은 0이됨
0더하기 1 은 1 1더하기 1은 0

뭐 캐리가 없다. 빌려주거나 위로 올려주거나 이런거 없이 단순한계산이다.
여기서 얘기하는 
뺄셈도 마찬가지임
0 뺴기 1도 1임
이런 부분들 보셈
덧셈이나 뺼셈이나 아무 차이가 없음 이 연산이
+ 든 - 든 똑같음
결과가 같다.
+ - 같다.
결과가 모듈러 2연산

## block coding
여기서 이 용어들 하나 봐야댐
데이터 워드는 내가지금 보낼려고하는 메시지, 내가 보낼려고 하는 메시지임
메시지를 일정한 사이즈로 나눈것을 어 데이터워드라고함
k 비트로 나누자 이거임
그래서 데이터워드는 k 비트다 뭐 이렇게 생각하면 좋다.
k 라는것은 여기에 redundancy가 안들어있는거다
순수한 메시지임
이거는
데이터워드는 
여기에 redundancy를 붙일려고함 r 비트를 붙여야되
그래서 결국 우리가 보내는것은 n = k+ r 비트를 보냄 
이거를 n이라고 표현하자
앞으로 n k r이 의미하는바가 바로 그렇게 되고 
이 바로 n = k+ r 로 구성된 놈을 코드 워드라고 한다
메시지만을 
메시지를 데이터 워드로 보내고 여기에 리던던씨까지 붙인걸 코드워드라고한다.
부른다.
코드워드 와 메시지, 데이터워드 사이에 차이가 났다 그러면 
이런 기본적인 내용을 갖고 한번 살펴보자
k비트에 데이터 워드를 구지 n비트로 바꿔서 보낸다. n비트의 코드워드로 바꿔서 보낸다.

뭐 이렇게 이런걸 이미 블락코딩 앞에서 우리가 본적이 있다.
앞에서 이미 봤듯이 4비트를 5비트 만들어서 보낼떄 16가지의 여유분이 생긴다 바로 이 여유분을 에러 디텍션용으로 쓰는것을 이미 우리한번 본적이있는데 그게 바로  4b/5b 라고 하는 블락코딩 방식을 이미 소개한바있음
이그림 다시 나온다. 
바로 리던던씨를 어떻게 만드느냐 이 제너레이트가 만듬

얘 데이터 워드가 인풋이되서 제너레이터가 코드워드를 만드는것이다.
코드워드는 r비트가 추가된거임
받으면 받은쪽에서 코드워드를 이용해서 체커를 돌려서 체커가 에러가 있는지 없는지를 디텍션해서 있으면 버리고 없으면 데이터워드를 추출해낸다. 
요게 바로 디텍션의 전체적인 프로세스임 

## 10.1
예를 한번들어본다 k가 2고 n이 3이다.
이게 무슨말?
데이터워드는 2비트고 리던던씨는 하나를 더붙여서 3비트의 코드워드를 만들어 보내는 방식임
여기에 지금 표라는거임
데이터 워드가 2비트면 4가지 경우밖에 없음
00
01
10
11
그거에 대해서 각각 코드워드를 이와같이 만들어서 보낸다
코드워드 어떻게 만들어졌는지는 여기서 일단생략하고
저런식으로 만들어서 보내기로 했다.
그러면 보낸 쪽도 이표에 의해서 이 데이터면은 이렇게 만들어서 보내고 
받은쪽도 당연히 이 표가 있음
그래서 요걸 받으면 아 01이구나 하고 거꾸로 추출해낼수있어야함
자 이런 상태에서 
예를들어서 01을 보낼려고 해 보내는쪽이 그러면 그표에 의하면은 011을 보내면된다.
그렇죠 데이터워드가 01일떄 코드워드는 011이었음
자 여러가지 케이스가 이제 발생한다. 리시버가 011을 받은경우에 당연히 표로 찾아보니까 011 이있고 여기에 대한 데이터들은 01이더라 그러면 01을 추출해내면 끝임
여기는 아주 나이스한거임
나이스한 통신환경에서 수행한거고
내가 받아보니까 111 이더라 
111 이면 또 표에있나 없나 보는거다
없죠, 없으면 에러로 체크한다.
이건 value한 코드워드가 아니기 때문에 에러다.
이건 에러 디텍션이 된거임

그런데 내가 011을 보냈는데 이와같이 011을 보냈는데 
받은쪽이 가다가 에러가 발생하다보니까 000이 됬다 이거임
그럼또 받은쪽 코드워드 value 한건지 표를 찾아보니까 000이 있더라 이거임 그러면 아 보낸데이터가 00이다 라고 추출
이경우는 어떻게 된거냐 
에러가 발생했는데 불구하고 011을 보냈는데 에러가 발생해서 000이 됬는데 에러 디텍션을 못하고 있음
그러면서 00으로 받아들인다 이거임
자 이 경우가 지금 아까 에러 디텍션한경우와 지금 에러디텍션하지 못한경우는 무슨차이가 있느냐
아까 에러 디텍션하는경우는 한 비트차이임
요 케이스는 111 이 됬단 얘기는 011을 보냈는데 맨 앞에 비트 하나만 에러가 발생해서 111이 된거임
이 경우 011 을 보냈는데 000이 됬단 얘기는 두비트가 에러가 발생한거임
그래서 에러발견을 못함
그래서 지금 이 결과를 보고 이런 방식으로 코드워드를 작성하면 이 코드워드에 성능은 어떻게 되느냐?
에러 디텍션은 가능한데 한 비트에러만 디텍션이 가능한 그런 코딩방식이다. 두비트는 에러디텍션이 안되는것임
이방 식을 쓰면 이미 두 비트 에러발생이 디텍션이 안되는것을 알았다.
자그러면 우리가 이런 그 코드워드를 보고 얘가 몇비트 디텍션이 가능한지를 알수있는 룰이 있지 않을까 이걸 찾아내야됨
사실 그런걸 기반으로 코드워드를 만든다.
우리가 코드워드를 보면은 얘가 몇비트의 에러를 디텍션할 수있다. 몇비트까지
이거를 알수있다. 이속에 비밀이 다들어있다.
지금 코드워드가 아무렇게 나 만들어지는게 아니고
그 요 코드워드는 한 비트에러만 디텍션할 수있고 
이 만약에 그말을 영어로 정리한거임

## 메모
에러 디텍팅 코드는 오로지 그 코딩이 디자인된 디자인 된 그 목적에 맞는 타입만 디텍션할수있다. 
앞에 예를들어보면은 앞에 꺼는 한 비트 에러 디텍션을 위해서 디자인된것이다.
그러면 한비트에러만 디텍션할수있다.
다른 타입의 에러는 디텍션을 못한다. 두비트 에러는 디텍션못한다. 앞에 있는 코딩방식은 
자 그러면 한번 다른 코딩방식을 살펴보자 
그다음 다른방식임 
그래서 우리 한번 코딩 능력을 키워보자 해서 
한 비트만 redundancy로 쓰는게 아니라 아예 두비트를 더 붙여가지고 3비트 를 redundancy를 3비트 리던던씨 비트를 
3비트 붙여서 보내는 새로운 코딩을 쓴다고하자
그러면 그게 그림이 이거임 이와같이 데이터워드는 2비트밖에 안되는데 4가지 경우임
이렇게 3비트씩 더 추가해서 코드를 만든다.
코드워드를 
과연 그러면 3비트까지 추가를 했는데 얘가 기능이 얼마나 될까 뭔가 아까보다는 성능이 늘어나야 한다.그래서 이런 표를 만들었을떄 한번 살펴본다
여기 중요한 예다.
이런 5비트의 코드워드를 만들어서 보낸다그래서 
상황을 만들어보자 내가 지금 01이란 데이터를 보낼려고해 

## Example 10.3
그러면 그 표에 의하면 01011을 보내게 된다. 표에 그렇게 되어있다. 그래서 보내는 사람이 01을 보내기 위해서는 리던던씨를 붙여서 01011을 보내는거야 자 그러면 5비트가 가는데 이것이 전송중에 꺠지는 바람에 01001이 됬다. 한비트가 에러가 발생
한비트 에러가 발생했으면 이 받 은쪽에서 먼저 저기에 지금 멜다던지 테이블에서 찾아야함 01001이 있어 없어? 없어 한비트 에러는 넉근히 에러 디텍션이 된거임 
자 된거임 그래서 없다 이거임 에러 따라서 
한 비트 에러그 것은 디텍션이 됬는데 
우리 여기 지금 이걸 이용해서 커렉션까지 가능하다는것을 보여줄려고한다

지금 이 한 비트 에러는 깨졌는데 우리가 지금 이 통신환경이 에러가 발생할 수있는데 저 5비트가 갈떄 이 시스템에서는 아무리 최악의 경우라고 해도 한비트만에 에러가 발생한다.
두비트 까지 에러가 절대 발생하지 않는다 라고 하는 그 가정을 한다면
가정이 그런 환경이라고 한다면 우리가 이 5비트를 가지고 에러 커렉션까지 할 수있는것을 여기서 보여줄려고 한다.
커렉션 뭐라고 했찌? 커렉션 위치를 찾아내준다고 한다. 
근데 여기 위치찾는 방법은 아니지만 어쩃든 커렉션을 어떻게 하는지 보여준다 
커렉션까지 
지금 01001 받았는데 01001 을 받았는데 분명히 이 표에 없다 이거임 다 에러가 발생한다. 근데 assume이 뭐냐면 한 비트 에러만 발생할수있는 상황임 그러면 자, 
그러면 1번 한번 쭉보죠
아, 이 011001 이라고 하는 놈이 어, 얘랑 비교했을때 에러가지금 써놨죠 01001 이라고 했음
받은 데이터가 이거임 이놈을 보니까 일단 표에 없어서 에러가 있다라는걸 알고 
가령 어떻게 커렉션을 할까 0100 얘랑 비교해보면은 몇비트가 차이가 나지 두비트가 차이가난다.
0101 하고 비교해보면 몇비트 차이나죠? 1비트
10100 하고 비교하면 10101 3비트 (101) 차이가난다.
얘랑 비교해보면 1111 무려 3비트 차이가 난다.
4비트 차이나나 

자 한비트만 에러가 있다고 했다
이 시스템에는 오로지 한비트 에러만 발생한다고 했다
근데 얘랑 비교하면 두비트 차이나고 얘랑 한비트 차이나고 얘는 3비트 차이나고 얘도 3비트 차이나고 그러면 한비트만 에러가 발생했다고 하면 원래 뭐였겠어 원래
원래 이중에 누구였을까 얘는 두번째 일수밖에 없다. 한비트에러가 발생했단 얘기는 한비트만 차이나야하는거임
그래서 에러 커렉션이 됨
얘는 얘였구나 그러면 원래 데이터는 이거였구나를 추측할 수있다.
우리가 지금 비교를 했다 몇비트 차이나는지
해서 몇비트 나는지 구했고
이 에러 커렉션이 한비트차이난다는 가정하에 한 비트 차이 나는놈만 커렉션을 하는거임

Q. 그러면 에러의 위치도 알수있는거 아닌가
- 에러가 난 위치를 알기보다는 이 속에서 어느 코드워드가 진짜였는가 를 알아낸거임 이거는 에러가 발생한 위치를 알게하는게 아니라 

Q. 원래 보낼 데이터는 01 이었기 때문에 에러가 발생한 위치 
- 근데 에러가 둘중에 하나니까 보내는건 이거를 보내는거다 에러가 위치가 여기일수도 있고 자기 원래 자기 값 01이 여기에 있는데 자기가 아닌 리던던씨 속에 에러가 얼마든지 발생할 수있다. 지금 이게 리던던씨에서 발생했잔아 에러가
물론, 해밍코드도 리던던씨에 발생하면 어디에 발생하든 해밍코드도 그거 찾아낼 수있어, 위치 찾아내는데 여기에 지금 접근이 아니라 다른 접근임 그냥 이 코드워드를 갖고 원래의 코드워드를 찾아내는 거임 한비트 차이나는 코드워드
그러면 이 코드워드를 어떻게 만들었길래 이게 가능하냐를 이제 생각을 해야댐
이게 지금 이 코드 방식이 3비트를 추가했는데 3비트를 추가했는데 아무렇게나 추가해서는 지금 이런 커렉션 기능이 있을수없다. 왜냐하면 또다른 놈이 다른놈이 하나가 이 차이가 똑같이 1이더라 얘도 차이가 하나밖에없는데 다른 코드워드 랑도 비교했을때도 또 차이가 하나밖에업더라 그러면 어느 놈인지 내가 어떻게 알아? 가령 이 코드워드가 01011 이거였다고 치자이 세번째코드가 이게 아니라(10101) 예를들어서 이겨였다 얘가 자기 이거랑 비교했을때 한비트 차이나고 그아래있는 놈하고도 한비트차이나고 그러면 얘였는지 얘였는지 알수가 없다.
따라서 이 코드워드를 섬세하게 만들어야 한비트만 차이나는놈이 하나만 있게 만든다 이거임
코드워드를 어떻게 만들었느냐 이게 가령 맥스?? 기구 속에 들어있다.
코드워드를 어떻게 만들었느냐!?

아무렇게나 만든게 아니다 저거를 뒤에도 그림ㅇ ㅣ나오지만 우리가 개념적으로 한번 살펴보면 뒤에 이런그림이 나온다 즉여기에 
(PPT참고)
코드워드가 01011 이걸 내가 보냈다. 한비트차이나는 놈은 이놈하고 한비트차이나는 놈은 몇가지가 나올수있냐? 5가지 나올수가있다 그런놈들이 요 주변에 한비트만 차이나는 범위안에 들어있다 이렇게 한비트 만 차이나는 범위안에 요렇게 들어있다 이게 한비트에러임
여기로부터의 차이가 한비트에러다.
이거 한번 개념적으로 머릿속에 있는것을 그림으로 그려보자 이거임
다른 코드 원간 이 속에 들어있으면 망하는거임 아까 말했다 한비트만 차이나는 놈의 경우에는 한비트 
원래는 얘였을것이다 한비트 차이나는 놈이 얘밖에 없으니까 라고 우리가 요 속에 이제 발생한 에러는 얘였다 라고 생각하는거임 근데 이속에 다른 코드워드가 들어있으면 안된다 그러면 다른 코드워드는 어디에 있어야 될까?
어디에 있어야 될까? 다른 코드워드가 가령 요기 없지만 요렇게 있다고 해보자
얘도 가령 요렇게 포함한다고 하자 얘도 이 코드워드 다른거 다른코드워드인데
한 비트 차이나는놈을 쭉 그렸을때 여기에 공집합이 있다.여기에 저놈하고 접하는놈이 하나 있다.
그러면, 자 이 문제가 된다 얘는 얘하고도 한비트 차이고 얘는 얘하고도 한비트 차이임그러면
커렉션을 할수가 없다. 누구라고 얘기못한다. 따라서, 이 코드워드의 위치가 여기에 있으면안된다. 
안되고 어디로 가야되? 이 얘와 다른 코드워드는 당연히 똑같이 원을 그렸을때 겹치지 않는 곳에 가있어야됨
그림이 쉽지
얘와 한비트 차이나는놈이 얘와 한비트차이나는놈과 접하는 공집합이 있으면안된다
교집합이 있으면안된다 결국은 뭐냐
다른 코드워드에 코드워드가 위치해야 되는 것 곳을 우리가 알아야한다
여기서 나오는
무슨얘기가 나오느냐
코드워드간에는 몇 비트 차이나야되? 최소한 두비트 차이나야되
이원칙이있음 코드워드간에 
그래야 한 비트 에러를 누군가 가져갈 수있다.
근데 두비트 차이라고도 안된다
두비트 차이나면은 요기 접하는 놈이 하나 있잔아 정확히 접하는 놈은 어느쪽이냐 그것도 또 안된다.

두비트보다 커야됨
뒤에 얘들이 코드워드를 보면 
4개의 코드워드를 보면은 정확히 지금 이 요청에 맞는다 이거임
서로 몇비트 차이나는지 봐라 
얘와 3비트 차이난다
얘와 얘 몇비트 
0하고 차이나는것을 보면 다알수있음 얘도 3비트 차이난다
1의개수가 차이나는 개수임
얘는 4개 차이나고 요기 그 서로 얘들과 얘뜰을 한번 exclusive or을 했을때 그 1의개수가 차이나는개수다
exclusive or 했을때 
01
위에 그림을 보자 01011 그 세번째 있는놈이 10101 자 도대체 몇비트 차이나느냐 우리가 exclusive or을 해보면 알수있다.
5개 차이난다 무려 
얘와 얘사이에는 1의 개수가 4개임 (수정) 4비트 차이임
이 코드워드는 뭘 뒤져 봐도 3개 이상 차이난다. 자 여기에 지금 내가 지금 이 코드워드가 몇 비트 차이가 나야 한 비트 에러를 디텍션 할 수있느냐 2 보다 커야된다
이게 지금 2 임
2 (two bit) two bit 만 되더 여기 지금 접하는 놈이 있을 수있다.
투비트만되도 바로 요고 한차이 얘와 한차이 라는 놈이 있을 수 있다 그래서 그거 보다 커야 된다.
투 비트보다 두 코드사이에 두 코드사이에 서로 다른 비트의 개수가 2비트 보다 커야된다.
결국 세비트임 그럼 일반적으로 얘끼할때 내가 한 비트를 에러 디텍션하고자 하는 사이즈를 에러 커렉션을 하고자 하는 사이즈를 s라고 한다면 두배의s 더하기 1 보다 
이 코드워드간에 그 차이날 비트개수가 2배 보다 커야된다
이게 얘가 크다 
해밍 디스턴스라고 얘기하는데

## 해밍 거리
해밍 디스턴스라고함
코드워드간에 차이나는 비트의개수를 해밍 디스턴스라고 함
히밍 디스턴스
근데 이거 보다싶이 얘들간에 서로 다 관계를 쭉 살펴보면 어느경우에는 3개 차이나고 어느 경우에는 4개 차이난다
그러면 그중에 가장 작은 것을 미니멈 해밍 디스턴스가 되는거임
미니멈 이 
2s+1 보다 크거나 뒤에 슬라이드에 있는 
미리 얘기해주는거임 개념을 설명해줄려고 이런 조건을 만족하면 s비트를 커렉션할수가 있다.
s 비트를 커렉션할수있다.

커렉션 할수있다 서로 다른 코드가 이렇게 멀리 떨어져있으면 이속에 들어있는놈은 원래 얘였다 이거지 이속에 들어있는 놈은 얘일수밖에없는거다 중복된 놈이 없으니까 어디선가 분명히 소스는 누군가의 코드워드를 보냈는데 어느놈인가를 보냈는데 가다가 꺠졌다 이거임
꺠졌는데 이속에 들어있으면은 원래 얘엿을테고 이속에들어있으면 당연히 얘엿지 않냐 이거임
근데 가정이 있어
근데 이 서클, 이안에 들어가는 에러가 발생한다는 가정 하에 이제 되는거임
아까 한비트 에러만 발생한다고 하면은 한 비트 를 지름 반지름 을 하는 이원안에 있는 놈들을 요 놈들은 원래 자기에 , 얘뜰꺼였다
라고 이제 우리가 예측할 수있고 
얘와 얘사이는 그래서 두 , 세비트이상의 차이가 있으면 이게 보장이 된다.
한비트만 내가 펄슨 할 수있으려면은 해밍 디스턴스는 3이상이어야함
얘가 지금 3이상이어야한다
이 코드워드들이 
이 디스턴스가 해밍 디스턴스, 미니멈 해밍 디스턴스가 3이라 이거임
여 코드워드들은 그러면 한 비트 에러는 커렉션할수있다.
자 이그림을 이해해야함
디텍션만 한다 그러면 디텍션 만 한다 그러면 어떻게 될까
디텍션만 

자 저 그림을 뒤에 나오니까 
중요한 얘기
저 그 리던던씨 를 보고 에러 커렉션까지 할 수있는거 를 얘기했는데
해밍 디스턴스 얘기가 나옴(슬라이드)
어 오류 제어를 위해서 아주 중요한게 있는데
어 해밍디스턴스라는게있다 두개의 같은 크기의 원간에 차이가 나는 비트의개수
그 어떻게 구하느냐 두 코드 워드를 exclusive oring 해서 나온 값에 1의 개수가 곧 차이나는개수다
결과 1의개수
해밍 디스턴스 
그래서 해밍 디스턴스가 중요한 개념이다
자 000과 011 해밍 디스턴스가 당연히 2고
뭐 그 해밍디스턴스를 구하는방법
간단한데
그럼 일단 우리가 주어진 이 코드워드의 셋이 주어지면 그 셋들간의 해밍디스턴스중에 가장 작은값을 미니멈 해밍디스턴스라고한다
우리가 아까그 10-2절 표에 보면은 얘들이있다.
이런 표가 있다.
000 과 011 아마 그 앞에있는 표
한비트 에러를 디텍션한 표에 의하면 서로간에 해밍디스턴스를 구해보면은 다 2이야 그러면 몽땅 2면
미니멈 해밍디스턴스로 2다
미니멈 디스턴스의 표기는 이거임 d(min)
그러면 이경우에는 바요 이경우에
미니멈 해밍 디스턴스가 2죠 이 거를 만족하는 정수가 s가 있어 없어
투일경우에 미니멈 디스턴스가 2일경우 이걸 만족하는 정수 s는 없다.
따라서 그 10-2 절의 표는 디텍션은 가능할지 몰라도 커렉션은 못하는것이다.
커렉션 불가 그런데 그다음에 5비트짜리 표를 보면은 
해밍 디스턴스를 쭉보면 33344 번해서 미니멈해밍디스턴스가 3이다
자 여기서 집어넣어서 보면은 s가 1이라는게 있다.
한비트가 커렉션이 될수있다. (10.6)
비트가 커렉션이 될수가있다.

디텍션은 요 비슷한 식으로 이건 커렉션이었고
더 쉬운 디텍션은 디텍션은 미니멈은 지금 저기 있져 s+1 
자 내가 디텍션하고자 하는것 더하기 +1
그레야 해밍디스턴스 갖는 코드를 갖고있으면 디텍션이 되는것이다.
그건 무슨얘기냐 

다른 해밍코드가 지금 어디에 들어왔어?
내가 지금 디텍션한 ??? 사이즈 +1 지금 이 해밍코드가 내가 지금 디텍션하고자 하는놈 가령 이 여기에 있는놈은 다 내꺼다 라고헀을때 절대 남에게 있을수가 없다 라고 할려면 내가 지금 디텍션할수있는 이게 s  내가 디텍션하고자하는 뭐에요 , 그럼 이거보다는 하나 더 큰 곳에 이 
하나 더큰곳에 다른 코드가 있어야 그 코드로 생각을 안하는것이다. 
디텍션 이 더 어렵게 생각이되지 지금 ? 커렉션보다 
내가 지금 s안에 들어와있놈들은 다 얘꺼 에러 디텍션이죠

에러가 발생했는데 s 비트가 발생했는데 s비트가 발생한 속에 보면은 다른 코드워드가 있더라 그러면 에러 디텍션을 못하는거였다.
에러가 발생했는데 다른 코드워드랑 같더라 s비트를 그림으로 그릴 필요강벗다
s비트를 내가 디텍션하고싶으면 해밍 디스턴스가 s 보다는 하나라도 크면은 s비트 가 에러가발생하면 다른코드워드가 될수가없다. 다른 코드워드는 s+1 비트만큼의 차이가있어야한다 d minmum이 
해밍 코드와 해밍코드사이에 디스턴스가 s+1 이면 s 까지만 에러가 발생하면은 어느 코드워드로도 들어갈수없기때문에 에러다.
이거임 
그렇죠 자이 디텍션이 더 쉬운 개념인데 이렇게 그리다보니까
디텍션에 그림을 여기서 표현하죠
디텍션 이그림임

자 이 코드워드고 얘도 코드워드다 
그래서 얘가 지금 s 만큼 어 에러가 발생 얘를 보냈는데 
얘로부터 s비트만큼의 에러가 발생한 놈들이 요 원에 있다면 이속에 다른코드워드가 들어있으면안된다
들어와있으면안된다. 그래서 당연히 이 코드워드는 
그래 저거네 
d minmum이 이렇게 표현하는게 맞다 
당연히 미니멈이 s 보다 커야되 그렇죠
다른 코드워드가 s비트 에러속에 들어와있으면 안된다 얘끼는 
d 미니멈이 s보다는 커야된다 이게 바로 d minimum이다
얘와 얘의 깊이의 차이 
얘보다 커야됨 그러니까 이걸 만족하는 어 식은 d 미니멈 에 대한 식은 equal로 바꾸면 더하기 1을 하면된다 이거임
 s+1 
미니멈 해밍디스턴스가 2면 한 비트 에러까지는 디텍션이 가능하다 이렇게 얘기한다 
그래서 얘가 디텍션에 대한 룰이고 
얘가 커렉션에 대한 룰이된다 d minimum
그래서 해밍디스턴스라는 그 용어를 갖고 저 디텍션과 커렉션에 대한얘기를 다한것이다.
그래서 이 내용을 갖고 앞에 표를 다시
살펴보면 앞에 있었던 표는 디텍션 한비트 에러까지만 디텍션이 가능하다는것을 볼수있고
5비트를 만들어서 보낸건 몇비트까지 가능하냐 ? 
미니멈해밍디스턴스가 3였으니까 코드는 2비트 에러 디텍션이 가능한것이다 
2비트 에러가 발생해도 다른 코드워드가 될수없다. 이거임
다른 코드워드가 될려면 3비트가 차이나야되니까
근데 두비트에러가 발생하면은 에러도 디텍션이 가능하다는 뜻이된다

다른 코드워드가 될수없기때문에

자 그때 그때 질문하셈

Q. 찾는과정에서 2s+1 과 같은거냐 
기호가 같다? 그 2s+1 크다라는것도 잇고 s+1 과 같다라는 표현도 있다.
저거의 의미가 같다 ??
그러니까 기본적인 요구는 d 미니멈이 이거임 
이거, 이게 디텍션 s 비트를 디텍션 
s 비트 에러를 디텍션할수있는 요구조건이 저것이다

s+1 을 만족하면 디텍션이 가능한것이고 2s=1 보다 크거나 같으면 커렉션까지 된다는거냐? 
2s+1 이 같다라고말하면안되고 이거를 만족하는 제일 가까운 해는 이거다 이거임 s+1 도 되고 s+2도 되고 +3 도 되고 다
만족한다  s+2 ... s+100 다 만족하는데 
이걸 만족 하는 가장 간단한 방법은 이거임 왜냐하면 이거를 구지 키울필요가없음 
s+100 으로 생각할 필요가없음 코드워드의 길이만 늘어나느거지 
코드워드 길이를 적게 유지하면서 이걸만족하자
라고 하니까 당연히 그러면 이거면되겠네 

2s+1 그것도 마찬가지임
가령내가 지금 두 비트 에러까지 커렉션 하고 싶다. 
이거 지금 5죠 어 
5조 d mimimum이 5면 되는거임 
d mimimum이 5가 되는 코드워드를 만들어내면된다
이건 커렉션임 

이건 내가 커렉션하는쪽에 얘기고 이건 디텍션 하는 쪽에 얘기임
그러니까 이쪽 
봐요 
내가 지금 s비트를 
이속에는 디텍션 당연히 포함하고 있음 가령 내가 커렉션 상관안하고 두 비트 디텍션만 하고 싶다 그러면 
d minimum을 3을 쓰면된다
커렉션을 못해 그대신 3을 쓰면 여기에 적용해보면 1비트 커렉션이 나온다 말이야 그렇죠 
그러니까 내가 목적이 뭐냐
내가 커렉션까지 생각한다 그러면 가령 3비트 커렉션까지 한다고 그러면 
dminimum을 7로 두면은 된다 이거임 그러면 이거는 
무지한거임 이미 이거는 훨씬더큰값임 
디텍션도 가능하면서 커렉션까지 가능한거임 7로 두면은 
내가 커렉션을 포기하겠다 그러면 디텍션만 3비트를 하고싶다 그러면 d minimum을 4를 쓰면된다 
그거는 커렉션을 포기한거임 
물론 4를 쓰면 커렉션을 여기다 집어넣으면 1 한비트 커렉션은 가능하겠다.
그렇게 된다 
내가 목표를 어디로 두느냐 두 식으로부터 
이 그림을 갖고 이해하면쉽다 
코드워드와 자기로부터 얼만큼 차이 발생하는 놈들의 세트가 있는데 그들이서로 중복되지않으면 이 원래 이 원에 있던 이놈들은 원래 얘의 ?? 얘는 다 여기에 쓰더라 이거임

Q. 5비트에서 커렉션 일때 3이잔아 (dminimum) 근데 4비트 차이나는것들 교점 떄문이냐?
그 꼭 3인것들만 5개를 추려내 지못해서 그보다 더큰놈들도 나오는것임
그래서 우리가 3보다 더 크고 한것은 아무 상관이 없고 미니멈만 본다 
미니멈 해밍 디스턴스만 보는거임
미니멈 해밍 을 3으로 두고 조금더 안전하게 하기 위해서 
안정화 의미가 아니라 교점이 생기면 이 교점이 양측에 속할 수있으니까 +1을 더해서 주는것임
그냥 그런 코드가 만들어 , 이것만 만족하면되지 뭐 그 4가 되는 놈들을 더많이쓰고 이런다고 더 안정화 되고 
안정화가 아니라 이렇게되면 한비트 에러 커렉션 할수있는거임 확률적으로 4인 놈들이 더 잘 커렉션되는게아님 
이거면 이거 조건만 만족하면된다
이 조건 미니멈이 2s+1 보다 크거나 같아야된다
1일때 3이다 구지 4인놈들을 여러개 더쓴다고 보안이 되느냐 아무 필요없는애기다 
d 미니멈이 3이 되면 되는거임 
