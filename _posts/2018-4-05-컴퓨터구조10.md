---
post : layout
title : 컴퓨터구조10
---
## 컴퓨터구조
컴퓨터구조

## Stack Allocation
1프레임은 프로그램을 실행할 코드들이 저장된 공간이다. 함수가 실행되던중에 다른 함수를 부르면 stack은 위에 높은 주소 , 또 다른 함수 stack이 쌓인다. 
subfunct를 부르면 subfunct를 위한 공간이 할당되어야하고, subfunct가 종료되면 없어진다.(return 시)
이전상태로 돌아가는것을 없어진다 라고 표현한다.

## 담기는 내용
레지스터 앞에 $을 작성하지 않았음.
argument - a0, a1, a2, a3 레지스터를 이용하는데 4개보다 많은 argument를 전달할때는 5개째는 이 stack에 전달한다.

saved register - s0, s1 계산을 했는데 메인코드에서 가져온것을 subfunct에서 계산을 하면 s0, s1 덮어씌워지게 되므로 미리 메인의 s0, s1의 값을 저장해둔다. back up

Local arrays - 지역변수가 이곳에 할당된다.


![stackallocation.PNG](C:\lllilllilllilili.github.io\images\stackallocation.PNG)
한 프로그램을 구성하는 4영역
static data - 한번 할당하면 변함이 없다. global 변수가 이 위치에 들어간다.
Text - code가 들어가는 영역 
$gp - global pointer, 이 위치에서부터는 global 변수가 할당된다.
heap - dynamic data, malloc 동적으로 메모리 할당받는 공간.
Stack - 위에서부터 내려온다. heap하고 stack하고 만나면 더이상 공간이 없으므로 stack over flow가 발생하면서 프로그램이 비정상 종료가 된다. ex) 재귀함수, 종료조건을 잘못 설정하면 호출 계속하다가 stack이 자라서 프로그램이 죽는다.

``
int x,y,z //static 위치
main
	int a,b,c; //stack 위치, main이 끝나면 stack 공간이 위로 올라가면서 사라진다.
``


## return address saved
왜 할까? 
$sp는 이전에 사용하던 함수의 꼭대기를 가리키고 있을 것이다. leaf_함수를 불렀단것은 leaf_함수가 사용할 프레임을 만들어야 한다. -12는 높은주소에서 낮은주소로 내려온다는것 3 word 만큼 내려준다. sp가 가리키는 1,2,3 번에 각각 값을 넣어준다.
이렇게 저장해주는 이유는 caller 쪽에서 subfunct에 넘겨준 값을 쓰고 있었을 지도 모르니까 저장해둔다. 
return 값은 항상 $v0에 넣고, 끝났으니까 돌아가야 하는데 아까 대피시켰던 값을 회복시켜주는 방향으로 간다. 
stack이 자라고 줄어드는것은 sp가 움직이는것이다. sp가 이전의 위치로 돌아가야 한다. 12만큼 더해주면 이전상태로 돌아간다. ra는 돌아갈 주소가 저장되어있다. 

$t 값들은 그자리에서 임시로 쓰고 버리는 값으로 많이 쓴다. 함수가 다른 함수를 호출할때 t의 값에는 중요한 값을 저장하지 않는다. (Actually Not needed 의미) 백업해두면 안전하다.(sw->lw)

## Compiling a Non-Leaf Procedure
leaf가 말단이다. Nonleaf가 leaf를 호출, 그결과가 돌아가는것을 non_leaf다.
word 3개를 확보시킨다. $a가 특인한데, $ra는 돌아갈 주소가 담겨있다. jal은 다음과 분기함과 동시에 $ra에 돌아갈 주소를 쓰는데, jal의 역할은 이순간에 ra가 다음문장의주소가 넣어져서 바뀐다. 그래서 ra가 돌아갈 주소가 사라진다. 따라서 미리 백업해둔다.
main에서 인자가 하나올텐데 $a0 레지스터를 통해서 올것이다. nonleaf에서 leaf를 호출하면 a0를주고 a1,a2,a3,a4 를 줄텐데 이미 a0값은 엎어써버렸으니까 다시 main으로 돌아올땐 a0의 값이 백업해둔값으로 돌아와야 한다.

*새로운함수호출때문에 바뀔값들을 미리 백업해둔다.

*복원은 lw로 한다.

(중요) sw $ra, 4($sp)를 빠뜨리면 jr $ra는 lw $a0, 0($sp) 이지점으로 돌아간다.

## Comiling a Recursive Procedure
자기함수에서 자기를 부르는것을 예로들었다.
fact를 부를때 첫인자를 $a0에 저장한다. 결과값은 $v0를 통해서 와야 한다.
프레임 사이즈는 한 function 호출하기위해서 stack에 8byte를 써준다.
$ra를 대피시키는것은 내가 또 다른 함수를 호출할 수 있기 떄문에 
$a0를 대피시키는것은 $a0를 받았는데 다음 함수호출시 $a0를 쓸 수도 있기 때문에
jar fact는 main실행후 두번째이기때문에 $sp위에다 또다른 프레임이 생성된다. 스택공간이 새로 생기면 새로운 데이터를 사용하지 이전에 데이터값을 사용하지 않는다.

언젠가 0이 되면 addi $v0, $zero, 1이 위치로 들어간다. 이때 jr $ra는 jal fact 다음 주소를 가리키고 있다. $a0, $ra를 회복시키고 스택의 공간도 회복시킨다.
mul $v0, $a0, $v0에서 가장 오른쪽의 $v0는 방금 밑에 stack의 저장된값 f(n-1) 값이다.
jr $ra 나를 호출한곳으로 다시 돌아간다.

![Recursive.jpg](C:\lllilllilllilili.github.io\images\Recursive.jpg)

## MIPS Instruction Classes
MIPS Instructions들의 비중을 살펴본다.
Conditional branch가 정밀계산의 비중이 떨어지는 이유는 이미 짜여진 코드 수행하는 행렬같은 경우 loop나 이런것을 적게 쓰기 때문이다.
benchmarks = 대표프로그램들을 모아서(파워포인트, db app) 컴파일해서 실제로 실행, 각각의 명령어들을 일일이 카운트해서 분석한다.


## 프로세스아키텍쳐
위와같은 명령어들이 동작할수있게끔 logic을 만든게 프로세스다.
프로세스 설계를 공부한다.
프로세스는 데이터패스와 컨트롤로 이루어져있는데, 데이터패스는 alu, multiplexer 이런건 조합회로로 구성되어있다. 조합회로는 상태에 대한 정보를 갖고 있지 않다. 완전히 아웃풋은 인풋에만 의존한다.

![컴구.jpg](C:\lllilllilllilili.github.io\images\컴구.jpg)
buffer는 들어온값을 잠시 buffering한다는 뜻

![컴구2.jpg](C:\lllilllilllilili.github.io\images\컴구2.jpg)
입력을 32bit로 받고 출력도 32bit로 내보낸다.
ALU 안의 한부분에 add가 들어가는것이다.
ALU안에 여러 함수들이 있고 이중에 하나가 ADD, OR 이런것이다.
ALU control은 입력이 들어오면, 전기가 들어가면 여러개가 동시에 동작하는데 그중에서 선택해서 보내고 싶을때 control이 통제해준다.(그 순간에 내가 원하는값을 지정하는것이 control이다.) 표참고

alu를 구성하는 기본적인 조합회로는 multiplexor다.

![컴구3.jpg](C:\lllilllilllilili.github.io\images\컴구3.jpg)
선택신호에 따라 0이면 0번이 나오고 1이면 1번이 나온다. 그걸 s가 통제한다.
A,B 공통값이라고 하고, S에 의해서 어느 하나의 값만 의미가 있고 나머지는 무시된다.
4TO1Mux는 위에 보이는 바와 같다. Input으로 4개가 들어온다. 선택신호 s가 있는데 s는 bit로 따지면 2bit가 필요하다. s0,s1이 00이면 A가 선택되고 이런식이다.

민텀 그리고 연결이 되어있다.(NOT이 안붙어있는부분은) 이게 끝이 아니라 사이 게이트도 존재한다. 4개중에 하나 선택하라는 Mux다.
Input에 대해서 Mux를 표현할때 각각의 bit가 몇 비트인지 표현할 수 있다. 32든지 64든지(컴퓨터 사양에따라??)

## Storage Elements(1)
![컴구4.jpg](C:\lllilllilllilili.github.io\images\컴구4.jpg)

![컴구5.jpg](C:\lllilllilllilili.github.io\images\컴구5.jpg)
메모리는 디 플립플랍을 기준으로 한다. D값이 안에 저장되도록
레지스터는 클락에 의해서 동작을 하고 Write Enable은 이 안의 값을 변경할 수 있게하냐, 비활성화 시킬것인지 
클럭 에지에서 값이 변한다. Falling edge에서 값이 변한다.(negative edge에서 변한다.)
write enable이 1일때만 안에값이 업데이트 0은 변하지 않는다.
이런것을 모아둔것을 내부에... 레지스터 집합, 레지스터 파일이라고 한다.
32개의 레지스터가 모여있는것을 레지스터 집합이락 한다.

밖에서는 내가 원하는 레지스터의 번호가 전달된다.
## Register File(1) : Output

![컴구6.jpg](C:\lllilllilllilili.github.io\images\컴구6.jpg)
읽을 레지스터 첫번째 넘버, 두번째 읽을 레지스터 넘버, R-format에 rs가 first source rt- seconde 소스 rt-destination

![컴구7.jpg](C:\lllilllilllilili.github.io\images\컴구7.jpg)
값이 아니라 레지스터 넘버를 읽는다. 넘버는 5bit다. 레지스터 내부에 32 넘버는 5bit로 표현가능하다. 데이터를 write data에 써줘서 Read register에서 레지스터 넘버로 읽어온다. write시 32bit로 보내진다. 레지스터에서 읽혀진 값이 read data로 나온다. 읽혀진값도 32bit 내보내진다.

r0~r31까지 있는데, 각각에 들어있는 값은 자기 number와 같은 값을 갖는다고 가정하자. 3과 7이 레지스터 넘버로 들어가면 레지스터 3번과 7번에 들어있는 값 3과 7이 나온다.9번에다 2000을 전달하면 r9에 9 값이 있을텐데 2000으로 바뀌는데, 바귀는건 clock이 떨어질때 바뀐다.

Regwrite는 Register write이고, register에서 writeenable이 레지스터 각각에 들어가는데 이게 writeenable 역할을 한다.

## Storage Elements(3)
메모리는 cpu밖에 있고, 메모리에 addr 전달되면 해당 addr 값이 밖으로 나오고 메모리에 값을 쓸때, addr 과 데이터를 전달하면 addr위치에 데이터가 저장될 것이다. (wrtie)
그래서 메모리에서 두개의 신호가 필요하다. 읽을때는 MemRead 쓸때는 MemWrite

![컴구8.jpg](C:\lllilllilllilili.github.io\images\컴구8.jpg)
읽을때는 MemRead에 1을 전달하고 쓸때는 Memwrite에 1을 전달한다.
비활성화될때 0으로 전달될 수 있기때문에 신호선을 각각 구분한다. 
addr line 32bit, dataline 32 bit, read된 data output 32bit, memread, memwrite 1bit이다. 1일때 해당동작 활성화, 0일때 비활성화

## Register File(1) : Output
Mux는 32개중에서 하나를 고르는것이다. 규칙성을 알고있지만 Input과 선택선(select, controlline) 와 mux면 input수관계를 보면
Input을 n bit 신호선을 m bit로 표현하면 n은 2의^m 이다. m이 5이고 n이 32개다.(현재그림에서)

## Register File(2) : Input
write가 들어가고
레지스터 넘버가 들어오면 해석해서 값을 알려주는 디코더가 제일 앞에 있다. 디코더의 특징은 출력중에서 오직 하나만 1이 되고 나머지가 다 0이 되는것이 특징
들어온값이 8이다 라고 가정 (32bit 선인데, 000000000... 1000) 0~32값 중에서 8번 bit만 1이되고 나머지는 0이되도록을 디코더라고 한다. 지정된 bit만 1이나오고 write 신호하라는 신호와 합쳐지면 해당하는 부분에만 클락신호가 들어가고 나머지는 0이되면서 write가 반영이 안되고 선택한 부분만 값이 반영된다.

## Instruction Execution(Steps)

![컴구11.jpg](C:\lllilllilllilili.github.io\images\컴구11.jpg)
프로그램이 메모리에 있고 cpu에서 메모리에 있는 명령어를 가져다가 실행을 하는데 각각 그림은 cpu와 메모리 cpu안에는 레지스터와 pc가 있다.
addi가 1000번지, lw 1004번지라고 하자. 프로세스가 있고 메모리가 있는데 pc 현재 다음 실행할 명령어의 주소를 가지고 있는데 1000번지 번지 수행하면 1000번지에 있는 명령어를 가져다가 레지스터 안으로 가져온다. (메모리에있는 한 명령어를 프로세스로 가져오는 이 동작은 Instruction fetch, fetch는 가져온다. 메인 메모리에서 명령어를 가지고오는 동작행위)
한 word를 읽는거지만 메모리쪽에다 read signal을 준다. 메모리에 값을 가져와야 하니까
pc는 다음 실행해야할 위치가 10004로 자동적으로 업데이트한다. (명령어를 가져오는 가장 기본적인 동작으로 instruction-fetch step이라고 한다.)

명령어를 가지고 오면 cpu안에 저장했는데 이건다 binary code로 되어있으므로 cpu는 지금 온 명령어를 해석한다. (용도 파악) Decode라고한다.(가저온 명령어를 해독한다.) opcode rs rt rd 해석후 레지스터에 값을 보내주고 레지스터에게 꺼내달라고 요청한다 해당되는 값들을 register free fetch라고 한다.

첫번째 두번째 step은 항상 동일하게 실행이된다. 이것을 공통적인 스텝이라고 한다.
3,4 단계는 해석된 명령어에 의해서 조금씩 달라진다.