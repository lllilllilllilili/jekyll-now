## Ex : File Sharing between Childs and Parent
my file을 read mode로 오픈했다. 
copyfile을 만들었다. 그래서 copy file에 복사할 것이다. 중간에 fork는 생각하지 말고
my file에서 한 바이트씩 읽어와서 eof까지 읽어서 write하고 
한 바이트 씩읽어서 한 바이트씩 카피한다. 다 카피하면 클로우즈 한다.
문제는 fork 가 들어갔는데 child-parent를 나누지 않았다. 결과적으로 부모도 자식도 fork 아래 프로그램을 동시에 돌린다. parent도 input에서 한 바이트 읽어서 copy file에 복사하고 자식도 같은 작업 수행

fork가 하나 더들어가면 프로세스가 4개가 생긴다.
4개가 똑같이 한 바이트씩 읽어서 한 바이트씩 복사한다.
fork 하면 무슨일이 일어나냐? fork시 open 된 파일도 물려받지만 파일 open하면 r/w offset 공유한다(중요)
부모가 한 바이트 읽으면 r/w offset 하나 간다. child 가 읽을때는 뒤에서부터 읽는다. (이어서)
부모와 자식이 돌아도 r/w offset 같은 번호를 읽진 않는다. 
쓰는것도 마찬가지다. 부모가 쓰면 그다음에 자식이 쓴다. 

프로세스가 2개가 됬다고 해서 파일이 2개로 커지지 않는다. 똑같이 일어난다.
key point는 r/w offset을 같이 쓴다.(중요) 그게 문제다.

fork 했으니까 결국은 while 속에 read가 있고 write가 있는데 fork 한 순간에 child가 생겨서 child도 while 룹을 돌면서 read하고 write 하고 있다. 부모가 한 바이트 읽어서 쓰고, 자식으로 가면 그 다음 바이트 읽어서 그 다음 바이트 쓰면 문제가 없는데 (프로세스가 두개일뿐), 부모가 한 바이트를 리드하고 라이트 하기 직전에 스케쥴링이 일어나서 context switch로 자식 프로세스로 넘어갔다고 치자(중요)

그러면 child가 그 다음 바이트를 읽는데 child 가 write하면 그 다음 바이트 먼저 쓰고 스케쥴이 부모로 다시 돌아오면 부모가 썻던걸 이후에 쓰니까 결과적으로 어떤때는 뒤집히는 결과가 나온다.(재수가 없는경우)

concurrent 는 공유를 하면 문제가 생긴다. read/write offset을 공유한다. 공유해서 문제가 생긴다.

parent가 read를 했으면 write를 완성해야 스케쥴이 넘어가면 해결되지 않을까? read, write 중간에 context_switch이 child로 가면 안됨(다른곳은 됨) 왜? 공유하고 있으니까(중요)(중요)
이렇게 경쟁하듯이 순서가 뒤바뀌는것을 race condition 이라고 한다. 
race condition 때문에 생기는 것이 critical section (임계영역)이라고 한다.

critical section 설명하는 예는 화장실 얘기다. 아파트에 화장실이 하나다. 집에는 두식구가 산다. 한사람이 화장실에 들어가면 볼일을 다볼때까지 다른 사람이 기다려야 한다. 화장실은 들어갔는데 끝을 못맺었는데 다른애가 화장실문을 열고 들어오면 문제가 생긴다. 사람 각각을 프로세스라 하면 공유하는것으로 판단한다. 화장실 변기를 공유한다. 
화장실 들어갈때 문을 잠근다. 나올때는 열어야 한다. 화장실 들어갈땐 노크를 하고 들어가라! 노크를 한다는것은 서로간 지켜야하는 프로토콜이다. (지켜야 하는 약속)=>critical section

문을 잠그고 들어가거나 노크를 하고 기다려주고 물어보는것은 솔루션이다. 문을 잠그고 while-read-write 한쌍돌때 문을 read하기전에 잠궜다가 write할땐 문을 풀어줘야 한다. 그렇게 해야 제대로 돌아간다. 

그런 솔루션을 mutual exclusion 이라고 한다.
exclusion은 베재한다. 의미 mutual 상호간의 
중요한 말은 내가 사람이 2명이 있는데 아빠, 엄마 화장실 공유하는데 각각 하는 일이 다르다(독서, 일) 이경우에 상관없지만 문제가 생기는것은 둘다 화장실 들어가고 싶을때 문제가 생긴다. 화장실 부분만 막아주면된다. =>mutual exclusion이라 한다. (오직 부모와 자식간의 관계에서만 이러한 문제가 생긴다 왜? 공유하니까)

## File Sharing between Childs and Parent
병행 프로그램에서 프로세스를 두개를 만드는데 병행 프로세스가 뭔가를 공유하면 문제를 생긴다.
병행 프로그램은 cuncurrent 프로그램 디버깅 소용없고 디자인을 잘해야 한다. 


## Inter-Process Communication(IPC)
fork를 해서 프로세스 여러 개 만드는것을 배웠는데, 콜라보레이션을 할려면 뭔가를 주고받아야 하는데 그런것들을 Inter-Process Communication(IPC)라 한다. OS는 ipc 툴을 많이 제공한다. 
r/w offset을 공유한다던가, file에다가 한 프로세스가 적으면 다른 프로세스가 읽어가면 공유가 된다. 
일반적으로 프로세스 사이에는 파이프 하나 있고, 
network socket은 멀리 떨어진 기계끼리 통신하는거 이런 여러가지가 있는데 파이프를 배우닫.


## circular queue
array를 원으로 만들어서 하나는 집어넣는 insert가 있고 끄내가는 remove가 있다. 큐는 front가 있고 rear가 있다.(집어넣는데가 있고 끄집어 내는데가 있따.)
그것을 os가 제공하는게 파이프다.
파이프를 할려하면 두개의 프로세스가 어떤 애는 집어넣고 어떤 애는 끄내는 과정을 한다. 
큐를 공유하므로 공유하면 crtical section문제가 생긴다. 
그런 문제를 없게끔 통신하는 기법이 파이프다. os가 제공하는 circular queue고 부모 와 자식간에 쓸수도 있고
전혀 관계가 없는 프로세스 사이에서 쓰는것을 (named pipe)라는것도 있따. 

파일을 하나 만든다. (가상파일) 파일은 가상적인 파일이라고 생각하고 
unnamed pipe라는것은 부모와 자식 사이에서 쓰는데 프로그램이 끝나면 자동으로 없어지기 때문에 이름이 없다 해서 unnamed pipe라고 한다. 

unnamed pipe를 배운다. 
파이프는 


## Pipe  an IPC tool(con't)
가운데 pipe channel에 큐가 있다. 파이프가 큐다. 집어넣는대로 밀려서 간다라고 생각하자.
읽는것은 앞에있는것을 끄집어 낸다. 파이픈데, 모양은 그런데 사실은 circular queue로 만들어져 있다.

크기는 4kbyte다. 이것을 가상적인 파일이라고 생각한다면 file open하면 r/w offset이 생긴다. r/w offset은 읽는데도 쓰고 쓰는데도 쓴다. 근데 queue는 쓰는 포인터하고 읽는 포인트가 다르다.(프론트와 리어가 다름) 결과적으로  큐로 볼려하면 파일을 2번 오픈해야 한다.(r/w offset 2개가 생긴다 하나는 프론트 하나는 리어로 쓸거다) 그것을 구현한것이다.

파이프를 오픈하면 프로세스가 여러개있는데 하나씩 생각하자 우선은!
이 파이프는 동구화 도구 이기도 하다. 동기화는 어떤 프로세스를 만들어놓고 내가 뭘 줄때까지 기다리는 상태다. block 되서 기다린다. 메시지를 보내면 꺠어나고 그 메시지를 받아서 일을해라! block됬다가 메시지를 보내면 꺠어난다.
그런것을 동기화라고한다.(syncronize)
파이프에 집어넣는게 하나도 없으면 비어있으면 읽을려하면 블락된다. 기다린다. 언제까지 뭐가 날라올때까지 큐에서
집어넣주면 받는쪽을 꺠워주는 역할을 하고 
파이프에 많이 있을때 가져간다.

항상 cuncurrent는 집어넣는쪽이 빠를수도 있다. 4kbyte 꽉차면 집어넣응ㄹ 대가 없으니까 집어넣는애가 블락된다. 
공간이 생길때까지 block됬다가 깨어난다. 파이프는 메시지를 다른 프로세스에게 전달할 수 있는 수단이면서 block된것을 꺠워줄수있는 수단이된다.(일반적으로 이것을 producersconsumers라고 한다.)
producers는 데이터를 생산한다. consumers 소비자다. 이둘은 항상 속도가 다르다.(서로 다른 프로세스) 그래서 완충한느 큐가 필요하다. 강류 상류에ㅓ 하류에 너무 많이 보낼것 대비해 댐을 쌓는데 댐과 같은 역할을 한다.

concurrent에서 제일 많이 등장하는 프로세스간의 관계다.

## PIpe : an IPC tool
파이프는 통신도 하지만, block의 wake up도 한다(기다리고 있는것을 꺠워준다.)
파이프는 가상적인 파일 이라고 생각한다. pipo 파일이라고 한다. r/w offset이 두개가 있는 파일이다. 하나는 front 읽을때 쓰고 하나는 쓸때 쓴다. 두개 생기니까 두번 오픈한다 실제적으로 Internal이 두번 오픈한다 파일을


os가 제공하는 circulat buffer 혹은 ring buffer라고도 한다. 집어 넣고 뺴깔 때 문제가 생겨서 mutual exclusion이 해결책으로 필요하다.(자동으로해준다.)

중요)파이프가 비어있는데 읽을려 하면 블락된다.(집어넣을때까지 파이프에 뭔가를)

중요) 프로세스가 파이프가 비어서 기다리고 있는데 파이프에 뭐가 하나 들어나면 꺠어나서 가져오는것이고 내가 기다리고 있는데 보내는쪽에서 일다해서 close하면 더이상 기다릴 필요가 없으므로 writer가 close했을때도 꺠어나게 된다(중요)

중요) writer는 파이프가 꽉차게 되면 블락된다. reader에서 가져가서 빈칸이 생기면 다시 wake up이 된다.

이 세개는 정말 중요하므로 꼭 숙지하자.

## Pipe Example
if(fork() ==0)이 child process 다. 파일을 읽어서 보낼것이다.
파이프를 통해서 부모한테 보낼것이다. 10byte씩 보낼것이다.
 55바이트면 나머지 5바이트 보내게 될것이다. n만큼 보내니까
child는 파이프에다가 쓰는 역할을 하는 프로듀서다. 부모는 파이프에서 읽어들인다.
읽어서 다른파일에 복사한다.  
중간에 보면 pipe(fd) 시스템콜이있다. 파일디스크립터를 준다.
파일 오픈할때 디스크립터 3,4,5 받아온다. 했었다 파이프는 internal이 파일 2번 오픈하는것이다.
디스크립터가 2개가 필요하다. array를 2개를 잡았다. fd0 , f1이 들어오는데
fd0는 읽는전용으로 쓸거고 fd1은 쓰기 전용으로 쓸것이다.

pipe(fd) 파일오픈한거니까 그 다음에 forkㄹ를 하면 부모도 파이프를 물려받고 자식도 오픈 파일을 물려받는다.
파이프가 두번 오픈했으니까 (fork떔에) 파일을 4번 오픈한게 된다. close는 4번 나와야 한다.
부모에서 2번 자식에서 2번 나와야한다.

포크한값이 0 이면 child process다. input file로 open해서 read mode로 한다.
나는 파이프에다 쓸꺼다(파일에서 읽어서) 읽는 채널이 필요없다. close(fd[0])했다. 쓰기만 할꺼니까 파이프에다
그러고 나서 input file에서 10byte씩 읽어서 그것을 write fd[1], 파이프에다 쓰고 있다.
언제까지 eof 까지 다쓰면, 전부다 close하고 파이프의 쓰는 write channel 도 임무를 다해서 close하고 exit을 한다.

부모 프로세스를 보면 pipe로 부터 두개를 물려받는데 쓰는게 필요없으므로 fd[1]을 닫는다. 
그리고 output file을 하나 만들어서 읽는것을 파일에서 읽는게 아니라 파이프에서 읽는다, 10바이트씩 읽는다. 읽은거 만큼 ooutput 파일에 카피한다. child는 10바이트씩 읽어서 파이프로 보내고 부모는 파이프를 통해서 날라오는 10바이트씩 받아서 파일 에  카피하는 프로그램이다. 다했으면 close하고 읽는 채널도 필요없어서 fd[0] 닫고 wait해서 child가 죽기를 기다린다. 

파이프해서 오픈을 두번 했는데 close는 양쪽에 2번씩 4번이 나왔다.
프로그램이 끝나면 이 파이프는 가상적인 파일이지만 없어지기 때문에 unnamed file, 이름이 없는 파이프라고 한다.

named pipe는 세미나를 통해서 한다. 이름만 있다. 부모와 자식간에쓰는게 아니라 전혀 관계없는 프로세스끼리 쓸때 이름이 있어야 찾을 수 있기떄문에 

여기서는 물려받았기때문에 이름이 필요없었다.  

## Shell processing with pipes
shell에 로그인해서 들어가면 컴파일 했다하면 a.out돌리면 printf하게 화면으로나온다.
빨리 지나간다고 생각해보면, | 치면 한 페이지씩 보여주고 yes no물어봐서 넘어가겠다.
| 가 shell이 하는게 아니라, a.out은 우리가 짠 프로그램이다. 
more는 프로그램은 따로 있다. shell 이 아님
more은 키보드에서 입력하는것을 받아서 scanf, getchar 입력받아서 한 페이지가 꽉차면 물어보고 
입력을 받고 넘어가는것이 more다.

a.out은 아웃풋이 printf standard out으로 나갈것이다. 
more는 키보드에서 입력을 받아서 standard Input에서 입력을 받는다.
중간에 | 가 있는데 파이프다.
a.out에서 나가는 아웃풋을 화면으로 내보내지말고(standard output으로 내보내지말고) 파이프에다 써라.
파이프로 내보내고, more라는 프로그램은 원래는 키보드에서 받아야 하는데 파이프에서 받는다.

자연스럽게 a.out의 아웃풋이 한페이지 씩 가면서 more가 보여준다.
| , 파이프를 만들어서 a.out하고 more 라는 프로세스를 만들어서 따로 돌리고 중간에 파이프를 만들어주는게 shell 하는 역할이다.

shell도 os 상관없이 유저 프로그램 짜듯이 짠다. 
shell :  //shall은 먼저 fork 하기전에, 파이프를 하나 만들어야 한다
	pipe(fd)//파이프를 만들어서 포크하면 다 물려받으니까
    if(fork() == 0) //첫번째 자식을 만들어서 a.out이 돌아갈것이고 
    	close(1);
        close(fd[0]);
        dup(fd[1]);
        ...	//pcb안에는 open file table이라는것이 있다. 50개까지 있는데 0은 standard Input이 open 되어있고, 
        //1번 standard output, 2번은 standard error channel로 오픈
        //포크하기전에 파이프했으므로 파일을 2번 오픈하는것이므로 3행에 fd[0]가 들어가있다.  
        //4번이 fd[1](파이프의 write channel)이 들어있따. 결국은 파일을 5개로 오픈한채로 오픈했다.
        // 첫번쨰 자식을 만들고 close(1) 한다. standard out을 닫는다. printf를 해서 내보내는 파일 디스크립터 채널을 닫는다.
        //나는 파이프에다 쓸거니까 fd[0] 읽는 채널은 필요없다.
        //dup은 fd[1]이라는 채널을 파이프로 쓰는 채널인데, 배끼라는 얘기다. 위에서부터 내려오다가 제일 처음 빈칸이 나오면 거기다가 복사를해라
        //그래서 pcb안에 open file table의 1번에 fd[1]가 들어간다. 왜? 처음에 close한 위치니까
        //위에서 내려오다가 첫번째 칸에 복사한다. 파이프 채널이 2개가 되버렸다. 2개가 있으면 안된다.
        //2개가 있으면 안되니까 close(fd[1]) 오리지날 fd[1]을 닫아버린다. 결과적으로, standard output 자리에 파이프의 write 채널이 들어간다.
        //a.out을 돌리면 printf 하지만 printf 하는게 화면으로 나가는것이 아니라, 파이프로 나가게 된다.
        // shell이 바꿔치기를 했기 때문이다.
        
   	if(fork() ==0) //shell이 두번째 fork를 해서 more라는 프로그램을 돌릴것이다.
    	close(0);
        close(fd[1]);
        dup(fd[0]);
        close(fd[0]);
        execl("more",...);
	//more로 들어갈껀데, standinput을 바꿔치기 해야한다. 쓰는 채널 fd[1]이 필요없으므로 지우고, 
    //읽는 채널을 빈칸이 0이니까 0에 카피를 하고(위와 같은 과정)
    //오리지날꺼 닫고 결과적으로 standard Input 자리에 파이프에서 읽는 채널이 들어가니까 scanf나 getchar 열심히 해도 
    //키보드에서 들어오는게아니라 파이프에서 들어오게 된다. 프로그램이 돌아가고 shell은 나머지 일을 한다.

쉘같은거 보면 ls 디렉토리 속 파일의 이름을 보여준다.
굉장히 많다. $ls | grep jokim, jokim이 들어가는 낱말의 파일만 보여달라 의미 
이것도 | 의미는 파이프 의미이다.(중요)
ls라는 프로그램이 내보내는것을 가로채서 grep이 파이프를 통해서 받아서 jokim이 들어가있는것만 골라서 보여준다.
shell이 파이프를 가지고 장난친다.

## Program Assignment #1
두번째 숙제, 프로세스가 3개가 된다. (부모하나, 자식 2개) 파이프는 한개가 아니라 두개가 된다.
부모는 파일에서 읽어서 파이프1을 통해서 자식(1)에게 보낸다. 10자씩 받는지 1자씩 받던지 받아서, 소문자가 있으면 대문자로바꿔서 
바꾼것을 파이프2를 통해서 자식(2) = p3에게 보내면 콘솔에다 아웃풋을 한다.

이전 프로그램과 다른것은 파이프를 2개를 만들어야 한다.
파이프를 하나 만들고, 파이프를 만들었으면 parent 인데 여기서 while loop을 돌면서 
파일을 read해서 파이프로 loop 돌것이다(보낼것이다) 

파이프를 만든다음에(부모)	close(fd[0]) 쓰는거니까 필요없어서 닫고 그 다음에 fork()했다. 
안돌아간다. 파이프를 만든다음에 close하면 읽는 채널 닫고 파이프를 fd[1]에다 쓰는데 os가 봤을때 
파이프에서 기다리는 놈이 없다. close를 해버렸으니까 fork 하기 이전이니까 
fork를 했으면 내가 close를 하더라도 child 2개중 하나를 open한 상태니까 기다릴수있는데
미리 close를 해서 다 close가 되기 때문에 write를 할려하면 os 받아가는놈이 없다. 가 된다.
error가 되서 프로그램이 안돌아간다. 파이프를 만들어서 fork해서 물려받은 다음에 부모도 자식도 일을 수행하는것이 좋다.

## 정리
지금까지 한것은 
child process 만들어서 프로세스끼리 돌아가는 concurrent program 이었따. 프로세스를 따로 만들어서 쓰는 경우도 있지만, 
대부분의 경우는 쓰레드를 사용한다. 쓰레드는 그냥 프로세스와 같다. os의 입장에서 프로세스다. 
피프로세스에는 pcb, 스케쥴링도 받아야하고, 해야되는.. 프로세스와 같다.
os는 프로세스라는 말을 안쓰고 태스크란 말을 쓴다. 태스크는 프로세스나 쓰레드를 나타낸다. 
쓰레드도 concurrent 하게 돌아가는 하나의 프로세스다. 프로세스와 다른점은 쓰레드가 훨씬 가볍다.
heavy weigh 프로세스라고 하는데, 무겁기때문에 만드는데 오래걸리고 메모리도 많이 차지한다.
메모리를 많이 차지하는것이 문제가됨(중요)
쓰레드는 경량급, light weight process라고한다. 메모리는 전혀 차지 하지 않는다.
프로세스와 쓰레드의 개념은 쓰레드가 등장하면 프로세스는 주소공간이 텍스트, 데이터, 힙, 스택인데
주소공간이 프로세스 라고 생각하면되고 쓰레드는 cpu의 컨트롤을 가지고 뭐가 하나 돌아간다.(스트림이)
바늘에다가 실을꿰서 바늘이 가면 실이 쫓아온다(이걸 쓰레드라고한다.)

프로그램속에서 프로세스를 하나 만들었는데 거기에 main밖에 없었다. concurrent 프로그래미이 아니다.
거기선 하나만 돌것이다. 그것은 쓰레드가 하나가 돌아간다 개념이다.
프로세스는 fork 해서 만드는데, (text data heap 중에서 data heap stack이 복사가 되서 다른 공간에서 도는데 프로세스를 만들면)
다른 공간에서 쓰레드가 돌아간다.

쓰레드는 돌긴도는데, 프로세스처럼 같은 공간에서 돈다.같은공간에서 3개가 돈다.
같은 공간이니까 메모리를 차지 하지 않는다. 

메인 프로그램은 메인이 돌아가는 그 프로세스가 생기는건데, 한프로세스내 쓰레드가 한개가 있기때문에 main 쓰레드 라고 한다.
fork 를 통해서 프로세스를 만는듯이 프로그램속에서 쓰레드 만들어야 한다.
그래서, 쓰레드는 

프로세스의 리소스를 부과하는데 fork를 하면 data, heap stack을 따로 가졌는데 (복사를해서) 쓰레드를 만들면
data,heap,stack을 완전히 공유한다.(중요) 메모리가 더이상 생기지 않는다. 프로세스 돌아갈려면 스택은 따로 필요하기 때문에
스택은 같은 공간을 쓰지만 스택포인트를 달리준다. 그러면 다른 스택을 쓰게 되는것이다. 공간은 같은데

결론적으론 스택만 따로쓰고, 스택말고 나머지 공유하는게 뭐냐! 데이터를 공유한다. 데이터 구간에는 글로벌 데이터가 들어간다.
fork 처음 설명할때 글로벌 변수가 있었는데 데이터 섹션에 들어가는데 fork 한다음에 데이터 섹션은 카피해서 따로 가지기 때문에
자식이 가지는 a하고 부모가 쓰는 a가 다른 a이다.쓰레드가 되면 같은 a가 된다.
같은 a가 되면, 통신이 간단한다. 파이프를 안써도 된다. 글로벌 변수에다 쓰레드 1이 써주면 쓰레드2가 공유하니까 읽을 수 있다.

좋은점이다. 메모리도 차지 않고 나쁜점은 공유하니까 생기는 문제가 있다.(mutua exclusion으로 해결한다.) 쓰레드는.
각각 성격이 달라진다.
쓰레드는 a는 같은 a를 쓴다.

쓰레드는 데이터를 공유하다. 메인에서 생기면 메인쓰레드라고 하고, 프로세스는 fork 할때 프로그램이 복제가 됬는데 그담에 execv 했는데 쓰레드는 function을 쓰레드로 만든다.(중요) 함수는 원래 calal해서 돌다 return 하는데 함수를 쓰레드로 만들면 
혼자서도 돌아간다. 다른 쓰레드가 되서 따로따로 돌아간다. 

## Threads
싱글 쓰레드가 돌아갈땐 a처럼 돌아가지만 프로세스속에 쓰레드가 여러개있으면 
코드, 레지스터, 스택은 따로 쓴다. 
코드 데이터 파일은 같이 쓰지만
데이터를 share 하는것이 다른점이다(중요)

## Address Space with Threads
어드레스 스페이스는 하나이다. 코드가 텍스트고, data heap이 있는데 다 공유를 하고 스택만 따로따로 쓰고 있다.
쓰레드가 3개가 생기면

## Threads
메인 프로그램이 시작되는데 routine 1, 2 함수가 있다.
함수를 콜하는게 아니라, ptrhead create(routione1) 하면 쓰레드로 따로 돌아간다. 메인 쓰레드와 경쟁해서 프로세스가 경쟁을 하듯이따로 돌기 시작한다. 
2도 따로 돌아간다. 프로그램은 쓰레드가 3개가 따로따로 돌아간다.(프로세스처럼) 프로세스는 프로세스인데 데이터를 공간을 공유하는 프로세스가 쓰레드다.(핵심) 함수의 이름을 줘서 쓰레드를 만든다.


쓰레드는 같은 프로세스 안에서 share하는게 많이 있다. global variable, file close, two pointer 가 같은데를 point 하면 같은 데이터가 될것이다.
이러한 문제떄문에 공유하면 화장실의 문제가 생긴다. 
그런것에 대해 synchronization이 필요하다. 화장실들어갈때 mutual exclusion 해야된다.


## what are Pthread?
쓰레드는 여러가지가 있는데 win32, 마이크로소프트 제공 win32 thread, Ibm 제공하는 쓰레드도 있고 솔라비스 쓰레드도 있는데 버전이 많으니까 POSIX는 OS 표준이다.
Potable os ... 
여기서 pthread 라는것을 표준을 만들었다.
표준을 따라서 프로그램을 짜면 pthread 지원하는 os에 대해 항상 돌아간다. 
POSIX thread를 줄여서 pthread라고 한다.

컴파일을작성시, #include <pthread> 해야하고 컴파일할때 lpthread 하면 library를 같이 load 해달라 의미 pthread library를 같이 프로그램하고 바인딩 해서 돌아가게 된다.

## Process/Thread Creation Overhead
fork 하는데 걸리는 시간과 thread걸리는 시간을 비교한것인데,
여러가지 기계에서 프로세스 1만개를 만들때 100초가 넘게 걸리는데 8.7초밖에 안걸린다 쓰레드는 빠르다. => 메모리를 카피할 필요가 없으니까
ex) 외대 홈페이지 웹서버 돌아간다. 홈페이지 들어가면 클라가 접속된것이다(유저)
서버는 클라이언트를 하나만 상대할수없으므로 클라이언트 접속하면 웹서버가 포크를해서 새로운 웹서버가 생길텐데 포크한 차일드가 새로들어온 클라를 상대하고 원래 웹서버는 또 다른 클라를 기다린다. 반복 => 느려지고, 속도가 떨어진다.
쓰레드로 만든다.클라가 붙으면 쓰레드로 만들어서 클라이언트 붙여준다. 가볍게 된다. 훨씬 많이 만들 수 있다.

## Benefits of Thread Programming
쓰레드의 장점은 쓰레드는 global variable을 공유하기 때문에 fork하고 다른점 이걸 가지고 통신할 수 있다. 장점이자 단점이다.
쓰레드도 프로세스처럼 cpi와 i/o overlaping 하거나 priority 라던가 실시간 스케쥴링 가능 cpu가 여러개면 쓰레드도 동시에 여러개 같이 돌아갈 수 있다.

## Designing Thread Programs
routine1, routine2, final routine을 쓰레드로 만들면 어떤 경우는 하나끝나고 다음꺼 돌아가고 일수도 있고 어떤 경우에는 순거가 바뀔 수도 있고, 어떤 경우는 time slice가 있어서 서로 조각 나서 돌아갈수있고 맨 밑에 있는것은 cpu가 2개 라는것이다. routine 1과 2가 다른 cpu에서 각각 돌면 동시에 돌아갈 수 있다. 전체적은 프로그램의 흐름으로 보면 다 다르다.
(fork()시 char가 뒤집어 질 수 있는 문제가 생길 수 있다.)

## A Simple Example
```java
include<pthread.h>
define NUM_THREADS 5 //쓰레드는 5개를 만든다.
void *PrintHello(void *threadid) //function을 쓰레드로 만듬, 쓰레드로 만들 함수는 항상 void* 리턴하고 argument로 void*로 받아야한다. (약속), 쓰레드를 생성할때 argument를 하나 넘길수가 있다. void * 로 넘긴다. 
{
	printf("\n%d: HelloWorld\n", threadid); //argument로 받은 쓰레드 id를 찍는다. integer을 void *로 바꿔서 보낸것이다. 
    pthread_exit(NULL); //쓰레드가 끝날때, 자동으로해준다.
}
int main(int argc, char *argv[])
{
	pthread_t threads[NUM_THREADS]; //pthread.h에 정의되어있는 ptrhead_t는 struct다. 쓰레드의 아이디 혹은 정보를 저장하고 있다. 구조체다. 쓰레드의 식별자로 쓴다. 쓰레드를 5개만들거니까 구조체를 5개 만들었다. 
    int rc, t;
    	for(t=0; t<NUM_THREADS; t++){ //loop 5번 돌면서 pthread 만든다. 
        	pintf("Creating thread %d\n"t);
            rc= pthread_create(&threads[t], NULL, PrintHello, (void *)t);
            //구조체의 주소를 주었다. array가 5개가 있으니까 5개 각각의 구조체를 줘서 첫번째 쓰레드의 id받아오고 두번째 쓰레드의 id받아오고 하기위해서 항상 어드레스를 주게 되어있다.(받아와야하니까) 두번째 argument는 null이 되어있는데 쓰레드의 성격이다. 다음 argument는 printHello로 함수이름을 주었다.(함수의 주소가된다.) 쓰레드로 만들어라 마지막 argument는 t를 넘겼다. 쓰레드를 생성될때 t를 받아가라(t는 integer인데 void * 받기로 되어있다. 여기서 쓰레드 id를 그냥 찍는게 아니라, 괄호하고 (void *) 캐스팅 하는게 좋다. 32bit 기계에서는 void * 32bit 인데, 64 bit 머신에서는 void * 가 64bit이다. 인트는 4byte니까 못받는다. 컴파일이 안된다. 64bit 머신에서는 void *을 longlong으로 바꿔야 한다. (longlong = 64bit integer))
            if(rc){print("ERROR; ...%d\n",rc); exit(-1);}//쓰레드를 만들다 에러가 났으면 죽어라
            }
            pthread_exit(NULL);
        }//loop을 돌면서 쓰레드를 5개를 만들면서 0,1,2,3,4를 argument로 넘겼다. 쓰레드가 5개가 돌아가면서 0Hello world 1Hello world ... 4Hello world 찍는다. concurrent하게 돌아가니까 순서가 보장이 안는다(어떤게 먼저 찍힐지 알 수 없다.) 먼저만든순서대로 돌아가겠지만(보통) 따로따로 스케쥴링을 받아야 하니까 순서가보장되지는 않는다.
```

## The Pthreads API
concurrent를 짜기 위해서 쓰레드를 만들었으면, 돌아가기 시작 
cpu가 여러개면 동시에 돌아갈 수도 있고, 번걸아가면서 돌아갈 수 있다.
pthread library가 제공하는 api는 3개가 있다.
1. thread management
thread를 만들거나 , thread를 죽이거나 하는것 
쓰레드 관리
2. mutexes 
mutual exclusion이라 했는데 이것을 줄여서 mutexes라고 한다. 화장실 갈때 쓴다.
3. Condition variables
저쪽에서 뭔가 기다리고 있다. condition 깃발 하나로 set하면 돌아가도록 설정, sychronize 할 수 있다. 만일에 네트워크를 통해서 영화를 보면 네트워크를 통해서 화면, 음성 날라온다. 화면을 display 하는 소리와 sound display하는게 시간을 맞춰야 한다. 

## The Pthreads API
나중에

## Creating Threads
pthread create 할때는 
pthread_create(&thread, attr, start_routine, arg)
1. thread의 id를 읽을 정보를 담은 구조체 
2. 속성
3. start_routine 루틴의 이름
4. 루틴에 넘길 void* argument를 줘야 한다. 
속성은 쓰레드의 속성을 의미한다. null이라고 정하자(dafault로 thread를 만들어준다.)

## Terminating Thread Execution
thread는 언제 끝날까?
function thread는 thread 각각으로 구성
function에서 return 하면 thread는 없어진다.
return을 하거나 function이 끝났거나 thread가 없어진다.
ptrhead_exit을 할때도 thread는 없어진다. 
*주의: return이라는것이 자신을 call한 함수로 돌아가는 것이 아니라, pthread_exit 과 똑같다 의미이다.

pthread_cancel은 자기가 죽는게 아니라 다른놈을 죽이는것이다. (thread Id를 받아서 다른 thread를 죽일 수 있다.)

thread 10개가 돌아간다 가정, 그중에서 하나의 thread가 만약 exit 했다 한다면 exit은 process가 죽는것이다. thread는 process 안에있으므로(중요) 프로세스가 없어지면 thread가 존재할 수없다. (전체 동반자살)
하나의 thread가 exit하기만 해도 프로세스가 죽는거기 때문에 모든 thread가 죽는다. 

fork() 한다음에 execv 하는것도 새프로그램을 올리는것이므로 thread가 다 없어진다.

child process exit 할때 뭔가 넘길 수 있다고 main이 wait 하는데 값을 pthread_exit 해서 값을 주면 이 값이 자기가 죽기를 희망하는 thread에게로 넘어갈 수 있다.
process에서는 exit 과 wait 이었다. 
thread에서는 주는 놈은 pthread_exit을 하고 기다리는 애는 pthread_join을 한다. (두개가 하나가 죽어서 하나가된다.) 
맨마지막 argument가 function을 thread로 만들어서 시작할때 void * 넘겨줬는데 이것을 잘써야한다.
## Passing Arguments to Threads 
위에

## Passing Arguments to Threads 
쓰레드에게 argument를 쓰레드 하는방법
```java
int *taskids[NUM_THREADS]; //넘길게 있으면 void * 를 사용한다.(캐스팅해서), taskid = thread id
	for(t=0; t<NUM_THREADS; t++){//
    	taskids[t] =(int*) malloc(sizeof(int));
        *taskids[t]=t; //taskid의 주소가 넘어간다.malloc을 했으니까, integer의 pointer 였는데 void * 로 캐스팅해서 보내야 한다. 받는쪽에서는 interger * 캐스팅해서 다시 쓰면되는데 64bit 머신에서는 longlong으로 해야한다. 
        printf("Creating thread %d\n", t);
        rc=pthread_create(&threads[t], NULL, PrintHello, (void *)taskids[t]);
        ...
    }
    
struct thread_data{
	int thread_id;
    int sum;
    char *message;
    
}; //thread를 만드는데 넘길게 많다. struct로 만들면된다. struct의 주소를 넘기면된다.
struct thread_data thread_data_array[NUM_THREADS]; //thread 여러개 만듬, thread 만큼의 array 만듬, array의 element의 주소를 void* 캐스팅하면 살아나는 thread가 받는것은 이 struct의 주소를 받으니까 그것을 다시 struct thread data*로 캐스팅해서 element를 access하면된다.
void *PrintHello(void *threadarg){
	struct thread_data *my_data; 
    ...
    my_data =(struct thread_data *)threadarg;
    taskid = my_data->thread_id;
    sum=my_data->sum;
    hello_msg=my_data->message;
    ... 
}

int main(int argc, char *argv[])
{
	...//thread가 loop을 돌면서 5개를 만든다.  
    thread_data_array[t].thread_id = t;
    thread_data_array[t].sum=sum;
    thread_data_array[t].message = message[t];
    rc=pthread_create(&threads[t], NULL, PrintHello, (void*)&thread_data_array[t]);
    ...
    
}
``` 

## Thread Argument Passing(Incorrect)
int rc,t;
for(t=0; t<NUM_THREADS; t++){
	...
    printf("Creating thread %d\n",t);
    rc=pthread_create(&threads[t], NULL, PrintHello, (void*)&t);
    ...
}
//thread를 loop을 돌면서 5개를 만든다. integer t가 있는데 t가 0이고 NUM_THREADS가 5면 0~4까지 변한다. 
아까는 t에 값을 보냈는데 t에 주소를 보냈다. t의 주소를 void*로 캐스팅해서 보냈다. 문제가 생긴다!

//첫번째 생성되는 thread다. argument로 t의 주소를 받아서 t안의 값을 가지고 올려하면 &t를 해서 가지고 와야 한다. 주소를 passing 했으니까 PrintHello가 생겨서 t를 access 할려니까 loop을 돌면서 t의값이 변하고있다.(변수로 써서) 나중에 thread가 생성되서 그 주소를 찾아가보면 원래 t는 0을 받았어야 했는데 t의 값이 변해있을수 있고, 안변해있을 수 도 있다.

//main이 있는데 t variable이 있다. thread가 하나있는데 t의 주소를 넘겼다. t에 0을 집어넣고 t의 주소를 넘겨줬으니까 내가 받는건 0이어야 하는데 t에 대해 loop을 돌고있으니까 loop이 돌고있을때 t의 값이 뭘로 바뀔지 알 수 가 없다. (오류) 

//thread를 쓸때는 pointer는 조심해야 한다.(중요)
//pointer를 main thread와 생성되는 thread가 공유하기 때문이다. 문제가 생긴다. 화장실의 문제가 발생한다.

## Thread Identifiers
pthread_self() 라는것은 자기의id를 리턴해준다.
자기 id를 저장하는 thread_struct가 있다고 했었다.
그것을 pthread_self()에 돌려준다.
id 리턴

thread 의 struct 2개를 가지고 같은 thread인지 다른 thread인지 확인한다.
pthread_equal, 잘 안쓴다.

fork 시 부모는 wait을 해야하는데 fork 시 부모와 자식의 관계가 있는데 thread는 thread가 thread를 만들던 main thread가 thread100, 10000개 를 만들든 그 thread는 다 형제지간이다. 부모가 존재하지 않는다.(중요)
thread는 모두 형제다.
여기서는 아무나 wait를 할 수있다.(중요)
어떤 thread의 id를 주면 어떤 thrad가 죽을때까지 기다려달란 말이다.

thread가 죽을때 pthread_exit에게 status를 넘길수있다.
죽으면서, 값을 pthread_exit으로 받아올수있다.

pthread에서는 pthread_exit과 (기다리는)pthread_join이 있다.
## Joining Threads
pthread_join은 main thread가 한다.
일을 기다리는건 main thread니까

thread에는 2가지가 있다.
1. joinable thread
끝나는것을 기다릴수가있다.
2. detached thread
형제인데 떨어져 나간다. 떨어져 나가서 기다릴수가 없다.
자기 혼자서 돌아간다. 

thread 만드는 option에 attr이 있는데(속성) null을 준다. null을 준다는것은 joinable thread를 만들라 의미이다. attr의 다른값이 오면 detached thread를 만들 수 도 있다.

## Detaching/Joining Threads
attr을 하나 선정해서 attr을 Initialize해서 clear 한뒤 attr에 dechted를 할꺼나 joinable로 할꺼냐 setting 가능하다. attr 을 pthread의 create하는데 쓸수있다. attr을 쓴뒤에는 destory해야하는데 지저분하다.
attr 구조체 만들어서 세팅을 하고 일회용으로 쓰고 지워야 하니까 번거롭다.
thread을 joinable만든 뒤에 detached 하고 싶으면 thread id를 주면된다. 그러면 detached thread로 된다.
attr은 쓸필요가없다. NULL로만들면 joinable thread가 생기고 후에 thread id를 주면 detached 하면 떨어져 나가게 된다.

복잡하니까 pthred_detach()를 쓰면된다.

## Example : Pthread Joining
include<pthread.h>
include<stdio.h>
define NUM_THREADS 3 //3개의 thread를 만든다.
void *BusyWork(void *null){ //argument는 안받는다.
	int i;
    double result =0.0;
    for(i=0; i<1000000; i++){
    	result = result + (double)random();
    }//100만번 loop을 돌면서 random()하게 generate한다. 합친다. 시간이 많이 걸린다.
    printf("result = %e\n", result);
    pthread_exit((void *)0); //끝난다.
}
int main(int argc, char *argv[])
{ //위 pthread가 끝나기를 기다린다.
	pthread_t thread[NUM_THREADS];
    pthread_attr_t attr;
    int rc, t, status;
    	pthread_attr_init(&attr);
        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE); //pthread의 create할때 attr의 속성이 pthread의 joinable로 만들어라 필요없다.
        for(t=0; t<NUM_THREADS; t++){
        	printf("Creating thread %d\n", t);
            rc=pthread_create(&thread[t], &attr, BusyWork, NULL); //attr을 null로 주면 defalut로 Join able thread가 생긴다.
            if(rc){
            	printf("ERROR; ...%d\n", rc); exit(-1);
            }
}
//thread를 busywork를 3개를 만들면서 id를 thread array에 받아왔다. (pthread_t thread[NUM_THREADS];)

//fork시 부모가 wait 시에는 아무 child나 죽으면 return 한다. thread에 joinable 시 thread를 지정해야한다. (중요)
thread 만든것이 3개면서 id 3개 있는데 loop을 돌면서 join을 3번하고 있다. 각각 id 줘서 해당 thread를 기다린다. 처음 기다리는것은 첫번째 thread 기달, t=1이 되면 두번째 thread 기달, 차례대로 죽기를 기달리는 main이 된다. 

ptread_attr_destory(&attr);
for(t=0; t<NUM_THREADS; t++){
	rc=pthread_join(thread[t], (void**)&status);
    if(rc){
    	printf("ERROR; return code from pthread_join() is %d\n", rc);
        exit(-1);
    }
    printf("Completed join with thread %d status = %d\n", t,status);
    }
    pthread_exit(NULL);
}

//thread exit할때는 0을 넘겼는데 (void**)&status에서 받아온다.

## Threading Issues
library 만들 시기가 온다. library는 함수의 집합으로 구성,
함수는 thread가 call할것이다. 
sin 함수가 있다. thread 1, 2가 있는데 thread가 sin 함수를 call해서 수행하고 있다. 스케쥴링이일어난다. thread2로 넘어가서 같은 sin에 thread가 들어올수있다. 
sin에 integer a 변수가있다고 가정. integer a는 stack에 생긴다. call할때마다 a는 다른 variable이다. routine thread1이 call했을때 stack에 a가 생기고, thread2 가 call했을때 새 a가 생기니까 서로 다른 a이다.
이 위에 int x가 global 변수 있는데 x ++ 했다하면, x는 thread간에 공유하니까 data section에 있으니까 critical 화장실의 문제가 있다.(중간에 짤리면, context_switch) sin 함수에서 global 변수를 쓰면 thread가 여러개가 한꺼번에 call을 하면 안좋은결과가 나올수도있다. global 변수를 안써야지 함수가 안전해진다. (multithread-safe routine 이라고 한다)(중요) 

multithread가 routine을 call해도 결과는 항상 같게나온다. 중간에 thread가 실행하다가 짤리면 다른 thread가 들어갔으니까 재진입한다해서 reentrant라고 한다. 다시들어왔다(중요) 안전하다

//c++에서 클래스가 있는데 클래스 속에는 데이터가 있고(private) 멤버함수가 있다. 멤버함수를 thread 2개가 같이 call하면? 객체 안에 데이터는 공유한다.(1 copy밖에없다.) global variable과 마찬가지다. 객체 속에 variable이 있는거니까 multithread safe하지않다(중요)
safe하게 할려면 화장실 메커니즘을 써야 한다.

//멤버펑션을 1thread가 들어오면 내가 끝날때까지 다른 thread를 막아줘야 한다.

//일반적인 function은 괜찬지만 객체안은 공유하기때문에 안의 멤버function은 thread가 여러개가 call하면 문제를 일으키게 된다.
## Critical Section(Race Condition)
file을 copy할때 한글자 뒤집히는 예
그게 race condition 이라 했늗네
그것보다 실질적인 예.
프로세스라해도 마찬가지인 경우다.
프로세스나 thread나 race condition이 생기는건 매한가지다. 
나하고 친구가 같은 계좌를 쓰는데, 내가 입금을 할때 잔액 읽어야 한다. 그리고 입금금액을 더한다. 디스크에 가져다 써야한다. 재수 없이, 똑같은 시간이 친구도 입금을 한다. 동시에 일어나면 이러한 경우

read balance 1000, 1000불을 읽는다.
thread 2에서 1000불 읽는다.
1200불 계산, 
따로 따로 일어나면 일어나면 1400불이 되어야 하는데
디스크에다 1200을 쓴다.	
쓴다음에 읽어야 1200불이되고 그다음에 200을 더해서 1400이 되는데 같이 읽었단 얘기가 된다(업데이트 도중에)

이런순으로 돌아가면 r/w 한것과 똑같이 200불이 날라간다.
(race condition) => 엊갈려서 일어남, 화장실의 문제와 같다. critical section, 이것을 하는것이 mutual exclusion 이라 한다.


## Critical Section
thread 해당)
integer counter =0 가 잇는데 global var이다.
thread여러개만들면 당연히 counter를 share한다. 같은 변수를 쓴다. for()랑 달리 
thread 1, thread 2 가 존재
Ang CPU 컴파일 하면 machine language가 3문장이 된다.
counter 값을 cpu에 가지고 와야 함 
LD = LOAD(메모리에있는 counter를 register1로 가지고 온다.)
그리고 register를 하나 증가시킨다.
ST = STORE(register에 있는 것을 counter로 store 한다.)
시나리오 3개가 있다.
a1, a2시 register에는 1을 더했지만 counter는 1을 안더했음.
결과를 예측할 수 없는것이 concurrent 프로그래밍이다.
counter를 공유했기 때문에 문제가 생긴다. critical section 이라고 한다. race condition때문에 결과가 일정하지 않다. 

## Mutual Exclusion
critical section은 자신의 counter part가 있다. process A가 돌아가다가 critical section에 들어와서 화장실 안에 들어와서 짤렸다. 다른 프로세스가 돌아가거나 화장실안에서 돌아가는거는 상관이 없는데 똑같은 화장실 코드를 공유하는 코드는 돌아가면 안된다. 내가 끝날때까지 기달려야 한다. (mutual exclusion)

## Mutex(Mutual Exclusion Variables)
들어갈때 lock 걸고 나올때 lock 건다. 서로 프로토콜이기때문에 나만 lock 건다해서 되는게 아니라 양측다 lock을 걸어야 한다. (양측다 약속을 지켜야 한다.)

파일에 어떤 record가 있다. record에 write를 하고 있다. 나이, 성별, 가족관계 write 하고있는데 중간에 읽어 가면 올바른 데이터가 되지 못한다. write가 끌날때까지 read 하려하면 기달려야 한다. 둘다 read를 하면 데이터는 이미 완성되어있기 때문에 상관은 없다. 둘다 write를 하면 문제가 생긴다. (critical), read- write도 critical 하다. read - read는 괜찮다.

mutual exclusion은 서로 화장실 들어갈려고 할때 내가 들어가있다. 그래서 스케쥴이 일어나면 다른 애 한테 가면 진행하다가 화장실 앞으로 오면 화장실 안에 누가 있으면 기다려야한다.(프로세스 상태 blcok 되는거, 화장실에서 나올때까지) 기다리는 놈을 꺠워주는거니까 sychronization 이라고 한다. 그런 프로토콜이 필요한데 mutual exclusion 이라고 한다. 




