## Ex : File Sharing between Childs and Parent
my file을 read mode로 오픈했다. 
copyfile을 만들었다. 그래서 copy file에 복사할 것이다. 중간에 fork는 생각하지 말고
my file에서 한 바이트씩 읽어와서 eof까지 읽어서 write하고 
한 바이트 씩읽어서 한 바이트씩 카피한다. 다 카피하면 클로우즈 한다.
문제는 fork 가 들어갔는데 child-parent를 나누지 않았다. 결과적으로 부모도 자식도 fork 아래 프로그램을 동시에 돌린다. parent도 input에서 한 바이트 읽어서 copy file에 복사하고 자식도 같은 작업 수행

fork가 하나 더들어가면 프로세스가 4개가 생긴다.
4개가 똑같이 한 바이트씩 읽어서 한 바이트씩 복사한다.
fork 하면 무슨일이 일어나냐? fork시 open 된 파일도 물려받지만 파일 open하면 r/w offset 공유한다(중요)
부모가 한 바이트 읽으면 r/w offset 하나 간다. child 가 읽을때는 뒤에서부터 읽는다. (이어서)
부모와 자식이 돌아도 r/w offset 같은 번호를 읽진 않는다. 
쓰는것도 마찬가지다. 부모가 쓰면 그다음에 자식이 쓴다. 

프로세스가 2개가 됬다고 해서 파일이 2개로 커지지 않는다. 똑같이 일어난다.
key point는 r/w offset을 같이 쓴다.(중요) 그게 문제다.

fork 했으니까 결국은 while 속에 read가 있고 write가 있는데 fork 한 순간에 child가 생겨서 child도 while 룹을 돌면서 read하고 write 하고 있다. 부모가 한 바이트 읽어서 쓰고, 자식으로 가면 그 다음 바이트 읽어서 그 다음 바이트 쓰면 문제가 없는데 (프로세스가 두개일뿐), 부모가 한 바이트를 리드하고 라이트 하기 직전에 스케쥴링이 일어나서 context switch로 자식 프로세스로 넘어갔다고 치자(중요)

그러면 child가 그 다음 바이트를 읽는데 child 가 write하면 그 다음 바이트 먼저 쓰고 스케쥴이 부모로 다시 돌아오면 부모가 썻던걸 이후에 쓰니까 결과적으로 어떤때는 뒤집히는 결과가 나온다.(재수가 없는경우)

concurrent 는 공유를 하면 문제가 생긴다. read/write offset을 공유한다. 공유해서 문제가 생긴다.

parent가 read를 했으면 write를 완성해야 스케쥴이 넘어가면 해결되지 않을까? read, write 중간에 context_switch이 child로 가면 안됨(다른곳은 됨) 왜? 공유하고 있으니까(중요)(중요)
이렇게 경쟁하듯이 순서가 뒤바뀌는것을 race condition 이라고 한다. 
race condition 때문에 생기는 것이 critical section (임계영역)이라고 한다.

critical section 설명하는 예는 화장실 얘기다. 아파트에 화장실이 하나다. 집에는 두식구가 산다. 한사람이 화장실에 들어가면 볼일을 다볼때까지 다른 사람이 기다려야 한다. 화장실은 들어갔는데 끝을 못맺었는데 다른애가 화장실문을 열고 들어오면 문제가 생긴다. 사람 각각을 프로세스라 하면 공유하는것으로 판단한다. 화장실 변기를 공유한다. 
화장실 들어갈때 문을 잠근다. 나올때는 열어야 한다. 화장실 들어갈땐 노크를 하고 들어가라! 노크를 한다는것은 서로간 지켜야하는 프로토콜이다. (지켜야 하는 약속)=>critical section

문을 잠그고 들어가거나 노크를 하고 기다려주고 물어보는것은 솔루션이다. 문을 잠그고 while-read-write 한쌍돌때 문을 read하기전에 잠궜다가 write할땐 문을 풀어줘야 한다. 그렇게 해야 제대로 돌아간다. 

그런 솔루션을 mutual exclusion 이라고 한다.
exclusion은 베재한다. 의미 mutual 상호간의 
중요한 말은 내가 사람이 2명이 있는데 아빠, 엄마 화장실 공유하는데 각각 하는 일이 다르다(독서, 일) 이경우에 상관없지만 문제가 생기는것은 둘다 화장실 들어가고 싶을때 문제가 생긴다. 화장실 부분만 막아주면된다. =>mutual exclusion이라 한다. (오직 부모와 자식간의 관계에서만 이러한 문제가 생긴다 왜? 공유하니까)

## File Sharing between Childs and Parent
병행 프로그램에서 프로세스를 두개를 만드는데 병행 프로세스가 뭔가를 공유하면 문제를 생긴다.
병행 프로그램은 cuncurrent 프로그램 디버깅 소용없고 디자인을 잘해야 한다. 


## Inter-Process Communication(IPC)
fork를 해서 프로세스 여러 개 만드는것을 배웠는데, 콜라보레이션을 할려면 뭔가를 주고받아야 하는데 그런것들을 Inter-Process Communication(IPC)라 한다. OS는 ipc 툴을 많이 제공한다. 
r/w offset을 공유한다던가, file에다가 한 프로세스가 적으면 다른 프로세스가 읽어가면 공유가 된다. 
일반적으로 프로세스 사이에는 파이프 하나 있고, 
network socket은 멀리 떨어진 기계끼리 통신하는거 이런 여러가지가 있는데 파이프를 배우닫.


## circular queue
array를 원으로 만들어서 하나는 집어넣는 insert가 있고 끄내가는 remove가 있다. 큐는 front가 있고 rear가 있다.(집어넣는데가 있고 끄집어 내는데가 있따.)
그것을 os가 제공하는게 파이프다.
파이프를 할려하면 두개의 프로세스가 어떤 애는 집어넣고 어떤 애는 끄내는 과정을 한다. 
큐를 공유하므로 공유하면 crtical section문제가 생긴다. 
그런 문제를 없게끔 통신하는 기법이 파이프다. os가 제공하는 circular queue고 부모 와 자식간에 쓸수도 있고
전혀 관계가 없는 프로세스 사이에서 쓰는것을 (named pipe)라는것도 있따. 

파일을 하나 만든다. (가상파일) 파일은 가상적인 파일이라고 생각하고 
unnamed pipe라는것은 부모와 자식 사이에서 쓰는데 프로그램이 끝나면 자동으로 없어지기 때문에 이름이 없다 해서 unnamed pipe라고 한다. 

unnamed pipe를 배운다. 
파이프는 


## Pipe  an IPC tool(con't)
가운데 pipe channel에 큐가 있다. 파이프가 큐다. 집어넣는대로 밀려서 간다라고 생각하자.
읽는것은 앞에있는것을 끄집어 낸다. 파이픈데, 모양은 그런데 사실은 circular queue로 만들어져 있다.

크기는 4kbyte다. 이것을 가상적인 파일이라고 생각한다면 file open하면 r/w offset이 생긴다. r/w offset은 읽는데도 쓰고 쓰는데도 쓴다. 근데 queue는 쓰는 포인터하고 읽는 포인트가 다르다.(프론트와 리어가 다름) 결과적으로  큐로 볼려하면 파일을 2번 오픈해야 한다.(r/w offset 2개가 생긴다 하나는 프론트 하나는 리어로 쓸거다) 그것을 구현한것이다.

파이프를 오픈하면 프로세스가 여러개있는데 하나씩 생각하자 우선은!
이 파이프는 동구화 도구 이기도 하다. 동기화는 어떤 프로세스를 만들어놓고 내가 뭘 줄때까지 기다리는 상태다. block 되서 기다린다. 메시지를 보내면 꺠어나고 그 메시지를 받아서 일을해라! block됬다가 메시지를 보내면 꺠어난다.
그런것을 동기화라고한다.(syncronize)
파이프에 집어넣는게 하나도 없으면 비어있으면 읽을려하면 블락된다. 기다린다. 언제까지 뭐가 날라올때까지 큐에서
집어넣주면 받는쪽을 꺠워주는 역할을 하고 
파이프에 많이 있을때 가져간다.

항상 cuncurrent는 집어넣는쪽이 빠를수도 있다. 4kbyte 꽉차면 집어넣응ㄹ 대가 없으니까 집어넣는애가 블락된다. 
공간이 생길때까지 block됬다가 깨어난다. 파이프는 메시지를 다른 프로세스에게 전달할 수 있는 수단이면서 block된것을 꺠워줄수있는 수단이된다.(일반적으로 이것을 producersconsumers라고 한다.)
producers는 데이터를 생산한다. consumers 소비자다. 이둘은 항상 속도가 다르다.(서로 다른 프로세스) 그래서 완충한느 큐가 필요하다. 강류 상류에ㅓ 하류에 너무 많이 보낼것 대비해 댐을 쌓는데 댐과 같은 역할을 한다.

concurrent에서 제일 많이 등장하는 프로세스간의 관계다.

## PIpe : an IPC tool
파이프는 통신도 하지만, block의 wake up도 한다(기다리고 있는것을 꺠워준다.)
파이프는 가상적인 파일 이라고 생각한다. pipo 파일이라고 한다. r/w offset이 두개가 있는 파일이다. 하나는 front 읽을때 쓰고 하나는 쓸때 쓴다. 두개 생기니까 두번 오픈한다 실제적으로 Internal이 두번 오픈한다 파일을


os가 제공하는 circulat buffer 혹은 ring buffer라고도 한다. 집어 넣고 뺴깔 때 문제가 생겨서 mutual exclusion이 해결책으로 필요하다.(자동으로해준다.)

중요)파이프가 비어있는데 읽을려 하면 블락된다.(집어넣을때까지 파이프에 뭔가를)

중요) 프로세스가 파이프가 비어서 기다리고 있는데 파이프에 뭐가 하나 들어나면 꺠어나서 가져오는것이고 내가 기다리고 있는데 보내는쪽에서 일다해서 close하면 더이상 기다릴 필요가 없으므로 writer가 close했을때도 꺠어나게 된다(중요)

중요) writer는 파이프가 꽉차게 되면 블락된다. reader에서 가져가서 빈칸이 생기면 다시 wake up이 된다.

이 세개는 정말 중요하므로 꼭 숙지하자.

## Pipe Example
if(fork() ==0)이 child process 다. 파일을 읽어서 보낼것이다.
파이프를 통해서 부모한테 보낼것이다. 10byte씩 보낼것이다.
 55바이트면 나머지 5바이트 보내게 될것이다. n만큼 보내니까
child는 파이프에다가 쓰는 역할을 하는 프로듀서다. 부모는 파이프에서 읽어들인다.
읽어서 다른파일에 복사한다.  
중간에 보면 pipe(fd) 시스템콜이있다. 파일디스크립터를 준다.
파일 오픈할때 디스크립터 3,4,5 받아온다. 했었다 파이프는 internal이 파일 2번 오픈하는것이다.
디스크립터가 2개가 필요하다. array를 2개를 잡았다. fd0 , f1이 들어오는데
fd0는 읽는전용으로 쓸거고 fd1은 쓰기 전용으로 쓸것이다.

pipe(fd) 파일오픈한거니까 그 다음에 forkㄹ를 하면 부모도 파이프를 물려받고 자식도 오픈 파일을 물려받는다.
파이프가 두번 오픈했으니까 (fork떔에) 파일을 4번 오픈한게 된다. close는 4번 나와야 한다.
부모에서 2번 자식에서 2번 나와야한다.

포크한값이 0 이면 child process다. input file로 open해서 read mode로 한다.
나는 파이프에다 쓸꺼다(파일에서 읽어서) 읽는 채널이 필요없다. close(fd[0])했다. 쓰기만 할꺼니까 파이프에다
그러고 나서 input file에서 10byte씩 읽어서 그것을 write fd[1], 파이프에다 쓰고 있다.
언제까지 eof 까지 다쓰면, 전부다 close하고 파이프의 쓰는 write channel 도 임무를 다해서 close하고 exit을 한다.

부모 프로세스를 보면 pipe로 부터 두개를 물려받는데 쓰는게 필요없으므로 fd[1]을 닫는다. 
그리고 output file을 하나 만들어서 읽는것을 파일에서 읽는게 아니라 파이프에서 읽는다, 10바이트씩 읽는다. 읽은거 만큼 ooutput 파일에 카피한다. child는 10바이트씩 읽어서 파이프로 보내고 부모는 파이프를 통해서 날라오는 10바이트씩 받아서 파일 에  카피하는 프로그램이다. 다했으면 close하고 읽는 채널도 필요없어서 fd[0] 닫고 wait해서 child가 죽기를 기다린다. 

파이프해서 오픈을 두번 했는데 close는 양쪽에 2번씩 4번이 나왔다.
프로그램이 끝나면 이 파이프는 가상적인 파일이지만 없어지기 때문에 unnamed file, 이름이 없는 파이프라고 한다.

named pipe는 세미나를 통해서 한다. 이름만 있다. 부모와 자식간에쓰는게 아니라 전혀 관계없는 프로세스끼리 쓸때 이름이 있어야 찾을 수 있기떄문에 

여기서는 물려받았기때문에 이름이 필요없었다.  

## Shell processing with pipes
shell에 로그인해서 들어가면 컴파일 했다하면 a.out돌리면 printf하게 화면으로나온다.
빨리 지나간다고 생각해보면, | 치면 한 페이지씩 보여주고 yes no물어봐서 넘어가겠다.
| 가 shell이 하는게 아니라, a.out은 우리가 짠 프로그램이다. 
more는 프로그램은 따로 있다. shell 이 아님
more은 키보드에서 입력하는것을 받아서 scanf, getchar 입력받아서 한 페이지가 꽉차면 물어보고 
입력을 받고 넘어가는것이 more다.

a.out은 아웃풋이 printf standard out으로 나갈것이다. 
more는 키보드에서 입력을 받아서 standard Input에서 입력을 받는다.
중간에 | 가 있는데 파이프다.
a.out에서 나가는 아웃풋을 화면으로 내보내지말고(standard output으로 내보내지말고) 파이프에다 써라.
파이프로 내보내고, more라는 프로그램은 원래는 키보드에서 받아야 하는데 파이프에서 받는다.

자연스럽게 a.out의 아웃풋이 한페이지 씩 가면서 more가 보여준다.
| , 파이프를 만들어서 a.out하고 more 라는 프로세스를 만들어서 따로 돌리고 중간에 파이프를 만들어주는게 shell 하는 역할이다.

shell도 os 상관없이 유저 프로그램 짜듯이 짠다. 
shell :  //shall은 먼저 fork 하기전에, 파이프를 하나 만들어야 한다
	pipe(fd)//파이프를 만들어서 포크하면 다 물려받으니까
    if(fork() == 0) //첫번째 자식을 만들어서 a.out이 돌아갈것이고 
    	close(1);
        close(fd[0]);
        dup(fd[1]);
        ...	//pcb안에는 open file table이라는것이 있다. 50개까지 있는데 0은 standard Input이 open 되어있고, 
        //1번 standard output, 2번은 standard error channel로 오픈
        //포크하기전에 파이프했으므로 파일을 2번 오픈하는것이므로 3행에 fd[0]가 들어가있다.  
        //4번이 fd[1](파이프의 write channel)이 들어있따. 결국은 파일을 5개로 오픈한채로 오픈했다.
        // 첫번쨰 자식을 만들고 close(1) 한다. standard out을 닫는다. printf를 해서 내보내는 파일 디스크립터 채널을 닫는다.
        //나는 파이프에다 쓸거니까 fd[0] 읽는 채널은 필요없다.
        //dup은 fd[1]이라는 채널을 파이프로 쓰는 채널인데, 배끼라는 얘기다. 위에서부터 내려오다가 제일 처음 빈칸이 나오면 거기다가 복사를해라
        //그래서 pcb안에 open file table의 1번에 fd[1]가 들어간다. 왜? 처음에 close한 위치니까
        //위에서 내려오다가 첫번째 칸에 복사한다. 파이프 채널이 2개가 되버렸다. 2개가 있으면 안된다.
        //2개가 있으면 안되니까 close(fd[1]) 오리지날 fd[1]을 닫아버린다. 결과적으로, standard output 자리에 파이프의 write 채널이 들어간다.
        //a.out을 돌리면 printf 하지만 printf 하는게 화면으로 나가는것이 아니라, 파이프로 나가게 된다.
        // shell이 바꿔치기를 했기 때문이다.
        
   	if(fork() ==0) //shell이 두번째 fork를 해서 more라는 프로그램을 돌릴것이다.
    	close(0);
        close(fd[1]);
        dup(fd[0]);
        close(fd[0]);
        execl("more",...);
	//more로 들어갈껀데, standinput을 바꿔치기 해야한다. 쓰는 채널 fd[1]이 필요없으므로 지우고, 
    //읽는 채널을 빈칸이 0이니까 0에 카피를 하고(위와 같은 과정)
    //오리지날꺼 닫고 결과적으로 standard Input 자리에 파이프에서 읽는 채널이 들어가니까 scanf나 getchar 열심히 해도 
    //키보드에서 들어오는게아니라 파이프에서 들어오게 된다. 프로그램이 돌아가고 shell은 나머지 일을 한다.

쉘같은거 보면 ls 디렉토리 속 파일의 이름을 보여준다.
굉장히 많다. $ls | grep jokim, jokim이 들어가는 낱말의 파일만 보여달라 의미 
이것도 | 의미는 파이프 의미이다.(중요)
ls라는 프로그램이 내보내는것을 가로채서 grep이 파이프를 통해서 받아서 jokim이 들어가있는것만 골라서 보여준다.
shell이 파이프를 가지고 장난친다.

## Program Assignment #1
두번째 숙제, 프로세스가 3개가 된다. (부모하나, 자식 2개) 파이프는 한개가 아니라 두개가 된다.
부모는 파일에서 읽어서 파이프1을 통해서 자식(1)에게 보낸다. 10자씩 받는지 1자씩 받던지 받아서, 소문자가 있으면 대문자로바꿔서 
바꾼것을 파이프2를 통해서 자식(2) = p3에게 보내면 콘솔에다 아웃풋을 한다.

이전 프로그램과 다른것은 파이프를 2개를 만들어야 한다.
파이프를 하나 만들고, 파이프를 만들었으면 parent 인데 여기서 while loop을 돌면서 
파일을 read해서 파이프로 loop 돌것이다(보낼것이다) 

파이프를 만든다음에(부모)	close(fd[0]) 쓰는거니까 필요없어서 닫고 그 다음에 fork()했다. 
안돌아간다. 파이프를 만든다음에 close하면 읽는 채널 닫고 파이프를 fd[1]에다 쓰는데 os가 봤을때 
파이프에서 기다리는 놈이 없다. close를 해버렸으니까 fork 하기 이전이니까 
fork를 했으면 내가 close를 하더라도 child 2개중 하나를 open한 상태니까 기다릴수있는데
미리 close를 해서 다 close가 되기 때문에 write를 할려하면 os 받아가는놈이 없다. 가 된다.
error가 되서 프로그램이 안돌아간다. 파이프를 만들어서 fork해서 물려받은 다음에 부모도 자식도 일을 수행하는것이 좋다.

## 정리
지금까지 한것은 
child process 만들어서 프로세스끼리 돌아가는 concurrent program 이었따. 프로세스를 따로 만들어서 쓰는 경우도 있지만, 
대부분의 경우는 쓰레드를 사용한다. 쓰레드는 그냥 프로세스와 같다. os의 입장에서 프로세스다. 
피프로세스에는 pcb, 스케쥴링도 받아야하고, 해야되는.. 프로세스와 같다.
os는 프로세스라는 말을 안쓰고 태스크란 말을 쓴다. 태스크는 프로세스나 쓰레드를 나타낸다. 
쓰레드도 concurrent 하게 돌아가는 하나의 프로세스다. 프로세스와 다른점은 쓰레드가 훨씬 가볍다.
heavy weigh 프로세스라고 하는데, 무겁기때문에 만드는데 오래걸리고 메모리도 많이 차지한다.
메모리를 많이 차지하는것이 문제가됨(중요)
쓰레드는 경량급, light weight process라고한다. 메모리는 전혀 차지 하지 않는다.
프로세스와 쓰레드의 개념은 쓰레드가 등장하면 프로세스는 주소공간이 텍스트, 데이터, 힙, 스택인데
주소공간이 프로세스 라고 생각하면되고 쓰레드는 cpu의 컨트롤을 가지고 뭐가 하나 돌아간다.(스트림이)
바늘에다가 실을꿰서 바늘이 가면 실이 쫓아온다(이걸 쓰레드라고한다.)

프로그램속에서 프로세스를 하나 만들었는데 거기에 main밖에 없었다. concurrent 프로그래미이 아니다.
거기선 하나만 돌것이다. 그것은 쓰레드가 하나가 돌아간다 개념이다.
프로세스는 fork 해서 만드는데, (text data heap 중에서 data heap stack이 복사가 되서 다른 공간에서 도는데 프로세스를 만들면)
다른 공간에서 쓰레드가 돌아간다.

쓰레드는 돌긴도는데, 프로세스처럼 같은 공간에서 돈다.같은공간에서 3개가 돈다.
같은 공간이니까 메모리를 차지 하지 않는다. 

메인 프로그램은 메인이 돌아가는 그 프로세스가 생기는건데, 한프로세스내 쓰레드가 한개가 있기때문에 main 쓰레드 라고 한다.
fork 를 통해서 프로세스를 만는듯이 프로그램속에서 쓰레드 만들어야 한다.
그래서, 쓰레드는 

프로세스의 리소스를 부과하는데 fork를 하면 data, heap stack을 따로 가졌는데 (복사를해서) 쓰레드를 만들면
data,heap,stack을 완전히 공유한다.(중요) 메모리가 더이상 생기지 않는다. 프로세스 돌아갈려면 스택은 따로 필요하기 때문에
스택은 같은 공간을 쓰지만 스택포인트를 달리준다. 그러면 다른 스택을 쓰게 되는것이다. 공간은 같은데

결론적으론 스택만 따로쓰고, 스택말고 나머지 공유하는게 뭐냐! 데이터를 공유한다. 데이터 구간에는 글로벌 데이터가 들어간다.
fork 처음 설명할때 글로벌 변수가 있었는데 데이터 섹션에 들어가는데 fork 한다음에 데이터 섹션은 카피해서 따로 가지기 때문에
자식이 가지는 a하고 부모가 쓰는 a가 다른 a이다.쓰레드가 되면 같은 a가 된다.
같은 a가 되면, 통신이 간단한다. 파이프를 안써도 된다. 글로벌 변수에다 쓰레드 1이 써주면 쓰레드2가 공유하니까 읽을 수 있다.

좋은점이다. 메모리도 차지 않고 나쁜점은 공유하니까 생기는 문제가 있다.(mutua exclusion으로 해결한다.) 쓰레드는.
각각 성격이 달라진다.
쓰레드는 a는 같은 a를 쓴다.

쓰레드는 데이터를 공유하다. 메인에서 생기면 메인쓰레드라고 하고, 프로세스는 fork 할때 프로그램이 복제가 됬는데 그담에 execv 했는데 쓰레드는 function을 쓰레드로 만든다.(중요) 함수는 원래 calal해서 돌다 return 하는데 함수를 쓰레드로 만들면 
혼자서도 돌아간다. 다른 쓰레드가 되서 따로따로 돌아간다. 

## Threads
싱글 쓰레드가 돌아갈땐 a처럼 돌아가지만 프로세스속에 쓰레드가 여러개있으면 
코드, 레지스터, 스택은 따로 쓴다. 
코드 데이터 파일은 같이 쓰지만
데이터를 share 하는것이 다른점이다(중요)

## Address Space with Threads
어드레스 스페이스는 하나이다. 코드가 텍스트고, data heap이 있는데 다 공유를 하고 스택만 따로따로 쓰고 있다.
쓰레드가 3개가 생기면

## Threads
메인 프로그램이 시작되는데 routine 1, 2 함수가 있다.
함수를 콜하는게 아니라, ptrhead create(routione1) 하면 쓰레드로 따로 돌아간다. 메인 쓰레드와 경쟁해서 프로세스가 경쟁을 하듯이따로 돌기 시작한다. 
2도 따로 돌아간다. 프로그램은 쓰레드가 3개가 따로따로 돌아간다.(프로세스처럼) 프로세스는 프로세스인데 데이터를 공간을 공유하는 프로세스가 쓰레드다.(핵심) 함수의 이름을 줘서 쓰레드를 만든다.




## what is a Thread?
## Threads
