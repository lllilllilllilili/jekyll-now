---
post : layout
title : 데이터통신(기)8
---
## 복습
자 10장에 에러디텍션과 커렉션 
이 부분했는데 
어떻게 해야..
이..

화면이 맘에 안듬
자 지난시간에 에러커렉션이나 에러 디텍션에 그 능력을 우리가 예상할수있는 중요한 변수 가 바로 해밍 디스턴스라는 미니멈 해밍디스턴스라는 것을 소개했다 이게 바로 d 미니멈이라고 하는 
요 부분이 그 미니멈 해밍 디스턴스를 의미하는데 
미니멈 해밍 디스턴스가 어떤 값이냐에 따라서 커렉션할수있는 비트에  개수 또 에러를 디텍션할수있는 비트의 개수를 우리가 알수있다 지난시간에 가장 중요한 내용이었다.
커렉션의 경우는 어 이 미니멈 
내가 커렉션 하는개수가 t bit 까지 커렉션 하고 싶다 그러면 해밍 디스턴스는 이와같은 관계를 가져야 한다. 그런 이유는 
이 그림에서 우리가 볼 수있듯이 어 어느 한 코드워드로부터 어 t비트만큼 에러가 발생한 놈들은 애당초 이 중심에 있는 얘였을것이다. 또는 얘였을거다 라고 해서 우리가 확신을 가질 수있을려면 이 원들이 중첩이 되면 안된다. 중첩이 안될 조건이 이거리가 2t 겟죠 2t 허용이되는 에러의 비트의 개수에요 이 반지름이 
따라서 이쪽에서 t 이쪽에서도 t 니까 2t보다 해밍 디스턴스값이 크면 에러 커렉션이 가능하다. 그런 의미로 에러커렉션 이 관계를 갖고 어 그 내용이 지난 시간에 제일 중요한 내용이었고 오늘은 

오늘은 이제 거기에 다음 내용으로 리네어블락코드를 어 살펴본다. 

여기쭉 거의 모든 블락코드가 

## Linear block code
현재 쓰고 있는 거의 모든 블락코드가 잉여 블락코드에 속한다. 잉여 블락코드라는것이무엇인가 는 밸리드한 코드워드 2개를 exclusive oring 하면은 또다른 코드워드가 생성이 되는 케이스다.
우리이 코드들이 있었죠?
이 해밍코드, 이런 코드워드들 아무거나 두개를 exclusive oring 하면 얘와 얘를 역시 exclusive oring을 하면 어떻게 되냐? 어 서로 다른 그 비트를 가지면 값이 1이되고 같으면 0이된다.
자 이게 이 두개를 exclusive oring 하면은 서로 다르니까 1 1 1 1 0 
얘가 여기있다. 이렇게 바로 이런식으로 어느 두개든지 갖고 exclusive oring 했을때 나오는 코드워드가 또다른 밸리드한 코드워드다.
그런경우에 리네어 블락 코드라고 하는거죠
우리가 이미 본것들이 이미 리니어 블락코드에 속하는거다. 얘기하는것이다. 그거를 좀더확장을 해서 이제 리네어블락코드를 좀더 광범위 하게 살펴본다는것이다.

정의는 그렇다. 근데 여기서 다룰 내용이 미니멈 디스턴스 얘기가  또나온다. 리네어 블락 코드에서의 
리네어.. 미니멈 디스턴스 그리고 또다른 리네어 블락 코딩 에 대한 소개 

저기는 넘어 갈수있으면 넘어가고

## Table 10.3 Simple parity-check code C(5,4)
자 여기 앞에 있는 표에서 이 리네어 블락 코드를 우리가 확인할 수있단 내용이니까 넘어가고 
어 우리가 아주 그 잘 알고있는 심플, 가장 간단한 패리티 체크 라고 하는 코딩 방식이 있다. 이거죠 이 런식으로 내가 보내고자 하는게 여기에 16가지가 있는데 에러체크를 위해서 한 비트를 추가를하는데 한비트를 추가하는 원칙은 전체 5비트 중에 1의개수가 짝수개가 되도록 한다. 이게 아주 가장 간단한 패리티 체크
이 방식을 우리가 이제 이렇게 c(5,4)로 표현한다 이거죠 이 앞에 있는것은 전체 만들어진 코드워드들의 길이 4는 데이터 워드의 길이 이렇게 하면 한비트가 더 추가됬다는것을 볼 수있고
바로 이런 심플 패리티 체크 코드들을 보면 우리가 또 이거를 어 이 코드워드들을 살펴보면은 리네어블락 코드에 해당하는것을 볼수있다. 

사실 이 간단한 패리티 체크 코드는 너무 어 검출 해낼 수있는 능력이 너무 미약하기 떄문에 뭐 크게 사용되지는 않는다. 그냥 개념적으로만 우리가 많이 익히 알고있는 내용이다. 이와같이 한 비트를 더 추가하는데 한 비트를 추가하는 
어!
한비트를 추가하는 계획은 무슨일을 하느냐? 이 4비트를 입력을 받아서 하나의 짝수가 전체 이 비트를 짝수가 되게끔 만드는 한 비트를 생성하는것이다.

여러분들 로직 1학년떄 논리 회로 같은거 배웠을때 이 제너레이터를 아주 간단하게 만들수있는 방법이 뭐였죠 제너레이터를 만드는 가장 간단한 방법, 우리 1학년떄 배운 회로에 의하면 이 exclusive or을 하면 어 그렇죠 0011 가령 
exclusive or의 아웃풋은 어떻게 이 정의가 되죠, 이 인풋이 몇개있던 상관없다. 인풋이 몇개있던 1의 개수가 짝수개면 0이고 홀수개면 1 이게 exclusive or에 아주 대표적인 기능이다. 이게 
따라서, 이 한 비트를 생성하는데 어떻게 하느냐? 이 4비트를 그대로 exclusive or에 집어넣어서 나온 아웃풋 이게 바로 패리티 비트가 되는것이다. 여기에 지금 홀수개가 있더라 이렇게 그러면은 아웃풋이 1이 되니까 결국은 이 짝수개를 만드는 회로가 되는거죠 이렇게

## Figure 10.10 Encoder and decoder for simple parity-check code
이 받는쪽에서 checker 있져 checker 
이 체커, 체커는 이 5개를 다 받는다. 5개를 다받아서 5개를 다 받죠
그래서 이 속에 짝수개 있으면 0이고 홀수개 있으면 1이다.
체커는 답이 exclusive or 을 통해서 나온 아웃풋이 0다 그러면 에러가 없단얘기다. 짝수개 있단 얘기니까 저룰 은 1이 짝수개가 되게 만들어서 보냈으니까 어 이 체커는 그 5개의 인풋을 다 exclusive oring에 지금 한것이고 sender에 제너레이트 쪽에서는 내가 데이터워드들을 exclusive or 해서 나온 아웃풋 을 패리티로 붙여서 보내고 
간단하게 이 exclusive or 회로를 갖고 이 한 비트 짜리 패리티 체크를 만드는 기능을 이미 살펴본 내용이다.
그렇지만, 어 오로지 홀수개수만 디텍션 할 수있고 짝수개수 가 발생하면은 에러 발생하면 디텍션을 할수가 없다.
대단히 심각한 성능의 제한이 있다. 그래서 어 이런 아이디어를 또 낸 것도 있다. 2개를 2개의 에러를 디텍션 할 수있는 방법 
자 이와같이 8, 7비트 짜리를 각각의 패리티 비트를 하나씩 붙였죠 이렇게 
그래서 이렇게 만들어진 코드워드들을 4개를 2차원식으로 코드워드 들을 만드는것이다. 코드워드들을 이쪽에 만들기도 하고 또한 여기도 만드는데 얘들은 무슨일을 하느냐?
세로 새로로, 역시 이놈들이 1의 개수가 짝수가 되게끔 하는 이 쳌 추가한것이다.
4 워드, 4바이트 에 대해서 여기에 체크 비트가 있고 여기에 노시크릿트가 있고? 패리티 비트가
자이렇게 구성을 하면 이제는 한 바이트에 에러가 발생한게 아니라 이 4바이트 속에 에러가 발생한느 경우에 자 하나가 발생하면 이렇게 안했어도 에러가 체크가 된다 한비트 에러발생하면
두비트 발생하면 
요 짝수개가 에러 발생하면 못찾음 근데 세로축을 봤을때 한 곳에서만 발생했으니까 에러체크가 된다는거죠 그러면 이 방식은 어디서 발생했는지 모르지만 이 4바이트 중에  어딘가 지금 에러가 두개 발생했다 라는게 체크가 된다. 이렇게 되면, 이 4바이트를 다 볼수 밖에 없는거지 어디 발생했는지 모르니까 
그렇지만 에러 디텍션은 된다 이거임 
4바이트 속에 분명히 2개가 발생했을거다
3개 발생해도 뭐 얼마든지 찾을 수있다.
근데 역시 이렇게 발생하면 에러를 찾기 어렵다
가로로 짝수개 세로로 짝수개 굉장히 제한이 있는 방식이다.

그다음에 소개하는게 이 해밍코드 , 해밍코드도 1학년때 메모리를 읽어낼때 7장에 그런 내용이 나와있다.
메모리에 읽어낸 데이터가 과연 맞느냐?
거기에 쓰이는 해밍 코드다.
해밍 코드는 한 비트 에러는 수정할 수있다. 이런 기억이 날거야
오래전에 배웠더라도 해밍코드라는게 있는데
그거에 대한 얘긴데 그때 여러분들이 	
아마 기억하기에 이런 해밍코드를 어떻게 만드는지를 기억하는 사람은 물론 대단한 사람들이지만 내가 가령 10111 5비트를 보내고자 하면은 
거기서 나온 해밍코드와 내용이 조금 다른데 
p1 이게 그다음에 d1 d2 이게 2의 0승 자리 2의 1승 자리 
어 이게 3 이죠 그러니까 0 1 2 3 이렇게 얘기하지 말고 
이게 1번째 2번째 3번쨰 4번쨰 5,6,7,8 이런 몇째자리에 어 이 데이터를 집어넣느냐 인데 2의 몇승에 해당하는 자리 이자리는 패리티 비트를 집어넣고 여기도 2의 몇승에 해당하는거죠? 여기에 패리티 비트를 집어넣고 나머지 자리에 내가 보내고자 하는 이데이터를 집어넣어, 
d1은 여기고 여기 d2 d3 d4 여기 그러면 9번째 d5가 올수밖에 없다. 그래서 5비트를 내가 보내고자 하는데 이 에러체크를 위해서 리던던씨가 누구누구냐 하면 이 p로 표현되는 애들 얘들이 다 리던던씨가 된다. 얘들이 리던던씨가 되서 어 4비트, 
지금 저 5비트를 보내는데 4비트의 리던던씨가 추가됨으로써 전체 9비트를 보내게 되어있다.

가령 메모리에 내가 이 5비트를 저장한다라고 했을때 5비트 를 저장하는게 아니라 이 9비트를 저장을 시킨다는거임
나중에 읽어냈을때 이 읽어낸 데이터에 에러가 있는지 없는지를 체크하게 하기위해서 그와 같이 같이 하는게 해밍 코드인데 
그때의 이 p1 p2 p3 p4 과연 이 값들은 어떻게 구하느냐?
뭐 어렴풋이 기억나는 사람도 있겠다.
어렴풋하게 이 제너레이션을 어떻ㄱ ㅔ하느냐
여기 뭘 집어넣을까? 여기 이 값들은 지금 우리가 집어넣을거 순서대로 집어넣고 데이터에는 1 0 1 1 1 이렇게 집어넣는데 이 사이사이에 들어가는 2의 몇승 자리에 해당한느 요자리를 2의 0승 1승 2승 3승자리에 들어가는 자리는 다 팔키???(페리티) 를 집어넣는데 
페리티는 어떤 원칙을 갖고 넣는지 아 그 원칙이 있다.
지금 여기서 다시 소개할 필요는 없고 그런데 그 원칙이 왜 중요하냐면 검출, 읽어낸다면 에러가 있는지 없는지를 체크하는 과정에 바로 이게 그런 특성을 이용하는것이다.
에러를 커렉션할수있는데 한 비트를 이 상태에서 에러 커렉션한다는것은 에러가 발생할 위치를 찾아내는 것이다.
위치를 그런데 위치를 어 어떤 수신쪽에서 어 체커가 어떤 로직을 돌려서 나온 값이 나온 값이 바로 에러가 발생한 위치를 가르쳐준다. 라고 하는 어떤 매직이 있다 라는것임 
매직이 그 매직이 그 가능하게 되는 근거는 바로 이 패리티를 어떻게 만들었느냐 그속에 있는것이다.
여기 이런 방식에 이제 해밍코드가 있었는데 우리책에 소개되는 어 내용은 또다른 해밍코드 방식인데 한번 
여기서 한번 살펴보죠
## Table 10.4 Hamming code(7,4)
뭐 즉 그런 전체적인 소개는 그렇고
어 여기 지금 해밍코드를 보면 어 바요 여기 지금 전체 코드 워드가 7비트죠 데이터는 4비트 짜리 라는얘기임
그러면 4비트를 위해서 3비트를 패리티 비트 추가한것이다. 요 표현이 그렇다고 했다 .
리네어 블락 코드에서 앞에 있는건 코드워드의 길이 뒤에있는것은 데이터워드의 길이 그 차이는 곧 리던던씨에 길이 가 된다.
그래서 4비트가 0000~1111 까지 16가지 가 있는데 뭐 그떄 추가시킨 이런 것들이 있다 이런거죠 이런것들
여기도 마찬가지다. 이 과연 이 코드워드들이 어떻게 만들어졌느냐 라는게 이 해밍코드가 갖고 있는 에러 커렉션에 대한 성능을 근거를 마련해준다. 
도식화 하면 이렇게 4비트를 보내는데

## Figure 10.12 The structure of the encoder and decoder for a Hamming code
도식화하면 이렇게 4비트를 보내는데 3비트를 형성하는 제너레이터가 있고 그래서 이렇게 만들어서 보내죠 
4비트 와 3비트 추가해서 보낸다 이거죠
받은 쪽에서 역시 7비트를 받아서 7비트를 전체를 이용해서 이 체커를 돌리는데 체커를 통해서 나온 이 3비트 값이 무엇을 애기하느냐 하면은 이 7비트 중에 에러가 발생한 위치를 알려주는 그 순서값을 알려준다는것음
가령 여기에 010 이라는 값이 나오면 010 이 뭐죠, 2죠 2
두번째 비트에 에러가 있다 라는 얘기를 해준다 이거임 바로 그렇게 에러가 발생한 위치를 알려주게끔 할 수있는 근거는 바로 제너레이터와 체커가 어떻게 만들어졌느냐 이속에 있는것이다.
여기도 마찬가지다. 이런방식으로 할떄 이 p1 ,p2, p3, p4 를 어떻게 만들어놓느냐가 체커 쪽에서 어 아 어떻게 이 발생할 위치를 어떻게 알려주는 비밀이 어디에 있느냐 
이거를 어 저속에 갖고 있다라는거임 자 여기지금 이 제너레이터 를 통해서 만들어지는 리던던씨들 3비트가 만들어지는 어이 수식은 이렇다 이거임
r, 0 1 2 가 각각 데이터워드들 3비트씩 묶어서 이렇게 만들어진다. 이렇게 3비트씩 묶어서 모듈러 2 연산을 하면은 모듈러2 연산을 하면 000 이면 당연히 0이고 
0이 아 0이 짝수면 0이고
홀수면 1이다.
그렇죠
이 모듈러 2연산을 해보면은 아까 exclusive or 랑 비슷하다.
1의 개수가 홀수면 1이고 짝수면 0이되는 요 리던던씨를 만들어서 보내는것이다.
여기넣어서 보내는것이다.
요 각각 만드는 원리가 이 4비트 를 이용해서 만든다. 지금 
그래서 받은쪽에서 체커가 
체커가 어떤 일을 하느냐
어 받았죠? 이렇게 여기 구지 a라고 표현했고 여기 b라고 표현한 까닭은 가다가 바뀔수도있었으니까 구지 다를 수도 있다 
라고 해서 여기 a가 아니라 b라고 표현했고 리던던씨는 여기 q로 표현했다. 자 
가다 바뀔수도있었으니까 단지 그냥 로테이션만 바꾼것이다.
자 체커가 하는일은 이 7비트를 이용해서 3비트를 찾아내는데 신드롬이라고 하는 3비트를 찾아내는데 그 찾아내는 연산은 이렇죠
내가 받은 데이터 7개중에 4개, 4개씩 묶어서 모듈러 2연산을 해서 나온 값들 이게 바로 s0, s1, s2가 되는데 
이 신드롬 이거를 신드롬이라고 한다 이거임 
3비트로 만들어진 요 3비트짜리 바이너리 넘버
s2s1s0 
이 값이 의미하는 바가 뭐냐에 따라서 이 값이 이 신드롬이 000부터 111까지 가겠죠? 무슨 값이 냐에 따라서 0 이 물론 0이면 이게 0이면 에러가 하나도 없다라는 말이고 0이 아닌 숫자가 나오면 다른 숫자가 나오면 요 밑에있는 아래에 표에 있는 요 자리에 있는 값들이 지금 에러가 발생했다 라는것을 의미한다.
라는것이다.
표 
표가 만들어진다. 이 표가 아까 우리 요 해밍코드에서는 단순히 이 신드롬을 구했을때 이 전체를 갖고 신드롬을 구했을때 그 나온숫자가 어,, 몇번쨰 자리에 그 에러가 있느냐를 보여주는데 요 당 우리
이 데이터 통신 시간에 소개하는 해밍코드는 약간 다른 방식으로 만들어졌는데 이 신드롬에 나타내는 에러 위치는 요런 표로 표현된다.
요 표 과연 이표가 
어떻게 만들어졌을까? 라는 것이 이 속에 이속에 그 근거가 있다.
어 여러분 책에 이 내용이  없나?
몇페이지에 있지? 해밍코드에 대한 얘기가 crc 전에 있어요
그래 여기 어 원서 263페이지인데 뭐냐하면 q-10 (2)
그림 10에 4 밑에 있다.
그림 4 밑에 
이런책에는 사실 간단하게 나와있고 뭐 전버전에서는 이거에 대해서 상세한 내용이 있긴한대 
어 여러분들이 슬라이드를 가지고 있으니까 여러분들 숙제로 줄려고 한다. 과연 이와같은 방식으로 이 체커 가 이와같은 연산을 통한다면 여기서 나온 신드롬이 과연 이 표에 나타나있는 위치에 있는 에러를 각각 표현할것은 나타낸다 라는 근거가 어떻게 되는지 
여러분들이 이 신드롬은 뭐하는 관계식을 보고 추출해 보자
그게 이 이 해밍코드 
1학년때 배울 해밍코드 쪽에서도 그근거를 어 이 체커가 어떻ㄱ ㅔ계산하는지 속에 이 근거가 있다. 이 신드롬이 나타내는 값이 에러가 발생하는 위치라면 
여기는 신드롬이 나타내는 값이 요 각각의 이런 사이에 에러가 발생했다라는것을 의미한다.
라는게 어 이 표가 만들어진다. 그것을 여러분들 이 고민을 해봐라 이 수식으로부터 어 뭐 그렇게 어려운게 아니니까 한번 생각을 해봐라! 
숙제다.
숙제임
이런 계산을 했더니 신드롬 
011 이다. 011 나왔다 그러면 이게 무슨 의미를 하느냐 b2에 에러가 있다는 얘기다. 
b2가 뭐냐면 내 받은게 뭐죠, 7비트를 받았죠 b2 여기에 에러가 있다라는 얘기가 된다. 요놈이 에러니까 요놈을 여기는 1로 바꾸고 1이면 0으로 바꾸면된다. 지금 이 해밍코드는 
그래서 한비트 커렉션 기능이 있는것이다.
표를 활용하는 방법은 내가 한비트 커렉션이 아 가능하다는것임 왜냐하면 에러가 발생한 어느 한 자리를 알려주니까 이 신드롬이 에러가 발생한 위치를 알려주고 있다. 그럼 거기를 찾아가서 그 비트를 반전시키면 원래 값이다 이런말임
그러니까 에러 커렉션이 된다 이얘기임
그 과연 어떻게 해서 이 에러가 발생할 위치를 알려주는 숫자가 될 수있을까 라는것을 여러분이 저 신드롬 계산하는 연산속에서 찾아 내봐라 라는것임 

그래서 이놈이 어디에 에러가 발생했는지 간에 7 비트 자리가 다 있죠 여기에 내가 받은 어 그 내가 받은 데이터가 q0 1 2 그리고 b0 1 2 3 이잔아 이 7비트가 그렇게 표현되죠?
이 표에 의하면 이 어디에 에러가 발생하면 7비트 중에 어디에 에러가 발생하면 이 표에서 에러가발생하는 위치를 알려준다 이말임 이 신드롬이 
저 표가 어떻게 나왔는지 한번 찾아보고 얼마든지 찾아낼 수있다.
임의대로 주어진게 아니고 
어 그런얘기가 있고 

아 여기는 뭐 이런얘기다. 이 어 이게 지금 무슨얘기냐 하면 
이와 같이 되면은 자 이 여기나 여기나 사실 마찬가지인데 
이거 가지고 설명하는게 더 낫다.
이 런방식이나 이런 방식이나 우리지금 우리본 지금 책이나 이게 뭐 구지 설명할 필욘없네 자 
자 이렇게 구지 우리 책에 없는 다른 것 가지고 설명할 필요없이 cn k 이게 리네어 블락 코드고
이렇게 해밍 어 코드같이 한비트 를 내가 커렉션 할 수있다 커렉션할수있다 라는 얘기는 한 비트가 자리하는 위치를 찾아낸다 그랫죠, 그러면 이 신드롬은 여기서 보듯이 신드롬에 개수는 어 이 신드롬의 비트수 는 리던던씨 비트수 하고 같다. 
여기서 리던던씨 비트는 n 이 게 코드워드고 이게 데이터 워드니까 리던던씨는 n-k 이다
그거를 m이라고 한다 이거임 
m, m은 n-k를 m 이게 리던던씨의 길이 이다.
이게 리던던씨의 길이
그다음에 이 그 지금 여기서 리네어 블락 코드 해밍 디스턴스와 같은 한 비트 에러 커렉션이 가능한 리니어 블락 코드가 될려면 그럼 가령 내가 이 갖고 있는 값이 데이터가 여기지금 7비트라고 하면 7비트 라고 하면 과연 이 리던던씨는 몇비트 를 더 붙여야 몇비트를 더 붙여야 
그럼 n이 얼마가 되겠냐 이거임 
n이 얼마가 되야 이 한비트 에러 커렉션이 가능하냐 이거를 물어보고있다. 
이 관계를 물어보는거임 
n 과 k 와 m 간의 관계 근데 m 이라는건 일단 n-k 라는관계가 있는데 m을 물어보는것이다
내가 지금 k 비트의 데이터 워드가 있다면 코드워드길이는 얼마가 되야 될까 리던던씨 를 몇개 를 붙여야 이 한 비트 에러를 찾아 낼 수 있을까?
이 관계를 물어보는게 여기 이 예 지금 
여러분들이 어 그냥 이 잠깐 생각해보면은 이 n과 m 과의 관계를 알수있다 이거임 n과 m과의 관계 
n과 m과의 관계 알수있다. 얘는 리던던씨 비트의 개수이고 얘는 전체 내가 보내놓은 코드워드 비트의 개수임 
이미 1학년떄 해밍코드 얘기할때도 똑같은 얘기를 한적이 있다. 아 m과 n과 m의 관계 를 어 이 우리가 지금 m 을 어떻게 사용하는지 를 어 보면은 알 수있다. 
자이 m이라는 그 m 이라는 값이 리던던씨의 개수다 
리던던씨의 개수다
근데 신드롬에 비트의 개수다 이게 그러면 이 신드롬이 나타낼 수있는 숫자는 2^m개 죠 가령 3비트면 0부터 7까지 8까지가 있다 이말임 
m이 3비트이면 
근데 애가 나타내는 신드롬이 이 저기서 얘기하는 신드롬이 
s2, s1, s0 가 의미하는 바가 뭐였냐면은 에러가 발생한 위치를 나타낼 수있어야 되 
그렇죠, 얘가 에러가 발생한 위치를 나타내야 하는데 위치라는것은 m비트라면 n개는 포함할 수있어야 된다. 
위치가 내가 코드워드가 m비트왔으면 첫번째 두번째 세번째 에서 m비트 중에 어느자리 에 에러가 발생헀는지를 나타내야 되는데 그게 얘가 그값을 나타낸다 이거임 
2의 m승이 에러가 발생한 위치를 나타내야되 그러면 위치에 개수는 몇개있냐면은 m개가 있다 이말임 
m개가 

그렇죠 근데 얘는 2의 m승 이 어떻게 되냐면 이 2의 m승 3비트는 8이죠 8 그렇지만 위치를 나타낼려면 0은 소용없고 1부터 7까지 이렇게 된다. 그러니까 8개가 아니라 빼기 한개를 빼야되 0이라는값은 뺴야되니까 이게 곧 위치를 나타내고 위치.. 우리가 표현할 수있는 위치의 개수는 m개가 되야 하니까 이 위치를 나타낼 수 있는 관계식이 어떻게 되죠 이게 바로 크거나 같아야 한다. 2의 m승-1 >= n
이런 관계가 있다. 

이런 관계를 만족하도록 이 리던던씨를 붙여야 한다. 이런 얘기다.
요 관계 뭐 비슷한 관계들이 거기서 또 비슷하게 나왔죠 그래서 이 런 기본지식을 갖고 문제 10.14 번을 여러분들이 한번 책에서 풀어보면 된다. 이거 보면 7비트 
이게 7비트일때 m이 몇 비트가 필요하던가? 라는게 이제 쭉 계산해서 저기 나오는것을 보여주고 있다.
저기 m이 4비트가 필요하구나 
이런것이다.

10.14를 꼭 풀어보도록하고 

어 여기는 해밍코드를 이용하면 한 비트 에러만 커렉션할수 있는데 좀 이 
이좀 그 머리를 굴려보면 한 비트 에러가 아니라 여러 비트 에러도 해밍코드를 이용해서 커렉션할수있다 이런 아이디어임
이런 아이디어를 보여주고있다.

과연 어떻게 할까?
아까 이 패리티 체크가 홀수개만 체크할 수있었는데 짝수개도 체크할 수 있는 방법이 투 디메션으로 체크비트를 만들면은 가능하다 라는것을 봤다 아까 패리트가 여기도 비슷한 아이디어 이다.
내가 이렇게 어 코드워드 
이게 해밍코드가 적용된 하나 둘 셋 넷 다섯 여섯 일곱
일곱개 뒷자리 워드를 지금 4개르 만들었다 이거임 
그래서 일반적으로 데이터를 보낸다 해도 코드워드를 먼저 보내고 원, 맨위에 있는거 먼저 보내고 그다음거 보내고 뭐 이럴텐데 지금 아이디어는 뭐냐면, 이 세로로 쭉 뽑아낸다 이거임 
세로로 같은색깔로 세로로 
세로로 같은  위치에 있는놈을 같은 색깔로 표현했다.
이렇게 세로로 쭉 뽑아낸다 
세로로 그러니까 각각 한비트씩 코드워드 에서 한 비트씩 끌어와서 4비트 짜리 만들고 그다음 요 4비트로 또 만들고 이렇게 이렇ㄱ ㅔ계속 쭉 만들면 어차피 28비트가 가는데 28 비트가 가는 모양은 쭉 일렬로 가는게 아니라 이렇게 쪼개진 값으로 간다 이거임
가다가 에러가 발생했는지 이와같이 덩어리로 발생하드라 4비트 가 발생한거죠 4비트
해밍 디스턴스라고 하면은 아니 저 해밍코드라고 하면은 4비트가 에러가 발생하면은 어 수정할 방법이 없다. 그런데 이경우에 4비트가 발생했다면 자 이 4비트가 발생했는데 이 각각에 소속을 보면 다 다른놈이야 그렇죠 여기있는놈은 여서와 쓰고 요것들은 우리가 ?
노란색 하나 둘 세번쨰 네번쨰 그다음 빨간색 두개는 요기 두개겠죠 이 4개를 이루는 요 각각은 서로 다른 노드에서 온것이다. 얘들을 다시 원래 코드워드로 쭈욱 나눠보면은 여기 발생하는 에러는 각 코드워드에 한비트씩 자리잡고 있다.
저러면 바로이 코드, 각 코드워드별로 다시 아까 같이 신드롬을 구한다면 이 속에 에러가 발생한 위치를 찾아내면 4비트를 고스란히 다 찾아낼 수있다. 이거임 4비트를 커렉션할수있다.
뭐 그럴싸한 아이디어이다. 물론 4개를 묶었을때 4비트 까지는 에러 커렉션이 가능하다. 뭐 5비트가 발생 하면 에러 커렉션이 가능하단 애기를 못한다. 어느 하나 의 코드워드에는 이제 한개 보다 더 많은 에러가 속할테니까 
4개까지는 연이어서 발생하는 4개 에러까지는 정확하게 에러 커렉션이 가능하다. 정확하게 에러 커렉션이 가능한 방식이다. 그렇게 블락으로 묶어서 아 보낼때 이 프레임을 세로로 묶어서 보내는 아이디어가 인제 이제 신선한 아이디어 다
버스트 에러가 발생한경우에 체크할 수있다. 이거임

자 그다음 얘기가 굉장히 중요한 사이클 링 리던던씨 코드라는건데 crc라고 실제 그 현재 가장 많이 쓰는 에러 체크다
우리 지금 헤밍 코드떄도 얘기했지만 그거와 달리 또다른 제너레이터 , 리던던씨 를 어떻게 만드드냐 하나의 룰이 여기서 소개가 되고있다. 그게 사이클링 코드 방식이 소개 되는것이다. 
아까 리네어 블락 코드는 뭐 어떤 특성이 있다고 했는데 그중에서도 그 서브셋인데 사이클 코드는 또 다른 어떤 특성이 있냐하면은 하나의 코드워드를 쉬프트 시키면 쉬프트 시키면 또 다른 코드워드가 나온다 이거죠 
이거 어떤 의미죠 가령
하나의 코드워드가 1011 이다 자 얘를 쉬프트 시키면 이렇게 로테이션 시킨다. 한 비트를 그러면 얘를 맨 이쪽으로 일로가지고 오면 1101 이 된다. 얘도 역시 코드워드로 사용하고 있는 또 애를 한바퀴 돌리면 1110 이 된다. 얘도 코드워드가 된다. 이와같이 사이클 코드는 어 로테이션 했을때 그 결과도 또다른 코드워드로 쓰이고 있을때 이게 사이클링 코드라고 하는것이다. 
이런 원칙이 지금 crc를 만드는데 어떻게 쓰이는지 모르겠지만 어 여기 지금 한예를 보여주고있다. 
이게 lan 이나 wan에서 많이 사용하는데 순환 
## 순환 중복 확인
c(7,4)  4비트를 보내는데 리던던씨를 3비트를 붙여서 7비트를 만든 사이클 코드 예를 하나 보여주고 있다.

이게 하나의 예다. 사이클 
어 이걸 이용해서 이런 사이클링 코드를 이용해서 만들어지는 어 방식이 좀전에 얘기한 사이클링 리던던씨 체크라고 하는 에러 디텍션 메카니즘 이라는것임
제너레이션과 체킹이 여기 룰이 이거 이 뒤에서 지금 어 하나의 소개가 된다. 

바로 내가 이 10장에 들어오면서 아주 파워풀한 에러 체킹 방식, 나눴을때 나머지가 없
나머지를 보고 에러가 있는지 없는지 체크하는 방법 이게 바로 사이클링 리던던씨 코드 라는거임
중요한 개념을 먼저보여주는게 중요하다 
어떻게 어떤 원리가 뭐냐 먼저
원리만 설명하면 끝날지 모르겠는데 

## crc 원리
이미 crc 방식에 대해서 들어본 사람 없냐
이거 굉장히 너무 널리 사용하는 에러 체킹 방식이고 혹시 여러분들이 이 정보처리기사라든지 이런거 공부해본 사람이라면 당연히 이 crc를 공부했어야 함 중요한 내용이니까 
여기 예를 이런 저런 기호가 있는데 내가 가령
1101 이라고 하는 데이터를 보낼려고 한다. 근데 사이클링 리던던씨 체크라는 방식을 통해서 보내고자 한다. 이거죠 그러면 이 리던던씨 비트를 몇비트를 어떻게 만드느냐 이거를 이제 예를 들어서 보여줄려고 한다. 
어 이게 나눗셈을 한다고 했다. 나눗셈을 하기때문에 나눗셈을 하는 그 어 여기 디바이져 
디바이져, g로 표현되죠 
디바이져를 가령 g를 101로 우리 봅시다.
그리고 얘를 표현하기를 어 여기 여기에 의하면 
어 메시지니까 이게 m이다. 
내가 보내고자 하는 메시지는 1101 이고 
우리가 서로 받는쪽이나 보내는쪽이나 나누어서 나머지를 볼껀데 그럼 나누는 숫자, 디바이저는 같은 값을 갖고 있다. 그리고 미리 정해져 있어야 한다. 프리 디파인드 
그걸 g라고 표현하자 이거임
이 g 가지금 몇비트라고 되어있냐면 지금 어 n+1 비트라고 지금 패턴 n+1 비트라고 얘끼하고 있다. 얘를 n+1 비트라고 얘기하면 3비트 니까 n은 2비트가 되는것이다.
얘가 사이즈가 지금 n+1 비트이면은 이 m에 2의 n승을 어 곱한 m 이게 뭐죠 2의 n승을 여러분들이 이 4비트 정보의 2의 n승을 곱햇따 가령 여기서는 n이 2에요 그럼 2의 2승을 곱했다 라고 하면 어떤 값이 나와? 바이너리 정보는? 어떤 갑이 나오지? 얘가 2의 0승 , 2의 1승, 2의 2승, 2의 3승이죠 
그러면 2의 2승을 곱했다 그러면 각각 이제 지수가 
5, 4, 3, 2 가 된다. 5에서 4 2에 4인 5에 5승 2의 5승 자리에 1 4승자리에 1 다시말해서 1101 이고 요 n비트 만큼 쉬프트 시켰는데 고 아래자리에 00이 추가된것이다. 
그렇다. 2에 n승 에 요거를 그대로 쓰면은 2의 3승 더하기 2의 2승 더하기 2의 1승은 0니까??? 없는것고 2의 0승이죠 그러면 n이 2면은 2의 5승 더하기 2의 4승 더하기 2의 2승이 된다.
다시말해서 5승 자리에 1 4승 자리에 1 2승 자리에 1 나머지 자리엔 0 이 있다. 사실 2의 n승을 곱한단 얘끼는 n비트만큼 왼쪽 시프트 시키고 오른쪽에 n비트만큼 제로를 집어넣는다.
요렇게 해서 이게 이제 나누기 위한 전처리 가 되는것이다. 나누기 위한 전처리이다. 그래서 몇비트를 쉬프트 시키느냐 이 디바이져 비트 개수보다 하나 작은 개수만큼 쉬프트 시켜서 이거를 보내는게 아니라 우리가 뭘 넣어서 보내냐면 이거를 2의 n승 * M을 디바이저로 나눈다. 나눗셈은 뒤에 나오겠지만 모듈러 2 연산을 한다. 뒤에 나오면 연습을 하면되고 자 일반적으로 어떤 수를 뭘로 나누면 몫이 나오고 몫이 나오면 나머지가 나온다. 나머지를 r이라고 하자  그래서 r/G 이라고 하자 그러니까 이게 나머지가 된다. 
자 몫이 나오고, 이게 일반적인 식이다.
그냥 몫이 나오고 그리고 나머지 r이 나왔는데 이렇게 표현한다 이거임 요렇게 이렇게 표현할 수 있죠 
이렇게 됬을때 보내는 쪽 제너레이션 얘기요 지금 제너레이터가 무슨 일을 하느냐 먼저 내가 보낼 데이터가 주어지면 n비트만큼 쉬프트 시켜서 여기에 00 를 집어넌 다음에 그값을 디바이저 로 나누었을때 몫과 나머지가 나오는데 바로 요 나머지 이놈을 요 아까 추가시킨 0두자리에 집어넣는다. 이거임 이게 왜 2자리로 되냐하면은 이 나누는놈이 지금 어 3비트 짜리이다. 가령 101 인데 110 이다 그러면 나누어져요 여전히 
여전히 1로 나누어지게 된다. 나누어지는 수가 있다 이거임 
이렇게 자릿수 적을 때 나머지가 되는것임 
더이상 나눌게 없는 따라서 이 나머지라는 놈은 얘보다 한자리 작은 숫자가 된다. 바로 요자리에 딱 들어간다.
요게 바로 r이 들어가는 거야 r이
그래서 보내는 내가 보내는 숫자는 뭐냐 여기서 그대로 요걸 그대로 보내고 옮겼으면 r/j 내가 보낸 숫자는 2^n*m 더하기 r 이 가는것이다. 내가 r을 추가해서 보낸다고 했죠 
자이 게 보내는쪽에 제너레이션이다. 제너레이션은 단지 나머지를 구해서 이 뒤에 붙이는 역할을 한다. 
그리고 받은 쪽은 똑같을 일을 한다 이거임 똑같은 애기 얘를 받았죠 얘를 g로 나눈다 받은쪽도 받은쪽도 나눈다 그러면 
요놈이 뭐죠 요놈이 여기 있죠 2^n*M +r/ G 우리이미 여기 나오죠 다 답이 이것이다.
이 equal 어 여기서다시쓰죠 G로 2^n * m +	r  / G 로 나누면 요놈은 
요놈은 여기 있듯이 Q+ r/G + r/G
그러면 얘는 더해진다.
모듈러 2 연산에서 같은 게 더해지면 없어진다. 모듈러2연산은 같은게 더해지면 없어진다고 했음 
모듈러 2연산 
11 + 11 = 00 야 같은거 더하면 00 가 된다 모듈러2연산은 
이게 다 이 연산은 모듈러 2연산이다. 나머지도 여기 나눌때 나눗셈도 다 모듈러 2 연산을 한다. 여기 
이 에러 디텍션에서는 같은 게 더해진단 얘기는 얘들은 없어진다 얘기임 없어진다. 결국 나머지가 없다. 내가 이렇게 보냈는데 보내는쪽이 r을 리던던씨를 만들어서 보냈는데 가다가 에러가 전혀 발생안했다 그러면 얘가 그대로 갔을거고 얘를 요렇게 G로 나눠보면은 지금 봤듯이 r/G이 2개가 생기면서 없어지고 결국 나머지가 없이 몫만 나온다 이거임 
나머지가 없다. 에러가 발생안하면 
근데 여기에 혹시 에러가 발생했다고 하면 
에러가 발생했다고 하자 
에러가 발생했다고 하자 그러면 에러패턴 에러 그냥 기호로 표현하면은 더하기 r/G 더하기 r/G + 2/G 라고 하는 이 에러패턴이 G로 , G로 나누었을때의 어떤 이 값이 있죠 아까 봤듯이 얘들은 없어진다고했다. 같으니까 자 그러면 우리 얻는것은 Q+ 2/G 가 된다. 얘만 남게된다. 
에러 발생했으면 
다시 말해서 에러가 발생했으면 몫만 나오는게 아니라 나머지가 발생한단 의미임 
나머지가 이와같이 
그런데 여기도 에러가 발생했음에도 불구하고 체크가 안될수도있다 어떤 경우에 안될까 - 짝수가 안됬다. 
에러 패턴인 G로 나누어지면은 안된다. 이거임 G로 이 발생한 패턴이 e라는 패턴이 G로 몇배수가 되면은 안나눠진다. 
그 케이스들은 우리가 뒤에 쭉 보면 알겠지만 극히 확률적으로 작은값이 된다는 거임 이 내가 디바이저 라는것을 큰 값을 사용할수록 디바이저 가 3비트밖에 안되는데 4비트 5비트 ..8비트 
뭐 16비트.. 도 사용하고 그런다 
그걸로 나누어 질 수있는 패턴이, 에러패턴이 발생할 수있는 확률 은 지극히 확률적으로 적다 이거임 
그런 원리가 이거다 사이클링 리던던씨 체크는 
다 나누는 것이다. 보내는 쪽에서는 나누었을때 나머지를 더해서 보냈고 받은쪽에서는 같은 디바이저로 나눠보는것이다. 그래서 나눗셈을 했을때 나머지가 있느냐 없느냐를 체크한다. 없으면 에러가 없다라고 체크한다.
그래서 이게 파워풀하냐 바로 요부분에 내가 G를 어떻게 선택하냐에 따라서 이 부분이 내가 놓칠 수 있는 확률이 얼마나 나오는지 한번 생각해보면 지극히 작은 확률로 이 나누어지는 에러 패턴이 발생 하는 나누어 지는 에러 패턴이 발생하는 확률이 매우 작으면 그리고 없어질 수없다는 얘기임 에러 체크가 된다는거임 
??? 값이 굉장히 작다라는걸이제 다음시간에 CRC 방식에서 살펴보자.



