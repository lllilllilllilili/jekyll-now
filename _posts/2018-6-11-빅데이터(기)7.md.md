---
post : layout
title : 빅데이터 7
---
## 빅데이터 7
빅데이터 7 

## Key-Value Databases(K-V Store)
키벨리유 스토어는 말그대로 키와 벨리유 관계로 여러분들 데이터를 가져다 모델링을 한다. 벨리유가 그냥 블락이에요
바이너리 파일이다. 그러다 보니까 특별한 
일정하지 않기 떄문에 
쿼리 파워를 제공한다. 
키값을 주면 거기에 해당되는 밸리유 블락을 가져다 
실제 캐시서버에서 굉장히 많이 쓰고있고 웹서버에서 캐시 뭐 
물론 
키밸리유이고 
다큐먼트 스토어 같은경우는 말그대로 다큐먼트를 어떻게 저장할것이냐 에 대한 그런 내용인데 여전히 왜냐하면 아무리 사전 에 이런 바이너리 파일이 많아져도 여전히 다큐먼트를 저장해야 하는 양은 괴장히 많다. 실질적으로 다큐먼트로 저장한느게 많이있다.
쉽게 생각하면은 아마존 항상얘기하지만 프로덕트가 있으면 그 많은 디스크립션 그래봐야 다 다큐먼트 부분이다. 그런 다큐먼트를 저장하는 수요은 많이 있는데 그런 용도로 나온것이 다큐먼트 데이터베이스이다. 다큐먼트 스토어인데 
여전히 aggregate 단 키는 존재하고 거기에 해당한느 밸리유 
스트럭쳐드 에그리 게잇이 있습니다. 얘네들은 그 에그리게잇이 스트럭쳐 가 있다 고 말씀드렸죠 스트럭쳐가 비저블 하다고 그랫다.
그렇죠
조금더 스페시픽하게 조금더 강력한 쿼리를 가져다 쿼리문을 할수가있다. 여기까지 우리가 했었다 3번째로 에그리게이트 타입의 마지막 부분 
세가지 있다고 했는데 첫번째 키벨리유 했고 두번째 다큐먼트 스토어 했고 세번째 가 이제 칼럼 스토어 이다. 칼럼스토어 인데 칼럼 패밀리 스토어 라고도 합니다. 사람들 실제 , 디비시간에서도 배웠을 텐데 그 칼럼 스토어 볼 수있쬬 그쵸 
칼럼 패밀리 그대로 우리가 그 칼럼 패밀리 스토어 에요 거기 에다가 db에서는 실제 rdbms 에는 칼럼스토어 자체를 어 자체를 지원하기는 힘들다. 
그 
실질적으로 rdbms 가 칼럼스토어를 구현하는 것은 사실상 불가능하다. 그런 형태로 나온것이다. 왜냐하면  rdbms가 그 row 형태로 레코드라고 하는 하나의 row 형태로 저장을 하기 되는데 장점이 분명히 존재한다. 장점이 존재도 하기도 하지만 그것도 마찬가지로 리미테이션도 존재를 하게된다.
그런 리미테이션을 해결하기 위해 나온게 칼럼 스토어 이다. 
보시면 알겟지만 컬럼 스토어든 뭐든 당연히 에그리 게잇 베이스 모듈 입니다. 그리고 뭐 각각 얘네들이 이제 칼럼스토어 가 되는데 데이터 별로 따라서 그런 굉장히 많은 그런 에그리 게이트가 계속 만들어지고 
그리고 보시다 싶이 얘네들도 각각 키값은 가지고 있다. 사실은 그래서 키벨리유 스토어가 중요하다고 하는것이 어차피 이게 형태, 에그리 게이트 형태가 달라지는것이지 궁극적으로 사실은 다 키벨리유 형태이다. 그런 구성으로 다 구성이 된다. 그럼 물론 얘네들은 칼럼스토어 경우는 딱 한가지더 특징이있는데 얘네들은 모듈링 자체가 2 레벨이 구성이된다. 키값을 주면 밸리유가 툭 튀어나오는 구조가 아니라 키값을 주면 , 그 값을 가져가서 다른 키를 찾고 그 키에서 다시 밸리유 값을 찾아가는 그런 형태다.
예를들어서 여기 보시면 row-key라고 나온다. 
row - key 값으로 시작을 한다.row key 값으로 던져지면 걔가 이제 받아가지고 이 컬럼 테이블 로 가면 그 중에서 그 여긴 뭐 메인 메인인가요? 메인 이라는 그 컬럼 값을 주면 거 키값 칼럼 키값을 주면 거기에 해당되는 밸리유 값을 리턴하는 이런 형식으로 투레벨이다. 투레벨 구성하고 있다.

## Cloumn(-Family) Stores
얘네들의 데이터 모듈링 자체는 크게 바라보면 row key랑 aggregate로 구성되어있찌만 그 에그리 게이트 각각 자체가 다시 칼럼 키랑 밸리유 키로 구성되어있는 그리고 칼럼패밀리 이라는건 이상? 요 하나 자체가 칼럼이다.
요 자체가 칼럼이고 얘네들의 묶음 
얘네들의 묶어논것을 칼럼 패밀리라고하는데 여러분들 칼럼 패밀리 배우셧죠
칼럼 패밀리라는건 연관있는 칼럼들의 집합이다. 그런데 심심해서 무조건 붙여놓은게아니라 
에그리게잇이라는 개념자체가 동시에 아니면 그 서로 연관되어있는 관계가 있는 그런 데이터들의 집합이라고 했다.
어느 하나가 만약에 엑세스되면 동시에 엑세스가 될 가능성이 높은 통상적으로 한꺼번에 묶어서 처리를 많이 하게되는 그런 개념들의 집합을 가져다 에그리게잇이라고 말씀드렸는데 
얘네들의 칼럼패밀리를 구성할떄는 각각 칼럼들이 어 고런식으로 구성된다. 그런식으로 많이 연관이있는 에그리게잇들을 묶어놓은 그런 칼럼들의 집합을 칼럼 패밀리 라고한다.

이 얘네들이 칼럼 패밀리이고 요 칼럼 패밀리를 구성하고
그리고 이칼럼 패밀리들이 다시 이렇게 패밀리를 구성하게 된다. 이런식으로 칼럼 스토어는 구성이된다. 보시다 싶이 얘네들 에그리게잇 새 (세? 3?) 스트럭쳐도 당연히 비저블 하다. 얘네들 각각에 대해서 칼럼과 밸러블, 이런식으로 스트럭쳐가 다보인다. 
그렇기 떄문에 얘네들도 좀더 그 다큐먼트 스토어처럼 서브시픽한 그런 쿼리가 가능하다.
그리고 말씀드렸다싶이 칼럼 자체가 이제 패밀리 형태로 이런식으로 컬렉션으로 구성이되어있는데 요 컬렉션 자체를 가져다 칼럼 패밀리라고 얘기한다. 그리고 걔네들이 하나의 그런 에그리게이트 형태를 구성을 한다. 그래서 만약에 우리가 스페스픽한 어떤 값을 가져오고 싶어 그렇게 엑세스 하고싶을떄는 제일먼저 row값을 먼저 던져주고 row값을 가지고서 이제 칼럼 보러가고 그 칼럼에서 궁극적으로  한단계 더 가가지고 밸리유 값을 끌어 오는 그런 형태가 된다. 
이미 디비 시간에 배웠겠지만 reference 삼아 제가 그냥 복붙해서 넣놨다
보시면 알겠지만 
row store하고는 딱히 얘기하진 않는다. 

## row-store vs column-store 
그냥 여러분이 흔히알고있는 rdbms 이다
그렇져 그 레코드 형태로 저장이 되는 rdbms이다.
왼쪽에 있는걸 얘네들이 그냥 어 그명칭에 어떤 통일성을 따져가지고 row-store라고 했을뿐이고 어쩃거나 여러분들이 알고있는 rdbms 형태이다. 그런 스키마 이다. 오른쪽이 여러분이 알고있는 금방 우리가 얘기했던 칼럼 스토어 얘기다.
보시다 싶이 아시겠지만 칼럼별로 요런 식으로 요런 식으로 지네들 끼리 몰려있다. 근데 row - store 같은 경우는 통상적인 rdbms 보면은 칼럼끼리 쪼맬 수가 없다. 칼럼 끼리 쪼맬수가 없기떄문에 하는 짓이 뭐야? 프로젝션이다.
그렇죠
어쩃든지간에 그런 하나의 더 그런 오퍼레이션을 거친단 말이야 그래서 이제 요 row-store는 그런식으로 되어있는데
그래서 각각 그런식으로 장단점이 있다. 그래서 만약에 여러분들이 데이터들 저장할떄 하나의 어떤 row 형태로 레코드 형태로 데이터를 만약에 확 저장을 한다. 그럴거 같으면 사실은 기존에 row - store 형식이 맞다.
데이터를 저장할떄 하나의 버퍼링에다가 각각 데이터를 가져다 쭉쭉쭉 집어넣어가지고 그냥 flush 해버리면 되는것이다.
자 그런식으로 쓸때 얘네들이 row-store를 쓰고 
반대로 이제 칼럼스토어는 각각 데이터가 보면 칼럼 형태로 요렇게 나눠져 있다.
그렇죠 그래서 우리가 원하는 요 데이터 
내가 만약에 어떤 데이터 베이스가 있을떄 거기서 내가 날짜만 내가 가지고 오고 싶어 아니면 예를들어서 커스텀 이름만 내가 가지고 오고 싶어 그랬을때는 얘네들이 다읽어들여가지고 프로젝션이나 아니면 그런 조인 같은 작업을 할 필요가 없는것이다.
내가 예를들어서 커스터머 이름만 읽고싶은데 다른 데이터를 읽을 필요가 없는것이다.
사실은 rdbms가 그게 큰 문제다. rdbms의 가장 큰 문제가 뭐냐면 내가 예를들어서 커스터머 이름만 가지고 오고 싶다고 해도 그것만 읽을 수 없다. rdbms 그 자체가 그렇게 되어있따. 레코드 단위로 저장하고 레코드 단위로 읽는다.
그래서 여기보면 그대로 나와있지만 이 불필요한 데이터를 가져다읽어야 된다. 라는 얘기가 그런관점에서 나오는것이다.
항상보면은 기본적으로 그 sql 여러분들이 뭐 그 sql 포맷있짠아 거기보면 항상 여러분들이 조금이라도 무슨 짓을 할려고하면 무조건 조인 이랑 프로젝션을 가져다 필히 거의 대부분 하게 된다.
근데 유치한 데이터를 읽어오지 않는이상 뭔가 테이블 과 테이블 그 사이에 무슨 릴레이션십을 갖다가 엮어가지고 데이터를 뽑아올려면 거의 대부분다 조인해서 프로젝션하게 만든다.
그얘기인즉슨 여러분들이 필요없는데이터를 다 읽어가지고 프로세싱을 해야한다.
그 단점이 rdbms에 존재하지만 칼럼 스토어는 그런게 없다. 내가 원하는 데이터만 쑝 읽어올수있다.
물론 요렇게 만 얘기하니까 다 좋은거 같지만 하지만 여러분 세상에 공짜는없다.
수십먼 말했다. 얘네들 경우에는 만약에 데이터가 반대로 이런식으로 레코드 형태로 데이터를 저장할거같으면 각각이 쪼개져있기떄문에 얘네들은 리드 라이트 자체가 오버헤드가 심해
왜냐하면 얘들 같은 경우에 봐라 하나 둘 버퍼링 잡아가지고 넣어서 그냥 flush 해버리면된다. 
i/o 숫자가 작지만 얘네들 같은 경우는 일일히 다 쪼개져 있기떄문에 그런식으로 저장을 할수가없다. 형태가
그래서 그런 어 "멀티풀 엑세스"를 해야한다.
라는 단점이 있다. 
존재한다.
# Properties of Column Stores
칼럼 스토어조금더 살펴보면 어 예를 들어서 우리가 원하는 그 어떤 그 하나의 칼럼의 데이터를 탁 읽어오기위해서는 그냥 통상적으로 여러분들 key -value에서는 get 주고 나서 그런 key값 하나 주면 그만이지만 
얘네들 경우는 투레벨로 구성이 되어있다고 말씀을 드렸어
키가 
그렇기 떄문에 두개의 키값을 줘야한다.
요 키값을 주고 그다음에 해당되는 칼럼에 키값을 주는것이다. 그러면은 거기에 해당하는 value 를 리턴해주는 그런형태로 작동을한다. 그래서 칼럼스토어에서 그 칼럼이란 얘끼는 자 칼럼패밀리에 자 어떤 하나의 그런 파트를 말씀드린거고 그리고 걔네들이 데이터를 엑세스하는 기본 유닛 자체가 칼럼이 되는것이다. row - store 경우는 데이터 기본 엑세스 유닛 자체가 하나의 레코드가 된다.
row가 되는거고 
그래서 이제 얘네들 실제로 데이터 쓰고 뭐 이렇게 할때 보면 굉장히 얘네들은 flexible 하다 
나중에 이제 이 슬라이드 끝에 보면 스키마리스 라는 얘기를 하면서 거기 같이 말씀드리겠지만 
굉장히 플렉서블 하다. 여러분들이 데이터를 보고싶으면 그냥 칼럼 패밀리에서 그냥 집어넣으면된다.
칼럼을 만들어서 넣어버리면된다. 왜냐하면 칼럼 단위로 저장이 되거든요
근데 여러분들 잘 생각해보세요 rdbms 같은경우는 그게 쉽지가 않다.
rdbms 여러분들이 이미 스키마 자체를 디자인을 먼저 한단 말이야 
그렇게 해서 칼럼 별로 그렇게 스키마 디자인을 해두고 
데이터를 저장하는 형식인데 여러분들이 거기서 아 이 데이터가 좀 바껴야된다.
그러면 그게 훨씬더 일이 커진다.
근데 칼럼 sotre는 그렇지 않다.
그래서 property도 플렉서블한 면이 있다. 라는 
그게 그얘기고
자 밑에 요거는 말씀을 드렸던것을 가져다 지금 어 다시 써놨을 뿐이다. 혹시나 리마인드 차원에서 
데이터를 가져다 이제 어 저장할떄 row 기준으로 넣느냐, 아니면 칼럼기준으로 넣느냐?
로스토어 칼럼스토어 인데 
어 로 같은경우는 이치 각각 로 자체가 하나의 에그리게잇 단위가 된다. 그렇죠 그단위로 데이터를 엑세스를 하니까 그리고 얘네들 입장에서 row 별로 레코드 별로 넣는 관점에서 바라봤을때 얘네들 입장에서의 칼럼 패밀리 라는것은 각각 그런 그 데이터에 그런 청크된 데이터일 뿐인것이다.
근데 칼럼 스토어 입장에서 바라봤을때는 얘들은 그 레코드 타입 , 칼럼 스토어 입장에서 얘네들이 말하는 레코드라는것은 각각 칼럼 패밀리에 패밀리에 있는 레코들을 갖다가 다 조인을 로우로 다 조인을 한것이다. 그 관점에서 바라봤을때 걔네들이 칼럼 패밀리에서는 row 라는게 그런 의미이다. 굉장히 직관적인 얘끼다. 별다른점은 없다. 자 칼럼패밀리 에서 이제 데이터를 엑세스한다. 별거아니다 이미다 말씀드렸던것이다. 그냥 그림으로 그냥 여러분들 조금더 이해 되시라고 넣어놨을 뿐이다. 각각 이제 그 얘네들이 칼럼 패밀리 같은게 있고 키와 그 벨리유 형태 결과적으로 이제 그런 형태로 구성이 되게 되는데 어 그 얘네들이 실제 데이터를 그 엑세스할때는 말씀드렸다 싶이 제일먼저 row키를 가져다 얘네들이 일차목표를 그러고 나서 칼럼키를 가져온다음에 거기에 해당되는 값을 가져다 리턴해주는 그런 형태가 된다. 그리고 여기보시면 맨마지막에 그 칼럼패밀리에 패밀리를 가져다 각각 뭐 나누면은 걔들이 성능이 좋다 라는것은 
여기 무슨말이냐면 이말이다. 요 얘네들 하나가 칼럼이고 연관성이 있는 걔네들끼리 묶어 놓은 요 에그리게이트 단위 요자체가 칼럼 패밀리이다. 그리고 요 칼럼 패밀리들이 묶여 의미가 자체 10개가 묶여가지고 데이터가 구성이 되게 되는데 얘네들을 칼럼 패밀리에 패밀리라고 한다. 얘네들을 자를떄 얘네들을 에그리게이트 단위로 쪼개놨을때 성능이 더 좋아진다는 얘기다 어떻게 보면은 굉장히 당연한 얘기다 그얘기이다.

## Popular column stores
부지런히 아주 진도가 잘나감 예제인데 
가장 대표적인 칼럼 스토어를 가져다 넣놓은 것이다. 여러분들이 그냥 보시면은 
여기서는 카산드라가 왕이다. 거의 칼럼 스토어에 대부분을 다 잡아먹고있다. 그리고 사실 넘버 투가 아파치의 hbase는 그 하둡 우리가 배웠던 하둡에 hdfs를 그대로 바탕으로 해서 그위에 하둡위에다가 얹어져있는 칼럼 스토어임 그래서 예를 들어서 여러분들이 하둡을 가져다 설치를 해가지고 hdfs 를쓰고있다 그런데 거기서 여러분들이 만약에 쿼리를 날리고싶으면 어떻게? 할꺼에요?
방법이 없다. 그렇죠 그럴때 쓰는것이다. 기존에 이제 하둡이 굉장히 널리 쓰이던 그 시점에서 얘네들이 그거는 그 문제를 해결하기위해서 위에서나온 그 칼럼 , 그 hdfs위에서, 하둡위에서 돌아가는 sql이다. 그게 hbase이다.
그리고 나머지 하이퍼테이블이 있긴한데 얘네들은 글쎼요 별로 
이름만 들어봤지 별로 쓰는건 못봣고 구글의 빅테이블 사실 굉장히 유명하지만 별로 여러분들 쓸일이없다.
왜냐하면 얘네들이 그 자체적으로 내부적으로 비매적으로 지네들이쓰는것이다. 여러분들이 빅테이블 을 써보세요 이런걸 경험할 기회는 아마 거의 구글에 입사하지않은이상 없을것이기 떄문에 걱정 ㄴㄴ 
빅테이블 같은 경우는 이게 왜들어가있냐면 이게 실제 카산드라나 hbase에 베이스가된다. 이 빅테이블은 2006년도 구글이 페이퍼 발행하면서 그때 얘네들이 구글이만들어내면서 우리는 내부적으로 이런걸 쓰고있어요 라는것을 걔네들이 살짝쿵 맛을 보여준다. 다 만들고 쓰고있으면서 나중에 슬그머니 살짝 맛을 보여주는데
어 페이퍼가 이제 빅테이블 페이퍼이다. 굉장히 센세이브하다.
그거를 보고서 그 위에서 바탕을 해서 만들어진게 hbase랑 카산드라이다.
실제 얘네들에 키에 엔진이나 그 베이스나 그 모든 모델들은 그 구글에 빅테이블을 바탕으로 한다.
아시겠쬬 그래서 사실은 이게 굉장히 의미심장하지만 어 이거는 뭐 오픈소스나 그런게 아니기 때문에
사실 우리가 돈을 주고 살수있는 그런건 아니다. 어쨋거나 그래서 넣놓은것이고
자 이렇게 해서 에그리게이트 베이스에 그런 모델이 되는 3가지는 훑어봤다.
그 3가지가 되고 어쩃거나 저쩃거나 보시면 알겠지만 궁극적으로 그거를 가져다 이제 어 그 3가지 모델 자체는 요 대부분다 형태가 살짝 다를 뿐이지 키 벨리유스토어 형태이다 그 벨리유 라는게 어떤 블락이냐 아니면 다큐먼트냐 아니면은 그게 투레벨로 가는지 칼럼 패밀리이냐로 따라가지고 그게 달라질 뿐인거지 결과적으로 abstract 시키면 사실은 그 3가지 에그리 게이트 베이스 모델은요 키 벨리유 스토어이다. 그래서 빅데이터 모델에서 그 데이터를 수용하는 그런 모델로서 키 벨리유 스토어 그래서 굉장히 중요한것이다.
실질적으로 세분화시켜놨을 뿐인것이다. 자이제 그거랑 별개로 이제 그 그래프 데이터 베이스가 나오는데 

## Graph Databases
그래프 데이터베이스는 여러분들이 이미 잘알고있다. 가장 대표적인게 페북이다.
자 이 그래프 데이터 베이스 경우는 기존에있는 3개 배웠잔아 에그리게이트 베이스 모델이나 살짝 다른데 얘네들은 불만이 조금 다 르다. 기존에 rdbms가 갖고있던 그런 불만들이 물론 있는데 얘네들은 그래프 데이터베이스는 그 모티베이션이살짝 다름 얘네들은 뭐가 불만이있느냐 자 페북이나 기존에 있던 소셜 네트워크 이나 얘네들 그 회사들에 대한 불만이 뭐냐면 

기존에 rdbms를 했더니 복잡한 그런 관계를 가져다 표현하기를 쿼리를 하기는 사실상 너무 힘들다. 할수있는데 열심히 조인을 열심히 열심히 프로젝션 열심히 열심히 해가지고 할순있지만 사실상 너무 복잡하다. 오히려 너무 크고요
그런거에 대한 불만이었다 얘네들은 그래프 데이터베이스에서는 그렇게 해서 나온다.

그래서 여기보시면은 이제 뭐 복잡한 글을? 릴레이션 십을 가져다 표현을 할려고하니 굉장히 컴플렉서한 조인을 필요로 하드라 
자그래서 이것을 가져다 조금더 행 좋게 좀더 할수 가 없을까? 
라는 모티베이션으로 나온게 그래프 데이터베이스이다.
그래프 디비 , 걔네들의 목적은 그런 복잡한 릴레이션 십을 가져다 표현을 좀더 쉽게 표현할 수있는 그런 방법을 없을까 라고 고민을하게되고 그리고 요거를 가져다 당연히 어 그런 복잡한 그런 관계를 표현하기 위해서 사실 좋은게 그래프이다.
이미 여러분들 데이터 스트럭쳐시간에 다 배운 그래프가가 뭔지
그런 그래프형태로 어 데이터를 가져다 저장을 하자 이거임 그리고 트랜 펄스도??(traversal) 그런식으로 하게되면은 복잡한 관계를 표현할떄 굉장히 좋을거같다 얘네들이 그런모티베이션에서 나온게 그래프 데이터베이스이다. 
그래서 얘네들 뭐에 많이 써먹냐 하면은 보시면 소시얼 네트워크 라든가 이미 뭐 잘 알고있다. 일상생활
그래서 굉장히 어떤 그 데이터들끼리 커넥션이 많은 그런데이터를 가져다 우리 ???? 하는 그런 use case로 많이쓰고 그리고 
location-bases service 로 이제 뭐 예를들면 여기보시면 딜리버리를 를 가져다 플래닝한다. 이게 shortest path를 찾는것이다.그렇죠 그런것을 찾는다 라던지 아니면은 추천시스템 자 recommendation system 같은거 이거는 여러분들이 너무 많이 보는것이다 사실은요 이게 너무 많이 보고있어서 잊고있을정돈데 어 여러분들 열심히 온라인 쇼핑하면 밑에 열심히 나오잔아 
이거 산놈이 이것도사드라 
그래서 이거 닥치고사는게 어떄 이런식으로 열심히 보여주잔아 그거다. 그게 딱 추천시스템이다. 그래서 보시면은 이그림 이 뭔얘기냐면 예를들어서 어떤 관광객 여러분들이 익스티비 하다. 그런 관광 호텔이라든가 부킹시스템에 들어가면 자 요 여행지를 많이 갔던 사람들은 요 여행지도 자주 가더라 그러니까 요기에 부킹하던 사람이 있으면 요거까지 같이 보내주는거야
같이 사면 좋지 않겠니? 이런식으로 보여준다.
옷 책도 마찬가지임
밑에 그냥 밑에 쭉뜬다. 심심해서 랜덤으로 보여주는게 아니라 데이터 클릭하면 백그라운드 프로세싱하고있는것이다. 그리고 나서 여러분꼐 보여주는것이다. 그런식으로 쓴다. 그래프 데이터 베이스 경우는 말씀드렸다싶이 여러가지 그래프가 있꼬 
그래프는 노드랑 엦지 로 표현하는것이다.
그래서 얘네들에 그래프 데이터베이스를 쓰면 굉잘히 똘끼 충만한 쿼리도 가능 보시면 어떤 쿼리도 가능하냐면 내친구 가 있는데 걔가 좋아할거같은 누군가에 의해씌여진 데이터베이스 카테고리에 들어가는 책을 한번 찾아봐줘 라고 하는 쿼리를 당연히 rdbms 어떻게 쓸꺼냐? 그래프는 그 노드만 쭉 따라가면 나온다. 노드만 따라가면 나온다. 이런식에 굉장히 복잡한 어 쿼리가 그래프 디비에서는 가능하다. 그래서 실제 얘네들이 데이터들이 어떻게 모델링하고 왜그런짓 살짝 살펴보면 그래프라는건 우리가 안다. 데이터스트럭쳐 시간에 배웠다. 노드랑 엣지랑 그 두개를 가져다 연결 노드를 엣지로 연결하는데 그게 디렉션하게 할수도있고 안할수도있고 바이디렉션도 할수도있고 유니드렉션 할수도있고 기본적으로 그렇게 연결이된다. 물론 설큐레이션이 가능하다. 트레이는 그게 서큘레이션이 안되지만 루프가 허락이 안되지만 그래프는허락이 가능하다. 그래서 그 쿼리의 기본성질이 더 강하다 그래서 얘네들이 그래프 형태를 쓴다. 보시다싶이 이미 알고있는 내용인데 좀더설명해준다.
## Data model of graph databases
얘네들이 그래서 데이터모델링을 어떻게 하냐면 
이 데이터가 자체가 노드 그 노드들간에 릴레이션십 그 릴레이션십을 표현하기위해서 노드에 데이터 에 들어가있는 데이터 자체 프로퍼티라고 하는데 그 프로퍼티 
이 3가지로 (노드, 릴레이션십, 프로퍼티) 그래프 디비 구성된다. 
그리고 이제 보면 노드랑 릴레이션십 은 다 그런 프로퍼티를 가지고 있다. 왜냐하면 그 프로퍼티를 가지고 계속 트래펄스 하는것이다.(중요) 그래프 디비라는게 그리고 이제 어 릴레이션 십 이라는게 여기서 엣지 .
여러분들 그래프 에서 배웠을때 그 엣지가 되는데 그 릴레이션 십으로 노드가 노드끼리 연결이 된다. 그리고 이제 프로퍼티는 어떤 키값이나 밸리유 값으로 형태로 구성이 되고 어 그 노드는 서클이고 릴레이션십은 arrow 키로 리턴을 표현을 한다.
그리고 이제 그래프니까 , 그래프 특성상 디렉션이 있을텐데 바이드렉션이든 유니드렉션이든 어쩃거나 그런 이 릴레이션 십 자체는 그런형태의 디렉션을 가지고 있다. 그리고 실질적으로 얘네들이 구성되는 그 펑션을 보면 물론 이 그래프를 가져다 그래프 디비 를 구성하기 위해서는 그래프 디비 자체가 지원해야될 기능들이다. 그리고 요런 기능들이 지원이 됬을때 그 바탕으로 그래프 디비에서 쿼리를 나를수있는것은 요런 종류의 ?? 쓴다. 그래서 노드가 있고 노드랑 릴레이션 십이랑 다른 각각 노드랑 릴레이션십에서  프로퍼티가 있고 걔네들 간에 관계인데 노드랑 릴레이션십을 만들고 지우고 프로퍼티 셋하고 리무브 하고 아니면 뭐 쿼리를 가져다 우리가 많이 날린 쿼리를 인덱실 해가지고 빨리 빨리 쓸수있게 인덱싱 할떄 그런 기능도 제공하고 이 그 그래프 디비 자체에서 이런 펑션에서 다 제공하고 제공하게 되면 여러분들이 원하는 그런 매칭이나 그런 패턴을 가지고서 여러분들이 트래펄스를 하게된다. 그래프를 가져다 찾아가고 아니면 그런 이미 우리가 인덱싱해놨던 쿼리를 가져다 빨리빨리 찾아가는 기능들을 가져다 우리가 수행을 할수가있다. 

## Base functionaliity
어 그래프데이터 베이스 에 데이터를 그러면 어떻게 엑세스를 하느냐! 뭐 이미다 말씀드렸다. 사실은 그래서 우리가 뭐 
노드가 있고 그 노드에 
그 노드와 노드를 연결하는 그 이 릴레이션십은 각각 다 자기네들이 네임을 가지고 있따. 그 노드는 다 네임을 가지고 있다. 그래서 실제 어떤 노드에서 다른노드로 트래벌스 할때 그 네임을 가지고 트래벌스한다. 그래서 어떤 복잡한 쿼리가 있떠라도 그 노드에서 출발해서 거기 자기가 찾는 그 네임만 따라서 쭉쭉 가면 그 아무리 복잡해 보이는 쿼리라도 몇단계 거쳐서 갈수있다. 그러다 보니까 조인이 뭐니 이런게 필요가 없다. 그리고 그렇기 떄문에 그런 복잡 한 쿼리를 굉장히 빨리 처리할수있다. 
자 여러분들 너무 빨리 나가고 있다. 

그래프 데이터베이스에 어 유명한 그런 데이터베이스 그래프디비이다. 

## Popular graph databases
neo4j가 왕이다. 
이해를 하면된다. 그래프 디비가 이어포즈가 다 잡아먹고 있다 아파치에서 giraph가 이인자다 오픈소스이기 떄문에 많이 쓰이고 있다. 그다음에 얘네들 orientdb 엄밀히 말하자만 얘네들은 그래프 디비라기 보단 컴플렉스 디비라고 보는게 좋다 얘네들은 단순히 그래프 형태만 제공하는게아니라 다른 기능들도 제공을 한다. 순수한혈통의 그래프 디비라고 볼수없다. 그리고 사실 점유 자체만 보면 neo4j가 넘버원이고 마이크로소프트 애즈올 얘네들이 
그런데 애즈홀 컨솔러티 디비는 컴플렉스 디비다. 실제 순수한 그 그래프 디비는 아니다. 그리고 이게 점유율이 높을수밖에 없는것은 얘네들이 클라우드서비스 제공하기 떄문에 그 클라우드 서비스쓰는사람이 점유율이 들어가기떄문에 높아보일뿐이다.
그런데 실질적으로 많이 쓰이는것은 neo4j 나 giraph가 많이 쓰이고 있다. 

## Data Accesses in graph databases

## Graph vs Aggregate-oriented databases

## Graph vs Relational databases
비교를 해보자
그래프디비랑 릴레이션 디비를 살짝쿵 비교를 해보자
자 rdbms에서 우리가 어떤 릴레이션십을 가져다 찾아내기 위해서 못하느냐? 할수있다. 그렇죠 
폴인키가 있잔아요 폴인키가  레퍼런스다. 그렇죠
폴인키가 레퍼런스키이다. 그렇죠
그 테이블들간에 그런 릴레이션십을 가져다 연결해주는 그런 레퍼런스 역할을 해주는 그런 폴인키를 가지고할수있다. 그런데 역시나 얘네들 폴인키가 있든 말든 수많은 조인과 그런짓을해야하는것은 사실이다. 그런것을 조금 덜어주는 것뿐이고 그런 한계가 명백하고 얘네 rdbms는 등장을 한다. 그래프같은 경우는 지금까지 말한대로 그런 복잡한 릴레이션십을 가져다 우리가 트래벌스 해가지고 그런 쿼리를 찾는건 굉장히 쉽다. 왜냐하면 그 노드만 따라가면된다.
그 네임이 있다고 그랬따. 그 네임만 계속 트래벌스한다. 아무리 복잡하든지 뭐든지 간에 굉장히 빨리 끝난다. 실질적으로 근데

좀 자 그런데 생각해보면은 트래벌스 하기 쉬운데 바꿔 얘기하면 그런 데이터를 가져다 구축을 해야한다.
구축을 하는데 시간이 걸린다. 왜냐하면 그런 기준의 노드와 그런 릴레이션 을 다 따져가지고 생각을 하기족 구성을 해야한다. 그리고 기존에 있던 노드에 집어넣는다. 그러다 보니까 실질적으로 그래프디비 같은경우는 쿼리 성능 은 굉장히 성능은 인설션 성능은 좀 떨어진다. 그래서 얘네들이 어 어떤 데이터에 좋으냐면 나와있는데 자 실제 그런 복잡한 쿼리를 가져다 수행해야 하는 그런 쿼리 퍼포펀스가 더 크리티컬한 케이스이다. 그래서 데이터를 가져다 인설션을 막하는 그런 디비도 그런용도 많이 있다. 그런데 그런 용도가 아니라 실제로 쿼리를 하는 그 퍼포먼스가 더 중요하게 작동하는 그런 케이스에 실질적으로 더 적합한 그런 모델이다. 무조건 얘네들이 좋다는 게 아니라

그리고 예를들어보면 그림 제가 카피앤 패스트 넣어놨는데 얘를들어서 어떤 사람이 있는데 어떤 사람이 뭐냐면 엘리스란 사람이 있는데 얘 
이 엘리스란 사람이 어느 디파트 먼트 에속하는지를 한번 다 찾아봐 라고 하면은 기존에 그 RDBMS는 자 디파트먼트에 속하는것을 다 디진다. 그리고 찾아내고 그리고 각각 디파트먼트에 속한 맴버 라는지 이런것을 다 조인하고 프로젝션해서 아 걔는 엘리스야 그리고 엘리스는 어디어디어디에 속해 이런식으로 찾아내지만 
그래프 디비 같은 경우는 엘리스가 어디 속하는 지 따라가기만 하면된다. 물론 얘가 여기만 속하지 않겠죠 다른 데도 뭐 다른 그 프로퍼티를 가지고 있는 그런 릴레이션은 있긴 할겁니다 그런데 엘리스 시작하는 그 노드 몇개만 뒤져가지고 거기서 빌롱하는 그 몇개만 찾아내면 다 찾아낼수있다. 훨씬더 강력하고 쉽고 빠르다. 보시면 위에 시퀄 SQL 
SQL Statement를 적어놨는데 이런 복잡한 그런 프로젝션 과정을 거쳐가지고 값을 찾아낸다. 이래서 여기서 누가 찾냐면 그 네임 엘리스 라는 사람을 찾아내는 것이다. 
Select name 이다. 우리가 일단 조인 몇가지만 하면 몇가지 조인을 거쳐서 그 테이블 에서 그 펄슨에서 누구를 찾는 그게 그래서 그 사람이 누구니 찾는거고
밑에 보면 Cyper Statement이게 뭐냐면 요것도 사이퍼라는것도 하나의 그런 쿼리문이다. 그게 그래프디비에서 날리는 쿼리문이다. 그래프디비에서 제공하는 쿼리문이다. 그래프디비라고해도 디비는 디비잔아 그리고 그것을 가져다 쿼리를 날려야 되잔아.
그러면 얘네들도 쿼리문도 있어야지 쿼리를 날릴것아니야 그렇죠 이런식으로 그래프 디비가 제공하는 쿼리문의 한 종류이다. 이것을 가져다 오해하지마라 
이 sql 에서 s는 그 sql 같은 경우는 표준이다. 모든  rdbms 는 이런 형태를 다 따른다. 모든 rdbms 그게 뭐가 그게 포스트 그레스가 됫든 그게 뭐가 됫든지 간에 rdbms 는 sql문을 넣으면 다 먹는다. 그건 표준이거든 그런데 그래프 디비는 그렇지 않다. 표준이 없다. 사실은 그게 좀 살짝쿵 문제다. 
그래서이게 사이퍼라고 넣놓은 이유는 뭐냐면 그 neo4j 
얘네들ㅇ이 거의 왕인데 얘네들이 쓰는 그런 그래프디비에 쿼ㅣㄹ문 얘네들이  사이퍼 라는 그 쿼리문을 쓴다. 
예제를 보여준것이다. 여러분들이 알아라 라는게아니라 
알려드리는것이다. 다른 페이지에서
그래프 디비같은 경우는 걔네들 그래프 베이스에 그런 쿼리 랭기지를 여러가지를 제공하게되는데 보시면 

## Graph vs Aggregate-oriented databases
보시면 사이퍼가있다. neo4j에서는 사이퍼다
Gremlin이라든지 이런것들이 있다.
보시다싶이 지네들이 만들어가지고 지네들한테 맞는 그런식으로
맞는 그런 쿼리문을 제공한다. 표준이 없다. 지네들끼리 제공을 하니까 그래서 그런 단점은 존재한다. 아시겠쬬 그래서
기존에 있던 sql 문 같은경우는 그것만 알면 여러분들이 포스트그레스를 쓰뜬 아니면 뭐 마리아 디비를 쓰든 오라클을 쓰든 뭘쓰든 작동하지만 얘네들은 그렇지 않다는 단점은 있다. 
그래프디비랑 rdbms를 비교를 해봤는데 

에그리게이트 베이스 에 그런 데이터베이스랑 비교해보면 물론 두개는 다른 모델이죠 
그래서 카테고리를 나눴다.
자그래서 에그리 게이트 베이스를 보면 자 여기보면 easy sharding 이라고 나왔는데 
bucketed data 그거를 가져다 이제 클러스터를 가져다 이제 그 데이터를 가져다
이거는 다음시간에 곧바로 설명드릴것이다. 샬빙이나 이런거 

자 sharding이 쉽다. sharding이 쉽고 어떤 데이터가 있을때 그 데이터를 가져다 sharding해가지고 그 클러스터에 디스트릿하는게 굉장히 쉽다. 지금 고민하지 말자

그리고 이제 어 쿼리랭기지가 그래도 훨씬더 간단하다 얘네들 같은 경우는 그리고 대신 얘네들은 acid 라는 지원하지 않는다. 지원하지 않는다 라기 보다는 여러분들이 이미 노시퀄 올려드린 표 출력해서 안보셧겠죠 만약에 보시면 거기 나올것이다. eventual consistency라고 나온다. 애네들은 그 모델을 따른다. 베이스 프로퍼티를 따르면서 지금 이벤츄얼  컨시스턴시를 를 제공을하낟. 대신 그러다 보니까 rdbms 가 따르는 굉장히 그 엄격하게 그 폴스를 하는 acid property는 제공하지 않는다. 그래프 디ㅣㅂ 같은 경우는 (그래프디비) 어떤 데이터 끼리의 그런 릴레이션십을 가져다 표현하기에 훨씬더 적당한 그런 모델이 된다. 그리고 말씀드렸다싶이 안타깝게도 얘네들은 아직은 표준 화된 쿼리 랭기지가 없다. 
그리고 이제 이거는 뭔가요 그렇죠 대신 얘네들은 그래프디비같은 경우는 엄밀히 말하면 얘네들도 acid 로 만들어 지는거 ????
지원하느냐 그렇지 않다. 그런데 기존에 있는 에그리게이트 모델보다는 얘네들이 트랜잭션이 훨씬더 강력하다. 그래서 어떤 노드는 아니면 그 노드 범위를 가져다 이제 여러분들이 어느정도 어떻게 디자인 하느냐에 여러분이 달려있겠지만 기본적으로 얘네들은 그래도 트랜재션이 어 에그리게이트 모델보다는 훨씬더 강력핟. 

## Schemaless Databases
그게아니라 에그

스키마 리스 
우리가 노시퀄 데이터베이스얘기할때 사람들이 제일 먼저 생각하는게 그중하나 이기도 하다.
스키마 프리라고도한다.
이 스키마 리스 디비가 스키마 프리 디비다라고하는데 왜그러냐면 말그대로 스키마가 없기떄문이다. 과연 어떤 의미에서 스키마프리냐, 어떤 스키마 리스냐 여러분들한테 설명드릴려고 하는건데
키밸리유 스토어 생각해봐라 
어떤 키가있으면 거기다가 밸리유 모든 회로에?? 다 제공할수있따.
재공할수있따. 바이너리가됫든 다큐멘터리가 됬든
다 제공할수있다. 그러다보니까 스키마 라고 할수없다. 
그리고 다큐먼트 디비같은 경우는 키가있고 그 에그리게이트 밸리유에해당되는 에그리게잇이있는데 
에그리게잇에 그런 데이터구조 데이터스트럭쳐는 이 데이터 스트력처는 는 비저블 하지만 이데이터의 형태를 어떻게 구성하든 여러분 마음이다. 여러분들 예제에서 그림을 다 보여줬다. 커스터머에서 그 에그리게이트 모양다르고 oder에서 에그리게이트 모양도 또 다르다. 스트럭트가 존재할 뿐이지 그 존재하는 그 스트럭트가 등위라는건 아니다 여러분들 마음대로 다 정의할수있다. 그런의미에서 다큐멘트 스토어 역시도 스키마 프리이다. 
칼럼패밀리도 마찬가지다. 칼럼 원하는 데이터 얼마든지 끝에 칼럼 으로 계속 붙여갈수있다. 그렇죠 스키마를 뜯어고치고 그럴필요가없다. 그리고 이제 그래프 데이터베이스 같은 경우도 여러분들 노드나 아니면 그 노드 사이에 그런 릴레이션십 여러분들 맘대로 넣어줄수있따. 정해진 그런 
## Pros and cons of schemaless data
정해진 형태나 스트럭쳐가 존재하지않는다. 그렇기 떄문에 이런 관점에서 그 노시퀄 데이터베이스 같은 경우는 스키마 프리 스키마 리스 라고 합니다 그런데 물론 다 장단점이 존재하게 되는데 
장점은 플렉서블 하다. 그렇죠 그렇기 떄문에 요즘시대에 그런 빅데이터에 잘맞는 것이다. 대부분 빅데이터가 80~90% 이상 대부분다 스트럭쳐가 없는 데이터들이다. 그렇기때문에 훨씬더 프리덤하고 그리고 어떤 플렉서블 하게 할수있다. 
그리고 이제 데이터 구성같은거 쉽게 바꿀수있다. 얘네들은 그렇게 해야된다는게 업다
그리고 보시면은 넌 유니폼이나언스트럭츠 데이터를 가져다 다루는데 좋다. 맞아요 이게 빅데이터 특성이다. 요런것을 다루는데 용이하기떄문에 요즘시대에 잘맞는다. 그런데 이제 장점일수도있지만 항상 ㅡㄱ렇듯이 단점일수도있는것이다.
스키마가 이렇게 익스플리싯 하지 않고 임플릿싯 하다. 라는게 장점일수도있는데 아니면 자 단점임ㄹ수도있는게요 그 스트럭쳐 가 비저블 하지 않게되면 여러분들 사실은 데이터를 가져다 딱 꼬집어서 뽑아내기가힘들다. 그리고 스키마 각 각각 다르면 다큐먼트 를 생각해봐라 다큐먼트에서 여러분들 그 에그리게잇 , 그데이터가 스트럭쳐에 각기 다 다르다. 그러면 여러분들이 그 데이터를 가져다 엑세스하고 묶는짓 을 하려면 그 최악의 경우는 여러분들ㅇ ㅣ코드를 봐야할 수도있다. 그렇죠 정해진 다큐먼트가 없다. 그런 단점이존재한다. 장점 explicit 하다 라는게 
스키마 리스 하는게 좋게 바라봤을떄 좋은점이 많이있는거지 나쁘게 바라보면 그런 단점도 존재한다. 그리고 이제 뒤에 부분이 나오는데 자 스키마가 어 없기떄문에 자 데이터 컨시스턴시를 가져다 어 체크하기 힘들다. 왜냐하면 데이터 타입이 명확해 
rdbms 경우는 각각 칼럼별로 보시면 알겟지만 데이터 구조가 있고 각 데이터에 해당되는 자 요 칼럼에는 요런 타입의 데이터가 들어가야되 라는것을 명시를 하게 된다. 그게 스키마 구조다. 그게없다. 그러면 칼럼 스토어 막말로 칼럼 스토어 만들고 그 데이터를 뭘 집어넣든 맞는지 틀린지 시스템 입장에서 어떻게 아냐 미리 그 데이터가 맞는건지 맞는 타입인지 아닌지 전혀 체크를 할수있는 방벙이없다.  어떤 형태든지 넣을수있으니까  아시겠죠 그래서 그러다 보니까 많은 애플리케이션들이 있는 그런데 각각 디밸류퍼노드들이? 각가 달라 걔네들이 만든 다른 애플리케이션들이 똑같은 테이블을 가져다 엑세스를 하게 된다면 문제가생긴다. 왜냐하면 서로가 각기 다른걸 바라볼수있다. 자 


## NoSQL Databases
여기보면은 크게 여기 4가지 찾아왔다. 제가 그냥 찾아서 넣어놨따. 위에 나와는 왜이것을 찾아 서 넣어놨다면 
위에 나와있는 애들이 다 넘버원이다.
여러분들한테 다 말씀드렸다. 그래프디비같은 경우는
그림에 보다싶이 
몽고디비 
그리고 칼럼스토어 카산드라가 원이다.
어쩃든지 다 넘버원임 어떤 종류가 있는지 말씀드렸기떄문에 자꾸 계속 나오지 

## Example:NoSQL use cases
요거는 예를들어서 어떤 데이터를 구축을 데이터베이스를 구축해야하는데 요렇게 있으면 어떤걸 쓰면 더 좋을까 에 대해 굉장한 심플한 아이디어를 드리기 위해서 넣놓은 페이지다.
대표적으로 행사에서 
내가 에버리지 인커버를 구해야되 그런류에 작업을 하게 되면 그냥 닥치고 rdbms를 쓰는게 편하다.
그렇고 예를들어서 쇼핑카트 구현한다. 그러면 키밸리유스토어를 쓰는게 편하고
그리고 어떤 데이터 스트럭트된 데이터 product information 같은것 그런걸 가져다 내가 넣는다. 그러면 당연히 다큐먼트 스토어가 제일 편할것이다. 그럼 어떤 포인트에서 다른 포인트에서의 릴레이션십을 표현한다 그러면은 그러면 그래프가 편하겠지 (ppt참고)

자 여러분 대망의 마지막장 

## NoSQL family
모든것을 가져다 모든걸 다 보여주진 않는다.
오른쪽 rdbms 고 왼쪾에 있는게 이제 그 말그대로 relational이 아닌것을 모아뒀는데 그 중요세서 요 범주에 들어가는 놈들이 nosql 데이터 베이스이다. 그렇다고 요 시험에 안낼꺼니까 외우고 그러지 마라 이런게 있다 라고 아시면된다. 그리고 괜찬다 셧다가


# NoSQL : Data Store for Big Data
일단은 어쩃거나 첫번째는 끝이나고
두번째로 들어간다. 
## Data distribution
첫번째 같은 경우는 no-sql 모델링 자체에대해서 배웠다. 
쿼리 날리고 그런식으로 배웠는데
이제는 nosql 실제 보면은 데이터를 가져다 그러면 우리가 처음에 시작할떄 nosql 데이터베이스 경우 클러스터에 잘맞는 모델이다. 라고 했다. 그리고 클러스터 데이터를 가져다 디스트리뷰트 할떄 굉장히 잘맞는다. 그러면 왜그런지 그리고 그 데이터를 가져다 클러스터에 디스트리뷰트 할때 어떤 형태로 데이터를 디스트리비우트 하는지 그리고 어 말씀드렸듯이 이벤트 컨시스턴시 ?? 
얘네들이 트랜잭션을 가져다 굉장히
acid 갖다가 얘네들은 acid 프로퍼티를 이렇게 하지 않는다. 
그러면 acid 프로퍼티를 가져다 만족시키지 않으면 얘네들은 트랜잭션을 가져다 어떤식으로 처리를 하는가에 대해 살펴본다. 

사실은요 여러분 이벤츄얼 컨시스턴시라는 얘기를 그 그저꼐 였나요 그 비트코인 할떄 그런 강제로 끌려오셨잔아요 그때 사람이 얘끼했다 이벤츄얼 컨시스턴시를 

그사람도 이벤츄얼 컨시스턴시를 얘기했을떄는 그게 클라우드 모델이다. 클라우드 모델인데 그 트랜잭션을 보장해주기위해서 이제 이벤츄얼 컨시스턴시를 쓴다. 라고 한국말로 얘기했는데 기억은 안나는데 이벤츄얼 컨시스턴시란 말을했다.

트랜잭션은 다못할거고
요번시간에는 데이터 ?? 갖다가 어떻게 클러스터에다가 nosql 데이터베이스가 뿌리는지 살펴본다.
데이터 디스트리비우션이다.

## Data distribution
자 말씀드렸다. nosql 데이터베이스 경우는 클러스터를 애시당초 목적으로 만들어진 목적이기떄문에 그 라지 클러스터에 데이터를 갖다가 쪼개는 그런형태, 그런 구조 장점
그리고 얘네들이 에그리게이트 베이스라고 했다. 
에그리게이트 오리엔트 베이스가 여기 보면 데이터 디스트리비우션을 시켰다. 이렇게 나와있는데
이게 왜냐면 말씀드렸죠 관련되어있는 그 데이터들의 어떤 묶음 자체를 에그리게이트 라고 했따. 그리고 그 데이터들을 단위로 해서 우리가 데이터를 가져다 뿌린다. 그렇기떄문에 클러스터에 뿌릴때 rdbms에 그런 트랜잭션은 어떤놈을 어떻게 뿌릴까 그런 부분이 사실은 굉장히 단순해진다. 
왜냐하면 연관되어있는 데이터들끼리 묶어서 얘네들만 뿌리면 되는거야? 그렇기떄문에 어떻게 데이터를 나누고 어떻게 스키마를 나누고 그데이터 바운데리 정하는거에 대해서 사실 굉장히 심플해진다. 그래서 얘네들이 굉장히 좋은것이다. 얘네들 nosql 데이터베이스 같은경우는 데이터 그 ?? 뿌리는 놈들이 두가지다.

이거보면 
샬딩 : 이라는얘기는 말씀드렸죠 샬딩이란 레플리케이션이란 말이나온다.
db 시간에 샬딩이란 말을 들으셨죠?
sharding : 샬드가 뭐냐? 자 단어시험
shard는 쉽게 말하면 꽃병들을 꺠드렸을때 조각들 
깨진 파편들 하나하나를 샬드라고 한다. 이 말이 샬딩인데 샬딩인데 똑같은 말이다. 데이터를 가져다 각각 다른 데이터잔아 만약에 유리컵을 꺠뜨리면 각각 조각자체는 오버랩이 안된다. 걔네들을 합쳤을때 하나의 유리그릇이 되는거지 컵이되는거지 각각 자체가 오버랩되지 않는다. 그래서 얘네들이 샬딩이란말을 쓰는것이다. 샬딩이라는 말은 구글이 쓴다. 빅테이블 이라는 논문을 발표하면서 처음 쓰는단어다. 그이후부터 샬딩이란 말을 굉장히 많이 썻다. 그러면 용어인데 
그렇다 보니까 자 중복이 안된다. 그 각각 조각이니까 그래서 서버는 걔네는 어떤 subset of data죠 왜냐하면 그게 샬더 이니다.
서브셋 오브 데이터, 잘라놓은 각각의 그 중복되지 않는 그 데이터 그거를 샬드 라고 하고 여기는 subset of data 라고하는데 얘네들의 싱글소스이다. 왜냐하면 중복되지 않잔아요 중복되지 않은 데이터를 가져다 각각 쪼개서 클러스터 쫙 뿌려넣는다. 이게 샬딩이다. 그리고 두번째로는 

replication : 이거는 뭐 여러분들 그냥 이해가 갈것이다. 말그대로 replicate 하다. replicate 만들어서 뿌리는것이다. 카피본 을 똑같은 카피본을 가져다 여러개 만들어서 던지는것이다. 클러스터에 그게 이제 replication이다. 그래서 여기보면 자 데이터를 카피하고 멀티플 서버에 카피를 하는것이다.
그래서 보시면은 각각 그런 데이터를 갖다가 여러군데서 보여집니다. 왜냐하면 replicar을 갖다가 그런 카피버전을 갖다가 여러개 만들어서 클러스터에 던져놓기떄문에 똑같은 데이터가 이 클러스터에서도 돌고 저 클러스터에서도 돌수도 있고 
여러군데서 보입니다. 물론 그냥 replication 팩터 ??  가 뭐냐에 따라서 달라지긴 하겠습니다만은
그런 중복 된데이터를 뿌려놓는게 replication이다.
자 각각 하나씩 알아보자 샬딩이다.
샬딩이라는건 흔히들 파티셔닝이라고도 합니다. 

## sharding (a.k.a partitioning)
오버랩핑 이 되지 않는다.
그런 데이터 아님
흔히들 파티셔닝 이라고도 한다.
보면은 얘네들 
데이터를 가져다 이렇게 중복되지 않게 샬딩으로 나눠서 이런 각 파티셔닝을 해가지고 데이터를 가져다 클러스터에 뿌리면 그짓을 왜할꺼같냐? 그거 왜할거같냐? 결과적으로는 데이터의 scalablility 떄문에 그런것이다. 왜냐하면 한 머신에다가 여러개 그많은 빅데이터를 갖다가 저장을 못한다. 
그렇기 떄문에 그 큰 데이터를 갖다가 쪼개가지고 그냥 샬딩형태로 쫙 뿌리는것이다. 
그렇다 보니까 이제 얘네들이 궁극적으로 뭘 얻냐면 궁극적으로는 scalability 를 갖다 높이기는 하지만 그렇게 했더니 얘네들이 쓰루풋과 퍼포먼스가 좋아집니다.
그렇죠 
쓰루풋이 어 좋아지고, 뒷부분에 나온다.
그리고 이제 여기보시면은 simply define as -> 파티셔닝이라고 하는데 얘네들은 shard nothing 구조라고한다. 전혀 share하는게 없기떄문에 sharded nothing 파니셔닝 이라고도 한다. 실제 여러분들 쉐어드 낫띵이란 말을 많이 들어봤을것이다.
쉐어드 낫띵. 
쉐어드 낫띵 구조다. 그리고 어 보시다 싶이 각각 데이터가 다르면 그 서버 각각 다른 데이터에다가 어사인된다. 그래야한다. 
그래야지파티셔닝이죠 
그러다 보니까 스케일빌리티를 높이게 됬는데 스케일빌리티가 어떤 스케일빌리티, 스케일 아웃형태로 horizontal scalability 이다. 
vertical 이 아니다.
당연히 쪼개서 클러스터에 그냥 균일하게 뿌려버리기 때문에 물론 균일은 아니지만 그런식으로 뿌려버리기 때문에 
스케일빌리티가 어 horizontal 하게 증가하게 됬고 그리고 자 스케일빌리티 자체도 그렇다 보니까 거의 리네어하게 증가를 하게 된다. 그노드 를 가져다 많이 집어넣어가지고 파니셔닝 각각 해가지고 뿌리면 되기 때문에 그리고 그 뿌림에 따라서 그 성능자체도 거의 리네어하게 증가한다. 왜그러는지 있다가 설명을 한다.
그렇다 보니까 구조가 이런식이다 보니까 가장 
ideal case 란 게 뭐냐면, 어떤 많은 유저들이 있는데 자 이 a라는 유저는 1라는 데이터를 엑세스 하고 b라는 유저는 2라는 데이터를 엑세스하고 c라는 유저는 3이라느 데이터를 엑세스하고 이렇게 엑세스 해주면 best 와 앰팻?? 이다. 왜냐하면 오버랩핑 되지 않는다. 그렇죠 그렇기 때문에 한 머신이 멀티플 구조를 가져다 서빙을 해야될 그런 어 그런 경우가 사라진다. 이게 그얘기다 . 아디얼 한 케이스가 각각 다른 모든 유저가요 각각 다른 클러스터 에 있는 노드들을 가져다 각각을 엑세스 하는 케이스이다. 
그렇게 되면은 그 당연히 퍼포먼스 뿐만아니라 스루풋도 당연히 높아지게 된다. 왜냐하면 클러스터가 많아질수록 당연히 그렇죠 리네어 하게 증가할거에요 
두대면은 두배가 나올것이고 세대면 3배가 나올것이고 4배면 4개가 나올것이다. 그럴수밖에 없다. 산술적으로 
이게 아이디얼한 케이스이고 그래서 장점이 뭐냐 말씀드렸다
장점 : 퍼포먼스가 좋다 퍼포먼스가 좋아질수밖에없다. 리드나 롸이트 경우도 어 그런 퍼포먼스가 마찬가지고 그 실질적으로 사실은요 이 있으니까 그대로 쓴거긴 한대 이 얘네들같은 경우는 퍼포먼스는 라잇을 조금더 치중되어 있다고 보시면된다. 리드보다는 리드 퍼포먼스는 잇다가 말씀드릴 레플리케이션이다. 
레플리케이션이 리드 퍼포먼스를 높이기 위함이다.
사실은요 아시겟죠 얘네들은 리드도 리드지만 리드보다는 사실은 write 퍼포먼스를 높이는게 조금더 목적이있다. 실질적으로 write 퍼포먼스가 더 좋다.
그리고 이제 값이 싸다. 값이 싸다 왜 그런 각각 데이터를 중복되지 않게 여러 클러스터로 뿌릴때 클러스터가 비싼 굉장히 멀티 cpu 그런 비싼 서버일 필요가 없다. 왜냐하면 로드가 확 줄잔아요 굉장히 큰 데이터가 하나의 그냥 스케일 업 되어있는 서버에 막 집어넣는것보다 잘게 잘게 샬딩 해가지고 잘게 잘게 뿌려놓으면 이걸 가지고 서비스 하기 위해선 얘네들은 그 비싼 그런 멀티 cpu 서버를 쓸필요가 없는것이다. 그래서 비싼 한놈보다는 그냥 싼놈 여러개를 꼽아가지고 쓰는게 더 맞는 구조다 그래서 가격이 싸진다. 
근데 이 싸다라는게 항상 좋으냐? 아니다.

비싼거 
사실 만다. 싼거 많은때도 많은데
이럴 때나온다 클러스터가 이게 싼 통상적으로 그렇게 조금은 
low cost commodity 서버를 쓰게되는데 그러다 보니까 ??? 퀄리티가 떨어진다.
어떤 이제 그 머신이나 이렇게 고장이나면 그 리절리언시가 떨어진다. 거죠 리절리언시 가 뭐에요
resilience 라는건 어떤 데이터가 db에서 어떤 시스템이 바꼈든지 아니면 뭔가 페일이 일어났을떄 그게 다시 원상태로 복귀될 수있냐는 소리이다. 실질적으로 여러분들 그 resilent라는 단어 뜻 자체가 그런뜻이다. 그렇죠 그러다 보니까 얘들은 당연히 높을 수가 없다. 인플렌시 가 낮을수밖에?? 없다. 
그러고 이게 샬딩 뭐 그림이 이렇게 나와있는데 그림을 자세히 보면 샬딩이라는 개념이 조금더 명확하다. 실질적으로 여러분들이 유저라는 테이블 이렇게 있다고 가정했을때 킴,리,박,맘 이렇게 나왔을떄 보시면 알겟지만 각ㄱ각 다른 노드에다가 중복되지않게 여기보면은 뭐 킴하고 리는 여기는 묶어놓고 그다음에 박이랑 맘은 이렇게 나눠놨는데 중복되지 않게 각각 데이터를 샬딩, 그래서 샬딩 이라는게 뭐였죠 나눠가지고 각각 그 클러스터에 뿌려주는 그런 형태가 된다. 그래서 얘네들이 어떻게 해서 퍼퍼몬스를 높이느냐?
퍼포먼스를 높이는 이 1,2,3 나오는데 사실은 이거 조금 은 굉장히 앱슬릿한(abstracr한) 내용이다. 틀린말은 아니다.
여러분듣다보면 당연하거 아니야 라고 이러고 싶으실수있겠다.

## Improving performance
얘네들이 실질적으로 샬딩같은 경우는 레플리케이션에서 조금 다르다. 중복되지 않는다라는게 쟤네들의 핵심이다. 오버랩되지 않는다 이건데 그러다 보니까 얘네들이 write 퍼포먼스가 좋을수밖에 없다. 중복된 데이터는 안쓰거든요 근데 read 퍼포먼스는 떨어질수밖에 없다. 근데 그런 문제를 가져다 얘네들이 해결할 수있는 방법이 이제 어 데이터를가져다 어떤 로켈러티를 따지는것이다.
첫번째가 데이터 로켈러티다. 
사실은 그걸가져다 제가 저렇게 풀어놨을 뿐인건데 데이터 로켈러티인데 결과적으로 그 데이터를 갖다가 많이 쓰는놈들이 있을거같은 그위치에다가 그 샤드를 주는것이다. 예를들어가지고 샌프란시스코에 있는 뭐 그런 중요한 데이터가 있으면 그 데이터를 가져다가 왜 뉴욕에다 두겠냐? 이스트 코스트에 둘 필요가 없는것이다. 당연히 웨스트 코트 데이터 센터가 두 샬딩을 던져놓는것이 맞는것이다.
왜냐하면 거기서 엑세스될 확률이 훨씬더 높다. 그런얘기다. 
그리고 자 로드 를 가져다 뭐 밸런스있게 로드를 얘네 로드 밸런싱 로드 밸런싱은요 클러스터에 서 항상 중요하다 사실은요 클러스터 에 맨날 나오는얘기가 로드밸런싱이다. 한놈만 줘패면은 힘들잔아 요 성능이 안나온다. 실제 그렇다. 그래서 그 로드 밸런싱을 가져다 어떻게 나눌것이냐 또 같은 문제다. 이거는 근데 그 로드 밸런싱 문제는요 샬딩 뿐만아니라 레플리케이션도 똑강다, 근데 상대적으로 레플리케이션은 거기에 조금은 더 자유로운게 어떤 중요한 그 런 핫데이터가 있더라도 치더라도 이거에 대한 레플리케이션 갖다가 똑같은 카피본은 만들어가지고 똑같이 던져놓는다. 그러니까 설사 그렇다손치더라더 이 데이터가 아무리 핫한 데이터라 치더라도 몇군대 나눠져있기때문에 분산되는 효과 는 있다. 그런데 자동적으로 분산되는 효과는잇긴하지만 샬딩은 그런기능이없다. 그렇기 떄문에 사실은 얘네들이 로드를 가져다 이븐리 하게 나눌수있는 그게 사실은 조금더 중요한 팩트가 되버리는것이다. 클러스터에서는 모든 클러스터에서는 이 팩트가 중요하긴 합니다만ㅇ
그리고 이제 이거는 뭐 에그리게이트 얘기하면서 많이 했던얘기이다. 비슷한 종류의 에그리게이들 동시에 이게 시퀀셜하게 엑세스 된다던가 ?? 엑세스 된다라던가 그렇게 하고 연관이있는 데이터들을 가져다 똑같은 순서대로 아니면은 	 그런 노드에다가 같은 노드에다가 같이 뿌려놓는게 훨씬더 쉽다. 따로 ??? 왔다갔다 할피요가없으니까 

자 그리고 이제 사실상 보면 많은 그 NOSQL 데이터 베이스는 샬딩을 갖다가 autosharding을 제공을한다. 여러분들 구지 admin ??? 고민하지 않더라도 얘네들이 auto sharding을 많이들 제공을한다. 그래서 데이터베이스 자체가 어떤 ??하지 않더라도 그것은 샬딩 데이터베이스 자체가 어 책임을 지는 경우가 많다.

자 

## Replication
이거랑은 사실은 다른 어플래치?? 이다.
어 어플리케이션이데 또는 이제 미러링 이라고도 한다
여러분들 많이 들어봤을것이다. 자 이거는 훨씬더 심플하다 그냥 똑같은 카피를 가져다 카피본을 가져다 여러다 멀티플 로케이션 에다가 뿌려주는것이다.자 그렇게 하다보니까 리던던시  그리고 어밸리빌리티가 높아진다. 왜 자 한놈이 죽어도 다른놈이 살아있다 . 그런확률이 높기때문에 어 availability 가 높아진다. 그리고 여기 나오죠 redundacny
capacity 가 높아진다 엄밀히 얘기하면 이거 커페시티 라기보다는 read performance라는게 맞는거 같은데 자 리드 퍼포먼스가 좋아집니다. 왜좋아지냐? 여러분 
아니거든요 a라는 데이터를 읽을떄 샬딩 해서 뿌려놓으면 예를들어서 여러 분이 이거를 갖다가 a라는 데이터를 엑세스 하면 밸리유스 자체를 n분으로 나눠?? 잔아요 근데 레플리케이션 같은경우는 만약에 a라는 데이터를 가져다 10곳에 던져놨다고 생각해봐요 그러면 각각 사람들이 10군데를 각각 엑세스 하게 되면은 그 퍼포먼스가 자체가 10배가 나온다 산술적으로 그렇기때문에 얘네들이 기본적으로 read성능이 좋다. 그리고 레플리케이션 이라는 거 여러분 그 하둡할때 이미 설명드렸다. 그떄 하둡은 디폴트로 레플레케이션 팩터 3을 쓴다고 말씀드렸다. 보통 그게 재밌는게 이거는 3이라는게 괜한걸로 나오는거 아니다. 수학이라는 통계치를 거쳐서 나오기 되는데 ㄴ통상적으로 그런 레플리카 같은 경우는 통상적으로 3개를 많이 카피한다. 던져두고 거기에 필요한대로 필요한만큼 더이제 하는거지만 학기?템 에 더 레플리케이션을 하는거지만 

통상적으로 디폴트로 3이 제일 많이 쓰이긴 합니다
자 그러면 레플리케이션 할때 어떤식으로 많이 하느냐 두가지 어프로치가 있는데 자 master-slave 형태가 있고 레플리케이션할때 peer to pert 형태가 있다.
자 말그대로 마스터가잇고 슬레이브 가 있고 각각 이제 그런 master가 없는 본인들이 master이자 slave인 그런 peer to peer 형태로 어 레픞리케이션을 구현을 한다. 제일 먼저 마스터형태의 슬레이브를 바라보면요 
자 쟤를 어떤 띠? 를 갖고있는 그런 쉽게 얘기할수있는 왕 이라고 얘기할수있는 마스터가 존재를 합니다. 그건 데이터 소스 
어떤? 티브한 소스인 마스터가 존재한다 그리고 얘네들이 실제 데이터를 가져다 레플리케이션 하고 데이터를 업데이트하고 그런거에 대한 책임을 얘네가 진다. 단, 여러분들이 여기서 주의할것은 쓰는것이다. 업데이트는 write이다. 업데이트는 read가 아니다. 업데이트는 같은 데이터를 가져다 똑같은 걸 쓰다보니까 업데이트일 뿐인거지 같은 데이터에 
얘네들은 마스터는 기본적으로 쓰는것에 책임을 많이 갖고있고 통상적으로 슬레이브 경우는 대부분다 read를 read에 대한 책임을 많이 지고 있다. 그래서 
이게 왜냐하면 레플리케이션을 하기위한 그런 하나의 , 두개 어프로치 중에 하나이다. 그 레플리케이션을 그 레플리카를 카피해서 누가 던져주느냐를 얘기를 하는것이다. 그러다 보니까 당연히 이 마스터가 어 데이터를 가져다 쓰는거에 대한 역할을한다. 주로요 
만약에 마스터가 죽어버리면 , 지가 한놈인데 죽어버리면 그럴경우는 네트워크 시간에 배웠겠죠 마스터가 죽어버릴때 다시 재선출하는거에요 물론 오토매틱하게 지네들끼리 내부 그 메시지 던져가면서 자동적으로 할수도있고 아니면은 admin 이 직접을 개입을 해가지고 니가해 얘기를 해줄수있도 있다. 메뉴얼 얼링하게 어프로치할수도있다.

슬레이브는 같은 경우는 보면 마스터 실제 마스터가 레플리케이션을 쭉쭉 카피해서 던져주면 슬레이브는 마스터와 당연히 다 싱크를 해야한다. 싱크 과정을 거쳐야 한다. 싱크를 하게 되고 만약에 마스터가 갑자기 죽어버렸다. 죽어버리게 되는경우는 지네들끼리 굉장히빨리 어 이  슬레이브 놈들중에 어떤 누군가가 다시 잽싸게 마스터가 되어야한다. 마스터 슬레이브 경향에서 어떤 구조든 간에 마스터 슬레이브 구성에서는 마스터가 죽어버리면 골때린다. 그래서 슬레이브가 죽고나면은 통상적으로 그 마스터를 다시 선출하는 알고리즘은 굉장히 심플하고 굉장히 빠르다. 얘네들도 마찬가지다. 누군가가 죽으면 굉장히 빨리 마스터 를 다시 선출을 해서 다시금 시작하게 된다. 그내용은 

## Master-Slave Replication
여기보시면 클라이언트가 있다. 클라이언트가 데이터를 가져다 여러분들이 넣는다. 데이터를 넣으면 어디넣는지 보세요 얘가 슬레이브에 넣지 않는다. 그림보면 심심해서 넣놓는게 아니다. 그림을 잘보시기 바랍니다. 
클라이언트들이 데이터를 쓸때 마스터 에 쓴다. 그러면 마스터가 그데이터를 받아가지고 자기에 팔러씨에 따라가지고 3카피면 3카피 4카피면 4카피 
필요한 팔러씨에 따라가지고 마스터가 다시 던져줌 
마스터가 써주는것이다. 그래서 마스터가 writing을 갖다가 업데이트라고 써져있지만 write 기능을 가져다 얘가 거의 대부분 통상적으로 담당하게 된다. 데이터를 읽을때는 여러분들 생각해봐라 마스터를 거칠필요가없다. 이미 레플리카가 각각 노드 별로 있는 거, 이게 필요하면 걔네들ㅇ ㅣ물론 실질적으로 보시면 그 읽을때는 각각 슬레이브 각각 가서 읽어온다 라고 나와있는데 실제 데이터흐름자체가 그렇긴 한데 그 프로세스 자체는 하둡 그 빼고 말씀드렸다 싶이 얘가 클라이언트 1이 
슬레이브, 슬레이브 1에 데이터 있는지 어떻게알아? 몰라요 
그렇김떄문에 통상적으로 읽을때는 마스터한테 먼저가서 야데이터가 어딧니 라고 그러면 그 마스터가 얘한테 메타 데이터를 넘겨준다. 어떤 위치에 어떤 ip에 있어 알려주면 그 데이터를 가지고서 곧바로 엑세스 하게 된다. 그 과정이 빠져있다. 어쩃든지 간에 그 클라이언트 입장에서는 리드는 곧바로 슬레이브 한테 가서 읽어 오게 되고 쓸대는 이 마스터 한테 던져주고 마스터가 그 레플리케이션을 책임임지는 그런형태로 얘네들은 작동을 하게 된다. 
이런 관점에서 장점이 뭐고 단점이 뭔지 살짝 살펴보면은

## Pros and coss
말씀드렸죠 리드성능이 좋다고 그래서 실질적으로
레플리케이션 같은경우는 어 느릴때 쓰는 데이터 ???
굉장히 좋다. 
자 하둡에서 레플리케이션을 합니다 왜 하둡에서도 딴짓을 할수있을텐데 하둡은 똑같이 레플리케이션을 하거든요 레플리카를 가져다 3개를 유지하거든요 그 이유가 이 유도 있다?? 하둡의 데이터는요 거의 대부분이 read only 인 경우가 굉장히 많다 그거를 가져다 하둡데이터는요 여러분들이 도중에 받고있는 경우는 거의 없다 그리고 그런ㄱ데이터면은 하둡을 쓰면안된다 그런데이터는 스파크를 쓴다. 그래서 스파크가 나온다 하둡 의 리미테이션이 명확하게 존재하기때문에 
어쩃든지 간에 이런 연유로 리드의 성능이 개네들이 굉장히 중요하기 떄문에 하둡도 똑같이 레플리케이션이라는 그런 시스템을 쓰게 되고 걔네들도 걔네들 딱 이거쓰죠 마스터가 있고 슬레이브 가 있다. 데이터 노드가 있고 그런 구조로 돌아가잔아 하둡이랑 똑같은 요 구조로 돌아간다. 
그러다 보면 리드 리퀘스트가 만약에 더필요하다 그러면 간단하다 슬레이브 를 뒤지면된다. 그리고 레플리케이션을 더 늘리면된다.??
굉장히 심플하다. 

그리고 만약에 마스터가 죽으면 이 슬레이브가 뭐 그쵸 그 걔네들 슬레이브중 한명이 그 마스터가 되가지고 다시 그냥 프로세스를 시작하면된다. 

자 그리고 요얘기는 그런거 보다도 어 요얘기 자체는 슬레이브 와 마스터가 죽어버렸다 그러면 그렇다 치더라도 슬레이브가 read는 슬레이브가 담당한다고 그랬잔아 통상적으로 raed 자체는 슬레이브 자체가 해줄수있다 라는 말이다. 근데 자 단점이 나오는데 마스터 슬레이브는 
단점은 굉장히 명확하다 항상 똑같다 어떤 시스템이던지 
여러분 그냥 마스터 슬레이브 나올때 단점이 뭐냐 라고 나오면 여러분 눈감고 얘기하면된다. 	마스터는 바틀렉이 될거야
라고 얘기하면 거의 대부분 90 다 맞는다. 
마스터 슬레이브는 항상 그게 단점이다
마스터가 바틀렉이 된다 지혼자서 다하잔아 지혼자서 
그렇잔아요 하둡도 그렇다 하둡도 이게 프라이머리 노드가 그 네임노드가 죽어버리면 골때린다. 실질적으로 그 하둡 2.0 나오기전까지는 마스터가 죽어버리면 답이 없다.
2.0 되면서부터 세컨더리 네임노드가 나오지 그래서 프라이머리 같은 경우는 세컨더리가 잽싸게 이어받아서 자기가 프라이머리 역할읋한다. 그런식이 되는거에요 그얘기 인즉슨, 마스터가 바틀렉이 될 확률ㅇ ㅣ 높다라는것이다.

실질적으로 보시면은 자 뭐 업데이트 라든지 그런뭐든것들 실제 이 요얘기는 그냥 실제 레플리카 를 쓰고 업데이트하고 모든것 자체가 얘네가 다 책임지고 있다. 그렇기 때문에바틀렉이 된다라는것이고 그 결과로 죽어버리면 골때려진다. 라는 얘기가 요 얘기가 됩니다.

그리고 어 inconsistency 문제 가 있다. 그 레플리카 잔아 레플리카 인데 이거 여러분들 비트코인할떄도 그대로 나왔다 여러분들 이해가시죠 비트코인 그거 
강의할떄도 나온다 네트워크를 통해서
클러스터는 기본적으로 네트워크 그 커넥션을 기본적으로 한다. 그러니까 클러스터죠 그런데 여러분들이 write 를 갖다가 딱 떄린다고 했을때 알아서 그냥 그순간 실시간으로 데이터가 파파팍 써지면 얼마나 좋겠냐만은 그런 경우는 절대로 일어나지 않는다. 그래서 비트코인할때 여러분들 그쵸 
데이터를 갖다가 모든 정보를 저장했는데 이벤츄얼리, 하게 컨시스턴시하게 된다고 그순간은 맞지 않지만 이벤츄얼리하게 컨시스턴시 한다고 데이터를 클러스터에 뿌려버리면 어떤놈은 빠르게 써지고 어떤놈은 느리게 써진다. 그 레이턴시에 따라가지고 그런 문제점이 사실 생긴다. 그런 문제는 단순히 여기서 끝나는게아니라 나중에 그 트랜잭션관련해주는 그런 문제까지 그대로 이어 ?
데이터 컨시스턴시까지 그대로 연결이 되는문제다 그쵸

내가 처음에 데이터를 가져다 던졌는데 데이터를 썻는데 a라는 노드에서는 a를 갖다가 a라고 뒀는데 b라는 노드에서는 읽을때는 아직 그 a라는 데이터가 b에 도달을 안했어 그러면 얘는 읽었을때 그데이터가 그데이터인게 아닌거에요 
원래는 그게 업데이트 되야 되는데도 불구하고 레이턴시 차이로 인해서 그런 데이터가 인컨시스턴 문제가 생긴다. 
이게 그 얘기이다, 그런단점이 생긴다. 

자 그리고 여기 나오죠 어 write traffic 굉장히 write 인텐시브한 모델에는 그닥 맞지 않는다. 왜 
write 인텐시브 모델은 안맞는다 샬딩은 맞는데 얘는 왜 안맞을까 뭐 프라이머리 얘가 독박쓰니까? 라고 생각하셔도 되지만 그런 문제보다는 더큰문제는 그게 아니라 
카피 버전이잔아요 한번만 써도 될걸 얘네들은 레플리케이션이 3개면 3번을 쓰잔아 그러면 쉽게 얘기하면 write throw put이 1/3 인거다. 아시겟죠 그래서 얘네들이 write 성능이 떨어진다. 이게 그얘기다. write traffic에는 맞지가 않는다.
굉장히 ??
리플레케이션 팩터가 높아지면 높아질수록 그 read 성능은 높아지지만 write 성능은 그게 반해서 그대로 read에 그대로 떨어진다? 그래서 그 모델에는 그닥 좋지는 않다. 요거랑 반대로 

## Peer - to - Peer Replication
요거랑 반대로 peer to peer 가 있다.
요런 문제점을 peer to peer는 어느정도 해결을 합니다.
물론 peer to peer 도 장단점 있긴 합니다만 
이 모델같은 경우는 여러분들이 직관적으로 
모 대장이란게없다. 니가 대장이고 내가 대장이고 에브리바디 대장이다.
특별히 그런게 없다. 
그래서 보시면 각각 걔네들이 똑같은 weight을 가지고요 
그리고 얘네들이 각각 다 아까전에는 그 write은 네임노드가 
그 대장인 노드가 독박쓰고 read는 클라이언트들이 각각 슬레이브 놈쪽에 직접적으로 access했잔아요 그런식으로 어느정도 나누져있는모델이었으면은 이 peer to peer 는 그런게 없다. 니가 write도 담당하고 니가 read도 담당하고 어느 노드이든지 다 썻던지 읽던지 상관없다 왜냐하면 그 노드 자체로서 어 
그 마스터 슬레이브 역할을 다하기 때문이다.
그래서 이 얘기가 그얘기다.
모든 그 엑세스의 write 은 얘네들이 다 맡게 된다.
그리고 어 자 클라이언트
클라이언트가 어떤 노드로부터 읽고쓰고 다 그게 그얘기이다.
어떤 클라이언트가 일고쓰고 어떤 노드들로부터 그런거 다 할수있따. 얘네들은 단순한 모델인데 얘네들의 장단점을 살펴보면요 
조금은 직관적이다. 아까전에 우리가 봤떤 그런 문제점은 얘네들은 어느정도 해결을 하고 있는 반면에 사실 또 반대의 개념도 생긴다 ??

## Pros  and cons
자 어떤 노드가요 
fail 
아까처럼 프라이메리 노드가 fail 하다는 것처럼 얘네들도 당연히 노드가 fail 할수도 있다. fail 된다 해도 큰 문제가 없습니다. 왜냐하면 지냬들끼리 알아서 다 작동을 한다. 지녜들이 그냥 마스털해먹고 슬레이브 노드 다해먹는다. 그래서 ???
그리고 예를들어서 내가 퍼포먼스를 높히고 싶어.
그러면은 이것역시도 간단하다. 노드가 지금도 ???
그렇게 될거같으면 당연히 컨커런트하게 엑세스할 수있는 그런 노드의 개수가 많아지게 떄문에 당연히 성능이 퍼포먼스가 좋아지게 됩니다. 굉장히 간단하다. 근데 자 여기서 그 문제가 나온다. 인컨시스턴시가 여기서 나온다

##### cons
아까전에 마스터가 있으면 걔가 알아서 어쩃든지 간에 뭐 바틀렉이 되든 말든 걔가 알아서 관리를 해주는거니까 이런 문제에 대해서 어느정도 조금은 더 나은걸 보여주는데 얘네같은 경우는 어 이 컨시스턴시 문제가 극악이다. 왜냐하면 말씀드렸다 싶이 각각이 알아서 하기떄문에 이게 데이터를 갖다가 이렇게 되면 프로퍼게이션같은거 이제 어떤 카페 가 있어 어떤 카페가 있을때 그 데이터가 업데이트 가 되거나 바꼈을때 이것을 다시 전체 노드에다가 다 알려주고 다시 다 프로퍼게잇 해줘야 되는거거든요 그쵸???
그렇기 떄문에 사실 여기서는 얘네들은 네트워크 프로퍼게이션 이 굉장히 큰 문제가 된다. 
근데 자 이떄 요 얘기는 
relatively transient라고 나오는데 
요고는 그래도 어 자 인컨시스턴스 리드가 그얘기이다. 
인컨시스턴시 를 갖다가 크게 이제 두가지로 나눠서 써놨는데
read 적인 측면에서 바라보는거랑 write 측면에서 바라보는문제다. read적인 측면에서 바라봤을때 read inconsistent read라는게 말씀드렸다싶이 이거다. 누군가가 하나 업데이트 되면은 그거를 가져다 이렇게 단놈한테다가 뿌려줘야한다. 기존에 있던 데이터를 가져다 
왜냐하면 레플리케이션이니까 기존에 있던 카피에다가 얘네들이 빨리 업데이트해가지고 그거를 해줘야하는데 그 데이터가 프로퍼게잇 되기 이전에 다른놈이 와가지고 그 올드 데이터를 읽어버리면 허당이다.
이때 이 제 인컨시스턴시가 read 측면에서 인컨시스턴시가 생기는것이다.
근데 요거는 이제 밑에 얘기가 되있는겁니다 그래도 이거는 조금은 덜하다 라는것임  왜냐하면 그냥 내버려 두면 시간이 걸릴뿐인거지 알아서 어쩃거나 한바퀴 돌고 두바퀴 돌고 지가 알아서 막 그거 프로퍼게잇 되가지고 결과적으로 다 싱크를 맞춘다. 그래서 이런 read 에 관련된 인컨시스턴시 문제는 조금 이 임플런트 한 문제는 아니다
인제 사실은 그것보다 더 골떄리는 문제가 뭐냐면 인컨시스턴스 write이다.

각각 다른 유저가 각각 다른 노드에서 똑같은 데이트에서 똑같은 시간에서 팍 써버리게 되면 그게 문제다. 그런 문제가 생겼을때 왜냐하면 지가 갖고있는 한 노드의 수는 자기는 이 데이터가 업데이트 되기때문에 그것 갖다가 싱크를 하기위해서 뿌린단 말이야 
근데 다른 노드에 있는 노드도 지도 이게 자 같은 시기에 같은 다 써졌잔아 그럼 얘도 자기가 그렇게 업데이트 됬으니까 자기가 마스터 잔아 그렇죠 
근데 똑같이 싱크를 시킨다. 그러면 서로 싱크를 시키고 앉아 있는것이다.
그런 문제, 데드라인? 문제가 생긴다.
사실은 이 인컨시스턴시 문제는 그 리드보다는 사실은 write에 훨씬더 어 그런문제점이 생긴다. 물론 이거를 해결할 방법이 없느냐 물론 그러면 사실 뭐 시스템 다 망해겠죠 뒤에 가면 벡터나 그런것을 써까지고 어 해결하는 방법은 있다. 뒷부분에 왔을때 설명한다
어쨋든지 간에 인컨시스턴시 , 피어 투 피어에서는 인컨시스턴시 문제가 굉장히 큰 문제가 된다 라는걸 알아두시면된다.

자 키포인트 이렇게 나오는데 
키 포인트는 별거아니고 제가 앞부분 내용을 여러분들 복습차 넣어놓은것이다.
데이터를 갖다가 디스트리비우트 할때는 뭐 2가지가 있다. 샬빙과 레플리케이션이 있다.
샬빙은 데이터 가 중복되지 않고 그것을 갖다가 쭉쭉 뿌리는데 어떻게 하다보니까 얘네들은 성능이 write 성능이 더 좋다
그리고 레플리케이션 같은 경우는 write 성능은 떨어지지만 상대적으로 read 성능은 더 좋아진다. 레퍼플리케이션할때는 어 마스터 슬레이 모델이 있고 피어투 모델이있다. 각각 장단점이 있다. 라는걸 제가 설명해드렸다. 자 
## consistency 
이 얘기가 이벤츄얼 컨시스턴시 가 여기서 드디어 나온다. 
acid를 우리는 그런걸 지원하지 않아 라고 얘기를 했다.
너네들은 consistency를 보장하기 위해서 트랜잭션을 어떻게 처리할거니 라는 질문이 생긴다. 왜 
데이터베이스니까
그것도 이제 그 클러스터 위에서 자 이게 보시면
어 
자 컨시스턴시 모습이 이렇게 나와있다.
기존에 rdbms 그런 걔네들 모델에서 자 클러스터 기반의 모델에 최적화 되어있는 그런 nosql 데이터베이스 모델로 오면 가장  큰 체인지가 이런부분이다. consistency 문제가 가장 큰 변화이다. 
한마디로 얘기하면 기존에 있던 rdbms 같은 경우는 굉장히 강한 consistency를 제공한다. 그래서 acid라는 4개의 프로퍼티가 그런것이다. 그 4개를 만족하면 절대로 컨시스턴 인 컨시스턴시한 경우가 생길수가 없다. db시간에 배웠다 왜그런지에 대해서

근데 nosql 같은 경우는 그렇지 않다. 
이벤츄얼 컨시스턴시를 우리는 보장을 한다. 그리고 어 대신 rdbms 는 대신 스트롱한 컨시스턴시를 우리는 제공을 한다. 라고 나와있다. 그래서 이벤츄얼 컨시스턴시를 굉장히 잘 표현해냈다.
Everthing is going to be alright 
이게바로 이벤츄얼 컨시스턴시이다.
자 컨시스턴시 얘기가 나오는이유가 한마디로 얘기하면 데이트 컨플릭트 떄문인것이다. 그렇죠 데이터가 컴플릿트가 일어납니다. 
자 언제 데이터를 갖다가 데이터 컨플릿트 라는것은 리드랑은 상관이 없다. 리드는 데이터 컴플릭션을 일으키지 않는다. 그래서 read-read conflict는 존재하지 않는다. 
근데 오해하지 말자 책에 따라 있다라고 말하는 사람도 있따.
근데 개인적으로 리드 리드 컨플릿트 라고 생각하지 않지만 어 책에 따라서 설명하는곳도 있다.
그래서 예제도 넣어놧따

어쨋거나 통상적으로 기본적으로 ocnlfict는 write이 반드시 수반이 되어야 한다 wwrite이 수반이 되어야지 그게 read랑 관련이 되든 write과 관련이 되든 지 간에 컨플릿트가 일어납니다 그래서 read -write conflict라고 나오는데요 
자 로지컬 어떤 write 을 여러분들이 삽ㄴ디ㅏ.
삽니다.
write 하는 와중에 read 가 들어왔을때 일어나는 데이터 컨시스턴시 문제다.
자 이거는 몇가지 있을수있는데 여러분들 그 데이터 베이스 시간에 트랜잭션 배우면서 그런거 배웠을것이다. 시리얼라이즈 하면서 배웠을것이다. 이 트랜잭션 1이 있고 2가 있다고 가정을 해봐라 트랜잭션 1이 있을떄 어떤놈이 a라는 놈이 어느 한순간에 데이터를 딱 쓴다. a라는 데이터를 갖다가 아 ! b라고 업데이트한다.그러고 나서 얘는 아직 커밋을 하지 않는다.
뭔가 뚝딱뚝딱 얘도 트랜잭션을 열심히 작업하고 있다.
그 동안에 트랜잭션 2가 뭘하냐면 이 a라는 데이터를 읽는다. 그러면 트랜잭션 2 입장에서는 이 a라는 데이터는 여전히 a이다 왜 아직 커밋을 안햇거든요 커밋을 안함 
여전히 얘는 a이다. 그리고 나서 골떄리는게 얘는 
트랜잭션 2라는 놈은 a라는 데이터를 가지고 c라고 바꾼다. c로 바꿔서 지가 먼저 커밋한다. 자 그러고 나서 이 트랜잭션1은 a를 b로 바꿔놓고 지가 열심히 일을 다 했어 그리고 나서 트랜잭션을 집어넣으면 값이 어떻게되요? inconsistency가 일어난다.

이런 문제다. 이게 통상적으로 제일 흔한 raed-write conflict 이다.
어떤 놈이 쓰고있을때 커밋하기 이전에 먼저 다른 다른 놈이 (트랜잭션) 다른놈이 그 데이터를 읽어가지고 읽는걸로 끝나도 상관없어요 왜냐하면 여전히 문제다. a는 그 트랜잭션2입장에서 봤을때는 여전히 a이다. 왜냐하면 트랜잭션1이 커밋을 안했거든요 
그러면 원래는 그게 사실은 아닌거죠 그쵸 자 그런 관련된 그런 conflict , read-write conflict이다. 이 예제가 나올때 다시 설명을 드리겠다 .
write - write conflict는 되게 명확하다. 그쵸 이거 보시면 두 사람이 똑같은 데이터를 갖다가 똑같은 시간에 쓰는거다. 이런 경우가 write- write conflict다
근데 만약에 그 여러분들 트랜잭션을 배우면서 db시간에 나오죠 그렇죠 시리얼라이져 그렇죠 시리얼라이져빌리티 기억나시죠 
배우셨을텐데 그겁니다 만약에 서버가 그런식으로 당연히 모든 그런 트랜잭션이 결과적으로는 시리얼라이저블 해야합니다.
그렇죠 그시리얼라이저블 해야하는데 이걸을 가져다 이제 시리얼라이즈 시켜버리면 어떻게 되냐면 똑같은데이터를 다른놈이 똑같이 업데이트를 해버리면 결과적으로 한놈은 데이터를 사라지는거다. 
그렇죠 왜냐하면 시리얼라이저블 시켜버렸잔아

(디비서버는 중국 사람, 웹서버는 한국 사람으로 생각하면
내 생각을 다른 사람과 의사소통을 하기 위해선
서로 알아듣는 영어라는 언어가 필요하지요.
그 영어 부분이 직렬화일테고 각각의 언어는 씨나 자바나 여러가지가 될거에요, serialVersionUID 사용하는 이유는 type safely 을 위해서에요

예를들어 직렬화한 객체를 원격지에 전송을 했다고 했을경우에 
전송된 객체의 클래스와 원격지의 클래스와 동일한지 여부 체크를 해주는거에요.
serialVersionUID 다를경우 java.io.InvalidClassException 을 발생합니다.
(원격지에도 해당 클래스가 있어야지 객체를 사용할수있겠죠)

그러면 한 놈은 억울하게 된다. 그 한 데이터가 사실 사라져버립니다.
그게 write-write conflict이다.
자 그렇게 되어있고 
이제 read-write conflict가 나옵니다.

## Read-write conflict
보시면은 write 하는거는 어떻게 read를 가져다 읽을때 생기는 그런 문제점이다. 라고 써놨죠 보시면 알겠찌만
이 a라는 사람이 데이터를 읽는다. 두개의 테이블이 있는데요 첫번째 라인 아이템이고 두번째가 십핑 찰지 이라는 테이블 이있다. 
이 말틴이라는 사람이 라인 아이템에서 데이터를 업데이트 해요 그거 가지고 
아직이사람은 커밋하지 않았음 그와중에 이 프라모드란 사람이 데이터를 두개의 테이블의 데이터를 다 읽어온다.
그렇죠 다 읽어와서 지가 먼가 쿵짝쿵짝 하겠쬬 
근데 이제 여기와서 그 말틴이라는 사람이 이단게에서 와서 이데이터를 갖다가 다시 업데이트 해버리고 얘 데이터를 업데이트하면서 커밋을한다. 그렇게 될거같으면 얘가 읽었던 데이터는 뭐에요 사실 보세요 얘같은경우는 커밋을 해버리면 이순간 이미 이 데이터는 바껴져 있다. 이 프라모드란 사람이 요 두개의 write 과정하에서 일어났던 그 사이에 읽었던 데이터는 특히나 요 예제에서는 요 십필 찰지죠 이 데이터는 허당이다. 그렇죠 그 순간은 자기는 맞았지만 결과적으로 시람이 3번 저 요 순간에서 커밋을 해버리는순간 쟤도 잘못된 데이터를 읽어오는것이다.자이게 read-write conflict이다.
//프라모드란 사람이 읽어낸 값이 첫번째 마틴에 의해서 엉뚱한 값이 되버렸다 라는걸 으미하는듯?

자 요고는 제목은 read-write conflict라고 써놨는데 제가 그렇다고 생각하기때문에 써놓은것이고 자 
책에 다라서 read-read conflict도 존재한다 라고 말하는사람도있따. 그사람이 주장하는 예제를 그대로 가지고 온것이다. 지금 고민 안합니다만은 
이때 이사람이 그 consistency 의 원인이 뭐냐면 레퍼플리케이션 해둔다.그런데 뭐냐면 예를들어보자 이 프라모드란 사람이 그 예를들어서 스피디아 닷컴가서 호텔을 예약한다. 호텔예약하느데 그 호텔이 하나만 남았어 하나만남았는데 이름 듣자마다 인도사람이잔아 문바이 이 노드가 여기있어 문바이 이노드, 이서버를 통해가지고 마지막 하나남은 호텔을 짜잔하고 예약한다. 그러고나서 이제 했으니 그 데이터를 싱크시켜야한다. 얘는 호텔에서 이제 어벨러블 하지 안아요 그데이터를 가져다 싱크시켜야한다. 싱크를 시키는데 이때 시드란 사람이 보스턴에서 보고서 에이 다 나가버렸네 나는 못하겠다 여기까지는 문제가 없다
그런데 얘 말틴이란 사람은 데이터가 아직 여기까지 프로퍼게잇 되진 않은거다 싱크가 안된것이다. 얘는 싱크가 되가지고 그 데이터가 뭐 마지막 남은 호텔이 사라진게 얘는 보이는데 똑같은 데이터를 보고 똑같은 테이블 을 찾아보는데 이 말틴 이라는 사람은 아직까지 싱크가 되지 않으니까 얘는 아직까지 하나 남은거에요 
그러기 때문에 아저 남은 호텔을 내가 예약을 할려고하는거다. 이거는 왜 그 분이 read-read conflict라고 주장하냐면 보시다싶이 똑같은 데이터를 똑같이 보고있는데 서로 다른 데이터를 보게 되는거야 서로 상충된 데이터를 보게 되는거다 ㄱ
그렇죠 그래서 이걸 갖다가 read-read conflict다 라고 얘기하는 사람이 있긴하지만 그게 논리적으로 말이 안되는게 결과적으로는 궁극적으로는 그바탕에 뭐가 있냐면 어떤놈이 데이터를 썻기때문에 이 일이 벌어진다. 그래서 그런것이다. 단순히 이사람이 쓰지 않고 그냥 내가 호텔이 있는지 없는지 조회해봐야 된다. 그러면 저런 conflcit는 일어나지 않는다. 내가 조회를 하고 써버리잔아 내가 그걸 예약하면서 내껄로 써버리잔아 
write이 존재하고 write 이 프로퍼게잇 되는 그 래이턴시 에 따라서 생기는 그 차이 입니다. 그래서 이거를 가져다 어쨋거나 read-read라고도 얘기를 합니다만 read-write가 맞다고 생각한다 
자 어쩃거나 이런 문제가 있다. 이런 문제들이 있는데

## 솔루션


