---
post : layout
title : 데이터통신3
---

## 5번 문제 
1 M hz 밴드위스를 가지고 있는데 열개의 채널 (독립된)
1 M hz 인데 10개의 채널을 구성할려 하니까 100 k Hz 라고 하는 대역폭이 각 채널당 할당이 됨 그런데 이 채널에 10 Mbps 를 보낼려고 한다고 함
10 Mbps, qam 방식을 이용해서 이게 가능하도록 하고 싶은데 결국 r은 무엇이냐를 구하는것이다.
한 시그널 엘리먼트당 몇비트의 정보가 담겨야 하는가? 
10 Mbps임
100 khz에 10Mbps 맞음? 
1 Mbps 아닌가 
채널당 10Mbps라고 되어있음 (이전에 쓸때도 m이 M이라고 생각해야할것임)
여기서 5번문제임
10개의 독립된 채널을 만들려고 하는데 각각이 10Mbps다 qam 방식이다.
이게 지금 10M 면은 지금 여기 d=0 가정을 함
우리 지금 요런 류에서 쓰고 있는 (1+d)s 의 관계식을 쓰고 있는데 
이 관계식이 책에 이런류의 문제를 어디서 풀고있냐면 5장에 
이런 관계식이 이 책에 유도가 되지 않고 example로 활용하고 있음
이 관계식이 있음 
이관계식은 s= n/r 임 
시그널 엘리먼트당 몇비트 의 정보를 전달해 주는 식이라고 하면
qam이용해서 그렇다면 r로 나뉘는 값이 보어 레잇이 되겠음
d=0라고 하면 지금 이문제가 어떻게 되냐면 r을 구해라
d=0 라고 두면은 r=n/b 이 됨 100M가고 
밴드위쓰가 0.1 M(100k Hz)
10 Mbps 
r= 100 이면 레벨이 
qam이 시그널 하나가 100bit의 정보를 갖고 있어야 함
100 bit의 정보를 가지고 있어야함 qam이 성운도에 찍히는 점이 곧 r의 개수임
이게 r의 개수가 아니라 r의 100승개에 해당하는 점이 저기에 찍혀야함
16-qam 이라고 하면 
저기에 16개의 점이 있고 그것에 경우 한 시그널의 엘리먼트 4bit 
4bit 정보를 가지고 있음
지금 100 bit 정보를 가지고 있음 그러면 r의 100승개
어딘가에 있어야 하고 qam의 경우 2의 100승개 
r이 100이니까 2의 100승개의 점이 있어야함
여기에 2의 100승개의 점이고 
qam 이라는 것을 구현해야 하는데 100승이라는것은 점이 2의 100승이면 
이 문제가 현실적으로 이 문제가 잘못됨
1Mbps로 바꿔보면 10이됨
2의 10승정도 
1024정도 qam 퀀설레이션의 다이어그램에(성운그림)에 그릴수있음
이게 너무 스케일이 너무 크다.
이게 문제가 잘못됬음.
이 문제에 대해서 다른 생각을 가지고 있는 사람!!
문제가 잘못됬음

밴드 위쓰가 0.1 이라니? 왜? 
100 khz 니까 지금 1MhZ를 가지고 있는데 10개의 채널로 나눈다고 했으니까
문제에 1MhZ를 가지고 있는데 채널을 10개로 날눌려고 하면 채널 하나당 채널당 0.1MhZ가 된다.
100KHZ임
근데 우리가 이 채널을 이용을 해서 10Mbps얻어낼려고 할려면 이 관계식에 의해서
d=0 일때 얘가 지금 10mbps라고 했을떄 r이 뭐냐를 찾아내야함
r이 무엇인가를 찾는것은 시그널 엘리먼트당 몇비트를 카바 를 쳐야 이게 지금 가능해지느냐?
이게 지금 100khz밖에 안되는데 여기는 10mbps라고 하면 r은 100이 되어야한다.
100 이 한 시그널 엘리먼트가 100bit를 표현할 수 있어야함
그러면 시그널 엘리먼트 2의 100승개가 있어야 얘기가 됨 
2의 100승개 
2의 100승개는 셀수가 없음
이것은 구현 
애당초 개수 자체를 셀 수 없음
1mbps로 문제를 풀어야함
10 m가 아니라 1m 로 문제를 고쳐야함

## 문제4번
4번은 4khz 밴드위쓰
위랑 유사한 문제 
4khz 밴드위쓰를 갖고있음 이식을 이용함

d=0로 두면 또 역시 r이 얼마냐 이것은 ask면 r이 뭐냐고 물어보는게 아니라 
r을 제시하고 있음 
ask면 r이 얼마냐 한 시그널 엘리먼트가 한 비트 밖에 없음 
0과 1이 +1 -1 이런식으로 ask 하고 있음
r이 1이니까 여기에 집어넣으면 d=0고 따라서 4kbps가 나옴
ask는 r은 
r은 구하는것만 보여주면 qpsk포인트가 4임 
4개의 엘리먼트 따라서 2bit 갈리니까 r이 2고
r이 4란 얘기고 이것은 6이란 얘기고 그걸 여기다 집어넣으면 됨
6의 경우에는 6*4=24 kbps의 스피드를 얻어낼 수 있다.
결국 우리가 지금 두문제를 푸는데 요 표현식이 주된 표현식임
저 표현식이 어딨냐면 이 슬라이드 앞으로 가보면 저 수식이 
psk 이와같은 식이 밴드위쓰

fsk는 이와같은 표현식을 갖고 있음 
우리가 지금 qam ,ask를 다 보고 있는데 그쪽에서 식은 요부분에 없음
fsk는 이 문제에 들어가 있지 않음
이식에 괜히 
psk 쪽에서 사용하는 부분을 사용함
대역폭 을 구하는 과정이 이 내용속에없기떄문에 그냥 주어졌기 때문에 
그냥 좀 이 주어진 식을 그냥 사용하는 입장 이니까 떳떳치 못한 생각이 든다.
b=(1+d)*N*1/r
우리가 지금 psk 가 pn 아날로그 아날로그 표현할 경우에 
주어진 밴드위쓰고 
내가 보내고 자 하는 시그널의 변화율에 의해서 밴드위쓰가 어느정도 생긴다 라는 힌트를 얻어낼 수 있는데 pm의 경우고(fm?? pm??? 정리 다시 한번 하자)
psk 경우는 달리 한번 살펴봐야 한다. 

## 문제2번
amplitude는 1과 3이고 face는 4가지다 .
그림에 어떻게 구현했는지는 우리는 걱정할 필요없이 
성운 그림에 저와같은 상황을 표시해 봐라 이것이다
amplitude 가 1과 3이고 face는 4가지다.
뭐 개념상 그려보고 
구현해본것은 깊이 살펴봐야하고
face가 4개면 서로 90간격을 가지고 있음 4개면 90도 간격을 가지고 있음
가령 여기에 1,3 1,3 이렇게 되어있으면 
요놈이 1,3 이고
반지름이 3인 원인 경우에 
이렇게 되면 저 문제를 만족하는 성운 그림을 하나 그렸다
amplitude는 1 또는 3이고 face는 0 90 180 270 임
이렇게 4가지인 케이스 만들수 있는데
답이 하나가 있는게 아님 어떻게 구현하느냐 에따라서 
멋있게 구현하고 싶으면 여기에 있을 수도있음
이경우는 페이스가 45 135도 -45도 -135도 
이렇게 
이게 어떻게 구현을 했느냐 물어보고 있지 않음(어떻게 구현을해? 오실레이터 그런게 들어가나?)
저와 같은 경우에 성운그림을 그려보라
(여기에 있을 수 있다라고 한것은 그림을 안그려서 모르겠음..)
사실 이렇게 이 둘중에 어느걸 택하고 나면 구현하는것은 이제 이쪽에 cos 에 대한 함수이고 sin 함수잔아 
90 도 위상차가 서로 
90도 위상차가 있는 케리어 시그널임 거기에 각각 진폭의 어떤 값들을 주므로써 8개 포인트가 어떻게 나올지를 고민을 해야함
이 문제는 구현하는것까지 물어보지 않음

위상 4개는 균등하게 이렇게 90도 간격을 갖는데
그림에서 그림에서 축을 4개를 만듬 90차이가 있는

## 시분할 다중화
프리퀀시 디비전 멀티플렉싱, 타임디비전 멀티플렉싱(챕터별 이름을 자세히 봐야함)
두가지를 했음 그리고 한가지 통계적 다중화의 단점인 이와 같이 보낼것이 없을때 통계적 시분할은
프레임 하나에 4개의 여기 5개의 5개의 유저 자기자리를 만들어 주고 했는데 정확히 나눠쓸수없고 그런데 유저가 보낼 데이터가 없으면 저렇게 비어서 간다 저런 낭비를 없애기 위한 방법이 
통계적 tdm임, 통계적이란 말이 왜붙었을까? 어떻게 구현했는지 보고 통계적이란 말이 왜 들어갔을까 살펴본다.
우리가 지금 이런상황임 a,b는 첫번쨰 slot에 보낼게없음
c는 아예 없고 d는 있고 e도 있음
가장 효율적으로 사용한다고 하면 
얘들만 가지고 첫번째 프레임을 만들고 그리고 얘들만 갖고 두번쨰 프레임 만들면됨
프레임이 짧아짐 프레임이 짧아질수가 있음
그럼 빈자리를 어떻게 보내겠냐? 필요한것만 채워서 보냄
필요없는건 아예 그 채널을 없애버림
이렇게
그게 이거임
통계적 다중화(통계적 tdm) 프레임을 형성하는건 좋은데 그 프레임 하나하나 에는 한바퀴 삥 돌아서 있는 애들로 애들갖고만 프레임을 만들겠다. 이렇게 만들면 
이 프레임 하나의 사이즈가 고정적이지 않음 고정적이지 않음
어느 순간에 3개가 이 3 유저가 준비되어있는데 
어느 순간에 4, 5유저가 또 준비될수도있음 이 사이즈가 3개 4개 5개 짜리 채널을 갖는 프레임이 될 수잇음 그런걸 감수함 프레임 사이즈가 가변적인것은 어쩔수없는거고 그렇지만 최대한 채널을 100% 활용하는 그런 모습이 될거고 그리고 굉장히 중요한 것은 하나는
이 순수한 tdm 은 자리가 누구것이다 정해져있음 그런데 통계적 다중화 와 같이 프레임을 만들면 각각의 자리가 주인이 없음 그떄 마침 보낼게 있는 유저가 곧 그자리에 주인이 됨
그렇게 되면 이주인이 
이 첫번쨰 프레임 속에 있는
첫번 째 채널이 누구것이다 라는것을 별도의 정보를 명시해줘야됨
여기서는 그럴 필요가 없음
자리에 각각 첫번쨰 유저 두번째 유저 라는게 정해져있기떄문에 그럴 필요가 없기떄문에
통계적 다중화를 하면 바로 a,b,c 까맣게 붙어있는데 얘들이 주인이 a꺼다 얘는 b꺼고 얘는 d것이다 라고 주소정보를 넣어줘야 하는 오버헤더가 따라올 수 밖에 없음
어찌보면 빈자리를 없앨려고 효과를 볼려고 했는데 어드레스 라는 오버헤드가 붙음으로 써
어느정도 효과를 얻을 지 에 대한 의구심이 생길 수 있음
그런데 네트워크에서는 이렇게 데이터 
어느한유저가 데이터를 데이터를 생성하는 율이 50% 이상이 거의 없음
계속 쉴새없이 데이터를 생성하는게 아니라 어느 정도 생성하고 쭉 쉬고 또 생성하고
따라서 한 유저들을 보면 채널을 점유할 시간이 몇 프로 안된다 그래서 그렇게 보면 여긴 좀 사실 말 이 데이터를 생성하는 케이스인데 이것보다 더 효율적으로 프레임이 생성이 될것이고 빈자리가 많이 생길텐데 빈자리를 없애는 효과를 볼 수 있음
그래서 이 tdm은 엄격한 방법을 쓰고 있지만 통계적 다중화 방식을 통해서 control 부분에 addr 집어 넣고 addr 읽어서 얘가 누굴것이다 라고 판단을 하는 로직을 추가 되야 하니까 회로는 나름대로 복잡해질 수 있는 면은 있지만 링크의 활용도 측면에서는 이게 훨씬 뛰어나다.
통계적이란 말이 왜 들어갔을까 보면은 각 유저별로 아마 이 
이 통계라는 부분이 이 상황에 그 적용될만한 부분은 불명확한 부분들이 있다. 내 각 유저들이 어느 정도에 자원을 활용해나갈까 또는
프레임 사이즈가 계속 변하기 때문에 변할 수 있기 떄문에 내가 지금 처리되는 스피드가 
좀 좌우될 수 있음 이 프레임 사이즈 가 앞에는 적고 뒤에는 큰 사이즈가 오면 큰 사이즈 속에 내가 들어가있으면 처리되는 속도가 느림 
프레임 하나가 열개 짜리가 있고 100개 짜리가 있으면 100개 속에 내가 하나 들어있을때와 10개 속에 내가 들어있을때와는 처리되는 스피드가 다름 따라서
내가 이서비스를 통해서 목적지 까지 가는데 얼마나 걸릴까 계산하는데 여기는 아예 고정된 값이 나오는데 여기는 
정확히 자원의 1/5씩 쓰니까 고정된 값이 나오는데
여기는 평균값으로 내가 얘기를 할 수밖에 없음 평균 지연이 어떻게 되더라 그런식으로 내가 이 얻어낼 수 있는 서비스 품질이 디터미스틱한 벨리유로 표현될 수 있는게 아니라 통계적인 숫자로 표현할 수 밖에 없는 서비스 그래서 통계적이란 말이 앞에 붙어있음
이걸 이제 이 큐잉쎼우리 같은데서 이런 방식으로 서비스가 되고 있고 내가 서비스 되는 그 품질은 다른 유저들의 극히 의존적이다.
남들도 열심히 데이터를 집어넣고있으면 나름대로 내가 지금 자원을 활용하는게 1/n이니까 n이 자꾸 변하면 나는 자원을 쓰는 내 몫이 다양하게 바뀜 그러면은 이 큐잉 쎼우리를 통해서 평균적으로 내가 어느정도의 자원을 쓰고 있고 딜레이는 어느정도 될것이고 확률적으로 표현하는 수식, 해석하는 과정이 필요함
이부분은 내가 서비스를 받는 품질에 대한 그걸 수치화하는데 어려움이 따른다. 
큐잉 쎼우리가 여기 당연히 들어가고 큐잉 쎼우리 들여다 보면 모든 얻어낸 값들은 통계적인 값들이다. 통계적 tdm 이다 라고 하는 이름이 붙은다.
개념만 알아둔다. 저런식으로 하는것이 통계적 다중화 방식임
다중화임

성능이 좋은 링크 하나가 여러 유저가 쓸 수 있는 방법에 살펴본게 다중화 였다. 이것임
또다른 다중화인데 여기는 멀티 플렉싱이 아니라 스프레딩 이라고 함 
스프레드 스펙트럼

## 확산 대역 방식(SPREAD SPECTRUMD)
여기서 보면 오히려 내가 본래 갖고 있는 필요로 하는 대역폭보다 
더 많은 대역폭으로 내 데이터를 확산시켜서 보내는 이상한 걸 이제 얘기하고 있는데
각각의 소스로부터 아주 큰 밴드위스에 집어 넣음
그런 의미에서 멀티플렉싱임 
이것도 아주 큰 대역폭에
이런 경우에는 그 각각에 대역폭을 늘려서 보내는데 왜 그러냐면
eavesdropping 이단어 아는사람!
이 단어 뜻
여기는 보안에 관련된 얘긴데 엿듣는다 라는뜻임 
남이 내 정보를 추출해내는 읽어 내는 그것을 프레벤트한다 막을려고 하는것이다.
그런 측면에서 스프레드 스펙트럼이라는 얘기들을 여기서 하고 있다.

구체적으로 뭔지 살펴보자 두가지 방법이 있는데
Frequency Hopping Spread Spectrum(FHSS)
주파수를 보낼때마다 막 이 주파수 저 주파수 뛰어 다니면서 보내는것과 
Direct Sequence Spread Spectrum Synchronous(DSSS)
여기는 이제 확산시키는 
이런 DSSS 방식

두가지 방식으로 쓰고 있는데 여기에 주목적은 이것임
남이 내 자료를 정보를 캐치하는것을 최대한 막아내기 위한 방법임
그렇게 보안기능을 넣다보면 크게 보면 내 데이터의 밴드위스는 요건데 스프레드 스펙트럼이라는 과정을 거쳐서 오히려 큰 대역폭으로 만들어서 데이터를 보냄
우리가 4B/5B 시험문제 나왔던
4B/5B 4bit 짜리를 구지 5bit로 만들어서 보내는것은 더 큰 대역폭을 요구 구지 왜 그렇게 했느냐 오류검출 이 기준선 표류나 이런 문제를 방지하기 위해서 그런 목적으로 오히려 대역폭을 더 키워서 보내는 일이 있었는데 이것도 마찬가지임 
보낼 시그널은 대역폭이 요것밖에 안되는데 일부러 대역폭을 넓혀서 보냄 여기서는 왜냐하면 보안을 위해서 쓰고 있다.

## Frequency Hopping 
어떤 방식이냐면 그림으로 표현하면
이렇게 됨
내가 지금 데이터를 보내는데 가령 이와 같이 Hop 이라고해서 아주 짧은 시간동안 700kHz 실어서 보냈고 고 다음 짧은 시간동안은 900Khz에 보냈고 시간을 8개로 구간으로 나눠서 각 순서마다 서로 다른 frequency 대역에 내 시그널을 얹어서 보냄
그러면 이 데이터를 캐피 하고자 하는 사람은 frequency 가 어떻게 변해가는지를 캐치를 해내야 내 데이터를 읽어낼 수 있음 
frequency 를 여기저기 뿌리는데 랜덤하게 뛴다.
이부분이 지금 그거임
이렇게 가령 8개의 주파수를 갖고 있음 그중에 내가 어떤식으로 주파수를 뛰어 다닐 것인가? 랜덤하게 랜덤하게 8개중에 순서를 쭉 정해서 특정한 유저는 어느 특정한 순서를 갖고 이 8개의 주파수를 반복해서 계속 사용하면서 이 프리퀀시가 변함
가령 어떤 유저는 사이클 1에서 이렇게 뛰고 반복되고 있음 지금
요 사이클이 지금 반복됨 
저 8개 주파수를 내가 지금 뛰어다니면서 내 시그널을 보냄
그러면 주파수 8배가 됨 그렇다.
이 주파수 다 사용한다는 말임 원래 하나만 사용해도 되는데
그럼 주파수 낭비같이 보이지만 이걸 여러명이서 사용하는경우에 
이런 모양이 될 수 있음
fdm 이라고 하면 고정적으로 주파수를 나눠서 쓰는데 
fdm 서로 슬랏 별로 시간을 잘게 쪼개서 각 slot 별로 남은 것을 패턴을 계속 바꿈
그러면 여전히 4개의 유저가 똑같이 쓰고 있음
자원 낭비가 이거에 비해서 전혀 자원 낭비가 없음 
4개의 유저가 이시간동안 동시에 전송을 한것이다.
근데 같은 프리퀀시를 이용했느냐, 프리퀀시 Hopping 을 이용했느냐 
빨간것은 이렇게 뛰었고 파란것은 이렇게 뛰었고 초록색은 저렇게 뛰고
자원낭비가 없는 식으로 운영할 수도있음
그러면서 보안이 보장이 된다.
각 유저별 프리퀀시는 어떻게 뛰는지에 대한 정보를 얻고자 하는 사람이 알 수없다면 캐치할 수 없음 시간별로 이 정보가 어디서 쫓아 가야 할지 모르니까 
근데 이것은 비효율적이라는 측면은 면했음 효율측면에서는 낭비요소가 없는 그리고 현명한 방식이라고 말할 수 있음(fdm 옆에있는건가 본데!!??)

## DSSS
다이렉트 ..?
이건 애당초 이 그림보다는 이 사례를 보자
내가 지금 특정한 유저는 여기에 코드가 있는데 
여기에 코드가 있는데 스프레딩 코드
이 유저는 스페레딩 코드가 10110111000 이런 패턴임 이 패턴이 반복되고 있음 
이 유저가 이 유저에게 부여된 코드임 
그러면 내가 1또는 0을 보낼때 1 high voltege , 0은 마이너스 볼티지 에 곱해버린다 
곱해버리면 1을 보낼때는 이걸 곱하면 고대로 이 파형이 그대로 갈것이고 
0을 보낼때는 그것이 역이 되서 갈것이다. 계속 이런 코드로 1과 0을 다양한 비트로 바꿔서 보내겠다 
11비트로 늘린거다.
당연히 1, 0, 1 요고 보낼때 에 비해서 당연히 이렇게 보내면 대역폭을 훨씬 많ㅇ ㅣ요구한다.
대역폭 많이 낭비되는 요소가 보인다 싶은 우려가 들기도함
여기서도 역시 효율적으로 사용할 수 있는 방법이 지원이됨

바로 CDMA 라는 방법임
CDMA 라는 방식이 저런 지금 스프레딩 코드 였잔아 코드 이 
용어가 코드 였음
각 유저별 유저별 서로 다른 코드를 가지고 있으면 이 것은 이방식에서는
서로 다른 코드를 가지고 있으면 이 침입자들 
이정보를 얻고자 하는 사람은 지금 코드를 정확히 알아야지만 아 이값이 1이고 이값이 0이구나 캐치해낼 수 있음 
이 코드가 비밀임 개인별로
인제 암호화 라기 보단 보안 측면에 보강이 됨 
암호화 할 수 없음
코딩을 한것임
근데 이게 
우리가 지금 멀티프로세스 저렇게해서 밴드위쓰를 거의 10배 이상으로 키워서 보냈는데 너무 자원의 낭비가 아니냐
여러 유저가 저런 방식으로 프리퀀시 호핑이 내가 여러개의 대역폭을 쓰고 있지만 결과적으로 4개 유저가 서로 뛰어다니면 서로 엇갈리게 뛰어 다니면 아무 낭비요소가 없듯이 
코드 디비전도 혹시 그런 방법이 있지않을까 그런것이 CDMA라고함
요 앞에 FDMA , TDMA가있었고 지금 CDMA 있음 코드 디비전 멀티 프로세싱 
코드 디비전 멀티 프로세스 가 요 찹터 에 안나오고 뒤에 나옴
미리 대역확산에 대한 얘기가 나왔고 CDMA를 여기서 얘기를 할 수있기때문에 미리 슬라이드 가지고와서말한다.
결국은 이 유저별로 쓰는 코드가 다름
이 코드가 유저별로 다 다른 코드를 줌
이 CDMA 와 같은 방식이 
저런 대역폭 확산이 효과적으로 되기위해서는 바로
코드, 유저들에게 주는 코드가 막무가내로 아무거나 11BIT 짜리 아무거나 서로 주는게 아니라
코드 라는 서로 관계가 있는 코드들만 뽑아서 줌
그게 CDMA 방식이 되고 서로 어떤 특성을 갖는 코드들을 사용하는가
이제 그 부분을 설명하기 위해서 뒤 슬라이드를 보여주는거임
먼저 이 부분은 혼자 쓰고 있을때 살펴보자
이 유저는 0 1 데이터를 보낼려고 함
근데 자기 할당 된 코드가 8bit, 예를들어서 111 -1 1 -1 -1 -1 이렇게 계속 이렇게 코드를 지금 보내고자하는 값에 이 곱해서 이 결국 이걸 보낸다. 이값 곱하기 하고 이걸 곱하기 하면 여기는 -1 =>0은 곧 시그널이 -1로 표현 이거에 거꾸로된 값이 가고 여기는 요 모양이 그대로 가서 
가게 되면 곱해서 가게되면 여기 나가는 시그널이 이때는 자기 모양이 그대로 가고 두번째는 얘때문에 거꾸로된 모양이 감
이런 시그널이 혼자만 사용한다고 하면 이 미디어를 
리시버 쪽에서는 리시버를 받았는데 리시버는 받는게 얘들임
얘들을 받아서 얘들이 지금 0인지 1인지 알아내야 하는게 리시버의 역할임
리시버는 무슨일을 하냐면 내가 지금 그대로 받은 요 코드화된 시그널을 받아서 상대방의 유저의 코드를 당연히 알고있어야함 
리시버는 센더의 코드값을 알고있어야함 그 센더의 코드 값을 그대로 곱하는것임 곱하면 코드값을 곱하니까 이 저 관계식을 쓰면
내가 보낼 데이터가 d(i) 였다 이렇게 되면
이게 +, -1 (플마 1임) 이 아이의 
보낼때는 곱하기 c를 했는데 받을 때는 또 c를 함
받는 쪽에서는 똑같은 코드를 곱한것임
센더 쪽의 코드값 똑같이 곱함
그러면 얘값을 보자 c * c라는것은
이 코드가 지금 몇비트로 되어있느냐 하면 8bit임
그러면 자기거 곱하면 -도 -1 곱하고 +1도 + 곱하면 똑같은것을 곱하는것이니까
이 bit의 개수가 나옴 여기는 8이 나옴
8번 1이 더해지는 값이 나옴
요 값이 8이 나옴
d(i)*8 됨 d(i)는 +,-1(플마 1이고)
그래서 코드길이가 8인데 코드 길이로 나오면 d(i)가 나옴
d(i)값이 -1 이면 0고 
d(i)값이 1 이면 1이었다 내가 데이터를 캐치하는 셈임
요렇게 
내가 받은 시그널에 센더의 코드를 그대로 곱해서 bit by bit 로 곱해서 나누기 8 
이 사이즈, 코드의 사이즈를 하면 이 경우에 +1 이 나오고 뒤 8비트에 대해서 똑같은 일을 수행하면 -1이 나옴
그러면 최종적으로 1, -1이라고 하는 원래의 보내고자 하는 데이터 값이 추출이됨
이게 지금 이렇게 스프레드 스펙트럼의 방식에 의해서 dsss 방식에 의해서 받는 쪽이 sender의 코드를 알고있어야됨
바로 지금 
여러명이 동시에 쓴다.
그다음 슬라이드

## CDMA: two-sender Interference, 여러 사람이 동시에 쓸때
그 다음 슬라이더 인데 우리가 쓰는데가 sender 1이고
여기 sender 2임
당연히 센더들끼리 간에는 코드값이 달라야함
여기 첫번쨰 센더의 코드고 여기 두번쨰 센더의 코드임
그러면 똑같이 아까는 얘 혼자만 보냈는데 애꺼까지 넣어서 보낸다. 그러면 수식을 어떤 값을 얻냐하면은
저기 날라가는 가령 a라고 하는 유저에 데이터에 그 코드 a와 코드 a 가는거고 b라는 유저는 자기 코드 b라는 값이 가서 곱해서 가는게 이 부분임
두개의 유저가 스프레드 스펙트럼해서 아예 더해서 시그널을 같은 매체를 통해서 가면 이 시그널이 감 이시그널의 모양이 이런저런 모양이 될것임
받은 사람이 이걸받음 이 시그널을 이중에서 내가 a라는 데이터를 뽑아내고 싶다. 혹은 b라는 데이터를 뽑아내고 싶다.
가령 내가 a라는 데이터를 뽑고 싶으면 나는 ca 값을 알고있는사람임 이사람이 하는 일은 다시 ca를 혼자 보낼떄 하듯이 받는 사람은 내가 원하는 sender 의 코드를 여기다 곱한다.
여기다 ca를 곱함 
그러면 그렇게 나온 수식을 역시 여기도 코드의 길이 Mm 코드의 길이로 나눈 식이 나오는데
이 경우에 우리가 바라는게 뭐냐
아까 혼자 보낼떄의 데이터로 가면 바로 요 몇만 살아주면(요 몇만 살아주면이 먼뜻이지??)
요 분자만 저것만 있으면 da를 뽑아내는것을 봄 
다시말해서 얘가 요놈이 이렇게 operation 하면 0가 되는것을 원한다 이것임
내가 관심없는 유저는 관심있는 유저의 코드를 곱했을때 0값이 되게 하면 됨
그렇게 바로 코드 b, a에 requirement가 됨
서로 다른 유저간에 다른 유저간에 코드값을 서로 곱하면 0가 된다.
i와 j가 서로 다르면 다른 코드간에 곱하면 0가 되고
같은 코드 를 곱하면 당연히 코드의 길이 m이라는 사이즈 가 나옴
바로 요런 조건을 만족하는 코드를 구해내면 그 코드들을 모아서 유저들에게 이 미디어를 같이 쓰는 유저들에게 나눠주면 그러면 서로 다른 코드 간에 곱하면 0 이기떄문에 몇명이 동시에 보내더라도 오로지 내가 원하는 유저에 데이터만 추출해낼 수 있음 이렇게 되면 da가 나옴
a에 코드를 쓰면은 애는 0가 되기 때문에 저 앞에 있는 그것만 계산이 되서 m으로 나눠지니까 d에 곧 a값을 추출해낼 수 있음 
이게 바로 CDMA임
CDMA의 키포인트는 이 코드를 찾아내는것이다. 이런 특성들을 서로 다른 그 개체간에서는 프로덕트가 0 가 되고 자기 것이 아닌 서로 다른 객체가 되는 0가 되는 코드들의 SET이 오쏘고날 (수직적)이런 표현은 여기저기서 오쏘고날 셋임 서로 다른 셋간에는 이너 프로덕트가 0고 그렇지 않은 자기 엘리먼트 간에만 0이아닌 값을 갖는 요소들, 엘리먼트 셋을 오소고날 셋이라고함
요 셋을 어떻게 구하는지 뒤에 가면 굉장히 어려워보이는데 
이런 셋을 가령 8비트 짜리 코드를 여러분한테 찾아가라 오쏘고날 셋을 어려워보임
뒤에보면 간단하게 코드를 찾아내는 아이디어를 보여주는 내용이 뒤에 있음.
그래서 지금 ...


