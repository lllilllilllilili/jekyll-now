---
post : layout
title 컴퓨터구조14
---
## 컴퓨터구조14
컴퓨터구조14

# Performance
화요일 10시 시험

## Performance Perspectives
성능을 말할때는 여러측면에서 성능을 고려하는데
1. 제품을 구입하는 입장에서 성능을 고려해보면
cost 구입비용을 관건이다.
performace/cost 비용당 성능을 고려한다.

2. 디자인, 제품을 설계하는 입장에서 여러가지 디자인 옵션이 존재하는데
투자대비 성능을 확인해볼수있다.

3. Both require
어느경우든지 여러측면에서 비교가 필요하고 비교할려면 기준이 요구된다.
평가를 위한 기준이 되는것을 metric 이라고 한다.

## Two Notions of Performance
컴퓨터는 아니지만 비행기가 747도 있고 Concorde 비행기도있고 기종이 여러가지가 있는데 각각 표의 제원을 가지고 있다. 

2배이상빠른데, 실어나를수있는 승객은 정반대다. 속도를 가지고 평가를할것이냐 단위시간당 수송량(트루풋) 
단위시간당 처리량
항공사 입장에서는 트루풋이 좋아야한다. 승객입장에서는 speed가 좋다.
어느관점에서 보느냐에따라서 가치 판단의 기준의 결과가 달라진다.
pmph(person mile per hour) 시간당 사람 곱하기 miles

컴퓨터시스템에서는 execution time(사용자입장에서 응답시간이 있을수있고 latency : 지연시간) 
어떤 작업을 완료하는데 걸리는 전체 토탈 타임 이렇게 여러가지 요소들이 평가요소가 될수있다.

throughtput은 단위시간당 처리량 또는 단위시간당 전송량(률) bandwidth 라고 한다.

단위시간당 작업의 개수(작업량, 트루풋) 종종 트루풋하고 타임스피드하고 제품을 고를때 약간 서로 상충관계 있을수도 있다.

어느요소를 결정하는가를, 무언가를 중요하게 여기는지 따라 다르다.
만약, 성능을 단위 시간당 유닛의 수(처리량으로따지면 많을수록 좋고 response time에만 관심이 있다고 그러면 performance는 executionTime에 역수이다.)

## Definitions
execution time이 짧을수록 좋다.
speed에서 x시스템이 y시스템보다 n배더 빠르다. 그얘기는 x시스템에 execution time 분에 y시스템에 execution time에 비율이 n이 나온다. 그리고 performance는 반대다. 성능지표로 따지면 x의 성능이 n배더 좋다.

작업을 하는데 x에서는 1초걸리고 y에서는 5초걸린다. x 시스템이 5배더 빠른것이다. 성능지표로는 x시스템은 1/1이고 y시스템은 성능이 0.2다.

++성능은 execution time의 역수로 성능을 나타낸다.++


## example
시간으로만 따지면 747이 concorde가 747보다 2.2배 빠르다. 시간으로 따지면, 뜨루풋으로 따지면 Concord가 0.62 time better(더 좋다.) 1배 이하로 좋다는 성능이 떨어진다.
Boeing는 1.6배가 나온다. 60%이상좋다.

## Evaluation Tools
제일 많이 쓰는건 benchmark라는걸 많이쓴다.
성능평가를 위한 어플리케이션들을 benchmark라고 한다.
traces라는건 어떤 프로그램을 실행하고 났을때 실행한 명령어들의 집합이다. 프로그램을 돌리면 명령어를 계속 생성해낼텐데 쭉 파일에 받아서 가공해서 성능평가를 한다.

benchmark를 굉장히 c language에서 high level에서 돌리면 Macrobenchmarks 이라고 하고 기게어 레벨에서 더 낮은 레벨에서 benchmark를 돌리는것을 Microbenchmarks이라고 한다.
benchmark는 set이라고 보면된다.(테스트 프로그램했을때)

workload라는것은 어떤 시스템이 얼마나 버티나 볼려면 계속 뭔가 부하를 가하면 된다. 예를들면 어느 회사에서 웹서버를 출시했다. 웹서버가 굉장히 많은사람들이 폭주해도 잘버티는지 볼려면 계속 가상의 클라이언트 가정해서 네트워크로 계속 접속을 해야 한다. 시험해야한다.
++제품을 시험하기 위해서 거는 부하, 가상의부하다++

또하나의 방법은 여러단계에서 시뮬레이션한다. 제품을 만들기전에 밉스프로세스를 만든다 하면 바로 밉스 프로세스를 설계들어가서 만드는것이 아니다. 밉스 프로세스가 어떻게 동작할것인가를 소프트웨어로 모델링한다.

밉스프로세스안에는 alu, 레지스터, 메모리 소프트웨어 컴포넌트로 모델링하고 메모리 access 할때 시간이 100ns 걸리고 레지스터 access 할때 5ns 걸린다. access할때마다 해당되는 시간을 쭉 count, 통계자료를 뽑는다.
그러면 어디에서 성능이 바틀렉이 되는지 어느 부분이 성능을 저하시키는 요소가 되는지
미리 발견할수있다. 시뮬레이션이라고 한다.

++제품을 만들기전에 소프트웨어적으로 모의실험을한다++

대부분 시뮬레이션을 한다.

모델링하는 소프트웨어 툴을 더 잘익혀야 한다.
instruction set architecture(레지스터레벨, alu레벨) 또 microarchitecture(더 밑에 디테일 레벨) RTL(Register transfer level, 레지스터에서 레지스터 간에 데이터전송) gate circuit(논리게이트)

시뮬레이션의 레벨에 따라서 시뮬레이션의 충실도가 달라진다(fidelity) 
level of abstraction으로 하면 전체적인 움직임을 볼 수 있지만 아주 디테일한 레벨에서 흐름이 정체되는지 보기 어렵다. 레벨과 충실도(fidelity) 시뮬레이션의 충실도는 레벨에 따라 차이가 난다.
처음에는 위에서 레벨을 보고 어느부분을 디테일하게 살펴봐야 겠으면 아래로 레벨을 내려간다.

실제로는 그 회로가 차지하는 면적이라든지 회로때문에 결정되는 전체적인 cycle time 이있다. a에서 시작해서 b까지 가능경로가 회로안에 있는데 신호중에서 가장긴것을 critical path라고 한다. 이런것에 따라서 clock frequency 결정할수있고 전력소모 그리고 생산단가 평가할수있다. 이론적으로 큐잉모델, 블랙박스로(안에는 디테일하게 가려놓고 블랙박스로 모델링하는 경우도 있고 경험을 토대로 모델링 하는 경우도 있다.)

## Benchmarks
참조
###### Microbenchmarks
high level 단에 해당하며, 성능을 확인할 수 있다.(ppt참고 항목)
성능에 요소를 미치는 부분을 볼수는 없다.(근본적인것은 확인할 수 없다.)
app의 성능을 예측하는 좋은 방법은 아니다.

###### Macrobenchmarks
app의 execution time을 확인할수있다.

benchmark을 향상시키는 것은 많은 프로그램들의 성능을 향상시킬 수 있다.

## Popular Benchmark Suites
benchmark를 쓰는이유는 서로 다른 시스템을 비교하기 위해서다. 그리고 모아놓은 프로그램

모아놓은 프로그램이 시스템의 성능을 파악할 수 있는 중요한 프로그램들을 잘 모아두면 굿 벤치마켓
어떤 경우는 의도를 가지고 자기들 시스템을 돋보이게 만들려고 벤치마켓을 의도적으로 만든것들이 있다.

벤치맠이 모든 시스템을 평가하는데 대표성이 있는 공정한 벤치마크인가 아니면 특정시스템에 편향된 좋지 않은 벤치마크인가를 살펴봐야 한다.

편향된 벤치맠을 피해야 한다.

###### desktop
spec이라는 벤치맠은 공정한 과정을 거쳐서 만든 벤치맠이다. desktop 을 위해서 10여개의 프로그램이 들어있다.
3d 모델링(애니메이션그림) 집어넣어서 그래픽 성능을 본다던지

###### server
데이터처리를 트랜잭션이라고 하는데, 데이터베이스 트랜잭션 프로세싱 밴치맠

###### Parallel Computers
멀티프로세스, 멀티코어 splash라고 하는 parallel 어플리케이션을 통해서 parallel computer 모델을 새로만들면 모델링 한뒤에 그 위에서 splash를 돌려봐야 한다.
이전의 parallel 컴퓨터보다 내컴퓨터가 splash가 각각 얼마의 execution time을 보내는지 결과로 볼수있다.

## SPEC CINT2000
여러 데스크탑 컴퓨터 모델들을 보여주고 있고 거기서 돌렸을때 실제로 시간 얼마만큼 걸렸다.
시간이 짧게 걸린게 좋지만 성능/비용을 계산해야 한다.
낮은것이 비용/성능이 낮은것이다.

## TPC
서버쪽의 벤치마켓

## Basis of Evaluation
참조.

## Metrics of Performance

## Organizational Trade-offs

## Programs to Evaluate Processor Performance

## Processor Cycles

## cpu performance
cpu time이라는건 프로그램당 소요되는 시간 의미한다.
프로그램당 몇 사이클이 걸렸는가(clock cycle 개수) 사이클당 몇초가 걸리는가?(clock cycle time)

프로그램은 instruction으로 구성되는데 프로그램에 몇개의 instruction으로 구성되어있는가 
한 instruction은 몇 cycle로 구성되어있는가 
한 사이클은 몇초인가

instructon count, cpi(single cycle은 cpi가 1이다.) 모든 instruction당 1다. 
cycle time과 clock frequency는 역수의 관계가 있다.

그래서 execution에 영향을 주는 요소가 instruction count, cpi, clock cycle 3요소가 instruction count에 영향을 주는데 
개별적으로 ic는 프로그램의 정의에따라서 영향을 받고 컴파일러가 (똑똑한) 똑똑한 compiler는 instruction 개수를 현격히 줄일 수 있다. instruction set 밉스와 같은것을 쓰느냐 x86 instruction 쓰느냐에 따라서 instruction 개수가 달라질 수 있다. 
cpi는 instruction set와 하드웨어적으로 어떻게 구성되어있는지에 따라서 cpi는 결정된다.(한 instruction당 clock이 몇개필요한가, 경우에 따라서 compiler가 약간의 영향을 줄 수 있는데 경우에따라 다르다.)
clock cycle time은 굉장히 하드웨어적인 요소에 영향을 많이 받는다.(실제로 datapath로 구성 반도체기술이 어떤것들이 적용되냐에 따라 clock이 결정된다.)

## Cycles Per Instruction(Throughput)
cpi = (cpu time * clock rate)/ instruction count
사이클의 개수는 cpu time * clock rate(=clock frequency).
clock frequency가 1ghz다. 한 클락 명령어당 한 클락을 써 cpi=1이다. 그 프로그램이 1초걸린다 명령어 개수는?
1/10^9 걸린시간과 clock rate을 곱하면 명령어가 몇개, cycle이 몇개 흘렀는지 계산할 수 있다.

Instruction frequency는 전체를 쭉 실행시켜보면 load /store 30% 나오고 branch가 20% 나오고 산술 논리 연산자가 30% 나오고 비율이 존재한다. Instruction frequency라고 한다. 
cpi는 평균적으로 구하는것이다. 각 instruction 당 cycle이 있는데 거기에 instruction이 나타나는 빈도가 존재하는데 single cycle은 이렇게 해도 1이 나온다.
왜냐하면 모든 명령어당 instruction cycle이 1이다. 
1*각각의 빈도를 곱한값을 다 더하면 1이된다. 
Average cpi 로 정의한다.

## Principal Design Metrics : CPI and Cycle Time
Performance하고 CPI*CycleTime 관계들을 정리한것이다. 

## Example
1) load cycle을 2로 변화시키면 CPI는 0.4가 된다.
총합 CPI는 1.6이 된다. 상대적인 성능은 2.2/1.6 = 1.38이 된다.

2) branch cycle을 1로 바꾸면 0.2가 되고 전체 cpi는 2.0이 되고 상대적인 성능은 2.2/2.0 = 1.1이 된다.

## Summary: Evaluating Instruction Sets and Implementation

Design-time metrics
소프트웨어를 디자인 하는데 성능 지표의 평가가 된다.
구현하고 얼마나 오래걸리고 비용이 얼마냐?
프로그램(소프트웨어 적으로 구현할 수 있나? 수정이 간편한가?(쉽냐?)

Static Metrics
프로그램상에서 얼마나 많은 바이트가 메모리에서 일어나는가?

Dynamic Metrics
명령어 몇개가 실행되는가?
프로세스가 프로그램을 실행하기위해 fetch하면 얼마나 많은 바이트가 필요한지?
명령어 하나에 필요한 clock의 개수는 몇인가?
클락이 얼마나 실용적인지?

## Amdahl's "Law" Make the Common Case Fast
암달의 법칙, architecture 설계할때 제한된 투자금을 가지고 투자시 원칙이 존재하는데 common case를 빠르게 만들어라
컴퓨터 시스템에 여러 요소가 있는데 그중에서 common case는 가장 많이 활용되는 부분이다.
그부분을 빠르게 만들자.

그림에서 검은색 빗금은 투자를 해서 안바뀌는 부분이다. 흰색은 투자한 만큼 효과를 보는 부분이다. 투자후 성능개선을 할때 안바뀌는 부분은 그대로 남는다. 시간이 줄어드는 부분은 

투자를 해서 영향을 받는 부분으로 일을 해야한다.
전체 성능 부분에서 차지하는 비율은 15% 나머지가 85%다. 15%를 0으로 만들어도 85%가 그대로 남는다.
85%는 개선의 효과를 못본다.

암달의법칙은 투자를 할때 가장 common한 부분이 어떤 부분인지를 찾아서 그부분에 투자하는것이 기본적인 원칙이다.

줄었을때 성능개선을 확인하고자 하면 그것이enhancement인데 성능개선을 통한 스피드업은 
성능개선전의 execution time/ 성능개선후의 execution time으로 나눈다.
그것이 speed up이다. 
execution time과 performance는 반대로 취급한다.

성능개선할 부분의 비율을 f라고 하자.
나머지 두개는 1-f이다.(비율)
성능개선을 적용한 실행시간은 1-f는 영향을 받지 않고 그대로온다. f부분만 성능개선을 하고 온다. 몇배를 하고오던지 간에 s배의 성능개선을 한다.
s를 몇배로 할지가 관건이다.
거기에 전체 성능개선이 없었을때의 실행시간을 추가하면 
최대한 투자해서 s를 무한대에 가깝게 하면 f/s는 0이된다.
0이되더라도 (1-f)*extime(withoutE) 이 된다.
나머지는 그대로 살아있을수밖에없다.

전체적인 Speed up을 보면 old/new  
f에 해당하는 speed up을 해당되는 fraction을 나눠주고 1-f 나머지 해당되지 않는 부분, old executiontime이 분자 분모에 있는데 약분되었다.

speed up(enhanced)는 개선이 필요한 부분에 해당되는 검은 부분이 speed up 되는 부분이고 speedup(overall)은 전체 시스템에서 speedup이 되는 부분이다.

overall speed up은  speedup(enhanced)가 무한대로 가서 그값이 0으로 가더라도  1-f(enhanced fraction)
영향받지 않는부분 에 1을 넘을수없다.
85%니까 0.85다.  1/0.85은 1.17, 아무리 잘해도 1.17배 이상 스피드를 낼 수 없다. 

암달의법칙은 전체중에서 우리가 어떤 요소를 개선할것인지 판별하는 기준이되는것이고 f라고 설정한 부분에 나머지영향받지 않는 부분을 1-f라고 했을때 이 부분을 투자를 해서 s배 개선한다고 했을때 s배가 전체다 영향을 미치는것이 아니고 해당 부분에서만 영향을 미친다.

2배 3배 4배.. 빠르게한다하더라도 전체를 봤을때 2배 3배 나오는게 아니라 전체비중의 차지가 크면 2 3 배 가깝게 overall performance가 나오지만 작은 부분을 차지하고 있으면 아주 미미하게 1.2배.. 1.1배 성능개선밖에 나오지 않는다.

/*밉스 어셈블리어, 데이터패스상에서 값이 어떻게 뜨는지, 다양하게 나올것이다. 궁금한사항은 eclass 질의응답게시판 이용. 그날 답이 안올라오면 이메일로 알려라!*/
