---
layout : post
title : 컴퓨터구조(4)
---

## MIPS(RISC) Design Principles
RISC로 모델한것이, 필요명령어의 집합이고 성능이 좋다.
### Simplicity favors regularity
굉장히 단순한것이 좋다.
명령어들이 32bit로 나눠지는데 32bit는 word로 표현할 수가 있다. 즉, 모든 명령어가 1word로 구성된다.
명령어들은 3개의 형식으로 나눠지는데,
op(opcode code) 부분은 항상 6bit로 고정되어 있는데, 처음 6비트를 보면 add인지 write인지 알 수 있다.
### 명령어 개수가 작은게 빠르다.(RISC)
레지스터가 작고, 주소지정기법으로 단순하게 만들었다.
단순하게 해서 프로세스도 작게하고 클락을 빠르게 한다, 빠른 속도를 보장한다.
### Make the common case fast(and the rest right) 가장 많이 쓰는 부분을 빠르게 설계한다.
연산에 참여하는 것을 피연산자라고 하는데, 모든 피연산자를 register에 둔다.(load-store machine)
**load-store machine은 뒤에 나온다.
#### allow instructions to contain immediate operands!
immediate operands는 1word당 32bit라고 했는데 처음 6bit는 opcode로 주고 나머지를 실제 사용할 상수값으로 표현하는데 원래는 메모리에서 값을 읽어서 가지고 왔는데 명령어안에 값이 있다(immediate operands).
* 연산에 참여하는 값이 실제 메모리 안에 있는데, 명령어 안에 있는 형태다.
MIPS를 load-store machine 이라고 부른다.
#### Good design demands good compromises
three instruction formats, a와 b와 c가 interface로 뭔가를 제작한다하면 규칙적인 부분을 따르게 하고 달라야 할 부분은 다르게 해서 타협점을 잘 찾은뒤에 디자인을 해야 한다.

## MIPS Instruction Set Architecture
RISC가 명령어 집합 구조에 선구자중 하나다.
일정한 형식으로 된 지침의 작은 레퍼토리, 반복적으로 쓰인다.

파이프 라인 된 실행, 자동차 생산 라인처럼 완성된 자동차 뒤에 또다른 자동차가 연달아 나올 수 있는 것을 파이플라이닝이라고 하는데 명령어도 비슷하게 이러한 모델로 구현되어있다.

캐시 메모리, CPU가 메모리에 값을 읽어오는데 메모리는굉장히 느리기 때문에 CPU에 캐시 메모리를 둬서 한번 읽어왔던건 메모리 말고 캐시에서 읽어온다.

### 로드/저장 아키텍쳐
프로그램 컴파일 후 실행파일이 하드디스크에 저장된다.
모든 연산은 Register에서 가지고 오는데(산술/논리 연산자) 우리가 코드를 짜면 하드디스크에 저장이 되고 이것을 OS가 가져다가  메모리에 올리게 된다.
어떤건 code(기계어 코드) 어떤부분은 data코드 (변수들)이고, 
데이터값을 레지스터로 가지고 오면, 그 위치가 Datapath이고 이 명령어을 Load라고 한다.
계산한 데이터값을 하드디스크로 결과를 써야 프로그래머가 알 수가 있는데(즉, 레지스터의 값) 다시 메모리로 옮기게 된다. 바로 옮길수없기 때문에 중간 과정을 거친다. 이 명령어를(옮기는 명령어가 동작하고) Store라고 한다.(copy) 메모리값을 하드디스크로 옮긴다.
따라서, MIPS를 Load와 Store의 Architrecture라고 한다.
(MIPS의 명령어 메모리값을 레지스터로 가져오는 명령어 Load라고 하고, 데이터 데이터2 가져와서 명령어 add실행해서 연산결과를 레지스터에 담는다.)
* 레지스터와 메모리는 서로 다르다. 레지스터는 cpu, 기억장치 안에있고 메모리는 cpu 밖에 있다. 속도는 cpu가 더 빠르고 연산 참여 값을 cpu안의 레지스터에 가져간다.

* RISC 꼭 중요한 명령어들이 있는데, 피연산자가 레지스터에 있어야 한다.
* 중요한건 모든 데이터는 메모리에 있다. 메모리에 있는 것을 연산하려면 값을 레지스터로 가지고 와야 한다. 레지스터에 준비시켜서 연산하고 연산결과를 레지스터에 쓰고 레지스터 연산결과를 메모리로 올리는 Load 명령어를 실행하고 결과를 Store 명령어를 실행한다. 이게 MIPS를 Load and Store Architecture라고 부르는 이유다. operation 자체는 code 영역에 명시한다.


#### 32bit 구조에서 시작했지만, 나중에는 64bit로 늘었다.
#### 현재는 많은 임베디드 시스템에서 사용되고 있다.


## MIPS ISA-Very Regular Formats
## Instruction Categories, 명령어를 나누는 기준.

##### Arithmetic/Logic instructions, add, write의 표현은 다르지만 명령어 형식은 같다. 
##### Data Transfer (Load/Store) instructions 워드 32bit, 주고받고(load/store) 하는데, 바이트(4byte)로 주고 받는 경우 "캐릭터"인 경우인데 경우에 다라 같은 정보전송단위가 다르면 load라도 명령어가 다 룰 수 있다.
##### Conditional branch instructions 조건에 맞으면 수행, 아니면 건너뛴다.(If-else)
##### Unconditional jump instructions 조건 따질 것 없이 어디로 가야하나(goto문 같이)
위의 4개의 클래스가 기본이다, 모든 구조의 명령어가 4가지 클래스로 구성된다.

## Only 3 instruction formats
Field size로는 R-format, I-format, J-format가 있다.
Fields 처음부분은 6bits opcode고 
R-format은 rs, rt, rd 는 register 번호다. 그리고 5bits는 shift의 개수이고 나머지 6bit는 function code이다.
I-format은 rs, rt 각각 5bit씩 구성되고 16bit가 address/immediate로 할당된다.
J-format은 26bit가 target address로 주소를 표현하는 용도로 쓰인다.
##### 0~31로 (오른쪽으로 갈수록 최상위비트가 되고) 32bit로 매겨진다.
R-format은 Arithmetic logical instruction format.
I-format은 Transfer, branch, imm format
J-format은 JUMP instruction format이다.
* 3가지 format으로 MIPS의 명령어 인코딩을 구성하고, 일치하는 부분을 가지고 있다.
* opcode는 2의 6승으로 add, load등의 작업을 실시한다.

## MIPS ISA State(Register & Memory)
프로세서가 제공하는 레지스터의 개수는 32개다.
Register는 번호로 접근한다, Register의 개수가 프로세스안에 32개로 구성된다.
Register는 앞에 $을 붙이고 접근한다. general perpose register 라고한다. (일반적으로 쓰이기 때문에)
pc는 program count라고 하고 다음 수행할 명령어의 주소를 저장하는 레지스터다.
LO, HI는 64bit 지원한다.(32bit의 연산으로 가지고 할 수 있는것에 범위를 넘을시 HI+LO결합후 64bit를 지원한다.)
Memory는 32bit로 메겨지고, 0xffff ffff 부터 0x0000 0000까지 32bit를 16진수로 표현할때 2진수가 4개가 16진수이니까 이런식으로 보여지게된다.
이 메모리의 사이즈는 메모리주소가 32bit로 메겨지기 때문에 2의 32승 byte를 제공하고 이는 4Gbyte다.(* 2의 10승은 1 킬로바이트, 2의 20승은 1 메가바이트, 2의 30승은 1기가바이트) 가 된다.