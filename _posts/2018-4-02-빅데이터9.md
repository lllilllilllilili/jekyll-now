---
post : layout
title : 빅데이터9
---
## 들어가기 앞서서
최소한 한개정도는 존재, level당 한개의 windowsize가 있어야한다. page29
숫자가 있을때 n이라고 치면, n에 자연수를 bit로 표현하고 싶다. logN 요구
logN으로 처리되는 값이 있으면 그 자연수N을 값으로(bit)로 표현할 수 있다.

## 들어가기 앞서서(2)
Exponential window 방법을 배우는것은 컴퓨터내에 bit들이 2의 좌승으로 증가되는것과 같은이치다. 

## 타임스탬프
타임스탬프 
스트림 데이터중에 n사이즈만 볼것이다, 새로운것이 들어오면 n사이즈중에 끝에있는것이 나간다.
n개만 본다. 타임스탬프가 굉장히 큰값이다.(증가만한다.) DIGIM method에서 타임스탬프를 표현할때 logN만 필요한이유, 실제 타임스탬프 값 신경쓰지 않는다. 들어오는 데이터들의 순서만 비교한다. 타임스탬프의 용도임 (긴 숫자를 저장하려면 필요없으니까 모듈러 n을 해준다. 커봐야 n을 넘지 못한다.)
0~n-1 값밖에 안나온다. 그래서 타임스탬프값을 n만큼만 가지고 있으니까 logn의 bit만큼 가지면 표현할 수 있다.

## logNlonN
loglogN, Digim은 exponential 기반 이고 버킷의 사이즈 자체는 0을 카운터하지 않는다. 버킷사이즈라는것은 버킷에 들어있는 1의개수, 1의개수에 제약조건을 썼는데 개수가 2의 k개만 카운터에 들어가도록 해두었다. 카운터를 할때2의 1,2,4,8의 카운터를 다 더해야 한다. (한묶음씩)
저장해야하는 비트자체는 3이된다. log8=3 (앞에서 얘기한것) 

카운터를 표현하기 위해서는 logn bit가 필요. 그리고 0승 1승 2승 3승의 값을 최종적으로 구하는것이므로 log 한번하면 카운트의 개수를 세는것이고 log를 한번더 하면 0승 1승 2승 3승을 계산하게 되는것이다. 결과적으로 지수를 표현하기 위한 bit로 loglogn만큼 필요하다.

## 에러율 50%
exponential window는 에러율이 100%가 될 수 있다. 그래서 나온것이 Dgim method다. 50%이기는 하기지만, 절대로 50%를 넘지 않는다. 사실 이것보다 낮다.
왜? 맨마지막에 걸쳐지는 window n에 대해서 left most에 있는 카운터 값을 2의 r승 이라고 하자.

에러가 될 수 있는 사이즈는 left most의 size에 절반이다. 재수없어도 이값만 틀리고 나머지 즉 뒤에값을 멀쩡하다. 잘못된 값이 될수 있는 left most의 절반값의 MAX 값은 2의 r-1승(절반값) 

분모를 구해보자, left most를 뺀 나머지 1의 값을 다더하고 마지막에 2의 r-1승 값을 더해서 %을 확인할 수 있다. 

worst case는 window size가 각각 하나씩 있는게 worst다. window가 많으면 유리하다. 
왜? worst는 1,2,4,8 이렇게 간다. 이렇게 가서 bucket이 하나씩만 있는게 worst다. 
bucket의 개수가 up to 2개가 가능하다. (이전에 window 여기서는 bucket)
왜? bucket이 하나씩 오면 left most에 있는 애가 제일 커진다. bucket이 두개씩 오면 left most값이 줄어든다. 
best case - 같은 사이즈가 2개씩 오는경우 worst case - 같은 사이즈가 하나씩 오는경우
(등비수열의 합 공식은 Google 하자)

left most가 절반이 에러이긴 해도 정확한값이 2의 r승 -1인데 +1을 해서 2의 r승이다. left most에 1이 항상 왼쪽에 있다. 따라서 1을 더 더해줘야 한다. 이것은 exponential window에서는 보장이 안된다.(0까지 고려함) 시작이 항상 1이 됨 (잘 보면)

left most에도 최소한 하나는 제대로 된 값이다. 최악의 경우 50%
같은 사이즈의 버킷이 늘어날수록 에러율이 줄어든다.

## Further Reducing the Error
버킷개수가 2개이상은 안될까?
50%가 너무 높다. 더 낮을 순 없을까? r의개수(=버킷의개수) 증가시킨다. 1/r로 계속 줄어든다.
left most 버킷의 사이즈가 2의 j승으로 가정 버킷의개수가 2개에서 증가되서 r이라고 가정한다.
분모로 들어가는 값이 1+r(2의 j-1승 + 2의 j-2승 + ... + 1)=1+r(2의 j승 -1) 이 된다.

overly estimated part 는 left most의 절반값 2의 j-1승인데 사실 1을 더 빼줘야 한다.(이미 오른쪽에 보장되는 값으로 넣어줬기 때문에)

r이 변수고 j는 이미 정해진 상수, j는 버킷의개수로 정해져 있다. (상수값으로 저장된다.)
O(1/r) 된다. O를 쓰는이유는 근사값을 알아보기 위해서

r값이 계속 늘어나면 문제가 된다. 저장해야하는 bit가 많아진다. 저장해야 하는 카운터수(버킷수)가 증가한다. application에 따라 달라진다. 에러율은 높더라도 메모리 사이즈가 중요하면 r을 줄인다. 

## Extensions
n개의 버킷을 갖고 안에 있는 1의 개수를 세고 있다. n개보다 작지만 k만큼만 셀수있을까? n->k로 바꿔서 생각

## Extensions, 양의정수
음수는 안들어온다. 양수값이 들어오면 window에 있는 양수값을 요약할순없을까?
integer 값을 더해줄 수 없을까? 1만 세우는것이 아니라, 정수값

자연수 계산 하는 방법 간단하다. 2의 비트로 바꿔서 (단, 2의 m승의 값은 넘지않는다.)
비트에 제한을 두는것이다. 10bit라고 가정하자, 들어오는 정수값이 10bit내로 표현가능하다면 자기에게 해당하는 것을 각각 뽑아서 스트림으로 묶고 2의 좌승의 형식대로 알맞는 위치의 값을 곱해준다. (DGIM Method를 돌린다.)

## Filtering a data stream : Bloom filters
Bloom filters의 목적은 Membership check
많은 Data stream이 들어올때 속하는지 안속하는지 체크, 헤시를 쓴다. Complexity 가 1 이다. 
헤시테이블 size가 한정되어있기때문에 데이터를 줄여서 담는다. 

## Counting distinct elements : Flajolet-Martin
Data stream이 들어오는데 중복된 데이터속에서 unique 데이터를 찾는것이다.
ex)아마존, 상품에 대한 판매목록을 확인코자 할때 100000번이 팔렸어도 상품은 한개만 팔린것으로 체크 이런경우

## Estimating moments: AMS method
moment는 데이터가 나타난 횟수이다. 각 데이터가 나타난 횟수에 제곱을 해서 더하는것이 정의다. 
표준편차로 숫자가 균등하게 분배되었는지 보여준다(값의분포), moment가 분포도를 보여준다. 
표준편차는 식이 복잡해서 moment를 쓴다.(비슷한 근사값)

## Finding frequent items : Exponentially decaying Windows
(현재)데이터중에 가장 인기 있는 items 찾는것, 자주 나타나는 데이터
현재 가장 많이 팔린것에 weight를 두는것이 Exponentially decaying Windows다. 

## Detail : Filtering Data Streams
저장하고 싶은 key set이 포함되서 온다.
ex) 메일, 스팸이면 전달x, 일반적이면 전달o
주어진 key list(set)이 많은 수의 이메일 주소는 다 일반적이다. 이외에서 오면 스팸으로 처리한다고 가정
많은 수 = 1000개
1000개 이메일 주소에 메일이 날아올때 메일의 주소가 이 1000개 속에 있는지 없는지 확인해야 함.(빠르게) 있으면 o, 없으면 스팸
=>Bloom filters는 membership check(test)다. 1000개가 member라고 생각하고, 들어온 membership을 주소로 check해서 존재하는지 없는지 확인하는 방법이다.(빠른시간에)
헤시 테이블을 사용한다, 데이터들을 다 저장할 수 없다. 메모리가 제한되어있기 때문에 
###### Publish-subscribe systems
검색시 키워드만 나와서 보여준다.(멤버심 테스트)
어떻게 효율적으로 접근할까?

## First CutSolution
효율적인 방법, Bloom filter는 bit array다.(0,1로만구성)
n개의 bit를 가지고 있는 bit array를 만들자! 
0으로 초기화시키고, 헤시함수를 선택, 헤시하고 나온 값의 범위는 0~n 사이의 값이어야 한다. 
10000개 이메일 리스트가 있다, 건전하다. 10000개를 다 가지고 온다. 헤시 하고 헤시해서 나온 값을 bloom filter에 저장한다. 헤시에서 나온 결과를 0~n 사이(=n bit를 가지고 있는 array 생성하고 헤시 값이 나온 위치로 가서 1로 세팅한다.)10000개의 이메일 주소가 있으니까 10000번 시행한다. n개의 bit가 (n은 10000보다 크다.) 그중 10000개는 1로 세팅 될 것이다. 현실적으로는 10000개보다 적다.
=>hash collision이 발생하므로 10000개 보다 적다.

좋은 헤시함수에 따라 성능이 차이난다.
10000개의 bit가 1로 세팅되었다고 가정, 이상태가 ready

이메일 주소가 오면 헤시를 하고 bloom filter에 갔는데 1이면 건전한 이메일이다. (이미 건전한 이메일리스트는 저장해둔 상태) 이메일을 보내주면 된다.
0이면, 스팸이다.(기존에 10000개의 리스트에 포함되지 않기 때문이다.)

## FirstCutSolution(3)
Bloom filter의 성질은 

false positives : 멤버십을 했을때 1이면, positive다.
알고보니 값이 없음. 있다고 언급했는데 알고보니 존재하지 않음. 
false negatives : 일어나지 않는다. 반대다. 위와, 없다고 했는데 존재한다. bloom filter에서 발생되지 않는다.

why? bit size를 8 billion bits로 잡았다. 이메일 어드레스를 1 billion 개다. s를 해시해서 b에 넣을것이다. (1billion<8billion) 
1/8차지만, 100% 에러율이 없는 해시함수는 존재하지 않는다. 해시 충돌은 반드시 일어난다. 그래서, 1billion 개를 넣어도 어떤 이메일 주소가 도착했을때 해시를 통해서 1의값이 나오더라도 1billion에 속할 수 있을까? 

같은 값이 나올 수 있다.(헤시 충돌) 1billion내 없는 주소임에도 있는위치에 헤시값이 나올 수 있다. 이것이 false positive(그 위치로 갔지만 실제로 내가 찾는 값은 없음)

bloom filter는 false positive는 일어난다. 반대로, 이메일주소가 들어왔을때 헤시하고 그값이 0이면 1billion에 없다는것을 확실하게 말할 수 있다. 따라서 false negative는 일어나지 않는다.

false positives가 일어날 확률은 1/8이다.(0.125%)

## Analysis: Throwing Darts(1)
다트판은 타겟이 1/m 나눠져있다. 면적은 같다. 동일한 확률
n개 다트를 던진다. m으로 균일하게 나눠져있는 다트에 n개의 다트를 던진다. n개의 다트는 독립적인 실행이다. 

각각 일어나는 확률은 다 같다.(독립적인 실행)
최소한 하나 이상에 다트가 꽂힐 확률은 false positive와 같다. 

하나하나 꽂힐 확률은 1/m이다. 
하나도 꽂히질 않을 확률(=0이 있을 확률) 1-1/m
다트를 n번 던지니까 n을 제곱하면 된다.
적어도 하나의 다트를 받을 확률은 1에서 (1-1/m)을 빼준다.
무한급수의 정의에 따라서 1-e^(-n/m)으로 표현한다.
=적어도 1번이상 다트를 받을 확률(=1로 세팅될 있을 확률)

해시 충돌이 일어날 확률처럼, 1에 갈 확률로 정의내릴 수 있겠다. 1의 비율이 false positive 확률이다. 그 확률이1-e^(-n/m)이다. 

## Analysis: Throwing Darts(3)
0.1175와 0.125 값이 비슷하다. collision으로 값이 살짝 달라진다.

## Bloom Filter
커다란 bit array이다. n개만큼의 멤버를 미리 집어 넣었다.
새로운 데이터가 왔을때 기존의 데이터에서 있는지 없는지 체크
헤시가 하나면 collision 확률이 증가한다. collision 확률을 낮추기 위해서 multi 개의 hash를 사용한다. 
만약 이러한 상태서 새로운 데이터가 왔을때 multi개의 hash에 모두 1이 되어야 ok될 수 있다.=>collision이 일어날 확률이 줄어든다. (단 하나라도 0이면 무시한다.)

## Bloom Filter --Analysis
몇개가 1로 될까? false positive와 관련있다.
n개의 다트를 던지는것이 아니라, kn개의 다트를 던질것이다.
헤시가 k가 되면 k개만큼 늘어나니까 k*n 던지는 다트의 수와 일치할것이고 각각 시행되는것은 독립적일것이다.
만약 헤시함수가 4개 들어나면, 1billion만 수행하면 될것을 4billion만큼 더 수행하게 될것이다.
한번 시행할경우 1-e^(km/m) 이지만, false positive 가 갈 확률을 보면 k개의 헤시함수를 1billion이 수행해야 하므로 (1-e^(-km/m))^k 이다.


## Bloom Filter - Analysis(2)





