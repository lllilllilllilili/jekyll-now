---
post : layout
title : 데이터통신12
---
## 데이터통신12
데이터통신12

## 문제5,6
밴드위쓰 2배하면, 라인의 스피드 리밋도 2배가 된다.
두번째는 snr을 2배한다. snr이 비해서 1이너무작으면 없는것과 무슨 차이가 있냐?
snr을 2배했는데 채널을 통해서 얻어낼수있는 밴드위쓰는 bps는 어느정도까지 올릴수있냐? B만큼 올라간다. (data rate은 b만큼 추가가 된다.)
밴드위쓰 2배로 늘리는경우와 snr을 2배로 늘리는경우가 비용 대비 얻어낼 수 있는것은 밴드위쓰2배는 bps 2배가 된다(data rate도 2배가 되네)

라우터하나가 패킷을 받아서 고속도로를 태우는데 걸리는 시간 1s 
라우터는 헤더를 보고 출력을 결정할 수 있다. 헤더만 들어오면 출력 길을 만들어놓고 줄따라서 만들어서 따라간다. 하지만 이렇게 하지 않고 패킷을 다받고 처리를 한다
다 받은 다음에 헤더를 보고 출력을 결정한다. store and forward 방식이다.

cut throw 방식 (head가 들어오면 길을 만들어놓고 딸려오는 애들은 물흐르듯이 가는 것처럼 만들 수 있다. 들어오면 헤더를 보고 길을 찾는 방식도 있다. 구현되는 라우터는 없다.)

access delay는 신경쓰지 않는다. 문제에서 제시하지 않는 이상 무시한다.

디지털 데이터를 디지털 신호로 바꾸어야 되는 이유를 먼저 살펴본다.
바꾸는 방법은 무엇인지 공부하는 방법

## 회선 코딩
기준선 표류
수신자 입장에서 신호가 하나 들어왔다. 신호에 값을 보고 단순하게 0과 1의 신호의 차이는 0이고 time 신호레벨을 갖는다.
수신자 입장에서 정확히 signal이 왔는데 0에 해당하는지 1에 해당하는지
받은 신호가 정확히 1또는 0으로 안들어 오고 어정쩡한 값이 들어와서 0으로 볼것인지 1로 볼것인지 심각한 문제다.
수신기는 기준선을 가지고 있다. 기준선 이상이면 1로 판단 아래면 0으로 판단, 기준선이라는것이 수신하는 입장에서 0이라는 값과 1이라는값간에 대충 들어온 신호로부터 적정한 선을(중간) 기준선으로 잡는다. 라인마다 품질의 차이로 인해서 대충 low, high 값을 보고 대충 가운데 기준선으로 잡아서 판단을 한다.

보내는 데이터가 계속 0으로 들어오면, low 값이 계속 들어온다. 가끔 high로 되고 
0이 길고 1이짧으면 평균이 되면 기준선이 아래로 간다. (low 값이 많으므로)
high가 계속 오다가 low가 가끔 떨어지면 기준선은 위로 가있을것이다. 전송되는 데이터가 어느 한쪽에 치우치게 되면 기준선도 그쪽으로 간다. 들쭉날쭉한다.
0과 1을 보내는쪽이 균형을 맞춰서 디지털 신호가 만들어진다면 기준선이 적정한 중간선을 유지하지 않을까 기대가 있다.
00000110000000 이면 stream 모양이 구성될 수 있다.

## 기준선이 너무 아래로 내려가서 이후에 들쑥날쑥하는 현상을 피할 수 가 없다.
강제적으로 길게 들어오는 0을 사이에 1을 넣어서 보낸다.
받는쪽에서는 1이 인위적으로 들어갔다고 생각하고 없애버린다. 원래 데이터를 복구한다.
1을 집어넣는이유는 기준선이 표류되는것을 막기위해서 
0이 너무 오래 지속되는것을 막기 위해서.
코딩의 방법이다. ++기준선의 표류문제를 해결하는 완화하는 문제++
표류값이 표류하면 제대로 값을 읽어내기 어렵다.
표류 방지가 필요하다. ++기존의 디지털 데이터를 다른 형태로 만들어서 보낸다.++

## 직류 성분(회선 코딩의 종류)
직류성분의 문제는 전송에 의해서 직류성분은 
라인에 따라서 직류성분을 전송을 못하는 라인도 있다.

집에 들어오는 전화선을 갖고 디지털 데이터를 전송한다고 할때 전화선은 주파수 대역폭으로 보면 200Hz 그 안에는 전송을 못한다.
매우 저주파 영역은 전송이 안된다. 200Hz 이상에서 데이터 안정적으로 전송된다.
200Hz 안에 있는것은 대표적인 값이 직류성분, 상수값이다. Hz가 전혀없다.

상수 전압이 계속간다. 직류성분이 계속있으면 전송이 안되는것이다. 11111111111... 이 이어진다고 하면, high값이 계속 이어진다 라고 하면 
이게 직류성분이 되어버린다. 111111111이 이어지면 못보내니까 강제적으로 0을 집어넣는다던지 인위적인 코딩을 해야 한다.
또는, 전기회로 보면 통신라인에 코일을 거쳐가는 통신라인이 있으면 거쳐가는데 코일이 역할을 한다. 

전류가 흐르면서 코일에서 유기전력이 발생하면서 전류가 유기가 되서 전달이 된다. 통신라인 중간에 이런 부분이 있으면 L이면 +,- 해서 이 부위가 v=L*di/dt 관계가 있다. 코일이
전류가 흐르면 여기에 유도되는 전압이 위의 관계를 갖는다. 코일 상수 L 과 관계를 갖어서 전압이 발생하면서 전류가 유도되는것이다.
만들어진 전압에 의해서 전류가 발생한다.

i는 직류다. 미분값이 0다. 아무런 전압이 유도가 되지 못한다. 전류가 건너가지 못한다. 인덕터를 통해서 전송이 안된다. ++코일이 전송라인상에
코일을 거쳐가는 경우가 있으면 직류는 차단이 되버린다.(신호에 직류값이 있으면) 신호에 직류값을 없애야한다.++

직류성분이 주파수 낮은 성분이 통과하지 못하는 시스템이 라인 중간 중간에 존재할 수 있기 때문에 직류성분이 생기지 않도록 신호를 바꿔줘야 한다.

## 자기 동기화(회선 코딩의 종류)
같은 시그널이 반복되니까 발생하는 문제다.
자기동기화문제, 보내는 쪽에서 8bit를 보냈다. 클락이 8 bit가 갔다.
signal이 갔는데 받은쪽에서도 1이 계속 왔는데 1이 몇bit있었을까? 측정하는것은 받은쪽에서 갖고있는 또다른 cpu를 돌리는 클락인데
보내는쪽과 오차가 있으면 8bit가 9bit로 인식할 수 있다.
보내는쪽의 1bit size와 받은쪽에서 1bit의 size가 서로 폭이 다르면 보낸쪽 9개1을 보냈는데 받은쪽은 10개 1로 인식할 수 있다. 클락의 오차로 인해서

## Effect of lack of synchronization
ppt에서 보다싶이, 보내는쪽이 8bit 보냈는데 받는쪽이 폭이 작은 신호로 12bit로 받았다.
signal이 변화가 크면 문제가 안되지만, 똑같은 신호가 계속 가면 경계가 안보이니까 clock이 간격을 추출해 내기 어렵다(오차가 생기면)
동기화 라는 문제가 생긴다. 
수신자의 bit의 간격이 발진자의 bit 간격과 일치해야 하는데 혹시라도 약간의 오차가 생기면 어떻할까..
문제를 해결할 방법이 coding해야하는 이유다.

3가지 특징 에 대해서 문제를 해결하기 위해 코딩을 해야한다.

## 회선 코딩 방식
Line coding 방식에는 여러가지가 있다.
이중에 여러가지를 살펴본다.
Line coding을 함으로써 3가지 문제가 어떻게 해결하느냐!

## 단극형(Unipolar)
nrz라는것은 not return to zero 이다. 
nrz는 0로 복귀하지 않는다. 복귀하지 안흔다 라는것은 unipolar의 nrz 방식이다.
유니 폴라 = 극을 한개만 쓴다.
+만 쓰고 -는 쓰지 않는다. 0과 1을 표현하는데 1은high 0은 zero 
직관적으로 쉬운 방법이다. 이렇게 보내면 전에 3가지 방식(기준선 표류, 표준전압, 자기 동기화)은 해결되지 않는다.
1이 연속해서 가거나 0이 연속해서 가거나 같다.
이런방식은 쓰지 않는다.
signal이 항상 1에 있다. (high에만) 0과 1 중간지점의 파워가 Normalized power라고 적혀있는거만큼 있다.
내가 signal을 보내기위한 에너지가 이만큼 소요된다.
0보다 큰값을 계속 유지해야 하는 에너지 측면에서 소비되는 것이 크다.
비용이 많이 든다.

## 극형
Polar 방식은 여러가지가 소개되고 있다.
+ 와 - 다쓴다.
양극 모두 평균 전압 준위가 감소가 되고 아까는 1,0 이었는데 polar 방식을 사용하면 0.5 -0.5 쓴다하면 제곱하면 파워가 unipolar 보다 드는 파워보다 덜든다.
직류성분 문제도 완화될 수 있다. 
NRZ, RZ, 맨체스터, 차분 맨체스터 방식이 있다.

## NRZ, non return to zero
두가지 버전이 있다.
0은 high, 1을 negative 방식도 unipolar 방식을 밑으로 내린것과 다름없다.
에너지 문제만 unipolar 방식에서 줄어들었지, 여전히 기준선 표류나 그대로 있다. 
signal을 어떻게 만드는지 원칙 이 나와있다. 
No inversion Next bit is 0 : 앞에 데이터에 비해서 변화가 없으면 0이다.
inversion Next bit is 1 : 변화가 있으면 1
다음에 1이 나타나면 변화를 주고 다음에 0이면 변화가 없다.
NRZ-I 는 high라고해서 positive 값이 1이냐 말할수없다. 신호만 보고 앞뒤의 관계만 갖고 1이냐 0이냐를 판단한다. 
계속 1이면 바꾼다는 거니까 앞서 우려했던 문제를 해결할 수 있다. 계속 0이면...
직류성분의 문제가 연속적인 1에서는 해결할 수 있지만 연속적인 0면 바뀌지 않아서 해결이 안된다.
어정쩡하게 해결한것이다. 비영복귀로 주파수 영역에 시그널을 만들었을때
주파수 특성이 이런것을 보인다. 직류성분 f가 0인 부분이 직류성분이다.
직류성분이 엄청 큰 signal이다. 이방식은 직류성분이 너무 크기 때문에 좋은방식이 아니다.
r=1이면 한 signal하나에 bit 하나다.
따라서, 신호 rate과 data rate의 차이는 s=c*n*1/r 이니까 s=n/2다.
신호 rate이 data rate의 반이다.

왼쪽에 그림에서 밑에 방식을 보면 bit 1을 만날때마다 변화되기 때문에 동기화를 제공한다.
신호 자체에 동기화를 위한 경계정보가 들어있는것이다. 
신호자체에 매 bit마다  신호가 바뀌면 경계가 되니까 동기화 문제가 해결될 수 있다.
계속 0이 이어지면 그것조차 없다. 반만 해결된 방식이다.(연속적인 0인경우는 문제가있다.)
++연속적인 0인경우에는 여전히 문제가 있다. 기준선 표류, 동기화문제, 직류성분 문제도 그대로 남아있다.++

## 영복귀(return to Zero)
한 bit나타내는 신호 내부에서 0이 negative면 중간에 0으로 간다.
1이 positive면 반만 positive고 zero로 간다.
모든 신호 element를 들여다보면, 반주기 이후에는 zero로 가있다.
직류성분을 없애기 위해서 한다.
중간에 0으로 돌아간다.
주파수 영역에서 보면 f=0인 성분이 없다. 직류성분이 제거 된다. 주파수 영역에서 대역폭이 굉장히 넓다.
왜? 대역폭이 많이 가냐면 구지 바뀌니까 신호 element가 내부가 항상 바뀐다 zero 가는 변화가 있어서
주파수 성분이 오른쪽으로 갈 수 밖에 없다. 
not return to zero 보단 자주생긴다.
1을 기준으로 갖고 이전에는 1 이전에 중요한 성분이 치우쳐져있는데 이건 1을 중심으로 거의 오른쪽으로 많이 shift 되어있다.
원하는것이다. 직류성분 문제.

변화가 생기므로써 동기화 문제도 해결된다.
1bit 간격안에 정보를 signal의 변화가 항상 있기 때문에 한 bit 간격에 대한 정보를 간접적으로 보여준다.
1bit 사이에 변화가 항상 있다. receiver는 이러한 변화로 캐치할수있다. 
단점 : 대역폭을 많이 쓴다.

## 2
3가지 라인코딩이 필요한이유
해결하는 방법을 보면 1과 0을 균등하게 만들고, 직류성분 기준선 표류 문제가 해결되고
직류성분문제도 1과 0을 균등하게 만드는데 1이 연속되거나 0이 연속되거나 하는것을 피하면된다.
자기동기화문제는 비트 간격별로 시그널이 바뀌면 된다.

3가지를 해결하는 방법은 signal이 각 bit 간격마다 변화되는식으로 signal의 변화가 자주 있어주는 식으로 코딩되어야한다.

## return to zero
매 bit간격으로 신호의 변화가 있다.
직류성분, 동기화 문제해결할수있다.
주파수 영역보면 직류성분없고 단점은 bandwidth가 너무 많이 든다.
S에 대한 식을 넣으면 r=1/2다.(한 시그널이 반비트밖에 못가져가므로)
따라서 s=n이다. 
signal rate 과 bit rate이 같은 값을 갖는다.
신호가 굉장히 빨리 바뀐다. 1/2n 보다
신호가 빨리 바뀌는쪽으로 가있다.

레벨 3개를 가지고 운용하니까 (+,-,0) 수신기는 0, +, - 구분할수있는 회로의 복잡도가 늘어날수있다.
이런 문제가 있기때문에 

## Manchester & Deifferential Manchester 방식이 있다.
Machester 방식
각 비트 간격 중간에서 신호를 반전

differential manchester 방식
여전히 비트 간격 중간에서의 반전은 유지, 시작점에서 바뀔것이냐 안바뀔것이냐는 0이냐 1이냐에 따라서

## 4.8
Manchester의 경우 0이면 시그널 모양이 ppt에서 보는바와 같고 1bit 내부에서 +, -로
내가 보낼 데이터가 1이면 -에서 +로
인위적으로 중간에 변화하는것은 항상 주고 -, +로 바뀌냐 +, -로바뀌냐로 0과 1이 구분된다.
애는 2개만 쓴다.

주파수 도메인에서 보면 원하는방식으로 직류성분은 없고(항상 바뀐다. 0이 계속 이어져도 계속 바뀐다. 직류성분이 없다. 항상 비트사이에는 시그널 변화가 있기 때문에 한 bit 간격에 항상 인지가 될 수 있다. 동기화 문제해결) bandwidth도 아까에 비하면 return to zero와 비슷하다. 약간 왼쪽으로 이동했다. return to zero 보단

Differential Macnchester는 다음 bit가 0면 바뀌고 다음 비트가 1이면 안바뀐다. 그림을 그려보면 잘 나온다. 시작 point가 바껴야 되는지 안바껴야하는지는 내가 표현하는것에 1이냐 0이냐에 따라서 차이가있다.
얘도 시그널 하나가 반비트만 표현하므로 r=1/2이다. 차가 2대가 있어야 한사람을 실어나를수있다.

위의 둘다는 동기화 문제를 해결할 수 있고
## memo
위의 둘다는 동기화 문제를 해결할 수 있고 nrz방식에 비해서 manchester와 differential manchester 방식은 2배가 필요하다.
왜냐하면 신호 중간에 바껴야하니까 nrz는 안바뀐다. 밴드위스가 2배가 필요하다.

멘체스터 방식이 많은것을 해결해준다.

## 양극형(bipolar)
3개 레벨을 갖는다. positive, zero, negative
return to zero와 같다.

## ami와 가삼진수
0은 0v이고 1은 나타날때마다 positive와 negative가 바뀐다.
이것을 역으로 구현한것이 가삼진수이다. 
ami(alternate mark inversion) 1이라고 하는애가 +와 -로 왔다 갔다 한다. 
직류성분이 없다. 1이 계속 이어지면 +, - 계속 반복되고 0이 이어지면 계속 0 이니까 직류성분 아니냐라고 볼수있는데, 직류성분은 맞는데 신호가 안간다.
보낼 신호가 없다 0v일때는 1일경우만 오르락 내리락 하면서 신호가 간다. 0일때는 아무것도 안보낸다.

pseudoternary(가삼진수) 연속된 1이 나오면 직류성분이 나올수있는데 amplitude가 0이기때문에 값이 없다.
밴드위쓰도 줄어들어들었다. 신호하나가 비트하나니까 수식이 s=1/2n이고 밴드위쓰도 1아래 영역에 몰려있다. 고주파 쪽으로 없다. 
맨체스터는 1주변에몰려있었는데 이것은 1 아래로 다갔다.
주파수 대역도 적게 필요하다. 직류성분 없어지고

++해결되지 않는 문제, 코딩 해야 하는 이유중에 하나 동기화 문제가 해결되지 않았다.++
ami 방식을 썼을때 0이 계속 이어지면 signal이 안간다. 몇개의 0이 이속에 있는지 receiver쪽에서 혼동할 수 있다.
ami에 long 거리 방식에서 이방식을 쓴다. 그럼 동기화문제를 어떻게 보안할까?
중간에 1을 넣는 스크렘블링 방식을 쓴다.

## 다준위 방식(multilevel Schemes)
신호레벨을 여러개를 사용해서 여러 비트를 하나의 신호에 묶어서 보낸다. 
자동차에 여러 사람을 태워서 보내듯이
r값을 키우겠다.
r이 2,4,6.. 키우겠다. 이런식의 코딩

mbnl이다. 각각이 무엇을 의미하는지 보자.
2B1Q방식이 있다고 하면, 이름체게 안에 만들어진 코드이름이다. 일반적인 이름이고 이중에 하나로 2B1Q로 쓴다.
각각의 자리에 의미하는바를 보면 맨앞에 m은 2진수 패던의 길이
2b는 두개의 바이너리 넘버를 2bit를 n은 레벨 패턴의 길이(신호 레벨 여러개가 있는데 레벨 몇개를 가지고 표현하냐?)
2bit를 레벨 몇개가지고 표현하느냐 레벨 한개 가지고 표현한다. 레벨이 몇개있느냐.
L을 보고 판단한다. L이 레벨의 개수다.
T면 3개 Q면 4개 레벨이 4개있다.
그래서 2B1Q는 2개의 Binary bit를 하나의 레벨로 표현하는데 레벨이 4가지 중에 어느 한개로 표현한다.
레벨을 4개를 쓰면 2bit가 표현이 가능하다는것을 이미 안다.

ppt에 그림, 레벨이 4개니까 00,10,01,11 레벨 4개로 표현할 수 있다. 그중 에 한개를 사용해서 2bit를 표현한다.

2B는 데이터의 종류고 1Q는 시그널의 종류다. mbit라고 하면 2의 m승개의 표현하고자 하는 대상이 있다.(binary라 하면)
이것을 표현할 수 있는 signal의 종류는 L의 n승이다. signal이 L개가 있고 n개의 패턴을 갖고 표현한다.

대상과 표현할 수 있는 표현방식은 이런 관계를 유지해야한다.

## 메모
2bit를 표현하는데 레벨을 3개만 쓴다. 불가능하다.
레벨은4가되어야 한다.
2의 m승 <= L의 n승

레벨로 만들어지는 하나의 패턴의 경우의수가 내가 표현하고자 하는 경우의 수보다 더 많은것이 제공되어야 가능하다.

## 다준위 방식(Multilevel Schemes)
2b1q는 2개의 바이너리 넘버를 패턴은 1개인 q는 4 그러므로 equal이다.
4개의 전압 준위를 이용하는데 그중 하나의 준위를 이용해서 2bit를 표현하는 방식이다.
dsl 기술에서 가입자 전화회선을 사용하는 고속 인터넷 접속 제공에 사용하고 있다.
표에 의하면 
00
01
10
11 
4개의 준위를 어떻게 할당하는지 표에 나와있는데 (앞뒤에 뭐였는지에 따라 4개의 준위를 쓰고 있다.)
negative였는데 01이 왔다. 

레벨 하나로 두비트를 표현한다. 이런식으로 운용된다는것만 알자. 여러가지가 있다.(매치시키는방법이)
직류성분이 어마어마하다. 2b1q는 직류성분이 많이 들어있을까? r은 2다. 수정

## 8b6t
8비트를 표현하는데 신호가 6개 조합으로 신호는 3개가 있다. 
positive negative zero 3개로 이루어지는 신호 레벨3개의6개조합으로 8bit를 표현한다.
-0 -0 ++는 00010001로 바이너리를 약속했다.
01010011은 -+-++0 을 표현한것이다. 이것은 표가 있다.
바이너리 넘버 8비트씩 끊어서 만들어질수있는게 256개 있는데 256 각각에 대해서 조합 이 뭐냐, 어떤 조합이 나올것이냐 표가 있을것이다.
레벨이 3개고 6개 조합이다. 478이다.
노란색으로 표현한것이 보면은 신호레벨이 3갠데 6개 패턴이다. 
처음껄 보면 0이 두개 -가 두개 +가 두개 그래서 평균이 0다.
두번째는 평균이 +다. (+ 1쪽으로 하나더 많다.)
직류성분이 없애야 하는 문제가 있다. 누군가가 +1 쪽으로 더 큰걸 만들었으면 뒤에서 -1 쪽으로 더 크게 만들어서 균형을 맞춘다.

모든 6개의 조합이 0 rate가 0 이라는것은 + 와 - 가 동수, +1인경우를 갖고 256을 표현한것이다.
478개중에 256개를 추출해야하는데 6개 의 조합을 쭉하다보면 +와 -가 동등한애, +가 하나더 많은애를 256개를 모아서 만들었다.각각
그렇지 않은 애들은 어떻게쓰느냐(478중에 나머지 256 제외하고)

## 심화
첫번째 그림은 동수니까 직류성분 없고, 두번째 그림은 +1이 하나더 있다. 그뒤에 -1 하나더큰것으로 상쇄 시켜야 한다.
모든 애들의 코드가 +1 또는 0이다 코드가 그래서 +1인애가 나타나면 뒤에 코드를 쓰는데 6t에서는 +1인 애밖에 쓸수가 없다. 그래서 ++극을 반전시켜서 쓴다.++
+ -- + 0 + 도 +가 하나더 큰데 얘를 극을 뒤집으면 그러면 -가 생긴다. 앞이 +1이고 뒤가 -1이니까 토탈 +와 -의 개수가 even하게 맞춰진다.
+ 
뒤에 쓰다보면 또 어느순간에 +1이 많은 애가나타나면 바로 뒤에 반전을 시켜서 -1이 되게 만든다.

(중요)
++의문, 보내는쪽에서는 맞춰서 보냈는데 받는 입장에서는 반전이 됬다는것을 어떻게알까?++
그래야 원래값을 표로 찾아서 원래 받은 신호를 찾을수있을것이다.
받은쪽에서는 + -- + 0 + 처럼 와야 되는데 반전되서 신호가 오니까 없는것이다. 왜냐하면, 코딩방식에서는 -가 하나더 있는것은 없다. rate가 +1 혹은 0인거만 봤었지 약속한 코딩은 그렇지않은애들은 안쓰기로 약속되어있는데 그렇지 않은애가 왔다. 약속되지 않은 패턴이 왔다. 그러면 receiver는 반전시킨것이구나로 받아들일 수 있다. 

보낸쪽에서는 +1이 하나더와서 -1로 반전을 시켜서 맞춰줬지만 받은쪽에서는 시그널을 보니까 쓰지 않기로 되어있는 -1쪽에 시그널을 보고 보내는쪽에서 반전시켜서 보냈구나를 캐치를 해서 원래 패턴을 본다음에 원래 패턴에 해당하는 바이너리 넘버를 추출해낸다.

## 약속
반전시켰다 정보를 receiver 사전에 알려주지 않아도 반전된것이 오면 원래값을 찾는데 활용한다. 
000 0000 ... 스크램블링 방식이 사이에 1을 집어넣어서 보낸다
0001 00010 받았다. 이렇게 받으면 안됨, 0000 00000으로 받아야 됨 이것을 찾아낼수있어야 한다. 받은쪽은 받고 나서 receiver는 뽑아낼수있는 약속이 있어야 한다.
++이것이 프로토콜이다++ 반전된것을 보내면 받은쪽에서는 스스로 반전시켜서 원래 데이터를 찾는다.
1이 추가된경우는 받은쪽에서 1이 추가된것을 알수있는 약속이 있어야 receiver는 추출해낼 수 이다. 스크렘블링에서 약속된것을 살펴볼 수 있다.
++반전이라는것이 약속의 키워드다. ! ++

## 회선부호화 요약
특징에 보면 코딩을 해야 하는 이유에 대해서 과연 해결이 되느냐, nrz 자기 동기화 문제가 해결되지 않았고 dc 문제가 여전히 있다.

## 블록 코딩
지금까지 라인 코딩이었고, 블락 코딩라는 큰 분류가 있다.
내가 보낼 데이터가 이만큼 있다. 그것을 이 보낼 데이터를 임의로 m비트로 쪼개서 m 비트 각각을 n비트로 바꿔서 
가령, 8비트로 쪼개서 8비트를 10비트로 바꿔서 보내는것이다. 이유는 오히려 보낼 데이터에 비해서 실제 보내는게 더 많아졌다. 밴드위쓰를 더 많이 소모하는 이상한 행동을 하는것인데,
10비트만 보내면되는데 12, 20bit 만들어서 보냈다 라는 의미가 된다.
그게 아까 얘기했던 3가지 코딩을 해야하는이유를 반영하기 위해서 어쩔 수 없이 한것이다. 아까는 라인코딩
블락코딩은 이런식으로 블락으로 나눠서 블락별로 코딩을 한다.
이것도 약속이 있다.

## 블록코딩 
4비트를 5비트로 블록코딩한다.
거기에 대한 mapping 이 있어야 한다. 가령, 4비트로 만들어 질 수 있는게 0000~1111 까지인데 이 각각을 5bit에 어떤 패턴으로 할지는 보낸쪽과 받는쪽이 표로 가지고 있어야 한다.
맵핑 테이블 이라고 한다.
4비트를 5비트로 만들어서 원하는것은, 5비트는 4비트면은 16가지인데 5비트면 32가지이다. 16개만 쓰고 16개는 논다. 16개를 표현하기 위해서 
32개중에 16개를 맵핑시켰다. 어떤 5개 패턴이 양쪽에 이어지는데 0이 이어서 3개를 넘지 않도록 뽑아놓은 애들이다.

0101이 101011 어떤 5개패턴을 이어붙여도 0이 연달아 나오는케이스가 3개를 넘지 않는 방식으로 5개 비트 패턴들이 선택됬다.
11100 뒤에 따라오는 게 어느것이 오든 0이 아나밖에 없다. (앞에)

++내가 보낼 데이터가 0000 0000 이면 코딩을 쓰면 11110 11110 으로 바뀐다. 받은쪽에서는 5개씩 끊어서 봐서 표를 참고해서 0000 0000임을 추출해낸다. 전송은 이와 같이 했는데 실제 전송된 데이터는0이 8개다. 0이 쭉 이어지는것을 피했다. 이런목적으로 블록코딩을 한다. 또하나 목적은 받았는데 표에 없다. 11111이 표에 없다. (만약 받은게 11111) 버린다. error detection이 된다. error 검출이다. 바꼈는데 표에 있는애로 바뀌면 대책이 없지만, 표에 없는 애로 바뀌면 error detection이 가능하다. 2의 5승에 16개의 여분이 남아있다. 16개를 이용해서 error detection도 가능하다. 이외에 control message 용으로도 쓸수있다. 여기에 안쓰고 있는것들 쓸 수 있다. 이러한 이유로 블록코딩을 한다.++ 
