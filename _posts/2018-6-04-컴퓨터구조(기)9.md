---
post : layout
title : 컴퓨터구조(기)9
---
## 시험
1번.  디램 엑세스 타임, 디램은 주소를 row address , column address로 분할해서 row address는 row를 선택하고 거기서 column address로 컬럼을 선택하는 방식으로 access 한다. 
그래서 row address strob = ras 
라스에서 다음 라스까지의 이르는 그 시간 한번 어
디램 엑세스가 시작되서 다음 디램 엑세스가 시작될때 까지 의 시간 그걸 뭐라하냐? 그것을 사이클 타임이라고 한다.
라스가 들어가서 실제 데이터가 나올때 까지의 시간을 뭐라하냐? 그걸 엑세스 타임이라고 한다. 그런데 왜 엑세스 타임하고 사이클 타임하고 달르냐? 뭐가 더 크다 사이클 타임이 더길다 왜? 엑세스 타임 + refresh time이 필요하기 때문에 디램은 

2번. 다음은 무슨 로켈러티에 관한 설명이냐? 영어 해석이 안되서 답을 못썻을수도 있겠다. 
어떤 아이템이 참조되면 그 어드레스 들이 가까이에 있는 close by 가까있는 아이템들이 곧 참조되는 경향이 있다.
그렇다. 무슨 로켈러티? 어떤 아이템이 있으면 그 가까이 에 있는 어드레스들 앞뒤로 그것들이 참조되는 경향들이 있다 . 프로그램에서
스페셜 로켈러티(ppt참고) 공간적 지역성 라고 한다.
어떤 아이템이 레퍼런스되면 그 아이템이 곧 다시 레퍼런스 되는 경향이 있다. 그건 무슨 지역성? 그건 템폴럴 로켈러티 시간적 지역성 이라고 한다. 시간적 측면에서 
그런 지역성을 활용하는게 캐싱 이라고 했다.

3번. 메인 메모리와 캐시 사이에 전송단위를 뭐라고 하냐? 블락이라고 한다. 블락은 뭐 한개의 워드 일수도 있지만 보통은 멀티플 모드, 여러개의 모드 로 구성된다. 다른 말로는 한 워드는 4바이트 이니까 멀티플 바이트로 구성된다 그말도 맞다. 어쨋든 블락이다. 다른말로 블락을 뭐라고도 한다고 ? 라인이라고도 한다. 

4번. 다음과 같이 캐시 블락주소가 결정되는 방식, 메모리 블락이 하나오면 캐시 블락에 어느 블락에 들어가야되는데 그 블락을 어떻게 결정하느냐, 블락 어드레스를 모듈러 나머지 연산이다. 캐시에 있는 블락에 개수로 나눠주는 이런 방식으로 걔의 위치를 결정하는 방식을 다이렉트 , 다이렉트 맵드 형식이다. 

5번. 어떤 메모리 시스템이 8비트 주소를 갖는데 무지무지하게 작은 시스템임 주소가 8비트 
그래서 이렇게 주소가 있는데 한 블락은 4워드로 구성된대 4워드니까 바이트수로 따지면 16바이트가 한 블락이다. 
그러니까 여러분들이 한바이트라고 하면 하나둘셋넷 다섯 여섯 16개가 한 블락이다. 그래서 여러분중에 하나를 cpu가 참조하면 걔만 가는게 아니라 누가가? 걔가 속해있는 16개의 바이트 한 블락이 캐시로 올라간다. 캐시로 올라가서 캐시의 16개의 바이트가 위치하고 cpu 는 그중에서 하나만 가져다 쓴다. 왜그렇게 한다고? 무슨 로켈러티를 활용하는거야 그게 방금 말한 스페이셜 로켈러티를 활용하는것이다. 얘를 지금 cpu가 참조했으면 곧 이어서 얘나 얘나 앞뒤로 가까이있는 놈들을 참조할 테니까 걔를 전체를 덩어리를 미리 가져다 둔다 캐시에 

6번. 밴드위스
다음 설명이 가리키는 퍼포먼스 매트릭스, 성능 측정 요소는 무엇인가 
이거 틀렸네 그래서 해석을 못햇구나 
얼마나 많은 데이터가 단위시간당 제공되는가
밴드위쓰 
대역폭이라고 
단어들은 알아두는게 좋다.
이 용어라는건 뭐냐, 내가 지식에 표현방법이기도 하지만 의사소통에 중요한 수단이다. 다른 사람이랑 얘기할때 대역폭 많이 쓰지만 밴드위쓰라든지 래이턴시라든지 일반적으로 쓴다. 
그러니까 영어용어 특히 글로벌 시대에 용어들을 잘 알아야한다. 
밴드위쓰 트랜스퍼 레잇(전송률)

7번. 다음중 틀린 사실을 모두 고르시오
sram은 dram 보다 집적도가 낮다. 집적도가 낮다라는것은 좋은말이야 나쁜말이야? 나쁜말이다. 집적도가 낮다는 얘기는 단위면적에 심어넣을 수있는 비트수가 몇비트 안된다 그얘기다. 
그렇지, 맞는말이야? 맞는말이지 왜냐하면 sram은 한비트를 구성하는데 트랜지스터가 몇개 필요해? 6개 정도 필요하다.
dram 은 트랜지스터 1개면 된다. 
1개 플러스 컴페스터 (축전지) 
 2.dram은 column access time 은 row access time에 비해서 짧다. 그렇다. row access time이 아주 제일 큰 장애라고 했다. 그거를 읽어내서 버퍼에 담은 다음에 그중에서 특정한 비트를 찾는건 일도 아니다. 그것은 
 3.메인 메모리 와 디스크 사이에도 캐시 기능이 존재한다. 그렇다. 왜냐하면 캐싱이라는것은 꼭 하드웨어 캐시메모리만 캐시를 의미하는게 아니고 우리가 맨 밑에있는 아주 대용량 저장 매체 optical disk , k2 그다음에 하드디스크, 메인메모리 그다음에 캐시 
캐시도 뭐 레벨2, 레벨1 그다음에 레지스터 거기에 이르기까지 피라미드 구조를 갖는다. 여러계층구조에서 낮은 계층에 데이터를 하나 상위에 계층으로 카피해서 올려놓는 모든 그런 작업들 그런것을 캐싱이라고 한다. 그러니까 예를들면 디스크에있는 데이터를 나중에 계속 쓸 목적으로 메모리에 어딘가에 카피해 놨다. 그것도 캐싱으로 
4번. 메모리 계층구조에서 특수한 변수 또는 특수한 데이터는 하위 계층에는 없고 상위 계층에만 있을 수있다. 맞는말이야? 어. 이게 우리가 지난번에 얘기했지만 상위 계층 어딘가에 어떤 데이터가 있으면 그 데이터는 아래로부터 올라온 복제본이다. 그래서 아래에 모든 계층들에 그 데이터가 있어야 된다. 그래서 위에 어느 계층에만 데이터가 존재하고 그 데이터가 아래계층에 없다. 그런일은 있을 수없다. 그것은 정상적인 메모리 계층구조를 활용하는 방법이 아니다. 그것은 우리가 어 우리가 그 용어로는 inclusion property , 포함관계를 말하는 인클루 포함하는 성질을 가지고 있다. 그러니까 아래에 있는 모든 데이터들은 위에 있는것들을 다 포함하는 관계를 가지고 있다. inclusion property를 가지고 있다. 

5번. sram은 주기적으로 refresh를 통해 상태를 유지한다. dram이다. 그래서 4,5 번이 틀렸다.

(중요) 자. 그래서 지금 어 이게 무슨 주소라고 했냐 
이게 바이트 주소라고 했다. 우리가 이제까지 다루던 주소가 바이트 주소다.
그러면 그림을 보면, 우리가 
이게 지금 바이트주소다. 한칸이 한바이트다. 한 칸이 한 바이트고 01234 주소를 매겨서 간다. 
주소가 매겨져서 간다. 자 우리 시험문제에서는 4워드가 한 블락이라고 했는데 그냥 예를들기위해서 조금 사이즈를 줄이지 뭐 
두 바이트, 두 워드가 한 블락이야 두워드가 한블락이면 어디부터 어디까지가 같은 블락에 들어가?
여기서부터 어디까지 
2,3,4,5,6,7,8 
여기까지 같은 블락이다. 
자 워드는 이안에 몇개가 포함되어있어?
워드는 2개가 포함되어있다.
요렇게 한워드고 요렇게 한워드다. 
그렇지 
자그러면 여기에 지금 바이트 주소 4개 옆에 4개에
각 바이트마다 부여된 주소인데 
이 주소를 보면 아 얘가 워드로는 몇번째 워드에 있고 이 바이트가 워드로는 몇번째 워드에 속해있는 놈이고 블락으로는 몇번째 블락에 속해있는놈인지 바로 알 수있다. 
어떻게 지금 이게 상위에도 비트수가 있을 수 있지만 그거는 일단 무시하고 아래만 일단 보면 일단 비트만 보면
이게 지금 바이트순서로 어드레스 를 매긴 바이트 주소면 이걸르 4로 나눈 몫은 어떻게 되지? 오른쪽 2개를 떼버리면 4로 나눈몫이다. 그렇치 이 바이트 주소를 4로 나눈 몫에 해당하는 이 번호가 뭘까? 이 번호가 이게 워드 어드레스다. 바이트주소 가 5면 그걸 4로 나눠 그래서 오른쪽 두비트를 떼버려 그러면 그게 워드어드레스다. 
그게 워드로  따졌을때는 몇번쨰 워드인가를 나타낸다.
요게 지금 자 
여기 a,b,c,d 4바이트 는 다 워드 0에 들어가 있는것이다. 
오른 쪽 두 비트 다 떼버리니까 다 뭐만 남어? 0만 남는다. 그다음에는 e,f,g,h는 워드 몇번이냐 워드 1번이다. 워드 0 다음에 워드1번이다. 오른쪽 두비트 다떼버리니까 뭐만 남어 1만 남지 그렇지
그래서 바이트 주소에서 워드 주소를 찾는방법은 오른쪽 2비트를 떼어버리면된다. 
그러면 마찬가지 원리로 어떤 바이트가 속해있는 걔가 속해있는 블락의 주소를 아는방법은 어떻게 되느냐? 블락의주소 방법은 그 블락을 구성하는 크기 만큼 오른쪽을 떼버리면된다. 지금 한 블락이 8바이트로 구성되어 있잔아 두워드는 8바이트잔아 8바이트로 구성되어있으니까 이 주소를 멀로 나눠주면되? 8로 나눠주면 되지
8로 나눠준 몫이 걔가 속해있는 블락의 넘버다. 블락주소
8로 나뉜다 얘기는 오른쪽의 3비트를 떼버리는것을 의미한다 
3비트를 쭉 떼. 자 쭉 뗴면은 여기까지 다 머만 남아 왼쪽에다 다 0이야. 무슨얘기야 a부터 h까지 속하는 요 8개의 데이터는 전부 블락 몇번? 0번에 속한다 그다음부터 i,j,k 얘들은 블락 몇번에? 블락 1번에 속한다. 그러면 문제가 간결해 졌다. 자 주소가 크면 바이트 주소가 크면 그러면 그 주소를 멀로 나눈다? 어 블락을 구성하는 바이트의 수로 나뉜다. 그렇지? 그러면 그 몫이 블락넘버다. 
구지 뭐 나누고 이러고 할 필요가 없는게 블락을 구성하는 그 블락의 개수는 2의 지수승개다. 4개 든지 8개든지 16개 든지 
2의 지수승 개니까 그냥 비트를 떼어주면된다.
2로 나누면 한비트 뗴어주면되고 4로 나누면 두비트를 뗴어주면되고 8로 나뉘면 3비트 16으로 나누면 4비트 그렇게 떼주면되는것이다. 
그게 지수승 형태

자 그래서 아까 문제로 돌아가면 이게 주소야 .
여기에 어떤 데이터가 있겠지
자그러면 얘가 속해있는 블락 넘버는 어떻게 해야되? 
이주소를 뭘로 나눠줘야되? 이게 지금 바이트 단위의 주소니까 그렇지 16으로 나눠주면되 오른쪽 몇개를 떼? 4개를 뗸다.
4개를 뗴면 1010 이다. = 10이다.
블락 넘버로는 10이다.
블락 넘버로는.. 
10101100
자그러면, 자 얘와 함께 얘와 함꼐! 속해있는 바이트들은 바이트 주소는 몇번 부터 시작해서 몇번까지 일까? 얘와 같은 블락에 속해있는 바이트들은 얘의 동료들 
어떻게되? 자. 어떻게되? 
블락 넘버는 1010 이라고 했다. 자. 얘의 속에 있는 바이트가 몇개? 16개 그렇지 그러면 그16개 첫번째는 0000이겠네 그리고 걔의 마지막은 뭐야 1111 이겠다. 
항상 선두에는 뭐가오고 1010 이 오고 
1010 이 오고 그렇지 
1010 0000 ~ 1010 1111 바이트까지
이 16개의 바이트가 한 블락을 이룬다. 
그래서 프로세스가 이중에 어느 하나를 가지고와 이렇게 엑세스 해도 걔만 가는게 아니고 어떻게가? 걔가 속해있는 이 16바이트 덩어리가 쭉 가는거야 캐시로 그래서 캐시에 적재 되고 그다음에 그중에서 요구했던 이 데이터가 프로세스로 들어간다. 이해되냐?

뭐가 들어있는진 모르지만 

## 진도
한번더 반복
이거, 블락 넘버가 1010 이지 
그러면 1010 블락에 들어있는 맨 첫바이트는 어떻게되? 
여기에 비트가 지금 0000 이지 그렇지
왜냐하면 16개가 번호를 갖게 되니까 16개가 0000~1111까지 16개라고
그러면은 이 블락의 첫바이트는 1010 0000 이고 
이 블락의 마지막 바이트는 1010 1111 이지
이렇게 연속된 16개가 한 덩어리, 한 그륩이다.
그리고 얘들이 캐시로 올라가고 그리고 캐시로 올라간 다음에 그다음에 거기서 프로세스가 진짜로 필요한 데이터는 그다음에 거기서 가져간다. 
그러면 조금더 진행을 해보자

## 진짜 진도
자 그래서 우리가 지난번에 얘기했듯이 
메모리가 있고 캐시가 있는데 메모리에서 이렇게 캐시로 올라다니는 이 단위는 블락이기 때문에 우리는 이제부터는 이 적어도 이 안에서는 관심이 블락에 있다. 
물론 이안을 구성하는 바이트들도 중요하지만 우리는 관심이 블락단위로 움직이는데 관심이있다. 그래서 여기다가 매긴 이 번호는 블락 넘버다. 블락 넘버, 블락 어드레스 라고도 한다. 
자 당연하겠지만 이 메모리에서 읽은 이 블락들을 메모리 블락이라고 하고 캐시에서 집어넣은 이 블락들을 캐시에 있다고해서 캐시 블락이라고 한다. 
자 메모리의 한 블락의 크기하고 캐시의 한 블락의 크기는 당연히 같아야 한다. 
그런데 이 블락이 이렇게 뜨면 이 블락에 해당하는 데이터를 캐시에 어디에 둘까 이거는 이 캐시가 용량이 어떻게 되느냐 하고도 밀접한 관련이 있다. 캐시의 용량이 얼마안된다. 캐시의 이 블락이 몇개짜리야? 8개 짜리다. 그렇지 8개짜리 자 그러면 
어떻게 하느냐 어 어떤 블락은 어떻게 위치시킬것인가 
그 블락 넘버가 나와 
그럼 그 블락넘버를 캐시가 제공하는 캐시블락에 개수로 모듈, 나머지 연산을 취해준다. 그러면 걔의 위치가 정해진다. 자 그런데 우리가 이렇게 있을때 
우리가 이진수에서 나누기 할때 2의 지수승으로 나눌떄 오른 쪽의 비트를 떼줬다. 그렇지 
떼주고 얘가 몫이 어떻게되냐 몫이
모듈연산은 역시 마찬가지 기법을 취하는데 이번에는 취하는게 이부분을 취한다. 예를들어서 16으로 나눈 나머지, 어떤 수의 16으로 나눈 나머지 를 알고 싶다. 그러면 오른쪽에 4비트야 왼쪽 버려버리고 그게 16으로 나눈 나머지다. 그렇지 
이게 몫, 왼쪽이 몫이니까 오른쪽이 당연히 나머지다. 그렇지
여기서 그러면 자 
블락 주소가 있어 얘를 이중에서 어디에 집어넣을까요 
어떻게 얘의 블락주소를 이거의 개수 8로 모듈을 취하니까 8로 모듈을 취하면 오른쪽에 3비트만 남는다. 얘가 들어갈 블락 주소, 어디로가 1번으로 간다. 
여기 011101 이란느 블락넘버가 있어 그러면 얘 어디로 가 
오른쪽 3비트만 취하니까 왼쪽 버리고 그러면 101 몇번이야 이게 5번이다. 5번으로 간다. 그렇지 
그렇게 하는거다 이렇게 가는것이다.
이렇게 위치하는것이다. 이런 위치 배치 방법을 다이렉트-맵트-캐시라고 한다. 
무슨 얘기냐 걔의 블락주소가 정해지면 걔가 들어갈 캐시의 위치도 정해진다. (중요)

그래서 블락 어드레스를 블락 넘버라고도 하고 블락어드레스 라고도하는데 이 블락 어드레스를 나머지 연산을 취하는데 뭘로 나머지 연산을 취해? 캐시에 들어있는 블락의 개수로 

만약에 캐시가 용량이 적다. 그래서 8개가 아니고 4개의 블락만 제공된다. 캐시가 그러면 뭘로 나눠줘여되 
4로 모듈을 취해야된다. 4로 모듈을 취할때는 오른쪽 몇비트가 나머지야 2비트야 
1번 1번 1번(01 01 01 이거 말하는듯)
무슨 일이지 이게, 공교롭게도 이렇게 되어있는게 4개의 블락을 가진 캐시를 사용할 경우에 전부다 어디로 맵핑이 되 같은 자리로 전부 맵핑이 된다. 이게 무슨 현상이 나타나냐면 
이게 프로글매에서 사용하는 데이터 인데 cpu가 얘도 쓰고 얘도 쓰고 이렇게 막왔다갔다 하면서 데이터가 쓰는데 공교롭게도 캐시에 같은 자리로 다 대응이 된다. 그러면 무슨일이 일어나겠어?
처음에 얘가 이렇게 가서 어 여기 이제 4자리 그러면서 있었는데 조금있다가 얘가 올라오면서 너 저리가 내가지금 여기 써야되 
그러고 있으니까 조금 있더니 얘가 또 오는 
아니야 내 자리야 이렇게 
같은 자리를 놓고 계속 쫓아내고 쫓겨나고 이런 현상들이 발생한다. 그렇지 
그게 다이렉트 맵드 캐시는 이게 굉장히 쉽게 구현을 할 수있는 반면에 같은 자리에 충돌할 수있는 가능성이 상당히 높다. 
다이렉트 맵드 캐시는 

그래서 같은 자리의 충돌을 우리가 뭐라고 하냐? 캐시 충돌
" cache conflict " 라고 한다. 
같은 캐시 블락에 서로 다른 메모리 블락이 올라가는 그래서 그 캐시를 쫓아내는 캐시 블락을 쫓아내는 현상 
그러면 우리가 다시 아까 질문으로 다시 할게
이게 뭐 어려운 수학은 아니지 산수지.
산수인데 조금 익숙해져야 하기 때문에 물어본다.
자, 한 블락이 블락이 사이즈가 몇바이트라고 내가 얘기했나?
그런말 없다. 만약에 이 한 블락이 8바이트로 구성되어있는 경우라면 8바이트로 구성되어 있는 경우라면
여기 8바이트가 들어가 있겠지
그러면 걔뜰의 주소는 얼마부터 얼마까지 뒤에 입니까 물으면 어떻게 해야되?
블락넘버 뒤에다가 000 부터 몇까지 붙이는거야 111 까지 붙이는것이다. 그게 00001 000 이 블락에 첫 바이트 주소이고 
00001 111 이 블락의 마지막에 위치한 바이트의 주소이다. 이해되냐? 
만약에 16바이트면 몇 비트 붙이면되 ? 
4비트를 붙여야되 그렇지
0000을 붙여서 00001 0000 부터 00001 1111 까지가 그 16개가 이안에 들어있는 블락들이지, 바이트들이지 
잘 기억해라 

## Cache Example(1/6)
그다음에 자 그러면 여기서 한가지 
우리가 이제 어떻게 한다고 했어, 그 내가 
이게 캐시야 이게 캐시야 자 프로세스에서 어드레스가 딱 나오면 바로 메모리로 가는게 아니고 머부터 먼저 본다고 캐시 내가 원하는 데이터가 있는지 본다고 그러면 어떻게 하겠어? 캐시는
프로세스가 원하는 주소가 나오면 거기서 뭐를 찾아내겠어? 
거기서 걔가 속해있는 블락 넘버를 찾아내겠지 블락넘버
그렇지?
블락 어드레스를 찾아낸다. 
그다음에 뭘 찾아내냐면 만약에 걔가 캐시에 이미 들어와있다면 어딘가에 들어와 있겠지 그렇지 
그 걔가 들어와있을 위치는 어디야 걔가 들어와있을 위치는 그 블락어드레스 모드 캐시 블락의 개수지(이건 오른쪽을 취하는 것이다.) 그렇지 그래서 거기를 딱 가보는거야 만약에 그 블락이 여기에 들어와서 이미 들어와있었다면 거기에 있을거라고 그렇지 딱가서 봤을때 뭐를 보냐 이 v가 valid bits
요 캐시에 데이터가 적재되어있는지 데이터가 들어와있는지 안들어와있는지를 구분해주는 비트다. 그런데 지금 뭐라고 되어있어 
No 라고 되어있지 
데이터가 없단 얘기다. 이거 캐시 미스다. 
그것은 데이터가 없는것이다. 
그런데 만약에 이게 어 No가 아니고 만약에 
어느 그냥 
뭐 자 cpu에서 10101101 이런 주소가 나왔다고 하자 그리고 어 16바이트로 한 블락이 구성되어있는 지금 시스템이다. 
그러면 어떻게해 지금 여기서 오른쪽 4비트 따내고 이게 블락 주소다. 이게 블락 주소가 여기에 지금 캐시 블락은 몇개로 캐시블락이 구성되어있냐? 8개잔아 그렇져 그러면 직접사상이라면 101 이라는 이 블락은 몇번 캐시 블락에 가있을까요 1010 에 오른쪽 3비트 
이게 이 블락이 들어갈 자리다. 그러면 
010 이지 그렇지 010 여기다 여기에 가서 데이터를 찾아가는데 먼저 뭘봐 이걸 보는거야 (이거 아마도 전 페이지를 의미하는것 같다)
근데 데이터가 없대 그러면 안올라와 있는것이다. 그러면 메모리에서 저 블락을 읽어다가 여기다가 뚜르륵 채우고 그다음에 여기를 아 이제 데이터가 있다 하고 yes로 고쳐넣는다. 그렇지 
그런데 이걸 생각해봐 
어드레스가 떳어 거기서 블락 어드레스를 찾아냈어 그리고 그 블락어드레스를 가지고 캐시블락의 개수로 모드를 취해가지고 개가 있어야 될 위치를 찾았어 그래서 갔더니 어 valid가 yes야 
ok! 
이거 내가 원하는 데이터야 ! 그래? 왜? 
왜그래? 
그러면 여기 갔는데 데이터가 있다고 그러잔아 
그러면 이게 내가 원하는 데이터지 
어? 안그럴꺼니까 물어본다.
왜안그래? 이자리에 들어올수있는 블락은 여러개 블락이 들어올수있다 아까 봤다. 아까 그림에서 지금 여기에 올라와있을  수있는 블락은 굉장히 많다.
여기에 데이터가 있다고 해서 그게 꼭 내가 찾는 데이터라는 법이 없다. 그렇지 
그러면, 무슨 정보가 필요해 여기에 지금 와있으면 얘가 이놈들 중에서 어떤 놈이 올라와있는거라는거를 거기다가 표기를 좀 마크를 해줘야한다.
어떤 정보를 마크해주면 될까 
어떤 정보? 자 아까 이게 블락주소지 
블락 주소에서 이 010이 뭐야 
자기가 위치할 요고를 우리가 뭐라고 하냐면 캐시에 들어갈 자리, 캐시 인덱스라고 한다. 
어 그러면 여기가 블락 어드레스고 ?? 어디
요부분은 뭐라고 하냐 
offset이라고한다. 

offset, offset은 뭐야 걔가 한 블락안에서 몇번째 위치하는놈인가를 나타내는 상대적인 값이다. 
그래서 0번부터 15번까지 있는거야 예를 들어서 16개의 바이트로 되있으면 offset이 0부터 offset 15까지 
만약에 8개면 offset이 0부터 offset이 7까지 그렇게 8개가 있는것이다. 
자, 요때 요 부분을 지금 우리가 캐시 인덱스라고 하고 그거를 제외한 나머지 어드레스가 있다고 가정을 하면 자 이부분은 고유한 값이다. 고유한값이다 라는 얘기는 무슨얘기야 
이부분은 블락 어드레스가 달라질때마다 이부분은 달라져 
예를들면 여기보면 자 지금 8개의 저 캐시블락으로 가니까 이 블락이 갈 인덱스는 몇번이야? 001 이지 오른쪽이지
그러면 왼쪽에 나온 주소는 00이죠 자 여기 여러분들 칠해놔라 00
자 그다음에 여기 중간쯤에 얘도 001 얘가 속한 블락이 1번 블락으로 간다. 
자 그렇게 곧 남은 요게 01이죠 01 이야
그렇죠 그다음에 여기 001이 이블락에 갈 위치 똑같은 위치로 가죠 
그런데 001 을 제외한 10 이거 지금 까지 봤던거하고 다르다. 그렇죠 이 부분을 고유값이라고 하고 이부분을 또 뭐라고 하냐면 
고유값 (tag)라고 한다. 
tag
그러면 방금전에 헀던 질문을 다시하면 블락어드레스가 나왔어 그리고 거기서 인덱스를 구해냈어 
그래서 그 인덱스의 값을 찾아가 봤더니 찾아가 봤더니 valid 라고 되어있어 자 
완전 hit 가 아니고 어, hit할 가능성이 있을 뿐이다.
자 뭐가 또 일치해야되 tag가 일치해야된다. 
내가 갖고있는 tag 와 그 안에 들어있는 tag 
그래서 항상 캐싱을 하면 얘가 어떤 블락에서 온 놈이라는것을 알려주기 위해서 여기다가 tag 여기에 캐싱 인덱스 를 제외한 나머지 상위비트들 
주소에서 그거를 여기다가 기록해둔다. 
그러면 일단 valid 하다 라고 하면 가능성있는것이고 그다음에 뭘 체크해야되?
이 tag 값과 내가 지금 찾을려고하는 그 address tag값하고 일치하면 내가 원하는 데이터가 들어있는것이고 일치하지 않으면 엄한놈이 들어와있는것이다. 그러면 반쯤 가분좋다 만거고 다시 메모리에서 갖고 올라와야 하고 그게 여기를 엎어쓰겠지 
걔가 올라오면서 내자리야 여기 여기서 엎어쓰면서 뭘 또 바꾸겠어 tag를 방금 올라온 tag 로 바꾸겠지
자 우리가 tag를 알기때문에 여기 들어와있는 놈들에 완전한 주소를 다 결합시킬 수가 있다. 어떻게 결합될까? 
tag 어디에 붙여 맨 왼쪽에 붙여 
그다음에 index를 붙여 그렇지 그러면 블락 넘버가 된다. 그다음에 여기 들어와있는게 000 001 002 이렇게 되잔아 그렇지 offset을 아래에다 붙여 그러면은 뭐든 바이트들의 완전한 주소들을 우리가 파악해낼 수있다. 그렇죠
자 여기 워드 어드레스는 지금 10진수로 표현한것이고 요기는 바이너리 어드레스 2진수로 표현한것이고 어 지금 
지금 가정하길르 여기서 가정하기를 
블락 당 한워드라고 가정해 시크하게?? 이게뭔말
블락당 8개 블락이다.

그러면은 어떻게 되냐 처음에 22번 어드레스 10110을 보면 8개 지금 한 워드니까 
한 워드니까 지금 블락 어드레스는 어떻게 되요? 
오른쪽 두비트를 떼버리면 떼버리면 블락 어드레스다 그렇죠
101 이 블락 어드레스다 그러면 그 블락이 8개 중에서 
이미 이 어드레스 자체가 워드 어드레스니까 이게 결국은 블락어드레스다. 착각을 함

바이트 어드레스는 요기 바이트 어드레스는 지금 어떻게 되지? 바이트 어드레스는 22 고안에 이 4바이트가 들어가 있으니까 22 뒤에다가 여기다가 0001 1011 이렇게 붙이면 이게 바이트 어드레스가 된다. 그래서 지금 여기 에 워드어드레스 괄호하고 블락 어드레스라고 써줘  (???)
Q. 22 뒤에다가 0001 1011 이렇게 붙이면 바이트 어드레스 가 된다가 무슨 말일까?

그럼 블락 어드레스 가 왔으면 이 블락이 어디에 속할건지를 보면은 오른쪽 세비트 이게 블락캐싱인덱스 죠 그렇죠
그러면 110으로 간다. 처음에는 비어있으니까 미스였을 테고 그다음에 가지고 와서 여기다가 채워넣겠지 
그렇지 자 그런데 여기에 10110 에 해당되는 블락이 들어가 있는거야 그러니까 블락 주소다. 그리고 여기다가 뭘 써좋야되? 
사실은 여기 캐시 인덱스를 제외한 나머지 두비트 이게 태그죠, 태그를 여기다 기록을 한다. 
주의 할것은 요건 주소에 관련된 정보들이지만 이안에는 실제로 데이터가 들어가있는거야(주의)
데이터가 몇바이트가 한 워드라고 했으니까 4바이트가 여기에 기록되어있을것이다 거기에 무슨값이 기록되어있는지는 모른다. 이거를 
여러분들 여기 6번까지 한번 쭉 따라가면서 해볼것 해보면 여러분들이 조금더 쉽게 그 익숙해질수있다. 여기까지 

## 질문
16바이트가 한 블락을 가리키니까 4바이트 
4비트를 지워야 남는값이 블락의 넘버가 된다. 
지금 요 강의자료에서는 비트 빼버리고 블락넘버만 보여주면서 지금 설명을 하고있다.

아무동작도 안하는것은 여기에서는 이런 값이 들어가도 여기에서는 동작을 안하는셍미다. 여기서는 EX 단계에서 값이 가야되는 경우에만 이게 의미있게 들어가는것이고 이게 만약에 여기서 0이 들어가서 안쓰면 그값은 여기서 하드웨어적으로 기능한다하더라도 EFFECT를 안미친다.
상관없는것이다. 이게 돌아다녀도 무시하면 되는거니까 근데 지금 그런상황인가는 확인해봐야 하는데 
정말로 그냥 무시 해도 되는지 상황인지는 
지금 원래는 이 단계에서 기록한 값을 사실은 여기로 보내는 일ㄹ ㅗ집어넣어가지고 그렇게 하는거야 여기서는 아무일도 안하니까 
여기서는 아무일도 안하는셈이니까 
너희들끼리 값을 주고 받아도 don't cate한다.

no-operation이 들어가면 걔들이 쭉 밀려들어간다. no-operation이 됬다가 그다음에 내가 ex가 되는게 아니고 no-operation이 되면 거기서부터 쭈욱 다 같이 따라가는거고 밀렸던 명령어가 그 뒤에서부터 시작되는것이다. 
