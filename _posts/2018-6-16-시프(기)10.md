---
post : layout
title : 시프(기)10
---
## 
커널에서 전역으로 관리하며
모든 메시지큐에서
하나의 메시지큐서버가 커널의 요청하여 메시지큐를 작성하고 메시지큐 접근 자 를 모든 프로세스는 동일한 메시지큐에 접근하여 데이터를 공유한다.(학)

지난시간에 우리가 네임드 파이프 했었잔아요 네임드 파이프는 관계, 자식 부모 간에 관계가 아닌 일반 프로세스 가 쓰는게 네임드 파이프가 있었죠 따라서 네임드 파이프를 만들때에는 이름이 있었던것처럼 메시지큐도 동일한 용도로 쓰는것이다.
전혀 관계가 없는 프로세스끼리 이것도 뭐 파이프랑 마찬가지다 피포니까
이름을 가져다 주고 그 이름을 통해서 메시지를 주고받을수있는게 메시지 큐인데
사실은 이게 파이프 보다도 기능이 다양하기 때문에 더 많이 사용이 되는 
우리가 지금 강의할때는 소켓을 배우고있잔아요 소켓은 좌우지간 멀리있는 기계들 하는 거고 같은 기계에서 쓰레드나 또는 프로세스간에 통신을할때는 이 메시지 큐를 제일 많이 쓰게 된다. 그래서 이 파이프랑 다른게 뭐에요

## 
파이프랑 다른점?

## 메시지큐스트럭쳐
이 파이프를 이용해서 각 프로세스에 필요로하는 메시지만 가져갈수있게 하고요 
이게 파이프는 다른점을 설명하는거죠 파이프랑 다른점은 메시지에 메시지뿐만아니라 타입을 줄수있다. 타입을 1,2,3 으로 이렇게 메시지를 집어넣을때 1,2,3 으로 주면 메시지 1번 파이프로 돌아가고 큐에 2번 파이프로 들어가고 3번 파이프로 들어갈텐데
메시지를 받는놈이 3번 만 나는 받겠다 그러면 3번만 받게되고 뭐 2번만 받을수도 있고 이렇게 받는놈이 이것을 가져다 타입을 지정을 해서 선택을 받을수있다 라는게 장점이다.
그래서 이런거는 소위얘기하는 멀티플렉싱이라고한다. 
만일에 여러개의 프로세스하고 여러개의 이거 집어넣는 프로세스하고 여러개가 받는다고 하면 
이거 하나를 이용해서도 가능하다 타입을 가지고 분류해서 야 우리끼리는 타입 1번만 주고받자 그다음에 우리끼리는 2번만 주고받자 하면 그것을 골라서 받을수가있기때문에 여러프로세스가 이것을 공유할수있는게 메시지큐에 특징이다.

## 
찾아봤을때 여러개중에 몇가지만 나와서 첫번째로 이 
msg tim 조작권한을 기술하는 구조체구요 
그리고 이 틀의 현재 바이트수를 확인하는 거고 그다음이 현재 대기하고 있는 메시지 큐 를 확인하는 것이다.
그리고 큐에 할당된 최대 바이트수를 확인하고 마지막 그 메시지를 센더하면 pid 를 확인하는 거가 이 msg 이고

이거는 이제 인터널의 문제다.
메시지큐를 디스프라임 하는 인터널 구조이기 때문에 여러분들은 사실 메시지를 큐를 사용할때 이거를 몰라도 상관이없다. 그래서 메시지의 여러가지상황, 그러니까 예를들어서 여기 보면 이 전체 메시지에 큐의 길이라든가 아니면 한 메시지가 가질수있는 최대의 길이라든가 이런 메시지 큐의 속성을 가지고 있는 디스크립터가 되겠다 그러니까 특히 이것을 딱히 사용하는거는 아니기때문에 그런게 있다 라고 넘어간다 중요한게 아니다

## IPC Permission
리드 라이트 할수있느냐 라이트 할수있느냐 이거를 얘기하겟죠 이것도 이제 인터널 한 구조이기때문에 그냥ㄴ ㅓㅁ어간다.

## 메시지 큐 시스템 파라메터
msgmnb 하나의 메시지큐에서 최대 바이트수를 지정하는 파라미터 
msgtql 메시지 큐 헤더 의 개수를 정의하는 파라미터 이다.
msgmni 최대 메시지 큐의 식별자수를 지정하고
msgmax 하나의 프로세스에서 다른 프로세스 에 보내줄때 최대 메시지 사이즈 를 지정하는 파라미터

요거는 뭐냐면 메시지큐에 전체의 길이를 얘기하는데 디폴트가 얼마라는거에요? 파이프도 그랬었고 4k다 이런얘기다
4k가 꽉차면 보내는놈이 어떻게 된단 얘기에요? 기다려야된다.
그얘기고 요거는 뭐냐면
메시지 ?? 넘버 오브 메시지는 여 큐안에 이제 메시지들을 보내면 이게 큐가 쌓일거 아니에요 그 개수에 한계가 50개다 이런얘기고
요거는 메시지 큐를 우리가 이제 api 같은것을 통해서 메시지 큐를 만들떄 최대 50개 까지 만들수있다 일반적으로 파일도 몇개까지 오픈되냐면 디폴트 로 50개까지 오픈이 된다.
그다음에 맥시멈 메시지 사이즈는 요 개별 메시지 사이즈가 얼마냐 최대한 그게 2k정도된다.

## 메시지겟
메시지 겟함수는 메시지 큐를 생성하는 함수 인데 이 첫번쨰 인자를 메시지큐를 만들고 그것을 참조하기 위한 식별번호로 인트형의 숫자로 쓰이구 그다음이 msgfig는 어떻게 생성하고 참조할지 에 대한 행동양식을 정해주는 아규먼트이다.
기존 
그래서 리턴값으로 는 기존 그 식별 번호로 생성된 메시지 큐가 있다면 해당 메시지 큐에식별자를 돌려주는 리턴값을 갖습니다.

이게 뭐냐면 여기에는 나하고 저기있는 프로세스하고 이제 메시지큐를 만들어서 통신을 하고싶다. 그러면 메시지큐를 여러사람이 만들수가 있으니까 메시지큐를 어떤것을 쓸건지 결정해야되잔아요 둘이 약속 을 해야되겠죠 그래서 만일에 이 t가 5번이라고 하면 이게 무슨뜻이에요
우리는 메시지 큐 5번을 가지고 주고받자 이런얘기다. 
그래서 이것은 메시지 큐에 아이디를 나타내는것이고
그다음에 

둘이서 통신을 할려그려면 누군가가 먼저 메시지 큐를 만들어놔야 되겠죠 그렇죠 만들어 놔야지, 메시지 큐를 통신할 수있으니까 처음에 이것을 만들어놓으면 이거 오픈 할떄 와 똑같다 라고 했잔아요 오픈할떄 우리가 무슨 옵션이 있었어요? 파일이 있으면 오픈하는거고 파일이 없으면 크리에이터 할수 도있었잔아요 그거랑 똑같다 그래서 여기서 크리에이터 옵션을 주면 처음 하는 사람이 키 5번을 가지고 메시지 큐를 만들어놓는거에요 그러면 거기에다가 통신을 하고 싶은 사람은 나중에 몇번을 가지고 오픈하는 겁니까 t 5번을 가지고 그 메시지 큐를 가지고 오픈을 하면 두개 가 연결 이 되서 쓸수가 있다 라는 얘기가 된다. 그래서 이 t라는건 나중에 여러개의 메시지 큐중에서 너하고 니캉 내캉 을 메시지 에 큐에 번호를 얘기하는거고 그리고 처음 만든 놈은 크리에이트 를 해야 될것이고 두번째 로 들어오는 놈은 뭐만 하면 되겠습니까?

오픈 만 하면된다. 그렇게 식별을 해서 쓴다. 

!t가 아니라 키다.

## 메시지 센드
이렇게 사용되고 첫번째 인자는 메시지 큐 아이디로 메시지 큐 식별자 받아오고 

여기서 메시지 큐 식별자라는 건 메시지 겟을 하면 내가 5번 메시지큐 를 쓰겠다 라고 그랬으면 그것을 오픈을 해서 디스크립터로 얼로 돌려줍니까 그 인테저로 돌려주는 그 번호가 있을거아니에요 그 번호, 파일을 오픈할때도 우리가 뭘 받아와요? 번호를 받아오잔아요 그 번호를 얘기하는것이다. 고게 메시지 큐에 번호가 되겠습니다.
그다음에 요거는 메시지 큐의 포인터로 메시지 큐에 넣고자 하는 구조체를 
메시지 큐 포인터가 아니라 메시지 포인터입니다. 
그래서 아이엠 어 보이하면 아이엠어 보이 어드레스가 여기 들어가는거고 요거는 메시지의 사이즈 가 들어가는 거고 요거는 메시지의 전달 옵션으로 블럭킹 을 할건지 안할건지를 정해주는

이거는 디폴트로는 블락입니다. 디폴트로 블락이라는 얘기는 보내는놈이 메시지큐에다가 메시지를 집어넣어야되는데 메시지 큐가 어떻게 됬어요? 메시지큐가 꽉찼으면 기다려야 될거아니에요? 언제까지? 메시지가 빈공간이 생길때까지 블락이 디폴트로는 되는데 나는 그게 싫다 이거임 그러면 여기에다가 IPC_NOWAIT 이라는걸 항상 집어넣으면 어떻게 됩니까? 집어넣을 공간이 없으면 에러 리턴을 한다 이런얘기다. 그런 옵션을 셋팅하는것이다.

## User Message Structure
어 마이 타입에 이부분을 필수 요소로 들어가야 되는 한다고 하는데 마이타입은 메시지 타입으로 반드시 0보다 큰 정수가 들어가 야 합니다. 
그러고 이것을 다르게 줌으로써 특정 프로세스에서 특정 메시지를 참조할 수 있도록 도와준다고 한다.
요거는 이제 메시지를 집어넣을때 여기 번호를 집어넣으면 요거에 메시지의 타입이 되는것이다 그래서 여기다가 1을 넣으면 상대방이 받을떄 1번만 받을수도 있고 2번, 내가 2번을 넣어서 보내면 그건 안받는거에요
그건 단놈이 받아가든지 큐에 의해서 계속 남아있는거니까 요 번호를 가지고 메시지의 종류를 구별을 해서 여러가지 메시지를 한꺼번에 큐에다가 집어넣을수 있겠죠 그렇게 되면 그래서 이게 편리하다 이런말이다.
ㅇ
이거는 이제 메시지의 본체가 되겠다 그래서 메시지의 본체앞에 항상 뭐가 붙느냐면? 메시지의 타입이 붙는다. 
메시지의 타입은 어디갔어??
센드를 할때 메시지의 앞에 뭐가 하나 붙는 모양이네 
다음으로는 메시지 

## msgrcv(2)
첫번쨰 인자는 역시 마찬가지로 메시지 큐에 식별자를 받고 두번째 인자로는 그 메시지 데이터가 저장될 구조체를 받구요 
세번째는 그 구조체의 크기를 갖고 그다음이 메시지의 타입을 정합니다.
그리고 나서는 이제 옵션으로 블락을 할지 안할지 정한다.

이거는 똑같다 0으로 하면 디폴트 란 얘기는 내가 원하는 메시지가 없으면 들어올때까지 어떻게 된다 라는 얘기입니까? 블락되서 기다린다 라는 얘기고 IP_NOWAIT 라고 하면 메시지가 없으면 즉시 어떻게 해라? 에러 리턴해라 그런얘기다
우리가 화장실이 차있으면 에러 리턴 해서 다른데로 갈수있잔아요 락 할떄도 그거랑 똑같은 얘기가 되고 
여기서 보면 메시지 타입을 줬는데 메시지 타입을 양의 정수로 주게 되면 이걸 만약에 2로 주게 되면 무슨 얘기에요?
여러 메시지가 있으면 나는 뭐에요? 메시지 타입이 뭐 인것만 받겠다 라는 거에요?2번인 메시지 타입 이 2번인 메시지만 무슨 순서로? FIRTST IN FIRST OUT으로 받겠다 라는 얘기다.

## 마이타입
마이 타입, 메시지 타입은 메시지 구조체에 접근 가능한데 첫번째로 
0이 들어가는 
케이스 0은 어 메시지 큐에 첫번째 데이터를 얻을 수있고 
이거는 무슨얘기에요
그 숫자 0을 
메시지 타입은 1,2,3,4,5 로 나가는데 메시지 타입을 0으로 줬잔아요 이거는 메시지 타입을 구분하지 말고 무조건 뭐를 받아라? 앞에 있는거는 아무거나 받아라 처음에 들어와있는거는 
그런얘기다.

이거를 0이라는 얘기는 이제 메시지 타입을 구분하지 않고 무조건 폴스트인 폴스트 아웃으로 들어온것을 아무거나 받아달라 이말이다.
n이 이제 양수면 어떻게 되는거에요
그러면 그 원하는 이게 만일에 3번이면 나는 뭐에요 다른 거는 필요없고 메시지 타입이 3번인 메시지 중에서 제일 처음에 들어오는것을 가져다 달라 이런말이다.

0보다 작으나 첫번째 데이터를 받을수있다.
이거는 만일에 -3을 줬다 라는 얘기는 -3을 주면 1,2,3 중에서 순서가 메시지 타입이 1번 인것을 먼저 주고 그게 없으면 2번인것을 주고 그게 없으면 뭐한다 얘기에요? 3번 인것을 준다. 

그다음에 이 IPC_NOWAIT 을 설정하는데 가져올 메시지가 없어도 해당 영역에서 블락되지 않고 에러 코드를 리턴하는 것이다.

## msgctl(2)
제어함수이다.
메시지 컨트롤
제어함수인데 처음은 역시 메시지 식별자를 인자로 받고 그다음에 두번째 인자로는 어 갖고온 명령을 인자로 받습니다.
그리고 세번째는 이 구조체를 포인터해서 어 cmd를 통해 해당 메시지 식별자 가 가리키는 메시지 큐를 제외하는 기능이 

요거는 뭐냐면 메시지 큐를 만들어놓고 아까 메시지 큐 디스크립터 아까 별로 알필요없다고 그랬죠 여러가지 들어가있는 
메시지 큐의 상태를 가져다 여기다가 리턴받을수도있고 근데 그거위해서 보통 이게 쓰는게 아니라 이거는 보통 그냥 null로 주면되고 커멘드에 뭘 주는거 같냐면 IPC_RMID를 줍니다 이건 뭐냐면 메시지 큐를 다 통신을 다 끝마쳤다. 그럼 메시지 큐가 시스템에 계속 남아있잔아요 여러개의 프로세스가 쓰는거니까
그래서 그걸 지우고 싶을때 쓰는것이다. 그래서 여기에 메시지 큐의 아이디를 주고 커멘드 에다가 뭘줘요? ipc_ 인터프로세스 커뮤니케이션 툴을 지워라 리무브 하란 얘기에요 아이디를 가지고 그래서 메시지큐가 아까 생성을 했잔아요 그거를 가져다 지우는데 보통을 사용을 하는 그런 시스템 api가 되겠다 보통 요것은 우리가 필요가 업으니까  null을 준다.
지울때 사용하는것이라 생각하면된다.

## Message Queue Control commands

보통 스테이터스 같은 거는 여러분들이 볼필요없고 뭐할때만 쓴다? 제거할때 많이 쓴다. 이런얘기다. 

그래서 메시지큐가 있는거를 가져다 어떻게한단 얘깁니까? 지워버린다 얘기고 만일에 센더 프로세스가 리시버 프로세스가 메시지 큐에서 센더 프로세스가 대기하는건 왜대기합니까 
메시지 큐가 꽉 차 가지고 집어넣을수가 없어서 대기하잔아요 그다음에 리시버 프로스세스는 왜 대기하죠 메시지큐에 아무것도 없어서 읽을려고 하는데 없기 떄문에 대기하잔아요 근데 메시지 큐를 갖다가 이제 지워버리면 어떻게 되요? 그것들을 다살려줘야 되겠죠?
그렇죠 그래서 리시버 애니 리시버 프로세스 랑 센더 프로세스 가 만일에 있다고 그러면 이걸 다 깨워줘 버린다 이런얘기다.
마지막으로 메시지큐 인데 

## 코드
해당 부분을 작성을하고 
이 
여기보면 struct 요기 메시지가 이제 보내는 메시지 큐를 통해서 보내는 놈이 메시지를 보낼려고 그러는거에 struct 이다. 그래서 어떻게 구성되냐면 
제일 앞에는 뭐가 있어야 되냐면 integer 가 있어야된다. long interger 랑 똑같음 4byte integer 인데 메시지 타입이 여기에 들어갑니다 나중에 그다음에 여기에 캐릭터 mtext[MSIZE]는 뭐 이게 FF니까 
256 바이트 까지가 되겠다. 256 바이트 짜리 캐릭터 어레이 를 해서 여기다가 메시지를 본체를 다 가서 보낼려고 하는거고 보낼때는 반드시 이타입을 지정을 해서 보내야된다 이거임 

## Sender 
타입을 지정을 하고 그다음에 표준 스트림을 이용해서 입출력을 하고 
아규먼트가 몇개에요 4개다.
첫번째 아규먼트는 프로그램 이름이다 그렇죠 두번째 아규먼트로 들어온게 아규먼트 벡터1 이죠 그렇죠 이게 뭐냐면 무슨 역할을 했어 
key의 역할을 했다 이거임 메시지를 아까 지정하는게 key 이라는게 숫자를 가지고 지정한다 그랬죠 
우리가 그것을 입력으로 받은거야 그래서 만일에 이제 야 우리끼리 이제 뭐하자? 
메시지 큐인데 메시지 큐4번으로 통신을하자 그러면 이제프로그램을 치면서 4를 쳤겠죠 그러면 그 아규먼트 벡터 가 4가 아스키로 들어오는것을 뭘로 바꿔요 ? 인테저로 바꿔서 그걸 key가 되가지고 4번 메시지큐로 만드는것이다. 그래서 ipc_create 니까 무슨말이비니까? 메시지큐를 만들어라 이런얘기다. 먼저 보내는쪽에서 만드는것이다. 그리고 요기에는 뭐냐면 오픈이랑 똑같다. 
이거를 만든 사람이 읽을수있고 만든사람이 쓸수있고 그륩이 읽을수있고 그륩이 쓸수있다 
그래서 만들고 메시지 큐를 가져다 오픈을해서 그 아이디를 큐아이디에다가 가지고 오는것이다. 지금 

그다음에 타입을 받아와서 문자열을 정수로 바꾸고 이제 
요거는 에러가 났으면 에러가 나면 이제 메시지 큐를 지워라 이런얘기다  
그래서 아규먼트 벡터2 두번째 아규먼트로 들어오는건 뭐란 얘기에요? 메시지로 보낼건데 메시지에 아까 타입을 지정해야 된다고 그랬잔아요 1,2,3 중에서 하나를 지정해야되니까 그거를 키보드 그거를 메인에서 받은것이다 키보드 칠떄 그래서 메시지에 타입을 만일에 5을 쳤다 그러면 아까 키는 4번이고 이거 5를 쳤다 그러면 4번 메시지 큐를 통해서 몇번 메시지? 메시지 타입을 5인 메시지를 보낼려고 하는것이다 그래서 
마이 메시지에 메시지타입 을 뭘로 집어넣습니까? 5를 집어넣었다 이런얘기다 그리고 뭘하냐?

메시지를 카피하죠 마이메시지에 아까 캐릭터어레이가 있었죠 그다음에 아규먼트 벡터 3번째로 들어온게 이제 내가 보내고 싶은 메시지다 이거임 아이엠어 보이 하면은 그거를 가져다 메시지 어레이, 캐릭터 어레이 에다가 카피를 해놔서 이제 메시지 아까 p를 통해가지고 메시지 큐는 준비가 됬고 그다음에 메시지의 타입도 받아가지고 메시지의 타입을 채웠고 그다음에 3번째 아규먼트를 들어온것을 메시지 텍스트에다가 카피를 햇어요 그래서 메시지가 이제다 준비가 된것이다 그렇죠 그다음에 뭘합니까? 
메시지 센더를 합니다 . 그래서 메시지 큐의 아이디 그다음에 마이 메시지의 어드레스 , struct 니까 어드레스 를 주고 그다음에 메시지의 길이는 뭐냐면 string length 아규먼트 벡터 쓰리 + 1, 0 에서 
여기에서 스트링에서 아규먼트 벡터 쓰리는 아규먼트 
아이엠어 보인데 여기에 +1 이니까 이게 뭐가 되는거죠? 널 캐릭터가 있으니까 하나를 더해준것이다
그래서 5를 보낸다 이런얘기다. 

## receiver
리시버 프로그램 돌땐 아규먼트 뭘 받아야되겠습니까? 여기나오죠 
umsg
아까 센더가 4번키로 했으면 나도 4번키로 쳐내야 되겠죠 그렇죠 
키를 줘야 되고 
두번째는 뭐냐면 내가 받고싶은 메시지의 타입을 줘야 한다 
그거를 집어넣어라 이거임 
그래서 프로그램 이름하고 요고하고 요거해서 아규먼트가 몇개에요? 개수가 ? 3개다 이런말이다.
그렇지 않으면 이제 너 이제 잘못했어 프로그램 끝낸다.

or 가 빠졌다.
그래서 이제 리시버 프로세스잔아요 
key 가4 번이면 4번지를 가지고 메시지 큐를 오픈을 해야 되겠죠 여기에는 크리에이터 옵션이 없다 
그래서 오픈을 하는데 유저가 리드모드, 유저가 라이트 모드, 그륩이 리드모드, 그륩이 라이트 모드로 오픈을 한다 이런 얘기가 되겠다.
그러니까 이 프로그램을 한기계 에서 같이 돌릴려고 그러면 센더따로 돌리고 리시버 따로 돌려야 되잔아요 뭐붙어 돌려야 되요?
센더 부터 돌려야지 메시지큐가 생성이 된다음에 리시버를 돌려야지 이게 에러가 안나겠죠 그래서 
그래서 센더는 무슨 타입으로 돌려요? 백그라운드로 돌려놓고 그다음에 리시버를 돌려야지 돕니다 그러고 나서 이제 메시지 큐를 오픈하고 뭐합니까
이제 리시브 함수를 쳐서 
마이 메시지 를 받아오죠 그래서 마이 메시지에 최대한 크기
타입이네 
타입입니다. 
메시지 받은것을 printf 하는것이다.

## Results
ipcs -qa 
유저 프로그램들이 인터프로세스 커뮤니케이션 하기 위해서 만들어놓은 도구 들이 있잔아요 
조금전에 뭘 만들었어요?
메시지 큐를 하나 만들어놨죠?
그런것들의 상태를 보여준다. 메시지 큐만 있는게 아니라 아까 네임드 파이프도 있고 나중에 이제 os 시간에 배우겠지만 세마포로 만들수도 있고 그리고 쉐얼드 메모리를 만들수도있다.
그런 인터프로세스 커뮤니케이션 하기 위해서 만들어놓은 도구의 상태를 보여주는것이다. 
어떻게 돌려야되요? 여기보면
센더를 돌려놓고 센더를 이렇게 돌리는게 아니라 & 로 돌려야 된다.
돌려놓고 나서 뭘돌려야 됩니까 리시버 하는 스레드를 돌리면 이제 여기서 도는게 아니라
이거를 먼저 돌려놓고 이거를 끝나도 상관이 없겠다
왜냐하면 
메시지 큐에 있는게 짤려서 나가지 않는다.
리무브 를 안했기때문에 그래서 센더를 돌려놓고 메시지 큐를 만들어서 거기다가 메시지타입이 몇번이에요? 키가 1번이고 메시지타입이 2번이고 메시지 본체는 hello world
ipcs 끝난다음에 ipcs 보면 
메시지 큐 
셋트어드 메모리 라든가 
요건 아직 안배움 세마포로 아직 안배움
메시지 큐가 메모리2를 사용하는데 
큐에 아이디는 0번이고 ???만들었고 
퍼미션은 660 이라는건 뭐에요?
리드 라이트 000 이거죠 
익셉트 퍼미션 얘기하는거고 헬로우 월드를 들어가는데 19바이트가 들어갔다 라는 얘끼는 19바이트는 요거 뿐만아니라 앞에 뭐가 들어가니까 타입이 들어가니까
그리고 메시지는 2개가 들어와있다 메시지는 2개가 들어와있찌?
모르겠는데 돌려봐야 겠다
키는 1번이다
그리고 나서 이제 리시브를 돌리면 헬로우 월드 메시지 툴을 가져다 받게된다. 이거임 

## posix mESSAGE qUEUE
아 우리가 아이타이머가 가지고 숙제했었잔아요
그리고 주기적으로 돌아가는 시스템 만드는거 냈었죠 
거기에 아이타이머 를 설명할때 아이타이머 보다 좋은 타이머가 새로나왔다 그랬죠 그게 무슨타이머?
POSIX 타이머라고 했죠 이거 POSIX 라는거는 OS 표준을 만드는 그거 다. 그래서 POSIX 에서 메시지 큐가 좋은게 나왔다 이런거임
메뉴얼 쳐보면 나오니까 따로 내용은 쓰지 않았는데 메시지 큐보다 쓰기가 편하기 그리고 버퍼 사이즈가 크다. 
크고 메시지 버퍼가 크기때문에 이걸 파일시스템에다가 파일에다가 맵핑을 해서 쓴다. 우리가 강의하는 도중에 뭘 배웠냐면
메모리 맵트 파일 이라는거 기억나죠 그렇죠
메모리 맵트 파일이라는건 파일 이라는걸 어떻게 한거에요? 메모리에다가 맵핑을 해서 메모리에다가 쓰면 그게 파일로 나가는거잔아요 
고 메커니즘을 사용을해서 메시지큐를 만드는것이 되겠다. 그래서 이거를 메뉴얼 찾아보면 사용하는 방법이 유사하기때문에 쓰는데 지장이 없을것이다.
