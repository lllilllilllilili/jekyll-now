---
post : layout
title : 컴퓨터구조(기)7
---
## 복습(what happens during an exception)
어쨋든 exception이 발생한 명령어를 우리가 offending instruction 이라고 했음
그 offending instruction 기점으로 해서 뒤따르는 것들은 다 무용화 시켜야함 앞서가는 놈은 컴플릿하게 진행하게 하고 
그래서 이게 preceding instructions 라는건 그 excpetion이 발생한 instruction 앞서서 진행하던 명령어들은 그대로 완료하게 하고 뒤따르는 succeeding instruction들은 그냥 다 무효화 시킨다.
flush 시킨다. 그다음에 exception에 그 원인을 register에다가 기록을 해야하고
그다음에 offending instruction에 address 
두가지가 중요하다. 왜발생했는가, 어느 지점에서 발생했는가 기록을 하고 
그다음에 뭐해야대? 그걸 처리하기 위한 excpetion handler로 점프해야됨 
여기 prearranged address 가 미리 사전에 준비된 어떤 address가 있음 
보통 인터럽트 라든지 익셉션 이라든지 이런것들은 이러이러한 것들이 발생할 가능성이 있다고 생각하고 그것들을 미리 처리하는 간단한 핸들러들을 미리 operating system 같은 경우에 다 준비를 해둔다.
그래서 거기로 점프하는거임
이것을 이름하여 exception handler 라고 함
인터럽트를 처리하는것은 인터럽트 핸들러라고 하고 익셉션을 처리하는것은 익셉션 핸들러임 
이게 하드웨어에서 자동적으로 일어남 하드웨어 아키텍쳐가 그렇게 설계되어있음

소프트웨어 입장에서는 그러면 여기로 excpeiton handler로 분기해서 오면 소프트웨어 입장에서 오 ㅐ발생했는지 그것을 살펴보고 예를들면 명령어가 잘못됬다 라든지 메모리 어드레스가 잘못됬다 라든지 그러면은 그 부분을 고쳐서 수행할수 있을것이면 고쳐주고 
안그러면 얘는 얘 프로그램은 이상하다 강제적으로 종료시키는게 좋겠다. 이런 판단을 하고 그다음에 예를들면 폴링싱크 프로그램에 종료시킨다거나 이렇게 하고 다시 오픈하는? 
근데 뭐 즉 프로그램을 종료시키면 다시 돌아가도 의미가 없음, 그프로그램은 이제 사라졌으니까 
다시 돌아가는 경우는 정상적으로 수행이 가능하도록 원인 치료가 됬을때 원인이 해결이 됬을때 다시 돌아가서 아까 멈췄던 instruction 에서부터 다시 실행을 재기 하도록 그렇게 설계되어있다.

## Excpetions(그림)
이그림 이거 별거 아닌거같지만 굉장히 중요한 그림임
내가 이거 뭐 예로 뭘 들었지? 내가 책보는중에 저쪽에서 전화벨이 울리는거 그런것을 예로 들었다.
내가 책을 쭉읽고 프로세싱 하고있는데 어느순간에 저쪽에서 사건이 발생헀음 그러면 여기에 어느지점인가 또 왜 여기서 멈췄는가 기록을 해두고 거기에서 그 사건을 처리하는 전화를 받는 프로세스를 내가 거기 가서 처리하는거임
처리하고 이게 exception으로 처리한것이고 그다음에 다시 끝나면 다시 돌아와서 원래 했던 그 멈췄던 시점에서 다시 실행을 재기하는데 중요한것은 지금 cpu를 하나란 말이야 이 cpu가 여기에 명령어도 지금 실행을 해야되고 그리고 이 cpu 가 여기가서 이 처리를 해야됨 cpu안에는 뭐가 있어? cpu 안에는 레지스터들ㅇ ㅣ있다. 그 레지스터라는건 저 쪽에서는 뭔가 처리를 해가지고 중요한 값들을 담아 놓은 일종의 메모리임 
레지스터라는게 근데그게 만약에 뭐 r0, r1, r2 이런 값이 지금 들어있는데 그거 가가지고 여기서 r0, r1, r2에다가 뭔가 값을 쓰는 작업을 하고 다시 돌아오면 어떤 일이 발생해? 저기서 기껏 계산해놓은 값들이 다 사라져 버린다.
그래서 어떻게 하냐면, 여기로 가기전에 현재 있는 instruction의 주소도 저장하지만 cpu안에 있는 register들의 값들도 백업해야 한다. 백업하고 가서 사용하고 돌아와서 그 레지스터들을 다시 어떻게 해? 리스토어 해야한다.
여기 중요한 말이 있는데
must save & restore user state // 유저 스테이트를 세이브 하고 restore 해야한다. 유저스테이트에 중요한 내용중에 하나가 뭐냐면 cpu 레지스터들이 유저 스테이트에 아주 중요한 요소다.

그다음에 
이걸 처리하기 위한 데이터패스상의 변화

## Additions to MIPS ISA to support Exceptions
EPC 라는것을 둬야 하는데 
Exceptional program counter 
프로그램 카운터에 복사본인데 
offending instruction의 주소를 담기위한 레지스터임
어디에 만들어져 있냐면 이 뒤 그림을 보면 35페이지에 

## Additions to MIPS ISA to support Exceptions
여기에 EPC 라는게 만들어져 있음
이 EPC라는값은 사실은 저 뒤에서부터 오는값임
왜냐하면 EPC라는건 현 
얘가 만약에 지금 Exception을 일으켰다면 
자기자신의 어드레스 겠지
그게 offending instruction 이겠지 
그 어드레스가 지금 계속 여기서부터 전달 되서 가지고 간다.
my address를 
그다음에 또 하나 요소가 뭐냐면 
cause 이라는 원인을 기록하는 레지스터임
왜 expcetion? 어떤 형태의 excpetion이 발생했는가 
그리고 또하나가 status ?? 라는 레지스터인데 
여기 중요한 말이 있는데 인터럽트 마스크, 인터럽트 마스크는 인터럽트의 종류가 굉장히 많다.
인터럽트의 우선순위도 여러 종류고 해서 경우에 따라서는 어떤 인터럽트는 허용하고 어떤 인터럽트는 불허하고 이런것을 조정할 수 있도록 되어있음.
그래서 인터럽트의 종류들과 허용여부들을 세팅하는 마스크, 설정하는 마스크를 우리가 인터럽트 마스크라고함
그래서 뭐 예를들면 지금현재 굉장히 중요한 작업을 하니까 별거 아닌 그런 쪼금 딜레이 시켜도 되는 인터럽트 들은 이렇게 꺼진다던지 뭐 그런 작업들을 여기 인터럽트 마스크에서 한다.
그다음에 enable bit라는건 아예 원천적으로 모든 인터럽트를 다 봉쇄할것인지 인터럽트를 허용할것인지 그걸 결정하는 비트임 
그러니까 우리가 처음에 인터럽트가 딱 뜨면 어떻게 하냐면 인터럽트를 받으면 exception을 받으면 일단 enable bit를 0으로 세팅해가지고 가는 다른 excpetion이나 인터럽트가 걸리지 못하도록 막아 막고
그다음에 인터럽트마스크를 조정해가지고 필요한 조정을 하고 그다음에 다시 인터럽트를 인에이블해가지고 그다음 후속에 있던 애가 들어올수있도록 처리를 하고있음

그다음에 또 필요한게 epc cause status 이런것의 어떤 값을 쓸수있어야되니까 그것을 제어하는 컨트롤 시그널이 필요하고 
레지스터니까 레지스터 인에이블 그 신호가 들어가야 값이 들어가겠다.

그다음에 exception address 가 다시 프로그램 카운터로 들어가야되 왜? 나중에 다시 그게 어떻게 그명령어가 다시 실행이 되어야함 그러니까 epc에 들어있던 // excpetion address 라는건 excpetion handler address 야 
그래서 exception은 핸들러 어드레스가 프로그램 카운터로 들어가고 그다음에 멀티플렉서 에 그 인풋을 하나더 추가함으로써 이 프로그램 카운터가 exception address 를 받을 수있도록
예를들면 이렇게 보면은 여기 이건 그냥 가정이다.
80000180 이라는것은 exception이 발생했을때 expcetion handler의 시작주소임 
exception handler 시작주소니까 exception이 발생했으면 프로그램 카운터에 다른 정상적인 프로그램 카운터가 아니고 여기 고정되어있는 exception address가 들어가도록 해야함
그래서 이 mux에 이것을 추가해야 한다. 

그다음에 또하나는 이제 프로그램카운터는 패치함과 동시에 4만큼 증가되겠지 
그렇지 그게 넥스트 어드레스가 되는데 만약에 지금 익셉션이 발생했어 현재 프로그램 카운터는 pc+4로 다음으로 증가됬으니까 
실제로 익셉션을 일으킨 어드레스는 epc에서 4만큼 뺸자리 그게 자기자신의 주소가 되겠지
그렇지 그래서 epc는 나중에 보게되겠지만 
pc 이미 4만큼 변경된 그 pc에서 다시 4를 빼줘야 epc가 뭐가 되냐 문제를 일으킨 익셉션 을 일으킨 자기자신의 명령어 주소가 된다.
그렇게 되도록 조정해야한다.
그거말고 중요한것중에 하나가 이게 제일 중요하다
앞에것은 그냥 가게하면 되는건데 익셉션을 일으킨 명령어 뒤에 계속 따라들어오고 있는 instruction 들은 전부 flush 해줘야 한다.
flush 해주는것은 별게 아니다 뭘? 그다음 next stage 에다가 컨트롤 시그널을 뭘주면되 다 0을 주면 그러면 아무동작도 안하게 된다 그 동작 이 거기서 끝나는것임

## Flush instructions in Branch Hazard
지금 우리가 앞에서 여기다가 여렇게 이 mux에 0을 집어넣는 이값을 input으로 줘가지고 만약에 여기서 해저드가 발생하거나 컨트롤 해저드가 발생해가지고 앞에서 나온 그런 뒤따르는 명령어들을 다 0으로 처리해야 된다고 그러면 여기에 0값이 여기 컨트롤 시그널에 들어가도록 해가지고 이 명령어 는 사라져버리게 그렇게 처리했다 앞에서
이게 이제 excpetion을 처리하기 위해서 역시 마찬가지인데
앞에서 만든거에 추가되는게 머냐면 여기 excpetion, epc 라고 cause하고 두개의 원인이 여기 저장되는데 중요한건 excetpion이 instruction fetch stage 그다음에 instruction decode stage 그다음 execution stage 그다음에 여기 뭐야 memory access 이렇게 여러 스테이지 있는데 여러 스테이지에서 지금 머야? 각각 스테이지에 excpetion이 다 발생할수도 있다.
exception이 다발생할수도있는데 그 expcetion이 발생했을떄 그떄의 그 익셉션 원인하고 익셉션 그 오펜딩 인스트럭션의 주소를 계속 앞으로 전달해서 가지고와서 여기서 보는거다. 여기서 익셉션이 발생했느냐 cause, 그다음에 그 어드레스가 어디인가 보고 익셉션이 발생했으면 이 뒤에따라오는 모든것을 다 어떻게 전부 control signal을 0으로 내보내도록
그리고 그다음에 뭘로 처리해야대 ? 그다음에는 익셉션 handler로 처리해야 되니까 그다음에는 일단은 익셉션 핸들러를 통해서 
요 익셉션 핸들러의 준비된 이 주소가 프로그램 카운터에 담기도록

## Additions to MIPS ISA to support Exceptions(그림)
그래서 여기 flush라고 나오는 이 신호가 다 요 해당되는 여기에 있는 그 레지스터 스테이스하고 여기에있는 그 컨트롤 시그널들을 0으로 클리어 시키는 그런 신호임 
## Exception Example

그래서 만약에 우리가 이제 명령어를 수행을 하는데 어... 요지점에서 arithmetic overflow가 났다.
값의 범위를 넘는것이다.
그러면 이제 이 오버플로우 도 일종에 excpetion 인데 익셉션이면 어떻게 되는가?
어떻게 되야되 여기서 익셉션이 execution 단계에서 익셉션 디텍트가 될것이고 
그러면 얘 앞선것들은 쭉 다 지나가게 하면 될것이고 
그다음에 얘들이 뒤따라올텐데 얘들은 다 0으로 클리어 시켜야 할것이고 그다음에 이지점에서 
excpetion handler 가 여기에있음 80000180 점에 이미 구비되어있다 pc에 800000180 주소가 들어가도록 그렇게 되야겠다. 그러면은 여기에 지금 쭉 가고있었는데 여기  add 이명령어
여기서 수행할때 이상태에서 exception이 발생한것이다.
excpetion이 
지금 원래 add 에 주소는 얼마냐 원래 주소가 4C 그렇져 
add의 원래 주소가 4C임 헥사로
add의 다음주소가 헥사로 50
여기 C가 12잔아 그렇지 
자 그러면 여기 지금 뭐가 보이냐면 50이라는 값이 온다 50이 뭘까 50이 헥사임 
헥사로 50이라는값이 현재 이 instruction에 다음 주소를 가리키고 있는거임 
이거를 지금 여기에서 부터 계쏙해서 가지고오는거야 자기의 다음주소를 
자그런데 여기서 지금 excpetion이 발생했잔아 그러면 epc에는 50이라는 값이 담긴다. 근데 사실은 50이 excpetion을 일으킨게 아니고 하나 전임 그렇지
그러니까 이 epc에는 이값이 담기는데 실제로 나중에 리스타트할떄에는 이 위치에서 리스타트 하는게 아니라 이거 하나 전위치에서 리스타트해야하니까 50-4 에서 리스타트를 하도록 해야한다.

자그러면 익셉션이 발생했으면 앞에껏은 가게하고 어떻게 ? 얘도 이 뒤에 진행하면 안되지 얘 얘 얘 다 뭐야? flush 시그널을 집어넣어서 여기에 다 0이 들어가도록 해야한다.
그래서 다음 시그널을 보면은 그 add 다음에 있던 or는 마지막 stage에 갔고 add도 다음 스테이지 에다가 no-operation 0으로 집어넣어서 bubble 이 들어갔고 그다음에 이전에 있던것들이 다 0으로 왔으니까 다 여기 여기는 bubble로 채워진다. 
여기는 다 0으로 no-operation으로 
그리고 여기 어떻게 되? 여기 프로그램 카운터에는 인터럽트 핸들러, 익셉션 핸들러 주소가 여기 들어가니까 8000180 번지가 일단 읽혀져 오겠지 근데 8000180 번지는 아까 인스트럭션이 뭐가 있었냐면 이렇게 sw 어쩌구 저쩌구 명령어가 있었다 이명령어가 
80000180 이 명령어가 읽혀져 들어온다.
앞에는 버블이고 

그리고 이 핸들러가 끝나면 어떻게 되 이핸들러가 완전히 종료가 되면 뭘 봐야되? epc 봐야대 epc를 보고 epc 있는 주소에 그 명령어들을 다시 시작해줘야대 
여기서부터 
epc -4 지 

## Summary
다시 정리하면 exception 크게 인터럽트와 트랩으로나뉘는데 
인터럽트는 옆 프로그램 실행하는 지점과 전혀 인터럽트가 발생하는 지점사이에 서로 상관관계가 없다. 그것을 우리가 어싱크로너스 하다라고 말했고 트랩은 프로그램이 실행한 위치와 인터럽트가 발생한 지점이 상관관계가 있음
예를 들면 그 명령어를 실행하다가 그 명령어가 불법적인 일을 했다던지 그명령어에서 오버플로우 가 발생했다던지 이렇게 명령어의 실행위치와 익셉션 이 발생하는 시간 지점이 상관관계가 있다. 그래서 이것을 우리가 어싱크너스 시간적으로 전혀 관계가 없는 어싱크로너스 익센션이라고 하고 이것을 싱크로너스 익셉션이라고 한다.
그래서 five-stage pipeline  excpetion은 뭐든 스테이지에서 다 발생할 수있는데 맨 마지막 write back을 제외하고는 모든 스테이트에서 다 발생할 수있다. 지금 사실은 여기에 약간의 결함이 있는데 문제 가 뭐냐면 모에요 
이게 지금 불안전하다 이게 불안전 한 이유는 어떤 stage 에서 발생하는 익셉션은 여기에 지금 반영이 안되어있음 
메모리엑세스에서 익셉션 이 발생할 수 있다고 했다. 메모리엑세스 하다가 주소가 엉뚱한 주소를 엑세스 한다던지 이럴때에 익셉션이 발생할 수있는데 지금 메모리 엑세스에서는 그 익셉션 처리가 안되고 있다.
그러니까 여기에는 메모리 엑세스에는 지금 문제가 없을거라고 가정하는 거야 적어도 execution stage 그다음에 decode fetch에서 익셉션이 발생하는건 여기까지 기다렸다가 여기서 그냥 처리해서 다 flush 를 시켜버리는데 여기만 지나가버리면 일단 익셉션 디텍트가 안되고 있음
그래서사실은 이게 요 뒤로도 미뤄져야 해 원칙적으로는 근데 지금 여러분들에게 명확한 익셉션 처리에 한예를 보여주기 위해서 저기 execution 단계에 집어넣었는데 그다음에 
익셉션 이 어떻게 디텍트 되는가 구체적으로 안나와있음 
오버플로우가 어떻게 디텍트 되는가 뭐 이런것들은 구체적으로 나와있지는 않은데
그냥 그런것들을 디텍트하는 회로가 있다. 예를들면 여러분들 계산했는데 계산결과가 오버 플로우가 발생했다. 그걸 우리가 이전 값하고 이후값 비교해보면 알 수있다. 그렇져 근데 하드웨어적으로는 우리가 그 두개의 값을 더해가지고 두개값을 더해가지고 뭐해
여기에  0 0 인데 결과가 1이 되는거랑 두개의 부호비트가 서로 다르면 오버플로우가 날일이 없음.
반대로 이게 1 1 인데 0이되거나 이런경우인데 그럼 어떻ㄱ ㅔ계산할 수 있어? 어떻게 디텍트 할 수가있지?
맨 요 자리에 기준으로 해서 여기를 들어갈때 이것을 캐리 in 이라고 하고 여기서 나오는것을 우리가 나오는 캐리를 캐리 out이라고 하는데 두개의 값을 비교하면 오버플로우가 발생했는지 알수가 있다. 그래서 두 비트가 서로 다르면 여기에 0이 들어갔는데 여기서 1이 나왔다라든지 
1이 들어갔는데 아무것도 안나왔다 라던지 그러면 오버플로우임
그러니까 하드웨어적으로 뭘보면되? 요 값하고 요값하고 해가지고 이거 exclusive or 하면되
exclusive or 해가지고 둘중에 어느 하나가 1이 나타나면 그러면 오버플로우 발생 
이런식의 회로들이 다 프로세스 안에 들어가 있고 그것을 우리가 전제로 하고 익셉션을 디텍트한다. 
중요한건 익셉션 핸들링, 이거 간단한거 같지만 2학기 os 배우고 하는데 익셉션 핸들링이나 인터럽트 핸들링이나 그 처리과정은 유사한데 현재 익셉션을 일으킨 인스트럭션은 잠깐 멈추고 그다음에 방금 얘기한것처럼 그 뒤따르는 명령어들은 다 flush 시켜줘야 되고 다 소거시켜야 되고 그 앞으로 가는거는 나눠도댐
파이프라인은 그냥 내버려 두면 앞으로 전진하게 되어있으니까 그다음에 offending instruction address 하고 사실은 뭐를 또 세이브해야되? 스테이트, cpu 스테이트 
cpu 안에 들어있는 레지스터들 , 이것을 세이브하고 그다음에 미리 준비된 익셉션 핸들러로 분기하고 그다음에 여기 위에 안썻지만 익셉션 핸들러가 다 처리가 되면 다시 돌아와야함 그러면 여기는 save 했으니까 save의 반대 는 restore 
save 라는건 이값들을 메모리 어딘가에다가 이렇게 기록해 놓는다. 그러면 여기서 이렇게 가져다가 offending instruction의 address하고 cpu stats를 다시 복원시키는 작업이 필요하다. 

## 과제
실습 내용포함, 실행해보면서 과제를 진행해볼것.
시뮬레이터 소개
이게 우리 지난번에 qtspim 이라는거 써봣지
스핌은 우리 어셈블리 프로그램을 시뮬레이션 해줌
이거는 데이터패스를 시뮬레이션해준다. 데이터패스에 어떤 값이 들어가있는지
그래서 이름이 닥터 밉스임
닥터 밉스에 보면은 이런식이다. 여기 보면은 이게 데이터패스죠 
여기 레지스터하고 메모리의 어드레스 들어있는값들 여기에 
각 주소에 어셈블 되어있는 그 내용들 나오고 저것들을 하나하나씩 
처리할때 여기 프로그램 카운터에는 어떤 값이 들어가고 
그다음에 여기 먹스에 신호값은 어떤 값이 들어가고 이런것을 고려해줄수있고 
이게 단순히 싱글 사이클 뿐만이 아니고 모든것들의 데이터패스가 다 구비된다.
여기보면은 잠깐 여게 이게 
그래서 내가 과제는 아니고
이걸좀 보면서 만져보면은 파이플라인도 이해하기 쉬울것이고
어 오늘 저녂대 연습문제를 풀이하는 과제를 이클래스에 낼려고해 
풀때 필요하면 이걸 돌려보면 도움이 될것이다.

여기그 cpu 가 여러종류가 있는데 여기 cpu를 선택을 하면 파이프라인도 있고 
우리가 싱글사이클 (우리사이클 이라고 표현하고있다.)
싱글사이클도 있고 파이플라이닝도 해저드 디텍션이 없는게 있고 포워딩기능만 가지고 있는게 있고 
이렇게 여러종류가 있다.
거기에 따라서 만들어지는
위에 색깔이 다르다. 저기에 하늘색 붙어있어가지고 이게 스테이지다.
그래서 파이플라이닝 같은경우는 명령어실행하면 스테이지 스테이지 마다 이렇게 명령어가 한 스테이지씩 채워져가지고 
앞으로 진행하는 그런 모습을 볼 수있다. 
설치해보고 