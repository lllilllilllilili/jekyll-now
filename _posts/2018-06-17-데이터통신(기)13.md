---
post : layout
title : 데이터통신(기)13
---
## 데이터통신 기 13
시작

## 
1초에 g 
그러니까 이 알로하가 어느 그 기지국에 기지국을 사용하는 여러가지 스테이션들을 여기를 접속할려고 하는 상황이다.
누군가가 혼자만 접속을 시도를 해야 성공하는것이다.
통신기지국에 그래서 토탈 얘들이 토탈 
만들어내는게 g 패킷 퍼 세크 라 이거죠 
g 초당, g개만큼 저게 지금 그거죠 g 패킷 퍼 세크
어 평균 이라는 얘기에요 이게 지난번에 그 n개 t 동안 
p(t) 동안 n개 발생 이거 확률이 ppt 참고 
지난시간에 람다로 표기해가지고 여러분들이 헷갈릴꺼 같아서 g로 바꾸조
ppt 참고 식은
이런 분포를 갖고 발생을 하는데
이런 확률 가지고 발생하는데 이럴 경우에 그럼 1초에 몇개발생하느냐 
이걸 가지고 평균을 구하면 되는것이다. 
평균을 구했을때 우리가 구지 평균 구하는 과정 여러분들이 지금 뭐 알아야 될 필요는 없는거고 확률시간에 하면서 배우는거고
그래서 평균을 구했더니 평균 g개가 나온다. 
자그러면 1초에 g개가 나왔는데 이들중에 성공할 확률은 지난번에 얘기했듯이 여기에 
어 성공할 이중에 성공할 확률은 그러면 벌레오브 타임?? 이 슬랏 티드 알로하는 하나의 t프라임이죠 
하나의 티 프라임 동안 제로개 발생 이라는 확률 이 같이 내가 이 초당 g개가 발생했는데 
이런 확률이 발생해주면 쟤들은 성공한다 이거임
이 값이 바로 이게 이걸 다시쓰면 
요렇게 이렇게 되는것이다 이확률이 이것이다.
그러니까 1초에 성공할게 몇개있느냐를 보여주는것이다 1초에
그런데 지금 여기서 이 윗부분에서부터 여기 얘기하는게 여기 여기까지가 s라는 놈이죠 이게
여기 지금 여기는 퓨어알로하라서 저기 2
티 프레임이 두 프레임 동안 없어야 된다고 그랬죠 지금 그 퓨어 에서 였고 
슬랏티드 에서는 1이니까 여기에 티프레임 일만 곱한다
쥐곱하기 티프레임 
근데 우리 관심사는 하나의 프레임 티 보낸 하나의 프레임 보내는 시간동안 티프레임
요 시간동안 과연 몇개가 성공하느냐 과연 몇개가 성공하느냐 최대한 1이죠 1
하나의 티프레임동안 한개 가 성송하는게 최대다 두개가 성공할수 없어요 
왜냐하면 계속 중첩되니까 실패하는거와 다름없는것이다 한 티프레임동안에 성공할수있는건 하나밖에 없다 이거임
맥시멈이 1이다 지금 그런 그값을 한번 보고자 하는얘기다 그래서 
이건 1초에고 이거에 비해서 티프레임동안이니까 티 프레임을 여기다곱한것이다. 이렇게 해서 
요기에 이 두개 똑같은 텀이 있잔아 그래서 이걸 라지 쥐로 바꾼거다 이거죠
쥐에 익스포넨셜 
그냥 노테이션만 바꾼건데 이게 라지 쥐라고 하는게 지난번에 이 슬라이드 갖고 설명을 안해서 이제 혹시 슬라이드 비교하면서 복습하면 되겠다 싶죠 그래서 라지 쥐라는게 의미하는게 뭐에요 저게 하나의 티프레임 전송시간동안
바로 하나의 프레임 전송시간동안 성공 할 개수를 의미한다. 그 생성되는 개수 , 얘기를 잘못했다 쥐는 초당 생성되는개수고 1초에 그런데 
티프라임 동안에는 얼마나 발생하냐 그러면 티프레임을 곱하는것이다
그러면 하나의 티프레임동안 생성되는 개수 를 의미하는게 쥐다 이거죠 
그래서 우리가 나온식이
## 
그래서 우리가 나온식이 결국은 얘는 뭐냐 하나의 티프레임 동안 성공 이 되는 프레임 개수가 되는것이다
얘는 하나의 티프레임 동안 발생되는 프레임 개수고 그게 성공할 확률이 이거다 이거임 뒤에있는게 따라서
성공적으로 하나의 패킷프레임 동안 성공적으로 전송되는 프레임 의 개수
당연히 맥시멈 1이다 1을 넘어설수없다.
이런 모양이 그래프를 변수가 지금 G라고 하는 하나의 함수를 표현한것이다 이런 함수의 모양도 어떻게 될거냐
여러분이 이모양새가 어떻게 될지는 상상을 해보면 두개의 커브를 곱한것과 다름없다
G라는 변수에 G라고 하는 함수하고 익스포넨셜 마이너스 G는 이런모양에 함수에요
각각 이함수는 익스포넨셜 마이너스 G는 얘고 
당연히 여기는 1이죠 1
이 쥐가 0일떄 얘가 1이죠 그래서 1에서 시작해서 이런 모양이된다.
익스포넨셜함수는
그리고 G라는 함수는 리네어하게 쭉 기울기가 1인 함수
이 두개가 곱해졌다. 그러면 이 두개 곱해진 함수의 모양은 어떻까
모양이 어떻까 이 모양이 모양이 지난시간에 우리 책에 이그림이 없어서 그런데
이 그림은 이 그래프와 이그래프를 곱하면

## 
이 그래프를 곱하면 이런 모양이 된다 쫓아간다 이거임
이런 모양이 되요 빨강 노랑
그래서 이 커브는 어딘가에 극값이 존재한다 이거임
절대값, 최대값 절대값아님
아거 이상 값이 증가될 수없는 어떤 이런 모양에 위로 맥시멈값이 있는 그런 커브가 된다.
그래서 우리의 관심사는 과연얘가 언제 발생하고 G값이
G값이 언제일때 맥시멈이고 그 맥시멈일떄에 값은 얼만가
이 값이라는게 하나의 프레임 전송시간동안 성공적으로 보낼수있는 패킷의 개수를 알고싶은것이다. 그래서 이함수를 뭐 이게 
이 빨간 커브가 이 함수고 이함수에 최대값을 알기위해서는 미분하면되잔아 
이게 G에 대한 함수니까 G로 미분을 하는것이다.
뭐 아주 간단하다. G로 미분하면은 얘도 G에대한 함수고 얘도 G에 대한함수를 미분하면 
요 미분만 보죠 이거 한번 미분하면 PPT 참고 이렇게된다.
이퀄 얘가 제로가 되는 포인트는 얘는 제로 안되고 G=1 일때가 되는거죠 
이걸 구하고 
G가 1일때 이 커브는 맥시멈을 준다 이거임 맥시멈 값은 얼마냐 여기다 1을 집어넣으면되죠 
익스포넨셜 -1 승이 맥시멈 값이다 G를 1를 집어넣으면 익스포넨셜 마이너스 1
슬라이드 뒤에 

슬랏티드 알로하로 가면 이 슬라이드를 볼수있다.
슬랏티드 알로하에서는 1/e 은 0.368 이라는것이다 즉, 이값이 0.368 
하나의 프레임 전송시간동안 0.368 개를 기대할수있다 맥시멈
이게 맥시멈 성능이란 얘기다.
요기까지 가 지난시간 좀 복습
이런 상세한 부분이 책에 없다 그래서 여러분께 보조적으로 설명하는것이다.
사실 이 커브 모양도 보여주는게 제일 중요한대 책에 이 커브 모양새를 안보여주고 있다 저런 모양이다 커브가 이런모양이된다.
맥시멈 값이 하나 하나가 존재한다.

## 
자그래서 
이그젬플이 하나 있다이거죠 
이그젬플이 
## 12.4
슬랏티드 지금 우리가 본 이 해석을 이용해서 이문제를 풀어보는 과정이다 슬랏티드 알로하에서 하나의 프레임이 200비트다.
크기가 하나의 프레임 크기가 200 비트고 어 이 그 
우리가 지금 
공유하는 이 채널의 스피드는 200 KBPS 다 
이거임 이두 숫자를 가지고 우리가 찾아내야 할것은 t프레임이라는것을 찾아내는것이다 하나의 프레임을 전송하는데 얼마나 걸리는가
지금 우리 이 수식에서 지금 필요로하는게 티프레임이라는 수식이 필요하다 이거임 그리고 G라는 하는 이변수가 필요하다 그것을 줄려고
문제들이 이런저런 숫자를 제시하는것이다 거기서 우리가 이값들을 찾아내면
바로 쓰루풋을 찾아낼수있다

전송시간 200kbps 스피드에 200 bit 짜리 프레임을 보내니 당연히 1/1000 20만분에 200
천분에 1 
1 미리 세컨드 , 티프레임은 1 미리 세컨드 가 되고 
자 이제 그 정보를 알앗죠 
그런 상황에서 스루풋을 구하라 이거임
다시 말해서 이 함숫값을 구하라
이 함숫값을 구하라는건데 시스템이 어떤식으로 동작하냐면

시스템이 초당 1000개의 프레임을 생성을 하면 초당 1000개 
자 초당 1000개 죠 그러면 우리가 지금 요 함수에서 G값이 뭐가되? 쥐값은 초당 발생하는 개수가 아니라 하나의 프레임동안 발생한 
프레임 시간 동안 발생하는거죠 하나의 프레임은 1 미리 세컨드라고 하죠

자 초당 천개면 몇개 죠 1msec 당? 초당 1000개면 1msec 당 몇개야? 하나의 티프레임동안 생성되는 이 스몰 g가 몇개냐 이거져 1이지 
1초에 천개면 1msec , 일 미리 세컨드는 한개져 어
그래서 g가 1이되는거에요 지금 이문제는 g가 1인케이스
g가 1인 케이스죠
아니지 맞아요 
그리고 얘는 500프레임 비트 퍼 세컨드는 초당 1000개가 아니라 초당 500개면 1msec당 0.5개 밖에 발생안하는거죠 
첫번째 케이스 가 a번이 여기다가 보면은 여기가 a번에 해당하는거에요 a번
1 g가 1이라고 했으니까 그렇죠 
## 
프레임 시간당 한개잔아 
1msec 당 한개죠 얘도 따라서 이 초당 1msec당 한개 
이 g값이 뭐죠? 한프레임 전송시간동안 발생하는 개수 한 프레임 전송시간동안 한개발생하는거니까 a번은 g가 1일것이고
b는 초당 500개면 1msec 에 1/2 밖에 발생안한다. 
1/2 인 케이스가 b에 해당된다.
c번은 250 프레임 퍼 세컨드
1/4이다. 요게 1/4 에 해당하는 c 번의 문제는 요기다 이거죠 이떄의 각각의 값이 얼마냐 이걸 물어보는것이다.
이값 3개를 물어보는것이다 저문제다 
이 문제가 재밌는게 부하가 점점 줄어들죠 이렇게 부하가 천, 1초에 1000개 발생하는거에 대해서 500개 250개 
부하가 점점 줄어든다 그런데 부하가 점점 줄어들면 시스템에 부하가 점점 줄어들면 오히려 성공할 확률이 높을거같은데 보다싶이 점점 떨어진다.
1일떄 비해서 0.5는 요만큼이고 1/4일때는 요만큼이다 
이 수식에 집어넣어서 구하면 이런값들이 나온다
1일떄는 0.368이고 b번일떄는 0.303 이고 c는 0.195 
아까 0.368이었는데 얘는 0.303 이고 그다음 c번은 0.195 가 되는거다. 요값은
요값은 0.195 오히려 부하가 더 줄어드는데 성공되는 개수 우리가 기대할수있는 성공되는 개수 자체도 줄어든다. 
이 경우에 오히려 부하가 줄어들었어 초당 250개의 프레임을 집어넣으면 우리는 오호지 그중에서 49밖에 성공을 못한다 기대를 할수밖에 없다. 이 슬랏티드 알로하 라는건
커브를 갖고 여러분들이 이해할수있죠 커브 모양이 저런 모양으로 되어있다. 
## 임의 접속 시작 ..
자 그래서 지난시간에 말미에 얘기했듯이 케리어 센스 라는 그것을 추가해야 되겠다 라는 생각을 하게됬다 
누가 보냈는지 안보냈는지 전혀 무관하고 내가 보낼게 있으면 보내겠다 이거 너무 무책임한 행위다 그래서 케리어 센싱이라는 기능을 집어넣자 라는게 ma앞에 cs 캐리어 센스라고 하는 기능을 추가한것이다 목적은 충돌을 줄이기 위함이다.

## 
충돌, 남이 보낼때 보내지 말자 이런거임 남이 보내고 있을때
자 그러면 어 이 케리어 센스가 이 공기중에 신호 세기를 측정하는것이다 누군가를 보내고있으면 어느정도 이신호 값이 느껴지면 누가 보냈다고 생각해서 안보내는것이다 단순하다.
물론 구현하기 복잡할지 몰라도 개념적으로
그런데
누가 보내고 있지 않다고해서 내가 보내고 있는데 그래도 충돌이 난다 왜 충돌이 날까?
누가 보내고 있지 않다고 분명히 채널이 놀고있는데
시그널이 전혀없는데 왜 내가 보냈을때 충돌이 날 소지가 있을까 왜?
거기서 왜 라라는거가 사실 충돌이 안나면 여기서 끝나야지 케리어 센스로 그냥 이런 멀티플 엑세스 기능은 끝나는거야
개념적으로 끝나야 될거같은데 역시 충돌이 발생한다 이거죠
충돌 가능성 은 줄일수있지만 제거는 할수없다 왜?
요 밑에 있죠 , 전파지연때문에 
전파지연이 뭐여 전파 지연 이전에 
그냥 간단하게 생각한게 두개의 노드가 데이터를 보낼려고하는데 동시에 채널을 감지했더니 둘다 채널이 놀고있다 그러죠 동시에 보내는경우에
동시에 
그거도 전파지연 생각하기전에 흔히 생각할수있는게 동시에 보내면 충돌 나는게 뻔한거지
근데 그런경우는 굉장히 적은거지 
동시에 
근데 문제는 뭐냐면 동시가 아니어도 아니어도 충돌이 가능하다 이거임 동시에 전송하지 않아도 
왜 바로 이 전파 지연이라는 그런 특성때문에 
전파 지연이 뭐죠 내가 보냈는데 내가 보내서 시그널이 제로 레벨에서 쭉 올라가는 시그널 레벨이 있는데 요 시그널 레벨이 멀리 있는 다른 노드가 감지하는데 까지 시간 이 있잔아요 그게 전파지연이다.
그림으로 표시한게 이그림이다.

## 12.8
이 그림이다. 이그림이 그거랑 너무 강조했지만
이거를 이렇게 보여주는것이다 
a,b,c,d 4개의 도구가 지금 하나의 매체를 공유하는것이다 
b라는 그 보낼게 있고 c라는 애도 보낼게있는데 d가 이 아래쪽이 시간이다.
밑으로 갈수록 시간이 흘러가는것이다 아래쪽이
t1 이라는 시간에 보니까 채널이 놀고있드라 
보내는거지 , 자 캐리어 센싱을 해서 아무도 없으면 보냈어. 보냈죠 근데 요 시그널이 
옆에 있는 c라는 애에게 전달되기까지의 전파지연시간 이 있다 애기죠 
요 일직선으로 그었을때 요 간격이 우리가 많이 본 전파지연 시간이다. 프로퍼게이션 딜레이다. 굉장히 작은 시간이긴 하지만 어쩃든 프로퍼게이션 딜레이가 있다 이렇게
따라서 고 프로퍼게이션 얘가 시그널이 c에 오기까지 이만큼 의 시간이 걸렸죠 요기서 그 금을 그어서 일직선 그었을때 그 기울기에 의해서 생기는 시간이죠 이렇게
이만큼이 이만큼에 프로퍼게이션 딜레이가 있는거에요 요 딜레이 오기전에 내가 보낼게있어서 보내버리면 
얼마든지 보낼수있는거지 이순간에도 c는 채널이 놀고있다고 알고있기때문에 보낼수있다 이거죠 그러면 
결국 노란색과 이 파란색이 충돌을 일으킨다.
그래서 이 회색은 이 충돌된 영역이다.
충돌됬어 될수밖에 없다 이거지 케리어센싱이 일어나도 
## 12.9
그러면 충돌이 난것을 결국 여기서 케리어센싱만 하니까 뭐 충돌 디텍션까지는 아직 없죠 어쩃든 충돌이 날수밖에 없다라는걸 지금 보여주고 있다 케리어센싱을 해도 전파 지연 시간이라는것 떄문에
전파지연 이라는것 떄문에 충돌을 모면할수는 없다. 이런 거다
정확히 나온다
그래서 알로하 할때 취약기간 (vulnerable time) 이라는게 있었죠 우리 이런 csma 에서의 취약시간은 이걸로 규정이 되는거다 여기서 맨끝에서 맨끝 노드까지의 전파되는 시간 
전파되는 데 걸리는 시간 이게 취약시간이 되는거다 요 csma는 취약시간 이 바로 요걸로 정의를 하는거다 
요시간동안
물론 가까이 있으면 그거보다도 적은시간안에 시그널이 다 보내지만 제일 멀리있는 에게는 이만큼이 시간이 지나야 얘가 보냈다라는거를 감지할수있다는것이다. 취약시간이라는게 저렇게 정의될수가 있다.

## 임의 접속
csma 에서는 비슷한 얘기고 이렇게
어 자 이게 그 csma에서 충돌이 발생할 수 밖에 없단 얘기를 보여주는거고 csma에서 채널을 감지한다 그랬죠 그러면 이제 저렇게 충돌이 발생할수있기떄문에 무엇인가 좀 
생각을 해보자 라고 해서 어떤 이미 랜덤 여기서 
이런 전략을 하나 만든다 이거임 전략을 즉시 보낼것이냐 아니면 채널이 지금 아이들인데도 혹시 다른애가 보낸게 전파지연 떄문에 나한테 아직 안왔을지도 모르니까 
좀 기다려보자 
이런 여러가지 아마 머리를 굴려봐야겠다 그래서 일반적으로 제시된 방법들이
이제 전략이 크게 2가지로 나눈다 이거임
어 요기는 아이들 인경우도 물론 그렇지만 감지를 했더니 누군가 보내고 있드라 그러면 어떻게 할껀가 이게 더 주안점이다 여기서는 이전략에서는 누군가 보내고 있더라 어떻게할까 ? 그떄의 2가지 이제 이 방법이 
비지속성과 지속성 
난펄시스턴트 방식 펄시스턴스트 방식 2가지가 있다. 
난펄시스턴트 는 제일 간단하니까 
사용될때 어떻게 되냐하면은 얘는 계속 케리어를 센싱을 하죠 누가 쓰고 있는지 안쓰고 있는지 
자 쓰고있드라 
예스 기다리는거지 
기다리다가 계속 센싱을 하는것이다 그러다가 안쓰고 있더라 그러면 무조건 보내는게 난 펄시스턴트 방식이다 이거임 안쓰고있을때와 쓰고있을때 에 어떻게 할껀가 2가지를 다 제시하고 있다
난펄시스턴트 방식은 계속 체크하다가 안쓰고있으면 그냥 보낸다 이거임
자 그렇게 되면 충돌될 소지가 많은거에요
여기 물론 여기도 웨이트 타임이 서로 이 노드 마다 서로 다른 시간동안 웨이트 타임을 갖자 우리 지난번에 알로하도 그런얘기 했죠 
서로 기다리는 시간을 달리하고 센싱을 하면 동시에 보내질 확률은 줄어드니까 이게 서로 다른 시간을 기다리는건 있어요 그래도 여전히
아이들이 감지했을때 보낸다 라고 하면 어떤 충돌될 소지가 여전히 있다 이거죠
여기서 좀더 소극적으로 가는방법 

## 임의접속(2)
비지이면은
얘는 계속 센싱을 하는데 애는 웨이트 타임은 ??? 한게 아니라 얘는 계속 센싱을 한다 이렇게 
펄시스턴트 방식은 
웨이트 타임 이없네
계속 센싱을 하다가 비지가 아니더라 아이들 이더라 그러면 보내는게 아니라 확률적으로 보내는것이다. p의 확률 뭐 0.8의 확률 로 보낸거나
0.2로 안보내는거죠 그러니까 채널이 놀고있다 그러면 주사위를 던져서 가령 뭐 5이하면은 보내고 6이면 안보낸다 
가령 이게 1/6 확률로 안보낸다 이거임
5/6 확률로 보낸다 이런식으로 확률 적으로 보내겠다 이거임
그게 펄시스턴트 방식
이 펄시스턴트 방식은 확률 p 에 따라서 두가지로 나뉘는데 그 확률이 p가 1이면 1-지속성 얘기하고 
무조건 보낸다 이거임 이런 얘기는 계속 체크하다가 아이들이면 무조건 보낸다 확률1로
무조건 보낸다
그거에 비해서 p지속성 이라고 하면 1이아닌 확률p 로 보내고 1-p로 안보내고 이런 가령 p가 0.2 일때
p 가 0.2인 0.2 펄시스턴트 방식이다 라고 한다면 0.2의 확률로 보내고 굉장히 소극적으로 보내는거다 
0.2 인 확률로 보내고 0.8인 확률로 안보내고 안보내면서 어떻게 하느냐 계속 이 루프를 돌리는거다 안보내면
확률 p가 안됬으면 돌아와서 또 계속 센싱 
저게 아니라 뒤에 그림이 있다.여기보면은
지금 봤던것을 그림으로 표시하면 

## 12.10
먼저 난 펄시스턴트 방식은 일정한 변수인데 웨이트 타임이 다르다 이거임 한번 센싱하고 비지드라 그러면 어느정도 웨이트 타임 주고 다시 센싱한다 또 비지더 라 또다른 웨이트 랜덤 넘버 만큼의 기다리는 시간 갖고 다시 센싱을 했더니아이들이더라
그러면 그때 즉시보내는게 난 펄시스턴트 다 이거임

요 기다리는 변수들에 이 랜덤한 어떤 특성이 있어요 펄시스턴트 방식은 계속 센싱을 하는거다 이그림이나 이그림이나 
둘다 펄시스턴트인데

얘가 원펄시스턴트, 얘는 피 펄시트턴트
원 펄시스턴트 계속 계속 그 아주 촘촘하게 센싱하다가 아이들 딱 체크되면 그냥 보내는게 확률 1로 보내니까 
이게 1펄시스턴트 
p펄시스턴트는 계속 센싱하다가 아이들이다 그러면 주사위를 던져서 보내자 말자 결정하죠 보내지 말자 라고 결정이 되면 
어떤 정해진 또 타입, 파라미터가 하나있다 타임슬랍 
타임 슬랏이라는게 대게 하나의 프레임 전송시간 이정도 겠죠 , 남이 보내고 있을만한 시간을 뭐 기다려 보고 있다. 이게 왜 이 프로퍼게이션 딜레이 떄문에 또 같이 충돌이 날까봐 한번 기다려보는거죠 
그만큼 기다려도 아이들 이더라 그러면 또다시 주사위를 또 던지는거지 
그래서 p의 확률로 보내는데 여기서 또 1-p가 나오면은 또 기다리는것이다 같은 시간 만큼을 계속 이런 동작을 하다가 이게 확률 p가 나오면 그러면은 보낸다 굉장히 소극적이다. 
지금 아이들인데도 불구하고 확률적으로 보낸다 이거임
얘도 굉장히 적극적인거 같지만 여기서 지금 비지인데 기다리기로 했쬬 기다리는 시간동안 아무일도 안한다 이거죠 
그러면 요시간동안 낭비요소가 되는것이다. 요시간은 아이들인데도 센싱을 안하기떄문에 애는 디폴트로 기다려야 한다 이 웨이트 타임에 의해서 좌우되지만 이만큼
얘가 가장 저돌적이다. 원 펄시스턴트가 가장 공격적이다. 얘가 가장 소극적이다. p 펄시스턴트 방식
p의 확률로 보내고 안보내고 그럼 이제 엔지니어들은 이런생각을 하죠 내가 p펄시스턴트란 방식을 쓰면 과연 평균 몇개의 타임슬랏을 기다렸다가 보내게 될까 이런 계산을 하자 이거임
p의 확률로 보내고 1-p의 확률로 안보낸다 이게 바이노미얼 디스트리비우션 이라는 또 확률적으로 가면 그런 확률분포가 있어서 그때의 평균값 이런 관연 몇번쨰 이 타임 슬랏을 몇개 평균 , 몇개 기다렸다가 결국 보내게 되는가
이런 값이 나온다 대게 대게 어 저런값 1/1-p 이런 이 계산해보면 확률분포를 돌려보면 1/1-p 
가령 0.1 확률로 내가 보내고 0.9확률로 안보낸다 
p가 그렇죠 그러면 여기다가 대입을 하면 1/0.9 거꾸로네
p가 지금 p가 안보내는 확률이죠
이렇게 계싼을 하면 자 0.1 확률로 보내고 0.9확률로 안보낸다 그러면 대게 한 10개 기다려야 되지 않겠어요?
하나 왔는데 0.1 확률 1/10 확률로 안보내 아니 1/10의 확률로만 보내 그러면 안보낼 확률이 0.9지
기다리게 될 스타일풀한 개수가 대게 계산해보면 이 확률값을 저 계산해보면 1/p 이런값이 나온다 이거임
이게 지금 p가 보낼확률인지 안보낼확률이냐에 따라 이 나온 과정이 다른데 어쨋든 보낼 확률이라고 치면은 이런 게 평균 기다리는 슬랏개수가 된다는거임
요 그냥 개념적으로 우리가 이해할수있다 0.1 의 확률로 1/10 확률로 보내면 대게 10개 정도 기다렸다가 보내는게 평균이 되겠다 
1/2 로 보내고 안보내고는 대게 2개정도 기다리면 되지 않을까 다 여기에 들어맞죠 1/2이면 2 여기가 1/10 이면 10 
1/20 이면 20 
대게 바이너미얼?? 표기로 구해보면 저런식으로 평균 기다리는 시간이 계산이 된다. 

## 12.11
그3가지를 다시 플로우 차트로 이런식으로 플로우 다이어그램으로 여기 애끼했는데 표현하면 이렇다 이거임
중보되는 얘기니까
그래서 이 펄시스턴트 메소드를 어 csma 에서는 쓰고있다.
비지 일때 어떻게 할껀가에 대한 얘기다.
지금 
3가지 방식 이있다. 비지로 감지가 됬을때 또 아이들로 감지되는 것도 포함됬죠 아이들인데도 당장 p의 확률로 보내고 안보내고하는 그 결정했으니까
자거기까지 csma에 이고 
보내고 나면 피드백이 없다 어쩃든 충돌을 피해서 보냈지만 정말 충돌이 발생하면 어떻게 할껀가 
컬리젼 디텍션이라는것까지 기능을 추가한 내용이 csmacd 이다.

## 임의접속(계속) csma/cd편
좀더 발전한거
컬리젼 디텍션 충돌을 발생한것을 감지할수 있고 
그 거에 대한 처리를 추가한것이다 csma에서 
두번쨰 충돌을 줄이기 위해서 대기를 하고 뭐 백오프 타임 대기시간을 갖고 이게 약간 복잡해진다 충돌이 감지되면
충돌이 감지되면 일단 객관적으로 봤을때 내가 패킷을 보냈는데 csma 방식에 의해서 최대한 조심해서
피 컨시스턴트 방식 이렇게 최대한 조심해서 보내는데도 불구하고 컬리젼 디텍션기능을 구동을 시켜서 봤더니
서로 충돌이 발생헀더라 그러면 내가 느끼기에는 이 네트워크에 지금 뭔가 트랜픽? 다를거다 인제 이런 생각을 할수밖에 없다
내가 최대한 조심해서 보냈는데 그러면 바로 여기에 이제 어떻게 대응을 할까 
기다리는 시간에 대한 이 그 폭을 넓히는것이다.
할일 이 그거다
즉시 충돌이 감지됬다고 버리는게 아니라 좀 기다려보내 보는데 기다리는 시간을 충돌이 계속 반복이 될수록 기다리는 시간을 늘려가는것이다.
이렇게 늘려가는 메카니즘이 백오프 타임 백오프 방식에서 여기서 그 이제 나온다.
이 지난번에 저 내용이 기본적으로 있다라는건 봤는데 csma cd 에서에 이제 그 내용이 추가가 된다. 

## 12.12
컬리젼 디텍션이라는 기능을 갖는다면 재밌는 요구사항이 생긴다. 컬리젼 디텍션이 라는 기능이 가능하기 위해서는 어떠 어떠 해야되냐 라는 조건이 하나 붙는다. 
자 여기서 a에서 컬리젼 이제 이 패킷을 보냈다 프로퍼게이션 딜레이에 의해서 이 시점에 의한 도달을 하는데 그전에 c는 이미 요기서도 아이들로 감지 됬기 떄문에 보낼수밖에 없다 아이들 이니까 어떤 방식에 의해서 감지를 했고 충분히 기다린다음에 보내는거지
이미 p-consistent 방식에 의해서 보내는 결정이 내려진거죠
어쨋든 충돌 상황이 발생하는거다. 그러면 이 충돌을 a라는 노드가 감지를 할려면 어느 시점에 감지를 할수있느냐하면은 내가 보낸 시그널 뿐 만아니라 c가 보낸 시그널이 나한테 도달하는 이 시점에야 a는 충돌이 났다라는것을 감지를 할수있다.

얘가 보냈다고 즉시 감지하는게 아니라 이 시그널이 나한테 영향을 미치는 시간까지 지나간 이후에야 나는 감지를 한다.
컬리젼 디텍션이 지금 있다고 그랬죠 과연 컬리젼 디텍션에 디텔한 내용을 들어가보면 내가 감지할수있는건 텀이 있다 이거죠 이만큼의 시간이 필요해요
감지를 하는 시간 
바로 여기서 무슨 조건이 나오냐면은 이 내가 지금 a라는 그 세션이 내가 보낸 패킷이 충돌이 났다라는거를 인지를 해야되잔아
단지 얘가 보낸 시그널을 내가 여기 이순간에 그 인식을 했다 그건 별문제없어요 누가 보내고 있지도 않은데 
내가 보내는 거와 더불어 얘까지 더 보내는구나 라는게 인지 되야 충돌이라고 생각하는거죠 
그러면 충돌이라는거를 이순간에 꺠닫기 위해서는 내가 전송중에 있어야된다.
내패킷을 여전히 전송중인 시간동안 얘가 시그널이 와야지만 충돌로 감지한다 이거임
저그림을 좀 바꿔서 보면 
내가 지금 얘기 하는바가 

## 
내가 지금 패킷을 쭉 보냈쬬 자 그런데 이 가기전에 요놈이 여기서 보낸다 이거죠
시그널이 오죠 나한테 
그런데 그전에 나온 패킷을 다 보냈어 끝났어
패킷을 보냈어요 끝났어? 그다음에 c가 보낸 이 패킷이 시그널이 여기에 도착을 해 자 충돌이야? 
충돌 아니야 이거임
이 a라는 a와 b 두개의 노드에서 어 b라는 애는 이만큼 시간을 걸려서 보냈다고 쳐봐요 그럼 a라는 
a는 까만색이고 b는 빨간색이라고 치자 이렇게 보내는 시간이 
요게 트랜스미션(전송)타임 이죠 이게 전송시간 이게
요게 전송시간
a가 보낸게 이미 끝난 다음에 b꼐 오면 a는 충돌이라고 생각을 해 안해? 안하죠
근데 실제 충돌이 났잔아 보다싶이 이 패킷은 이 그 충돌이 이미 발생한 패킷인데도 불구하고 
a는 충돌이라고 생각을 못한다.
조건이 하나 붙는거죠 그래서
내가 보낸 패킷이 충돌이 났다라는것을 a가 알게 하기 위해서는 이게 미리 끝나면 안되고 이 패킷이 충분히 길어서 얘 의 시그널이 
나한테 도달하는 시점까지 내가 계속 보내고 있을 정도에 길이를 가지고 있어야 된다 이거임
이 패킷의 길이가 어느정도 길어줘야 상대방으로부터 오는 패킷을 내가 충돌로 그동안에 오는 놈 시그널을 내가 충돌로 감지할수있다.
그럼 여러분들이 이것을 보면은 앞으로 패킷 길이라 어느정도 되야 되는가?
패킷에 대한 미니멈 이 리콰이얼먼트가 생기는거야 
최소한 어느정도 커야 된다 이거죠 
얼마나 더 커야되죠? 이 그림에 이그림을 갖고 패킷의 미니멈 사이즈에 대한 리콰이어먼트가 생길수있다 이거죠?
그림을 갖고 얘기할 수있다 얼마든지
최악의 경우가 어떻게 되느냐 내가 맨끝에 로에 게 로 보내는데 맨끝에 놈이 마침 이순간에 어 보내기 시작했다 그러면 
그동안에 이 내가 보내는 패킷이 이 a가 보낸 패킷이 이 b가 보낸 패킷에 의해서 충돌이 났다라는것을 감지할려면 a는 이만큼 의 길이만큼 이상을 
내가 계속 보내고 있어야 충돌로 감지한다 이거임
자 그러면 이게 티프레임, 이게바로 프레임 전송시간이다. 프레임 전송시간이 뭐보다 길어야되? 뭐보다 길어야 된다는게 나오죠
바로 요 구간보다 길어야되 요구간 
그런데 요 구간이 뭐냐 요 구간이 바로 여기서 여기까지의 티프로퍼게이션 딜레이죠 그리고 얘가 여기서 보내기까지의 티프로퍼게이션 딜레이 두개죠 이 요기 티
그러니까 이 전파지연 시간 티 프레임이 두배의 전송지연 시간보다 크거나 같아야 되는 정도가 이런 조건이 만족해야 내가 충돌을 감지할 수 있는거야
이거보다 짧은 패킷을 보내면 이와같이 문제가 발생해서 충돌이 났음에도 불구하고 패킷이 충돌 난지를 모른다
그래서 csma cd 에서는 우리가 왜 지금까지는 패킷에 맥시멈 사이즈에 대한 제약을 많이 얘기했지만 여기서는 미니멈 , 최소 뭐보다 커야된다 라는 그런 리콰이어먼트가 생긴다 이거임
csma cd에서는 
이해했죠 감지 하게끔 여권을 만들기 위해서다. 
자 그래서 이런 내용을 갖고 이런 문제가 형성이 되는것이다 이런 예가 있는데 csma cd에서 
밴드위쓰가 10mbps고 프로퍼게이션 타임 당연히 나오죠 여기에 
프로퍼게이션 타임이 25.6 마이크로 세컨드다 이런 환경에서 이런 csmacd 를 사용하는 환경에서 이 패킷의 미니멈 사이즈는 패킷이 최소 몇비트 이상의 사이즈들로 이 스테이션들이 패킷을 보내야 되느냐
자 이런 문제가 형성이 된다.

## 12.5
이 문제를 쉬는 시간이 읽어본사람이 있을까 
지금 이문제가 그거다 아까 얘기했었던 csma cd 에서 어 최소한 패키사이즈는 얼마 사용이 되어야 되는가를 한번 알아보는 문제다.
이런문제 제시되면서 우리가 관게를 알수있다.
프레임 시간
전송 지연
요런값들이 당연히 문제에서 주어지고 거기에맞춰서 우리가 패킷사이즈를 구해내면된다.
이거 여러분들이 한번 풀어보면된다.

## 12.14
완성된 csma/cd 라고 하는 이 맥 프로토콜 전체를 한번 상세하게 플로우 차트로 플로우 다이어그램으로 그려본게 이거다
여러분들이 이거 하나하나 를 쫓아가 볼 필요가있다.
이 맥을 확실하게 이해하기 위해서 맥이 어떤 프로세스를 갖는지
어떤 프로세스를 갖는지 하나하나 살펴보라는거임
우리 알로하에 그 처음에 봤던 알로하에 틀을 그대로 유지하고 있다 
70년대 나온 알로하라는 그틀을 그대로 유지한다.
k는 전송횟수
허용된 전송횟수 
어 대게 이 네트워크에서 어 뭐 계속 실패하더라도 계속 성공할때까지 보낸다 이게 아니라 어떤
제한을 갖고 한다는거죠 제한을 갖고 그래서 그 만큼의 실패했으면은 네트워크에 어떤 문제가있다라고 대충
포기하고 한참후에 한다든지 뭐 이런
그런 특단의 조치를 취해야되는 그 파라미터 하나 가 있는게 바로 이 전송횟수다
허용된 전송횟수
자 제로부터 시작을 하죠 내가 보낼 패킷이 있어서 처음에 시작한다 얘기 k=0
알로하 랑 똑같겠죠 이때 
그래서 여기에 이제 우리가 그 펄시스턴트 메소드 그림을 지금까지 봤던 1펄시스턴트 p펄시스턴트 난펄시스턴트 뭐든지 
어 채널을 감지하는거지 계속 아 보내기로 결정을 하는거죠 여기에
어 내가 드디어 보낼 자격이 됬다 
보낼 상황이 됬다 이런 메카니즘을 통해서 이 속은 앞에 있었던 펄시스턴트 메소드가 이 블락다이어그램이 이속에 들어가는것이다 그래서 보낼 
어 환경이 됬다고 하면은 보내고 나서 보내는거지 보낼 자격이 있으면
보낸게 끝났던지 아니면 출돌이 디텍션이 됬든지 둘중에 하나죠 
예스 면 뭔가 끝났다 이거임 컬리젼이 지금 느껴졌느냐? 없드라 그러면 완전히 끝난거죠 패킷 하나보고 끝난거죠
k=	0 라는 한번 보내고 끝난거죠
자 여기에 가령 컬리젼이 디텍션 됫거나 아니면 여기에 그 어 뭐죠 컬리젼 보내고 나서 이 
트랜스 미디어 리시브가 뭐야 계속 보낸다 이런얘기다 
하여튼 끝나기를 기다리는것이다 계속 보내라 리시브는 다른 시그널로부터의  다른 패킷으로부터 오는 시그널이 있는지 없는지 감지를 하기도 하고 뭐이런 
이런거겟죠 
이 보내는 동작 끝내고 나서 컬리젼인지 아닌지 이제 확인을 해서 컬리젼이면 아니면 끝내는거고 컬리젼이다 하면 여기부터 중요한거죠

재밍시그널을 보낸다고 되어있는데 저 재밍 시그널은 뭐냐면 보내는중에 컬리젼이 감지가 된거죠
내가 보내는중에 이렇게 쭈욱 이사이즈가 여기서 끝나는게아니라 내가 계속 보내고 있는중에 이 빨간색 사이즈로 내가 보내고 있는 중에 컬리젼이 감지가되면 여기도 컬리젼이 감지가 되는거죠 다른쪽에서 오는 시그널이 오는거지
그러면 
컬리젼이 발생했다라는것을 재밍시그널은 좀 다른 노드들에게 확실하게 알려주기 위해서
이 매체 속에 시그널크기를 그냥 확 키워주는것이다 그래서 재밍시그널이라고 해서 일부러 이 공기중에 전파??트랜스를 키워주는 재밍 시그널을 잠깐 확 보내므로써 이 사이에 끼어든 놈들은 다 확실하게 컬리젼이 디텍션 되게 만들어줄려고 하는것이다.
뭐 이런 디테일 한 부분이 있고 
재밍 시그널 보내고 자 컬리젼이 발생했으니까 이제 횟수를 한번 늘려야 되겠져 
늘렸더니 제한된 케이 맥스더라 그만두고 이제 포기해야 되고 아직 제한된 케이맥스가 아니면은 이제 웨이팅 타임 여기 필요하겠쬬 
충돌이 발생했으니까 
웨이팅 타임을 결정을 해야된다 그래서 여기서 또 랜덤 넘버를 뽑는데 
이게 알로하에서 똑같겠죠 내가 지금 시도한 횟수를 k라고 했을떄 2의 k승 뺴기 1이라는 이 1부터 2의 k승 -1 이라는 값을 사이에 랜덤한 넘버를 하나 고르는것이다 이사이에
당연히 내가 시도한 횟수가 클수록 이 맥시멈 값도 커진다.  그래서 선택할 범위가 커지는거죠
그래서 그게 랜덤넘버를 하나 취득하게 되면 바로 여기 랜덤넘버 r이죠 r 곱하기 프로퍼게이션 딜레이  만큼 또는 r 곱하기 트랜스미션 딜레이 만큼 기다린다음에 다시 이 루틴으로 돌아와서 또 이루틴을 반복한다. 컬리젼 디텍션이 바로 여기에서 이루어진다. cs 형식으로? 
여기가 지금 알로하랑 거의 똑같다 이런 컬리젼 디텍션이 있다라는 얘기 이런 부분들이 추가가 됬다
그래서 알로하라는 가장 원초적인 아주 단순한 메카니즘이 지금도 그틀은 유지하고 있다라는게 중요한 얘기다.

## 12.15 (계속)
아까 이 우리가 시그널을 살펴보면 하나만 보내고 있을때는 요정도 에너지가 있는데 가령 두개 이상이 보내게 되면 에너지가 갑자기 뛴다 이거임 이거가지고 컬리젼을 디텍션한다는건데
저게 유선에서는 저렇게 명확하게 이런게 확인이 되죠 유선은
근데 무선환경은 이거 자체가 이 시그널이 증가되는거에 대한 감지가 그렇게 명확하지 않다는거임
그리고 무선은 즉 내가 보내면서 센싱을 해야되잔아 보내면서
그러니까 이 장치는 내가 지금 보내고 있으면서 다른 다른쪽에서 온 시그널이 이 시그널을 통해서 시그널 레벨이 공기중의 레벨이 커졌나 보는건데 
이 무선에서는 그런 딜레마가 있다 이거죠 내가 보내고 있는 사이에 만들어내는 내가 만든 시그널 크기가
엄청나게 있다 이거임
내가 지금 뭔가를 보내고 있잔아 따라서 내 위치에서 느끼는 시그널이 굉장히 큰데
이 멀리서 온 시그널이 쭉와서 나한테 와서 내가 느끼기 까지에는 약간의 변화가 있을수있다 이거지 약간의 변화
내 시그널 , 내가 느끼는거에 비하면은 상대방 시그널이 너무 취약할수가 있어요
내가 보내고 있는 입장에서는 내 시그널이 다른 시그널을 감지하기에 방해가 되는거다 내시그널의 크기가
너무 커서
당연히 내 시그널, 바로 내 위치에서 발생한거니까 내가 제일 크게 느끼는거에요
그래서 무선에서는 바로 이런 문제때문에 컬리젼 디텍션이라는 기능을 신뢰하지 않는다. 무선에서는
유선에서야 저걸 신뢰를 하는데 그래서 나온게 컬리젼 어보이던스가 된다.
무선에서는 이와같이 컬리젼 디텍션을 취하는게 아니라 최대한 내가 충돌이 발생안하게끔 최대한 조심한다 
충돌을 스스로 그냥 피하는 수준으로 보낸다 이거임
그래도 충돌이 발생하면 어쩔수없이 뭐 타임아웃을 줘서 항상 ack를 기다려야 되 그러니까 애는 충돌에 대한 디텍션을 못하기 떄문에 충돌이 발생했는지 안발생했는지 내가 최대한 조심했지만 충돌이 발생했는지 안발생했는지는 상대방으로부터 ack 메시지가 오느냐 안오느냐 로 판단을 한다 여기서는 무서에서는 ack 메시지가 정의가된다 이거죠
그래서 타이머라는걸 두죠 ack 메시지를 무한정 기다리는게 아니라 타이머라는걸 설정을 해서 이시간동안 
ack 메시지가 안오면 충돌이다. 라고 해서 재전송한다던지 이런식을 쓰는것이다
그러니까 타이머가 컬리젼 디텍션 기능을 간접적으로 해주는걸로 생각하면된다 이 csma ca는 
컬리젼 어보이던스 방식

## timing in csma/ca
자 최대한 조심한다고 했는데 충돌이 안나게끔 어 지금 봤던 것중에 안디펄시스턴트 방식에 의하면은 여기서 뭐 아이들이 감지되면 한슬랏 기다려보고 또 p의 확률로 보내보고? 요고 모양이 달라졌다 비지동안 쭉 감지하다가 아이들이 감지가 되면 이런것들이 새로 들어와야겠죠 csma ca는
인터프레임 스페이스 ifs , 라고 하는 어떤 시스템 파라미터가 있음 맥파라미터다.
인터프레임 스페이스
이거는 스펙이 정해져있다 뭐 마이크로세컨드 뭐 이렇게 정해져있다 이거임 근데 이게 여러가지가 있다 
si short 있고 아니도로리가 있고 여러가지가 있다. 그 여러가지 는 그 사정에 맞춰서 둔다 가령
이스테이션이 굉장히 우선권이 큰놈이다 그러면 이 우선권 이 큰 스테이션에게는 인터 프레임 스페이스값을 작은것을 준다.
우선권이 낮은 스테이션에게는 인터프레임 스페이스를 큰값을 준다  더오래 기다리게한다
이건 무조건 기다려야 되는 시간인데 여러개를 준다 이거임
여러개를 설정해서 그중에 우선권에 따라서 이거를 어사인 하는거죠
고런 역할을 하기도 한다 이거죠 ifs 가 인터프레임 스페이스가
그만큼 기다린다음에 보내느냐 또 기다리는거지 컨텐션 윈도우라는 이 파라미터가 또 스테이션별로 주어지는데 그만큼에 해당하는 슬랏이 요 슬랏인데 요게 타임사이즈가 요 타임들을 매우 잘게 쪼개서 슬랏이라고 인제 해서 슬랏 개수를 컨텐션 윈도우가 의미하는 숫자만큼 기다린다음에 
보내는것이다 그러니까 기다리게 하는 변수가 2개가 있다 인터 프레임 스페이스 가 있고 여기에 컨텐션 윈도우 라고 하는 이런 2가지 변수가 있다.
얘도 어떤 우선권을 주기 위해서 여러가지가 있다. 컨센션 윈도우는 사실 이거나 다름없다 이거나 
이거나 다름없죠 지금 이 스테이션이 가령 타임아웃이 되서 뭐 실패한 케이스가 몇번있다라고 하면은 컨텐션 윈도우는 1부터 2의 k승 -1 요사이에 랜덤하게 하나 뽑는것이다.
뽑아서 그 개수만큼 슬랏을 기다리는데
기다리는데 여기 우선권을 내가 줄수있다면 
이 맥시멈값을 제외한 나머지 여기를 횟수에 상관없이 우선권있는애는 1부터 8까지 만 사이에 두고
우선권 이 없는애는 1부터 이 k에 계속 적용을해서 k가 10까지 10번까지 허용되면 1부터 1000사이의 값을 어사인한다는거임
컨텐션윈도우도 클래스 에 따라서 우선권 처리를 할수있는 식으로 운영을 한다 거기까지 깊게 들어갈 필요가 없이
두가지 요소가 있다 ifs 요소와 컨텐션 윈도우 라고 하는 요소 를 다 딜레이 기다리게 하는것이다.
두가지로 나눠서 한 까닭은 여기에 여러가지, 그 융통성을 이 맥 알고리즘속에 맥 프로토콜속에 여러가지 융통성을 두기위해서 두가지로 나눴다 실제이 맥을 공부하는 그 와일리스 랜에서의 이 맥 프로토콜을 공부하는 사람들은
이 두가지 파라미터가 굉장히 중요하다. 저 두가지 요소 
인터 프레임 스페이스 하고 컨텐션 윈도우 값들을 어떤 상황 상황에 맞춰서 어떻게 운영을 하느냐에 따라서 이 어떤 시스템에 성능을 네가 제어할수있다 그래서 이게 중요한 파라미터로 쓰이는데 우리는 이 개념만 본다
왜구지 2개로 나눴을까 융통성을 더 주기 위한것이다 이 네트워크 를 제어하는 매니지 먼트 입장에서 융통성을 더 갖기 위해서 스펙에는 이 2가지로 나눠서 웨이팅 타임을 조절한다 그리고 나서 센드 프레임 
이만큼 기다리고 났으면 센드 프레임을 하고 
타임 아웃은 인제 기다리는것이다 보내고 나서 ack가 올떄까지 타임아웃 설정하고 기다린다음에 안오면 다시 재전송하는데 그떄는 다시 여기로 돌아와서 똑같은 이거를 수행하죠 다시 수행을 해요 근데 한번 실패가 있었는까 
뭔가 파라미터가 또 변화가 생긴다 이거죠 
변화가 생기면서 계속 이루프를 계속돌린다.
## 2
요기서 문제는 요사이에 그럼 계속 그 아이들을 감지를 계속 하면서 슬랏을 가는거야 이게
이렇게 쭉 계속 여기도 아이들인데 기다리다 보니까 남이 그 다른사람이 끼어들었다 그러면 어떻게 되느냐? 
여기 그 이그림에는 없죠 
이런 문제가 여기 이그림에는 없죠 당연히 csma ca 는 그런기능 까지 다 그런것까지 다 포함이 되요
뭐 간단하게 얘기하면 여기도 계속 이 케리어센싱을 하는거지 계속 요시간동안 은 할필요없어요 무조건 기다린다.
그리고 이시간동안에 센싱을 하고 아이들이면 또 한채널 기다리고 가령 애가 10개의 채널을 기다려야 된다라고 변수가 지금 랜덤넘버가 나한테왔으면 10개를 기다려야 되는데 그때마다 채널을 체크하는것이다.
체크하다가 한 3개쯤 지났는데 
어 갑자기 아이들인게 다른 사람이 끼어들어서 전송을 하고있더라 그러면 어떻게 하느냐 ? 
3개는 지나갔죠 아직 7개남았지 
그럼 이상태에서 딱 멈추는것이다 7개라는 숫자를 갖고 또 계속 7개는 더이상 진행안하고 멈춰있는것이다 타이머를
얘도 멈춰있으면서 채널을 계속 센싱을 하는것이다 그러다가 
아이들로 돌아오면 어떻게 하느냐 그럼 그떄부터 다시 7이니까 6감소시키고 5감소해서 이 제로가 되면 보내느냐 즉시 그렇게 가는게 아니라 여기서부터 시작을 해요 사실 
인터프레임 스페이스만큼 여기서 기다린다음에 카운터가 7이니까 7에서 1감소시키고 이게 계속 다시 처음
이카운트 10에서 시작하는게 아니라 아까 멈춘 시작 시점부터 줄여나간다 이거임
그렇게 해야지만 오래 기다린애가 불리하지 않을수있다. 유리하게 만들어주는거지 중간에 이 아이들이 없어지고 비지가 되더라도 고 순간에 카운터 값을 유지한다. 그러면서 또 계속 기다리다가 아이들이 되야지만 이렇게 감소가 되는거야 채널이 아이들이 감지됬을때마다 
그런게 csma ca는 인터프레임 스페이스 가 아까 애기한대로 이 스테이션간에 이 단말기들 간에 어떤 프라이빗 우선권을 서로 다르게 주기위한 용도로도 쓸수있다. 

요얘기가 그얘기다.
그 채널이 중간에 비지가 되면 어떻게 하느냐 자여기 그얘기가 아까 했던얘기
타이머 , 타이머인데 이거 백오프 타이머라고 지금 우리 책에 들어가보면 백오프 타이머값이 현재 9개 
9로 형성되는거다 타이머가 
그럼 9부터 시작해서 하나 
시간 한시간동안 한슬랏동안 아이들 이라고 하면 8이 되고
계속 감소시키는것이다 카운트 다운을
하는데 가다가 비지면 거기서 멈춘다 다시 9로 돌아가는게 아니라 여기서 멈추고 아이들 이면 이제 그 숫자부터 감소시킨다 라고 해서 이얘기가 그얘기다 리스타트 하는데 이게 

## csma ca를 플로우차트
지금 내가 설명한거 그래프 상세히 들여다 봐야되고 항상 루프가 있죠 충돌이 나거나 문제가 발생하면은 횟수를 증가시키고 뭔가 다시 수행하는 

## controlled access
자 그다음 문제는 이 무선 통신쪽에서 이제 하는얘긴데 우리 이책에 요 부분은 13장인가 14장인가 다른챕터에 들어가있는데 지금 여기서 얘기안할수 없는 만큼 중요한 문제가된다. 이게 무슨 문제냐면 
이게 무선통신에서 그러니까 내가 전송을 하고안하고는 캐리어센싱을 한다고 그랬죠 근데 이런 상황이 있다.

b라는 노드가 a에게 뭔가를 보내고 싶다.
b라는 노드가 그러면 근데 b라는 노드는 캐리어 센싱을 할수있는 범위가 이만큼이다 라고 했쬬
캐리어 센싱이 무한정 센싱을 못할거아니야 그냥 반지름 500미터 1키로 이정도를 뭐 센싱을 한다 이렇게 얘기를 하죠
다시 무선에서 ?? 작아지기 떄문에 이 케리어센싱 할수있는 범위가 줄어든다 
다시말해서 이거 반경500 미터 안에있는 다른 노드가 뭘보내면 얘가 센싱을 할 수있을수 있다 이거임
그래서 이 b는 이만큼의 그 센싱을 할수있는 범위가 있고 c는 이만큼의 센싱을 할수있는 범위가 있다 이렇게
이문제에서 지금 상황이 뭐냐 
b가 뭘 보내고 c는 뭘 보내고 b는 감지를 못한다
얘 범위를 넘어선 c 넘어선 자리에 멀리 c가 있기때문에 이런 무선통신에서 얼마든지 있을수있는 상황이에요 서로 단말기들이 이렇게 
공간이 그냥 마음대로 펼쳐져 있으니까
자 b는 내 감지범위 안에 있는 a에게 패킷을 보내고 싶어요 그러면 감지, 채널을 감지해서 놀고있다고 그러면 보낸다 이거임 
근데 문제는 c가 b가 보내고있는거를 모른다 이거임
왜냐하면 c입장에서도 역시 b는 캐리어 센스 범위 밖에 있기떄문에 
그래도 c도 a에게 보낼게 있으면 마음놓고 보내게 된다. b가 보내고 있는 사이에 
캐리어 센싱이 안되서 b가 보내고 있다는건 뭐기떄문에 c도 보낸다 이거죠 
여기서 충돌이 난다.
a입장에서는 b에서 온거와 c에서 온게 동시에 오기떄문에 충돌이 나는거다 이거지 
이런 문제는 이 무선 이 무선 네트워크에서는 아주 중요한 문제이고 얘를 일종에 숨겨져있는 노드죠  b입장에서는 c가 숨겨져 있는거고
c 입장에서는 b가 숨겨져있는것이다
같은 목적지를 공유하는 두개 서로 숨겨져있기떄문에 동시에 전송할수밖에 없다 이거임 무선에서는 이걸 바로 히든 모드 프로블램,  

히든 스테이션 프로그램, 히든 모든 
이게 무선에서 굉장히 중요한 문제다. 해결방법을 찾아야 한다 저런 경우에
## 
자 이런 히든 모든 문제를 해결하는 방법이 여기서 애기하는 실제 
이 그문제를 보자 아까 똑같은 상황인데
a라는 노드가 있고 b와 c가 서로 히든 위치에 있다 과연 b가 a한테 보내고 있다는걸 c로 하여금 어떻게 알게 해줄까 이게 중요한것이다. 숨어있지만얘가 b가 보고 있다는걸 알게해주는게 중요하다 
그 역할은 a가 해준디.
왜냐하면 얘와 얘사이는 통신을 할수없다
너무 먼거리라서 중간에 a는 얘의 통신 범위안에 들어있고 얘의 통신범위 안에 들어있다
그래서 a를 활요하는건데 무슨 일을 하느냐 데이터를 보내기 전에 ready to send 라고하는 이 컨트롤 시그널을 이 a한테 보낸다. 내가 너한테 지금 보낼 패킷이 이거임 rts
그러면 이속에 어떤 내용이 들어있냐면 내가 너한테 보낼 패킷이 있는데 패킷의 길이는 어느정도 되기떄문에 보내는 시간은 어느정도 될꺼다 라는 향후에 전송하게 되면은 내가 채널을 점유하게될 시간 구간을 알려주는거다. 내가 1초동안점유할거같다 너한테 패킷을 보낼준비가 되어있고 그패킷을 1초동안 점유할거같다 라고 보내면 
a는 그걸 받아서 응답을 해주는데 무선이잔아요 그럼 얘가 얘한테 응답을 하면 그 시그널이 얘한테도 가겠죠
c한테도 간다 이거임 
a가 역할을 한다.
b가 나한테 뭔가를 보내준다고 하는데 앞으로 채널이 한 일초동안은 b한테서 오는 패킷때문에 점유될거같다라는 정보가 이리로도 간단얘기죠 여기는 ack의미를 가지는 ??파고 
c가 아래 ?? 
아 a로부터 난 가지 못하지만 b로 부터 데이터를 a가 받게 될꺼구나 
앞으로 충돌한 그럼 1초동안 나 를 보내지 말아야겟구나 a에게 이런생각을 하게된다. 
간단하다. 여기는 a를 활용하는것이다 그래서 이게 이컨트롤시그널이 오고 가고 그다음에 데이터가 가는것이다 그다음에
그리고 인씨멈?보낼수있다 아까 일정한 시간동안 데이터를 보낼수가 있다
요게 컨트롤 프레임을 사용을 해서 히든 노드 프로그램을 쓰는 문제다.
이 히든 노드 문제고 

## 익스포우즈드 문제
이런저런 상황이 나오는데 2가지 대표적인 케이스가 바로 히든 노드 문제하고 익스포즈드 문제 이건 너무 괜히 나서는 문제다
어떤 상황이냐면 a에 통신범위가 요렇게 되어있다.
a는 d한테 보내는데이터가 있는거고 c는 d한테 보낼 떄가 있어요
자 그러면 과연 a는 b한테 보내고 있으면 가령 가령 a가 b한테 보내고있으면 
이 보내고 있는 시그널이 c가 감지가 되죠 
그렇죠 a가 범위안에 들어있으니까 
그 익스포우즈드 되어있다 이거지 a에 그 통신범위 안에 지금 노출이 되어있는거죠 c가 (이게 더 맞다)
근데 사실 c는 d한테 데이터를 보낼게있는데 d한테 보낼 데이터는 내가 보내면 가령 a가 보내고 있는 데이터범위를 넘어서 있기떄문에
얘한테 간섭을 안줘 그래서 보내면되는데 
얘가 a가 뭔가 보내고 있을때 a가 b한테 보내고 있을때 c도 보내도 되는데 못보낸다 
왜? 시그널 채널 이지만 비지 잔아 얘떄문에 비지라서 보낼수 있는데도 못보낸다 이거임 
이건 익스포우즈드 문제 

채널을 idle을 감지해야 보내는거였잔아 지금까지 모든 그 맥 프로토콜이
근데 이경우에는 보내도 상관이 없는 사황인데도 못본다 이거임 
이건 익스포우즈 문제고 
이건 어쩔수가 없다. 이건 못풀어 이건 네트워크에 낭비 요소가 된다 이거임
익스포즈드 문제가 저건 풀방법이 없다.
내가 지금 채널이 idle 이아니기 때문에 못보내는거야 (기본원칙) 실제 보내도 되는데
저건 풀방법이 없다 아이디어 있으면 내봐요 내가 지금 채널이 아이들이 아니기 떄문에 못보내는 거야 기본원칙
실제 보내도 되는데
여기서 간섭이 없으니까 
a가 보낸 놈은 얘한테 간섭을 못준다 거지
그런데도 못보낸다 얘기죠 익스포우즈 문제
요런 두가지 문제가 무선통신에 있다 이거임
참고로 여기에 지금 아이 이이이 802.11 이라고 나왔는데 전세계 통신 규격에 관해서 
학회임
규격제정

핸드쉐이킹에 의해서 
익스포우즈드 문제는 어떻게 되는지

## IEEE 802.11 
A가 양쪽에 RTS 보내면 CTS 오면 A를 B한테 보내는것이다
RTS CTS에서 결국 여기까지는 A는 안보내는것이다.
C는 여기서 왜보내 여기서 RTS, CTS를 보낸단 얘기야?
이렇게 보내면 깨지져 어차피 
C에 사실 데이터 보내기 전에 얘도 RTS CTS 를 쓴다고하면 얘한테서 오는 CTS가 C에서는 A의 범위안에 들어있기떄문에 깨져요 이건
C에는 RTS CTS를 내가 구지 익스포우즈 문제 
아까도 이게 좀더 발전하거네 그거네
내가 이 D한테 보낼게있는데 분명히 D는 여기에 간섭이 없기때문에 내가 한번 보내보겠다 라고 해서 

CTS/ATS를 받는단 말어에요
그러면 데이터를 보낼려고 했는데  이 CTS가 못온다 A의 범위안에 잇기떄문에 꺠진다 라는거임 A와 보내는 데이터와 여기서 오는 CTS데이터가 꺠져서 이 컨트롤 시그널에 속,텀이 안된다.
여기 익스포우즈드 문제는 해결이 안된다 라는거임

여기까지가 랜덤 엑세스다
## controlled access
실제 랜덤 엑세스 지금까지 얘기한 csma ca 방식으로 지금 여러분이 지금 어 지금 요기 가령 어디에서든 무선랜을 접속한다든지 어드서든 다 이방식을 쓰고 있다 802.11 맥프로토콜을 다 
실제 현재 쓰고있는 여러분들 쓰고있는값 그런게 쓰고있는값
## 컨트롤엑세스
컨트롤엑세스는 누군가 제어하는거죠 뭐 저 예약 방식이있고 뭐 
폴링방식 있고
예약방식은 미리 여기앞에 풀네임 시간쪽으로 자 5개가 지금 공유한다 하면 5개중에 내가 보낼 데이터가 있다 없다 예약을 하는거죠 
1이라고 하면 예약이 된거야 그럼 예약되는 이만큼의 시간이 주어지고 얘도 이만큼 주어지고 그럼 얘뜰이 3개가 예약되어있으니까 3개 쓴다음에 
다시 또 예약프레임이 오고 
여기 예약 프레임에 1이라고 셋팅 한놈만 또다시 예약프레임
이런식으로 서로 이프레임을 같이 사용을 하는거죠 예약 구간 데이터전송구간 이게 계속 반복되는 이런 시간이 지나면서 요런 프레임을 사용하면서 서로 충돌이 안나게 한다 이게 컨트롤러
또다른 방식은 
프라이머리 노드가 하나 있어서 얘가 다 컨트롤하는거죠 얘들 공유하는 놈들을 서로 컨트롤하는 거에요
그래서 가령 얘들간에 이방식에서는 이 주극이고 종국인데 이게 번역된
a 와 b사이에 통신을 하고싶어도 서로 못하고 프라이머리를 보낸다음에 얘가 이렇게 보내는방식이다.
오로지 통신은 주고 가고에 주극을 통해서만 통신하는방식
주극은 철저하게 이 미디어 사용하는것을 관리를 하는거고 
그래서 뭐 주극이 누구에게 보낼게있으면 걔한테 보내서 ack를 받으면 걔한테 보내고 거기다가 ack 받고끝내고 
주극에서 종국에서 보낼 일이 있을 지 모르니까 자 너 보낼일이 있냐? 없다 
보낼일있냐? 그럼 보내라 
이거 철저하게 주극이 관리하단다. 스트릭트한 방식

## Controlled access
그다음 방식은 토큰 방식이다 토큰이 네트워크에 하나있어서 토큰을 갖고있는 노드가 보내고 내가 다보냈으면 투큰?를 옆에 넘겨준다. 
토큰이 하나 개별적으로 들어오는방식 토큰 패싱 방식이다.
토큰 패싱은 하드웨어적인 투플로우지는 어떤 모양이라도 상관없음 로지컬하게 토큰이 일단 오고가면되니까 
반드시 뭐 이렇게 물리적으로 연결되어있는 토큰이라는 패스 가 항상 ??이어간다. 이럴 필요없이 이 방식에도 토큰이 하나잇어서 내가 쓰고 커브로 넘겨서 옆으로 보내는거고 어쨋든 로지컬 하게 1 다음에 2 다음에 3 이런식으로 토큰이 서로 옮겨가게 하는것이다.

토큰 전달 방식은 보면
심플하고 이게 컨트롤드 방식이고 그다음에 채널라이제션 이거는 뭐 
## 채널화
이거는 주파수를 나눠갖든지 시간을 나눠 갖든지 이미 여러번 나왔던 얘기다 잘 코드 분할을 하던지 이미 나왔던 얘기다.
지금 공유하는 채널이 있는데 미디어가 있는데 
미디어를 4개의 채널로 나눠서 대역폭이 다른것이다 우리 얘기했었죠 광 케이블 공중에 주파수 성분을 달리하면서 동시에 시그널 오고 간다고 딱그거다 우리지금 ap도 가령 우리가 지금 무선접속할떄 어디까지 ap가 채널이 32개 있다 그러면 이런게 32개를 채널을 주파수 대역으로 나눈거죠
그래서 동시에 32개가 이렇게 통신할수있다 각자 내보내는 그 시그널은 그 대역에 집어넣어서 보내야되는거지 각자
그게 fdma 프리퀀시 디비전 멀티플 엑세스 방식
동시에 쓰는거죠 

이거말고 바로 있었던거 시간을 나눠서 시간을 촘촘하게 쪼개서 쓰는거
이건 동시에 쓰는게아니라 내가 쓰면 남이 못쓰는데 아주 짧은시간을 계속 바꿔가면서 쓰기때문에 마치 내가 계속 쓰는거 같은걸 느낄수있게 타임 디비전 멀티플 엑세스다.

이거는 여기서 얘기할때 우리먼저 얘가하고 다른사람 얘기하고 그다음 사람얘기하고 이렇게 시간을 나눠서 얘기한다
그런개념이다.
fdma는 높은 목소리를 주고받고 여기는 저음으로 주고받고 그건 내가 잘들리면 저음만 캐치해내고 이런것이다 동시에 막 진행하는데 
주파수 높낮이를 캐치하는방식

얘는 시간을 나눠서 
## 
그것도 저것도 아니고 동시에 막 주고받는데 그래도 통신이 되는방식

그게 cdma다. cdma 는 생각해보니까 더 확실한 예가 그거다.
우리 둘은 한국말로 주고받고 저기 둘은 영어로 주고받으면 서로 동시에 해도 내가 한국말 패치하고 저긴 영어 패치하고 그러지
코드가 다른거지 둘간에는 
사용하는 코드가 다르다 cdma 방식이다.
그래서 cdma는 각 유저들이 사용하는 코드가 키팩터다 코드를 서로 다른걸 쓰는데 지난번에 얘기했듯이 코드들은 서로 오쏘고널한 코드다
코드들은 서로 이너프로덕트를 취했을떄 0가 되는 방식들 그게 코드4비트라고 하면은 이런거죠 
나는 1 1 -1 -1 쓰고 누구는 
1 -1 1 -1 을 쓰면 얘들 다 각자 이거 곱하기 이거 곱하기 해서 다더하면 어떻게 되죠 ? 다 0가 되게 만드는 코드들이죠 이게
여기에 이거를 더하기 하면 0이다 이거임
그래서 이 코드와 이코드는 오쏘고널한 셋이다.
저런 코드들은 만들어서 서로 서로 다 오쏘고널 한 프롬프트를 만들어서 4개의 유저가 4개의 오쏘코널한 코드를 만들어서 각자 다른 코드를 사용해서 쓰면 그러면 내 보내는 데이터에 내가 자기코드를 곱해서 이렇게 보내면 토탈이 이 같이 쓰는공간에는 이런값이 돌아다니는거에요
그렇죠 4명의 유저가 자기가 ?? 자기 코드를 곱해서 만들어진 이 신호들이 더해져서 돌고있다.
섞여진 신호속에서 d1만 어떻게 추출하느냐? 
cdma 에 기본원리
저기 지금 d1c1 + d2c2 + d3c3 + d4c4 (d4는 자기코드) 데이터를만들어서 공중에 띄어보내면 받은쪽에서 내가 오로지 d1만 알고싶다 그러면 여기다가 곱하기 c1만 하면 d1이 나온다.
토탈 지금 막돌아다니는 이 시그널에 내가 요 c1이라는 코드를 이너프로덕트하면 어떻게되죠? 괄호를 풀면 
c1c1+ d2c2c1 
곱해지면 서로 다른 코드가 곱해지는것이다
ppt참고
이렇게 되죠 c1이라는 코드를 합해진 시그널에 이너 프로덕트 하면 이와같이 식이나오는데 
CiCj는 0이다 이게 바로 이너프로덕트에 기본 어 성질이다 이거임
오쏘고널한 코드면 아까 봤듯이 그렇게 서로 오쏘고널한 코드라고 하면
서로 다른 코드를 이너 프로덕트 시키면 값이 0가 된다.
서로 다른 코드일때 그래서 c1과 c4가 여기 곱해지잔아 없어지는거야 0
c1과 c3없어지고 
c1과 c2없어지고 
오로지 c1만 c1 자기 스스로를 곱한거죠 스스로 곱한거는 이 자기스스로 곱하면은 이사이즈가 4개죠 
그럼 4가 나오죠 4가 
자기 코드가 자기 스스로 곱하면은 항상 자기사이즈에 해당하는 숫자가 나온다 
1*1+1*1-1*-1
자기 코드를 자기 스스스로 이너프로덕트하면 사이즈가 나온다 그래서 바로
여기다가 사이즈로 나누면 그 사이즈를 나누면 바로 d1이라는 값이 추출이된다. 이게 cdma 의 방식이다.
그래서 오쏘고널한 셋을 이 코드셋을 찾아내는게 중요하다  바로 이것들이 4개를 예를 보였을떄 c1~c4까지 얘네들 아무거나 곱해봐도 0가 나온다 
이너 프로덕트 취하면 0가 나온다. 자 그럼 걱정이 그럼 저런 오쏘고널한 셋을 어떻게 찾을까 
이거 4개짜리는 앉아서 나올거같은데 가령 8개 
유저가 지금 1000개 되면 도대체 이 코드를 어떻게 찾아낼껀가 오쏘고널한 셋틍 관련방법이 이 뒤에 orj
월스 테이블 

## 
너무 간단하게 만들어낼수있다 월스 테이블을통해서
전에 나온 이내용들 이 슬라이드 이거에요 이거 지금 좀 그림으로 더 알기쉽게 표현한것뿐이다 
이그림들은 서로 곱하잔아 이게 전체 합해진거 
여기다가 취하는 놈에게 결국 자기 코드를 곱하면 m이 나온다 이문제 앉아서 보면되고
이 오쏘고널한 셋은 어떻게 만드느냐
너무 간단하다 시작이 +1 이라는 하나 갖고 합시다. 
그다음 사이즈는 요놈이 요기 하나 요기 하나 요기 하나 그거에 컴플리먼트값
여기 +1이면 -1이 된다.
여기시작해서 2에 1나짜리가 2by2자리를 만드는데 방법이 얘가 요기요기요기 그리고 컴플리먼트 요거 보다 사이즈가 하나 큰거는 2by2 가 이렇게 만들어지면 4by 4가 되죠 요덩어라기 요기하나 요기하나 요기하나 그리고 여기는 컴플리먼트
얘의 - 가 들어간다 즉 - - - + 
이렇게 만들어가면 요 한줄한줄 하나 띄어내면 이게 오쏘고널한 코드가 된다 8개 까지 이거가지고 8by 8짜리 만드는데 요놈을 고대로 컴플리먼트 그러면 8 by 8 자리가 나온다. 또 그륩도 16 바이 16자리를 만들수있다 요놈도 들아맞는거다
계속 사이즈를 키워 나가면서 그때그때 나온 요 하나의 로우 
행에 해당하는 놈들이 코드라 이거다 오쏘고널한 
이렇게 만들어진 코드들이 정말 오쏘고널 한지 워시 테이블이 바로 오쏘고널 코드를 만들어주는 너무 쉬운 방식 제시한다.
cdma 방식이 - 굉장히 효율적으로 보이죠 저런 코드들만 갖고 있으면 그냥 뭐 fdma 해기고 주는거죠 구지 주파수 나누고 장치가 있어야되요 
주파수들에 서로 다른 시그널에 다른 주파수에게 내 시그널이 올려면 이 보내는 장치속에 변조하는 장치가 있어야된다 이거 복잡한 일이야 그런거 필요없다 이거죠 포워드배? 내데이터를 곱해서 보내기만 하면된다 최대한
그래서 효율이 높고 cdma는 와이얼스 커뮤니케이션해서 굉장히 많이 쓰이는 독보적인 존재가 된거다 cdma는 
여기 월스 테이블 과정을 보였는데 지금 말했듯이 보이면됨

## 
90개의 노드가있다 월스태이블 얼마 까지 만들어야 되겠는가
몇바이 몇 
어디까지 가야
8
7 =128
7비트 짜리 
2의 7승에 해당한다. 
여기 막판에 이거 보여주고 있다.

## 마지막 부분
오쏘고널한 셋을 가지고 자 여기까지 정확히 12장 까지 한번 봤다.
