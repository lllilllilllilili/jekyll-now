---
post : layout
title : 컴퓨터구조(기)12
---
## 시험
1번. 로우 컬럼 어드레스 설정하고 버스트 랭크 한꺼번에 읽는 워드의 개수를 설정하고 버스트 모드로 그러니까 이게 한꺼번에 일괄모드로 데이터가 전송된다. 우리가 앞에서 내가 스킾한 3페이지가 있는데 sdram 싱크로너스 디램 페이지 베이스 디램 
관련된 내용인데 읽어보라고 했쬬 sdrm
sdram 은 sram 하고 다르다 dram인데 싱크를 가지고 클락 기반으로 동작한다고 해서 싱크로너스 디램이다 라고한다.

2번 메인 메모리 캐시사이에 전송단위를 블락이라고 한다.

3번. 1k byte 용량 2word(=8byte) 끝에 3개 떼고 그다음에 1024/ 8 = 128 7승이죠
0x12345678 
01 10 01111 000

10 01111 = 1+2+4+8+64 = 79
// 이거 무슨 캐시 가정하는거야 다이렉트 맵드 캐시 가정한다 그러면 뭐를 알아야되? 캐시 블락의 개수의 개수를 알아야지 캐시가 몇개의 블락으로 구성되어있나 캐시용량은 1 킬로바이트고 한 블락이 두워드니까 바이트로는 몇바이트야 
8바이트죠 한블락이 8바이트 
이 3비트를 블락 오프셋이라고 함, 블락 오프셋이 뭐에요 그블락내에서의 상대적인 위치 블락 오프셋 그래서 블락 오프셋은 얼마에서 얼마까지 변할수있느냐 0부터 그블락의 크기 -1 만큼 
블락이 8바이트면 0부터 7까지 변하는값이다. 그다음에 이제 요기에 있는 나머지가 캐시 인덱스인데 블락, 캐시블락의 개수가 128개 라고 했으니까 2의 7승이잔아요 그쵸 
그러니까 여기에 7.


4. byte address 0,4,8,12,16,12,16,52,60
word address 0, 1, 2, 3, 4, 3, 4, 13, 15

캐시가 두블락으로 구성되어있는것이다 
그러면 자 cpu에서 다음과 같이 워드들을 참조할때 캐시미스는 몇번 발생하는가 숫자만 적어라
이때 주소는 무슨 주소? 요 주소는 바이트 어드레스 라고 했으니까 일단 이것의 해당되는 워드 어드레스를 4로 나누면 
근데 지금 두워드 잔아요 그쵸 
캐시가 2워드야 , 워드넘버 그리고 한 블락이 두워드이고 그다음에 캐시 용량이 4워드 니까
처음에 워드0 읽을때 얘는 뭐야 
얘의 그 블락넘버 얘의 블락넘버 
얘의 블락넘버는 뭐지 이숫자를 , 워드어드레스를 블락의 크기 블락의 크기가 2워드죠 이로 나눈 뭐에요? 2로 나눈 몫이 걔의 블락 넘버다 그러니까 블락 어드레스는 요고 각각을 2로 나눈 몫이니까 0 0 1 1 2 1 2 6 7 
이 블락어드레스 가 긱긱 0과 1의 블락 어드레스가 같다. 뭐라고 이해해야 되지? 어 이두개가 같은 0번블락으로 같이 움직인다. 
0번 워드를 cpu에서 읽을때 뭐까지 같이 움직이는거에요 1번 워드까지 같이 캐시로 올라간다.
이렇게 보면 0 1 0번 워드 있고 1번 워드 있는데 얘들이 두개가 같은 메모리 블락 넘버를 가져 그러니까 우리가 그냥 한번 생각해보면 얘를 읽어서 캐시에 들어갈때 뭐까지 같이 들어갈까 얘도 같이 따라 들어간다 그러니까 결국은 0번에서는 얘는 캐시 히트야 미스야 , 0번은 미스다 근데 그다음에 1번읽는떄는 캐시 히트야 미스야 캐시 히트지 왜냐하면 0번읽을때 1번 워드를 같이 저기 캐시에 들어가있다고 
그렇게 따지면 자 여기 요것들이 각각 요렇게 블락 넘버를 봐도 되고 일단 캐시 블락 넘버는 밑에 블락 어드레스가 나오면 이블락 어드레스를 캐시블락의 개수 2로 나눈 나머지니까 요 0을 2로 나눈 나머지는 0이고 1 이고 1이고 2는 어떻게 되 ? 2는 2로 나누면 나머지가 0이다. 이거 무슨얘기야  
블락 2는 2로 나눈 몫이 0이란 얘기는 요 블락은 캐시 블락 0번에 위치한다 그러니까 2개가 있으니까 캐시블락이2개야 극단적으로 
여기 아니면 여기 들어가는데 어떻게 들어가? 그 블락 어드레스가 짝수면 0번캐시죠 그다음에 그블락 어드레스가 홀수면 1번 캐시블락에 들어간다. 
자 그리고 이게 지금 뭘 보는 캐시미스를 보라는거지 그치 
0번 블락 접근할때 그게 캐시블락 0번에 들어가고 결국은 얘도 캐시블락 0번에 들어가있고 
사실은 이때 우리가 태그를 봐야되는데 우리가 그냥 숫자를 가지고 어 그 계산할수있는, 그냥 알수있으니까 요기에 처음에는 미스고 그다음에 히트고 그다음에 얘들 두개가 연달아서 들어가니까 처음에 미스고 히트고 그다음에 4번 어떻게 되요? 4번은 블락 2지 그렇지 블락 2인데 얘가 어디에 들어가요 블락 0에 들어가서 누구를 쫓아내지? 아까 올라왔던 0,1 을 쫓아내고 그자리에 들어가죠 그쵸 그건 미스?
그다음에 숫자가 그다음에 3번은 여전히 블락 1번 그대로 있으니까 히트고 4번은 블락 제로에 히트고 그다음에 13번은 처음을 묻는거니까 미스다. 처음에 읽는것은 미스고 
그다음에 15번, 13번이 지금 블락 어드레스 6인데 13 번 워드하고 같이 블락 을 이루는 한 블락을 이루는 워드는 몇번일까? = 12번 
13번 읽을떄 12, 13이 같이 캐시에 들어가는데 어디에 들어가냐면 블락 0번에 들어간다 
만약에 여기서 15가 아니고 12라고 했으면 이거는 미스가 아니고 히트죠 그렇죠 그래서 이렇게 따지면 우리가 캐시 미스 의 횟수가 5번이라는것을 알수있음 

5번 . 영어 약자로 lru 
풀네임은 리스트 리스트리 유즈

6번. 처음에 뭘 물어요? 세트의 개수, 세트의 개수는 뭐에요? 지금 용량이 32 , 8킬로바이트 라고 했고 
한 블락이 16바이트 라고 했으니까 사실은 8키로 바이트가 16바이트 블락으로 나누면 이게 애가 만들어낼수있는 토탈 캐시 블락의 개수다 
근데 지금 2way 라고 했으니까 다이렉트 맵트는 캐시 블락 하나가 하나의 인덱스에 할당이 되지만 
2way는 뭐야, 한세트에 2개씩의 블락으로 할당한다고 했죠
그래서 2로 나누면 256개
256개의 집합이 있는거야 
256개의 집합이 있고 각 집합에 블락이 몇개씩 구비되어있어요? 2개씩 그게 2way set associative 캐시 다.

7번.
역시 같은 메모리 시스템인데 거기서 어 
이 블락 
각 블락의 태그는 몇비트인가?
태그? 태그는 지금 어떻게 되 
태그가 뭐에요 전체 어드레스에서 밑에 블락오프셋을 떼네고 그다음에 
어 캐시인덱스 여기서는 지금 셋 어쇼티브 캐시니까 셋 인덱스를 뗴내고 그나머지 위에 부분이 태그 값이죠 그렇죠 그래서 
지금 32bit 중에서 어 블락 크기가 4워드 라고 그랬으니까 바이트로 하면은 몇바이트에요 4워드, 16
한워드에 4바이트 
그래서 4비트를 아래 4비트를 뗴버리고 그다음에 아까 그다음이 세트 넘버인데
이 세트넘버는 셋 어쇼티브 일경우 세트넘버고 다이렉트 맵트 캐시일떄는 캐시인덱스라고 부르죠 그렇죠
세트 넘버가 셋이 몇개였어 256 개 였죠 그렇죠 그러니까 몇비트가 세트넘버에 해당되요? 8비트 
그러면은 여기 4비트 8비트 12비트 를 제외한 나머지 몇비트? 20비트가 태그에 해당한다. 

8번.
한 블락 당 밸러드 하고 태그 를 합친 21 비트가 필요하고 한 블락이 16바이트니까 비트로 환산해야 하니까 * 8 
그리고 한 세트의 그런게 몇개있어요 2개
이게 한 세트를 위해서 필요한 메모리다 그런 세트가 몇개? 256개 있짠아요 그렇죠
그러니까 토탈 76288 비트가 

9번.
1 기가 헬스 클락 시스템에서 L1 캐시 엑세스를 위해서 1클락, 메모리 엑세스를 위해서 100 클락 사이클 이 소요된다.
L1의 히트 래이트가 0.95
일때 
이시스템에 AMAT 몇 클락 사이클 인가

거기에 메모리 엑세스 타임 평균 메모리 엑세스 타임은 일단 캐시 윗 레벨에 있는 캐쉬에 엑세스 하는 타임 * 캐시 힛 레이쇼 (이게 왜 이 횟수만큼 이만큼이 성공하는거지 그런데 캐시 미스 레이쇼는 머에요, 실패했을때는 아래쪽에 있는 메모리 에서 데이터를 가져와야 된다. 그떄 얼마만큼 100 사이클 든다고 했지 그치, 그래서 캐시 )
L1 캐시에 엑세스 타임은 1 cycle 이라고 했으니까 1 * 0.95 그다음에 미스 했을떄 메모리에서 가져오는 사이클 100 사이클 이라고했으니까 100* 미스 레이쇼는 뭐야 1-히트 레이쇼가 미스 레이쇼 죠 그쵸 그러면 
0.05

10번.
한 블락의 크기가 
한블락의 크기가 8바이트니까 밑에서 몇비트를 떼야되? 주소에서 3비트를 뗴야된다 그게 블락 오프셋이고
그다음에 256개의 세트를 가졌다고 했으니까 세트 넘버로 몇비트를 뗴야되? 8비트를 뗴야된다. 
그러면 어 주소 8188번지를 읽을떄 이 메모리 블락이 적재되는 세트 넘버는?? 이게 
여러분들이 그 교재 나와있는 예제 에서 한부분인데 요 이거 계산하느라 고 시간 다 보냈을거같은데 이게 지금 8188이 이렇게 되요 이렇게 
2048 그다음에 4096 그다음에 8192 
8188, 어 이거 확인해 봐야겠는데 이게 8188이 2진수로 이렇게 안나올거같은데 
8188이 이렇게 나오는게 맞나? 
잘못된거 같은데
내가 이거 이진수 계산기가 
뒤에 몇개?
0이 몇개? 2개죠 
어 2개야 
교재에도 틀렷구만
우리가 
8192 그러면 이게 2의 13승이다. 
그러면은 우리가 1
8192를 이진수로 따지면 1하고 밑에 0이 몇개? 13개 있는거야 
14번 쨰에 1이 있고 밑에 쭉 13개의 1이 있는데 
8188은 어떻게 되?
8192에서 4뺀거지 그러면 1하고 0이 13개있는데서 
밑에 4를 아래로 뺴니까 여기애 100을 빼는거죠 그럼 어떻게 되? 요부분에서 100000에서 사실 1을 뺴는거니까 어떻게 될거같아 여기가 전부 여기서 여기까지가 1로 채워지고 
이게 몇개야 이게 지금 13개 2비트빼고 여기에 11개가 1이 되고 여기가 00이 된다. 이렇게 
8188 이죠 그냥 그 여러분들 숫자에 익숙하면 그런 팁을 쓸수있었다. 어쩃든 이게 틀렸다
1이 11개 그다음에 요게 0이 두개 아래 0이 두개 그러면 아래 3비트 100은 블락 오프셋 그다음에 나머지 몇개 8개가 셋 넘버 그러니까 역시 8개 똑같이 1111 이죠 그렇죠 답은 256 맞는데 이 표현이 틀렷다 여기가 

강의 자료로 돌아와서
# 강의자료 after reference 1 
자이게 투웨이 셋 어쇼티브 이고 그다음에 한 블락은 2워드 바이트로는 8바이트, 빨간색 밑줄 그다음에 이게 레펀런스 트레이닝?? 이게 나오는데 이게 음 이 어드레스가 바이트 어드레스 라고 가정할떄 바이트 어드레스라고 할떄 
바이트 어드레스라는 말은 없었는데 여기 지금 주소 자체가 32비트가 어 이게 요 값이 32 비트 표현이 되죠 그렇죠 자 그러면 어 첫번째 0 엑세스할때 0번지 어드레스는 이와같이 나오고 밑에 여거 3비트는 블락 오프셋이라 뗴고 
이게 전부 셋트로는 블락으로는 512개 블락이 지만 2개를 한 셋트로 묶었을때 셋트 넘버로는 256개가 되고 그러면 여기에 
상위 고 다음에 8비트가 세트넘버가 되고 그렇져 그러면 나머지는 태그값이라고 하죠 
세트 넘버는 뭐야 이 블락이 위치할 세트에요 이 0번 세트에 들어간다는거지 0번 세트에 들어가는데 사실은 들어갈수있는 자리가 두자리가 되죠
여기도 들어갈수있고 아래도 들어갈수있고 
기회를 주는거야 
그래서 둘다 비어있으니까 첫번쨰 에다가 위치시키고 여기에 태그를 여기다 태그에다가 저장하고 맬러드를 맬러드로 표시하고 
그럼 여기에 8바이트가 들어가는데 어떻게 8바이트가 들어가느냐 내가 얘기했죠 여기에 지금
요게 오프셋인데 요 오프셋이 0부터 7까지 변할수있는 어 모든 어드레스 그러니까 지금 이게 이 블락의 첫번쨰 바이트고 이 블락의 마지막 바이트는 7번 바이트다 0~7번 까지 8바이트가 여기에 차곡 들어가게된다. 
어쩃든 첫번째는 뭐 하여간 메모리에서 가져와야 되는거고 미스였고 그다음에 4번 4번역시

## 2
그다음에 4번, 4번 역시 이렇게 떼버리고 여기 세트넘버고 가서 봤더니 하나가 자기가 원하는 태그 하고 같고 그럼 캐시 히트고 
그럼 4번 바이트가 어딨어요 다시 0번부터 7번사이에 4번 바이트가 있죠 거기서 데이터를 가져간다. 
여기 틀렸던데 8188
8188, 
그러면 밑에도틀렸네 밑에 어떻게 되 밑에가 여기가 이게 틀렸어요 그렇죠, 8188 이면 100이 되고 여기 이렇게 뗴버리고 
얘가 들어갈 자리는 255 번지 인덱스가 맞고 거기에 태그 값 들어가고 그러면 얘는 8188 이라는 바이트는 이 블락의 첫번쨰 바이트가 아니죠 
첫번쨰 바이트가 아니고 얘는 100 이니까 몇번째 바이트에요? 5번쨰 바이트에요 
0 1 2 3 4 5 6 7 이다 
그러면 여기서 000에 해당되는 이 블락의 선두 바이트는 얼마일까? 선두 바이트 주소는? 100 이 지금 중간이고 000이 선두 바이트 잔아 얼마 뺴야되 이값에서 4빼야지 8184 부터 얼마 끝이 얼마야 8191 이다. 

그다음에 0번, 뭐 히트죠 여기 아직 쫓겨나지 않고있죠 그다음에 16384 아까 같은 요령으로 하면 16384 2의 16승
17번쨰 자리에 1이 있고 16개가 아 2의 14승이죠 
밑에 13개의 0이 있고 여기 14번쨰에 1이 있고 그러면 역시 블락 오프셋은 빼버리고 여기 8개가 어 세트넘버고 거기에 이제 요 블락이 들어가는데 가서 봤더니 그 세트 0번에 2블락이 들어갈 수 있는 자린 데 한블락은 이미 하나가 와있고 한 블락은 비어있지 
여기 있으면 되 
예전에 다이렉트 맵트 캐시였으면 어떻게 됬어요? 그냥 요자리를 어짜피 요기 한자리로 배정되어있으니까 여기를 그냥 오버라이트 하고 들어갔는데 지금 은 두자리 중에서 여기 빈자리에서 들어가서 충돌을 한번 회피할 수있는 그런 상태가 된다.
결국 여기는 얘가 이블락의 선두바이트라는것을 알수있다 여기가 000이니까 16384부터 + 7인 16391 인 가 여기 된다. 그다음에 다시 0하면 여기있죠 그쵸? 히트
그래서 토탈 몇번의 히트가 있어요? 히트는 3번 나머지 3번은다 미스. 

퀴즈 문제, 교재에 나와있는 예제 연습을 해보도록 하세요!!(중요)
## Improving Cache Performance
자 요기 강의 자료 33쪽으로 다시 가서
33쪽 보다도 30 쪽을 봅시다 
우리가 지금 캐시 라는 표현을 이제 지난 요렇게 표현하면 이건 공식적인 표현은 아니고 왜 이렇게 달러 로 표시하는건데 이게 
캐시 하고 돈 캐시하고 발음이 같기떄문에 그렇게 달러로 표현하는것이다 이건 재미로 써놓은 엔지니어쓰는 그런것이지 공식적으로 저렇게 쓰면안된다. 
우리가 보통 캐시가 레벨1 캐시 있고 레벨2 캐시있고 이렇게 나눠져있는데 레벨1 캐시는 일반적으로 인스트럭션과 데이터 캐시가 분리가 되어있어 
그런 이유는 인스트럭션하고 데이터하고 엑세스 하는 특성자체가 많이 다르고 그다음에 인스트럭션 캐시는 거기에 write를 안하죠 
인스트럭션 하나 읽어가기만 하는것이고 
그렇기떄문에 레벨1에서는 용량을 작게하고 어 둘을 분리시키는 그런 형태를 써
그래서 어쩃든 캐시 에서 데이터를 읽을떄 그 데이터가 원하는 데이터가 있으면 리드 힛 이라고 그러고
어 데이터에 쓸때 그 데이터가 있으면 라이트 힛인데 주로 이건 라이트 는 데이터캐시 에서만 일어나는 현상이다.
그런데 이 라이트 를 만약에 캐시에서만 라이트를 하도록 하면 지난번에 잠깐 얘기해줬던 것처럼 원본이 있는 메모리에 있는 값은 올드 밸리유죠 그쵸? 우리가 그걸 올드 밸리유 또는 스테일 ? 스케일? 밸리유 라고해 스케일이라는건 맛이갔다 그런 예전 값이다 그런 말인데
자그래서 이럴때는 일단 캐시에 만 쓰도록 하고 그다음에 나중에 그 캐시블락이 캐시 에서 쫓겨날떄 그것을 우리가 쫓겨난다는걸 이비트 된다고 해 
희생된다 그렇게 얘기를하는데 그 캐시블락이 쫓겨날때 그떄 요기 변경되어있는 내용을 메모리로 쓰는것을 우리가 라이트 백이라고 한다 
나중에 쓴다
그러면 우리가 어떤 게 필요하냐면 각 캐시블락에 이게 
어 쫓겨날떄 라이트 백 되어야 되는지 바꿔 얘기하면 캐시로 들어온뒤에 값이 
바껴 가지고 메모리 값하고 다른 값이지 그러니까 인 컨시스턴트 라고 하는데 
이거는 캐시에 있는값하고 메모리 값하고 서로 다르다.
불일치한다 .그런말인데 그걸 표현하기 위한 어떤 정보가 필요한데 그거를 우리가 덜티비트라고 한다.
덜티 비트는 값이 변했다 그말이다. 
그래서 우리가 캐시블락에 밸러드 비트있고 태그있었는데 거기에 하나더 추가되는거죠 그렇죠 덜티비트가 추가되 
그래서 값을 쓸때 더티비트를 셋해요 그리고 나중에 그 블락이 쫓겨나야될 시점에서 그블락의 더티비트가 만약에 1이라고 셋트 되어있으면 뭐야 그 값이 변경된 값이니까 그걸 메모리까지 써주는거 그걸 라이트백이라고 한다. 

그런데 경우에 따라서는 항상 
두개의 값이 일치하기를 원한다 어떤 시스템에서는 그러면 이런 방법을 쓰지않고 항상 데이터를 쓰는데 
캐시에서만 쓸뿐아니고 항상 어디까지? 메모리까지 쓰게하는 방법 그것을 우리가 write-through 라고한다
이럴 경우에는 더티비트가 필요없죠 
항상 라이트가 끝까지 가니까 
그런데 문제는 뭐에요

문제는 라이트 했을때 캐시의 장점이 별로 없다 어차피 메모리까지 쓰는거니까 리드는 캐시에서 읽어가니까 뭐 거기서 어느정도 캐시의 이점을 활용하는건데 그래서 이런경우에는 우리가 보통 라이트를 끝까지 가는데 라이트 메모리까지 보내고 걔가 응답하는것 까지 기다려서 이렇게 돌아가지 않고 라이트라는건 메모리 쪽에 전달하면되죠 그쵸
이거 사실은 리드는 그값이 와야지 그값을 갖고 다음 인스트럭션을 실행할수 있지만 라이트는 메모리 쪽에 이렇게 전달만 해주면 되는거야 사실은 이렇게 쓰라고 그래서 메모리 시스템 에 바로 끝까지 완료하지 않고 라이트 버퍼 라는걸 둬요
캐시 아래에다가 그래서 라이트 버퍼를 둬서 라이트할 내용을 여기다가 리퀘스트를 여기다가 요청하고 자기는 다시 프로세스 다음 동작을 실행할수있도록 한다. 
이것도 여러분들 연습해보고 

## Handling Cache Misses
캐시 미스 3종류 있다는거 얘기했었죠 
이거는 캐시 미스가 발생할때 
어 한번 읽어봐요
리드 미스가 발생할떄 라이트미스가 발생할떄 

리드미스가 발생할때 어떻게 해요 일단 파이프 라인 구조에서는 파이프라인이 서야 되고 데이터가 이제 메모리부터 와야 되니까 
그다음에 메모리 하이러리커 에서 지금 그 다음 개체 L1에서 미스가 미스가 나면 L2, 그다음 계층에서 블락을 가져와야 되고 패치 해야되고 
그다음에 그것을 캐시에 인스톨 한다 하기도하고 load 한다고 하기도 하는데
캐시에 해당하는 그 블락 위치에다가 적재하고
그다음에
그 워드는 실제로 프로세스가 필요로 하는거니까 캐시에 적재한다음에 프로세스에게 그 워드에 해당되는 
해당되는 워드를 올려주는 그런과정으로 그리고 파이플라이닝을 다시 재가동시키는 그런 과정을 거친다.

write 미스일경우 비슷한데 일단 파이프라인 세워야 되고 
그다음 넥스트 레벨에서 블락을 가져오고 그다음에 그 캐시를 인스톨 하는데 
어 만약에 어 라이트백 캐시가 사용되고 있다 라이트백 캐시가 사용되고 있으면 거기에 있는 쫓겨나가는 캐시블락을 메모리로 내려보내고 
우리가 이떄 두가지 스킴을 쓰는데 일반적으로 라이트 백 캐시 를 쓸때는 캐시 미스가 나면 먼저 캐시에다가 해당되는 블락이 들어갈 자리를 먼저 잡고 거기다가 그 블락에 해당되는 데이터 
여기서는 지금 일단은 한 블락이 한 워드라고 만약에 가정을 하면 그 워드를 일단 캐시에다가 확보 해서 써주고 
그다음에 바로 진행을 하는 방법이 있는데 그게 우리가 write allocate라고 한다
write 미스가 났을때 캐시 블락에 한 캐시를 캐시 블락을 확보한다 그게 write allocate다.
이게 일반적으로 당연하다 캐시를 쓰는 입장에서는 

그러니까 지금 우리가 여기서 데이터를 가져온다 그랬는데 데이터를 write를 할떄 꼭 가져올 필요가 있는가도 생각해본다 왜냐하면
우리가 어떤 변수는 a라고 합시다 이 변수를 처음에 읽는값을 읽어와서 무슨 연산을 하고 그다음에 여기다 이렇게 
읽고 이게 read죠 그렇죠 
read하고 그다음에 이걸 쓰는거 이게 write 죠 이렇게 하든, read를 선행하고 write를 하는 경우는 저와 같이 캐시 미스가 일어났을때 밑에서 가져오는게 반드시 필요하지만
어떤 경우는 그냥 a에다가 5, 이렇게 쓰는거부터 시작하는 연산들도 있다 그렇죠
이런 경우들은 값을 밑에 메모리에서부터 미리 가져올 필요없이 그냥 이값을 바로 캐시에 쓰는 동작으로도 충분하다 이거는
이런경우에는 write allocate를 해가지고 캐시에다가 해당되는 워드를 바로 써버리는 그런 방법 이 이 write miss 를 처리하는 충분한 방법일수도있고 

그다음에 write allocate를 허용하지 않는 no write allocate는 캐시블락을 허용하지 않고 얘는 무조건 캐시에 쓰지 않고 메모리로 내려보낸다 write throw 방법 을 사용하는것이다 
이거는 캐시블락 을쓰지않고 아까얘기한대로 write buffer에다가 데이터를 쓴다 끝낸다. 
이거는 뭐 여러가지 방법중에서 한가지 방법을 write 캐시 에서 선택적으로 사용한다 보여준다. 

## Miss rate vs block size vs cache size
자이건 뭘보여주는거냐면 지금 캐시블락 사이즈를 증가시켜 가고 
밑에 캐시 미시 레잇을 지금 측정하는 변화하기를 보여주는건데 
캐시블락 사이즈 다시 한번 말하지만 
한번에 이렇게 전송되는 단위는 블락의 크기 
우리가 보통은 8바이트 많아야 16바이트 쓰지만 컴퓨터 시스템이 고도화 되면서 블락 사이즈가 커지는 경향이 있다.
버스에 전송대역폭이 굉장히 좋아지면서 한번에 굉장히 실어날을수 있는 데이터양 이 커지니까 

그런데 지금 블락 사이즈가 커지면 자 그다음에 여기 각각은 뭐냐면 
캐시에 용량이다. 
이게 지금 요 파란색 삼각형 표시되어있는건 256 킬로바이트 캐시를쓸때
256 킬로바이트를 쓰되 16바이트 블락으로 쓸수도있고 64바이트 블락으로도 쓸수있쬬 그렇죠 그러면
뭐가달라져요 만약에 다이렉트 맵트 캐시라고 그러면 블락의개수가 달라진다. 
16으로 할떄는 256 킬로바이트 나누기 16바이트 하면얼마야 = 16 
16킬로 약 16000개의 블락이 만들어지는데 반해서 64로 하면 그거의 1/4 = 4k 개 4096개의 블락이 만들어진다.
같은 용량을 다양하게 블락을 키울것인가 아니면 같은 블락이라도 셋 어쇼티비티를 키울것인가 이렇게 다양하게 설비할수있는데
어쩃든 이 그래프를 보면서 우리가 이해할수있는건 
당연히 용량이 클수록 미스는 적게 난다. 
그렇다.

왜냐하면 이게 256킬로바이트는 거의 뭐 한 1~2% 대 미스 레잇 이라면 
저 위의 노란선은 뭐냐 굉장히 작은 8킬로바이트에 용량으로 할떄는 사이즈와 상관없이 전체적으로 굉장히 미스가 많이 나는 그렇죠

그다음에 또 알수있는건 캐시 블락이 이렇게 캐시 블락을 키우면 캐시 미스 레이쇼가 떨어지는 경향이 있다. 
그렇다. 저거는 왜 떨어져요? 뭐떄문에? 캐시블락을 키우면 캐시블락이 16바이트 일떄하고 64바이트 일떄하고 약간 캐시 미스 레이쇼가 떨어지면 어떤 이유 때문에 캐시 미스 레이쇼가 낮아질까? 뭐떄문에 우리가 그 블락이 크면 무슨 로켈러티를 충분히 활용하는거죠 스페이셜 로켈러티 
그러니까 한 곳에 엑세스하면 그 주변에 있는것들에 곧 엑세스한다.
이게 스페이셜 로켈러티인데 하나를 미스하면 걔로부터 딸려오는 놈들이 많다. 그러면 
아까 그 쓰리쉬 , 그러니까 캐쉬미스의 3가지 원인 (컴펄러리 미스, 컨플릭트 미스, 커패스티 미스이렇게 있었는데) 그중에서 뭐가 좀 줄어들까 컴펄서리 미스가 줄어든다.
컴펄서리 미스라는건 뭐야 그 데이터를 처음 접근할떄 불가피하게 발생하는 미스 그게 컴펄서리 미스인데
지금 여기서는 블락이 커지면 첫번쨰 바이트에 대해서는 미스가 나지만 드론에서 한 꺼번에 전송되어 오는 블락 사이즈가 커지기 떄문에
그 뒤따르는 놈들은 히트의 효과를 보는거야 그래서 이렇게 블락 사이즈가 커지면 미스 레이쇼가 점점 약간 줄어드는 경향이 있다.
그런데 어느순간을 넘어서면서 오히려 다시 미스가 커진다. 
이건또 뭐지 뭐가 증가했기떄문에 다시 캐시미스가 올라가는거냐? 이거는 같은 캐시인데 블락 사이즈를 어느정도 키웠을떄는 어 공간적인 스페이셜 로켈러티를 활용하는 이점이 있기때문에 미스 레이쇼가 낮아졌는데 
더 키웠어 그랬더니 뭐가 됬냐면 그 블락 캐시블락 안에 캐시안에 블락의수가 몇개안되서 서로같은 공간에 대한 충돌 컨플릭트가 오히려 더 증가하는 그런 경향을 보여서 다시 올라가는 
그래서 우리가 이제 캐시를 설계할떄 어느정도에 캐시블락 사이즈가 각각의 용량에 좋은지는 이와같은 시뮬레이션 통해서 이 한번 점검을 한다음에 캐시에 대한 용량을 우리가 구한다. 캐시 다지인을 한다. 이것또 비슷한데

## block size tradeoff
이것또 뭐 비슷한데 
캐시 미스 레이쇼는 이렇게 방금 봤던것처럼 세부화해서 
좀 떨어지다가 올라가는 경향이있고 
이거는 블락사이즈를 키울떄 미스 패널티는 어 리네어 하게 증가한다 무슨얘기야, 블락 사이즈, 미스 페러티 라는게뭐지 미스가 나면 아래 레이어에서 데이터를 가져오는 데 걸리는 시간을 미스 페러티 라고 하지

그러니까 당연히 많은데이터를 가져와야 되니까 미스페러티는 점점 이렇게 비례하죠 그렇죠
자 여기 에버리지 메모리 엑세스타임 아까 앞에서도 나왔는데 에버리지 메모리 엑세스타임은 여기다 저걸 써줘야 곱하기 히트레이트를 
히트 타임 곱하기 히트 레이트

그래서 어 캐시에서 히트되는 시간이 있고 그거에 대한 히트 레잇 이 있고 그다음에 캐시에서 히트되지 않았을떄 요 식을 다시 써주는데 캐시 히트 타임 * 캐시 히트 레이쇼 + 

히트 레이쇼
고쳐야된다. 
에버리지 메모리 엑세스 타임은 캐시 히트 타임 * 히트 레이쇼
그다음에 어 미스일경우에는 어떻게 되냐면 사실 미스일경우에는 위의 레벨에서 히트인지 미스인지 보고나서 그다음에 아래 레이어에서 데이터를 가져오니까 여기 시간에 히트타임이 포함이되요
히트타임이
그래서 사실은 저걸 풀어내면 이렇게 볼수있다 왜냐하면 여기에 히트 타임 * 히트 레이쇼가 있고 여기에 히트 타임 * 미스레이쇼가 있는데 이거 두개 밖에서 꺼내면 어떻게되요?
히트 타임 * 히트레이쇼 + 히트 타임 * 미 스 레이쇼는 히트타임이죠
왜냐하면 히트레이쇼 하고 미스레이쇼를 더하면 1이니까 그쵸 서로 이것과 이거는 1에 대한 보수관계에 있으니까 그래서 이 식이 성립하는것이다.
밑에다가 써줘요 요부분을 
이식이 성립하는거야 밑에다 이걸 써줘요 요부분을

## Multiword Block Considerations
따라서 average access time, average memory access time은 역시 블락사이즈가 감소하면 그 캐쉬의 효과에서 어느정도 타임 자체가 감소하는 경향을 보이지만 역시 블락사이즈가 너무 증가하면 뭐가 지나치게 커지기 떄문에 미스패널티가 지나치게 커지기 떄문에 다시 오히려 증가하는 경향이 있다. 역시 여기는 미스패널티도 커지고 커지면 미스레잇도 올라가요 왜냐하면 여기에서 미스레잇이 약간 증가하는 경향이 있다.
그래서 저 캐시 디자인을 할떄 3요소 블락사이즈 그다음에 셋 어쇼티비티 그다음에 거기에 해당되는 메모리 엑세스 타임 이런것들에 따라서 우리가 캐시디자인을 주의 깊게 해야된다. 
여기서도 
우리가 이제 


## Multiword Block Considerations(2)
우리가 이제 멀티워드 블락일 경우에
미스가 왔어요 그러면 밑에서부터 여러 워드가 와야되지 그치? 
여러 워드가 와야 되는데 가만이 생각해보면
우리가 좀 생각해볼 부분이 있는데

그 여러워드로 구성된 블락인데 내가 프로세스가 엑세스하는게 첫워드야 그블락의 그러면 문제가 없어 
그냥 차례로 오니까 걔부터 걔가 오면 바로 프로세스가 다음 연산을 실행할수있지
데이터 워드니까

그런데 만약에 0번부터 7번까지 8개의 워드로 한블락이 구성되어있는데 실제로 프로세서가 원하는건 3번워드야 
그러면 어떻게되지 그러면 3번 워드가 속해있는 8개의 0 1 2 34 5 6 7 워드가 이렇게 차례로 와야지 0123 이렇게 
그럴떄 그렇게 차례로 메모리에서 보내고 프로세스가 원하는 워드가 도착했을때 그때 도착하자마자 
프로세스에게 전달하는것 그것을 우리가 
erly erstart 라고 한다
requested word 
프로세스가 원했던 
프로세스가 접근하기를 원했던 
워드가 도착하자마자 캐시에 도착하자마자 데이터패스에 실행이 되게 되는것 

근데 조금더 우리가 생각을 하면 메모리에서 꼭 0,1,2,3,4 이렇게 보낼 이유가 있냐 이런거다
뭐부터 보내? 원래 프로세스가 3번을 원했으면 3번부터 올려주고 나머지 블락은 천천히 데이터에 올려줘도 되죠 그렇죠
리퀘스티드 워드를 먼저 메모리에서 전송하고 나머지 워드들은 그 뒤에 보내는 방법
이거를 리퀘스티드 워드 프로세스 라고 한다.
대신에 이것을 구현할려면 뭐에요, 데이터 로직이 조금더 복잡해지겠죠 처음에 원하는 정보가 가고 그것이 가고 여기에서는 받는 캐시에서도
순차적으로 오는게 아니니까 

그다음에 넌 블락킹 캐쉬는 무슨얘기냐면 예를들면 지금 캐시에 어떤 데이터 가 미스가 나서 
아래 레이어에서 그 데이터를 오고있는중이야 리퀘스트에서 그럴때 그캐시를 프로세스에서 그다음에 엑세스 하지 못하도록 막으면 
그거를 우리가 블락킹 캐시라고 한다. 
아래에서 지금 처리되고 있는 핸들링 되고 있는 그 동작 이 완료될때까지 캐시가 묶여있는 상태 멈춰있는상태를 블락킹캐시라고 하는데 그러면 효율성이 떨어지겠지 왜냐하면 위에서는 그다음 동작들도 일어 날수도 있는데 
그래서 그런것들을 우리가 데이터패스 를 설계할때 캐시가 밑에서 데이터를 핸들링하고 있는 중에도 그 캐시에 엑세스 할수있도록 허용하는 캐시 이거를 우리가 넌블락킹 캐쉬라고 한다. 
참고로 알아두고 

## Cache Block Replacement Policy
다이렉트 맵트 캐시에서는 어떻게 리플레이스 먼트 팔러씨 라는게 따로 있을수없다.
그자리로 들어갈수밖에 없으니까

n-way set 어쇼서티브 캐시에서는 들어갈수있는 자리가 n개의 자리가 있기떄문에 
만약에 그 n개의 자리가 다 이미 다른데이터로 차있으면 누군가를 쫓아낼떄 고민을 해야되는데 그떄 대표적으로 사용하는방법이 
lru 다. 리스트 리센트 유즈드 
누가 가장 오랫동안 사용이 안됫나 사용이 가자 오랫동안 안된 캐시블락을 교체하는것이다.

## Miss Rate vs Set Associativity 
미스 레이쇼 와 셋어쇼셔티비티 의 관계이다.
그러니까 역시 이게 용량별로 1킬로바이트 에서 32킬로 64킬로 바이트까지 캐시를 쓰는데 
얘들을 어쇼셔티비티를 변화시켜 가면서 
어 그러면 미스 레이쇼는 전체적인 추세로 떨어지는 경향이다.
뭐가 완화됬기떄문에 충돌이 완화 됬기때문에
어쇼셔티비티 따라서
근데 이렇게 완화하는데 이쇼셔티비티 를 높이는게 좋긴한데 여기에 뭐가 들어가요? 비용이 들어간다.
비용이 들어가고 그 하드웨어 코스트가 들어가면서 동시에 캐시 엑세스 하는 엑세스 타임이
길어진다. 예를들면 아까 L1 캐시 엑세스 할떄 원사이클 이라고 가정했죠 한 사이클에 캐시 엑세스 할수있다고
근데 만약에 여기다가 그걸 다 OK 그러면 어쇼셔티비티를 높이자 그래가지고 4-WAY 8-WAY 으로 막 컨퍼레이트 를 가져다 붙이면
그데이터를 찾아오는데 원사이클에 가져오지 못하고 두개 내지 세사이클 만에 가져온다 그러니까 뭐에요 비용도 들고 엑세스 타임 자체가 
약간 늘어나니까 
결과적으로 뭐가 늘어나? 아까 앞에서 봤던 메모리 엑세스 타임, 에버리지 메모리 엑세스타임이 약간 증가하는 경향이 있다.

## cACHE Coherence Problem
요즘 멀티코어 프로세스 를 많이 쓰는데
어 cpu안에 두개의 코어 가 있어요 두개의 코어가 있고 피지컬 메모리를 서로
공유하는 그러니까 우리 그림으로 만약에 구지 그린다면 
여기에 피지컬 메모리가 있고 그다음에 여기에 코어 우리가 코어를 프로세스라고 읽는
프로세스1 프로세스2 가 있고 요 밑에 얘들을 위한 각자를 위한 이게 뭘까 이 박스가 뭐에요 캐시에요
캐시다.
자기 코어를 위한 캐시가 있고 메모리를 공유해
이런 상황이다.

일반적으로 라이트 뜨루 캐시를 쓰는경우에는 문제가 없는데 메모리에 지금 어떤 값이 있는데 
그 변수의 값이 0이에요 
이거 그 변수를 그냥 x라고 합시다. x라고
그 x를 a가 읽어가면 read x를 하면 그러면 
a에 왼쪽에 있는것을 a라고 하고 이걸 b라고 읽어
a에 캐시에 그 변수가 거기 카피될것이고 거기에 초기값은 0을 가리킬것이다.

그다음에 바로 다음 스텝에 cpu b 오른쪽에 있는게 그 변수x를 또 읽어가면 역시 거기에 0이라는 값으로 카피 값을 갖고 있죠 그렇죠 
그런데 만약에 캐시를 갖고 있는데 cpu a가 변수에다가 1이라는 값을 썻어요 
라이트 뜨루 캐시를 쓰면 어떻ㄱ ㅔ되냐면 
여기에 지금 처음에는 그 변수가 0 0이고 여기도 그 변수가 0이라는 값을 갖고 있었는데
라이트를 해버리면 어떻게 되?

여기 캐시 일단 1로 바뀌죠 값이 그리고 라이트 뜨루 한다고 했으니까 여기까지 와서 
어떻게 이 값 1로 바뀌죠 그렇죠 근데 이제 문제는 뭐에요?

얘와 얘 관계는 컨시스턴트 하게 됬는데
지금 이값을 누구도 가지고 가있어요? 오른쪽에 있는 여기서는 오른쪽에 있는걸 b라고 합시다
b가 0이라는 값을 갖고있쬬 그렇죠 이런 상황이 인컨시스턴트한 상황이다.
이런상황

저런상황이 허용되면 안된다 라는거임 저런상황이 허용되면 우리가 멀티프로그래밍을 할떄 멀티코어를 이용해서 페러라이프 프로그램을 많이하는데
값이 이상한 불안정한 상황으로 갈수있는 그런 인제 경우가 만들어진다.

그래서 이떄 사용하는 방법이 캐시이런상황을 우리가 캐시 코어티어러즘  프로블럼이라고 그러고 이런상황은 캐시인컨시스턴트 상태라고 그러고 이거를 해결하는 방법을 우리가 캐시 코히얼언스 프로토콜이라고 한다.
이걸 해결하는 방법을 

## 스누피 프로토콜
이 캐시 코히얼언스 프로토콜 중에서 어 일반적으로 가장 만이 쓰는 방법중에 하나가 스누피프로토콜이다.
이 스누피 프로토콜은 기본적으로 버스를 기반으로 한 멀티코어시스템에서 대표적으로 사용한다.
방금 처럼 
이와같은 구조가 이게 뭐에요? 버스죠 그쵸 버스를 기반으로 한 멀티코어 시스템에서 사용하는 대표적인 방법이 스누피 프로토콜이다. 
스누피 프로토콜 첫번쨰 방법이 이거는 이제 이렇게 이런 방법을 채택할수도 있고 이런 방법을 채택할 수 도 있다는건데 
이방법은 라이트 인밸러 데이트 프로토콜이다. 이것은 서로 다른 프로세스들이 쉐어하고 있는 어떤 데이터가 있고 걔들이 캐싱이 되있을때
걔들의 어떤 라이트가 일어나면 버스에 매달려있는 모든 캐시에게 인밸러데이트 하라는 시그널을 보내요
인밸러데이트, 무효화 시켜라 그래요

그래서 아까 그림으로 돌아가면 아까 여기서 얘가 여기다가 1을 썻져 1을 쓰고 그것을 여기다가 메모리에다가 write throw를 할려고그려죠 그떄 이 버스에다가 인밸러데이트 하라는 신호를 쫙 뿌려요 
버스 의 특징은 모야 여기에다가 무슨 신호를 이렇게 실으면 거기에 매달려있는 모든 디바이스 들이 그신호를 다 볼수있다 라는게 버스의 특징이다.
우리가 버스라는 매체의 특징이 그건데 그러면 각각의 캐시에서는 무슨일을 하냐면 

## 
각각의 캐시에서는 여기에서 지금 버스에서 무슨 지시가 오는지 각각의 캐시는 여기를 들여다 보고 있다 이동작을 뭐라고 하냐면
스눕핑이라고 해 스눕핑이라는건 버스를 엿본다 버스를 계속해서 이렇게 들여다본다 이얘기다.

그러면 어떻게 되냐면 얘가 봤더니 지금 캐쉬를 계속 여기에 버스를 지금 보고 있는데 
버스에 이 데이터 x가 지금 값이 바겼으니까
이 x를 갖고 있는 캐시들은 다 니네 캐시에서 다 무효화 시켜라 다 삭제해라 하는 신호를 보내고
그거를 보면은 여기있는것을 얘를 여기서 제거한다 없애버린다.
그걸 보는순간 
이거는 뭐 여기 지금 두개의 코어가 보여주고있는데
이 버스에 몇개가 매달렸어도 똑같이 할수있는거지
이건 뭐 여러개가 매달렸어도 걔들이 계속 보고 그래서
캐시에서 이걸 지워버린다.
그러니까 만약에 그 다음에 오른쪽에 있는 p2가 이 데이터x를 엑세스 할려고 그러면 
캐시에서 가져가요 못가져가요
캐시에서 못가져가지 왜냐하면 캐시에서는 이 데이터가 사라졌기떄문에
이와같이 하는 방법을 라이트 인밸러데이트 프로토콜이라고 한다.

## wrie 브로드캐스트 프로토콜
어차피 돈을 버스에다가 요청을 할떄
어차피 버스에다가 신호를 내주는거잔아 그렇지 그럴때 조금더
비용을 들여서 인밸러데이트 하라고 하지 않고
그 버스에다가 뭐야
업데이트된 데이터를 실어줘요
그래서 업데이트 해라 또는 브로드캐스트하라고 신호를 내보낸다.
멀티 브로드캐스트 프로토콜은
이게 어떤 경우는 더의미가 있는게 
아까 이게 지금 1번으로 바뀌면서 아까는 요 데이터를 갖고있는건 다 제거하라고 인밸러데이트 시그널 을 보내는 
이번에는 그게 아니고 이게 1번으로 바꼇으니까 x를 갖고있는놈들은 다 이값을 다 1번으로 업데이트 해라
이렇게 보내는것이다

근데 어차피 그 데이터는 여기 메모리에도 갈껏 아니야 
그렇지 1번으로 바뀌는건 그러니까 이게 2번쨰가 합리적인 방법이기도 하다.
이게 그래서 여기다가 1번으로 그다음에 여기다가 업데이트하라그라고 그다음에 그 1번이라는 데이터를 
여기다가 보내줘서 여기를 1번으로 이렇게 말그대로 전체에게 전송해주는 그런 방법이다.
그러면 요 프로세스 p2가 그다음에 x를 엑세스할떄 그다음에는 1번으로 갱신된 값을 캐시에서 가져가겠죠 그쵸
그래서 아까의 문제점은 뭐에요 
원래 캐시 코헤어런스 문제는 같은 메모리를 서로 다른 곳에 카피해서 가져갔는데
그다음에 하나는 그값을 1로 업데이트 한뒤에 나머지 다른 프로세스가 업데이트 된 상황을 모르고 
올드 밸리유를 여전히 가져다가 쓰는 그런 이상한 상황 그것을 우리가 캐시 코허런스 문제라고 했는데
지금 여기에서는 두가지 방법으로 그문제를 풀었다
하나는 캐시 인밸러데이트라는 방법을 써서 값을 쓸때 다른 놈들에게 이 배리어블 을 갖고있는 놈들은 다 니캐쉬에서 제거해라
이렇게 하는 방법을 하는 썻고 그래서 올드 밸리유를 엑세스 할일이 원천적으로 없는거지
왜냐하면 여기에서 캐시에서 사라져버렸으니까 
그렇지 또하나는 그거를 아예 새로운 값을 알려주는거야 
이게 1값으로 바꼈으니까 니네가 다 이거를 1로 업데이트 해라 
그런데 업데이트 하라는게 비용이 조금 더 든다. 왜냐하면 데이터 블락을 보내줘야 하잔아 걔한테 업데이트가 되면 걔에 해당되는 데이터블락을 보내줘야 되기 떄문에 비용이 더 드는 측면이 있다.

그래서 프로그램이 보여주는 특성에 따라서 인밸러데이트 가 더 효과를 볼수도있고 어떤 경우는 브로드캐스트 가 더 효과를 볼수있고 굉장히 좀 프로그램특성에 따라서 다른데 그래서 

어 어떤 그 캐시에서는 두개를 이렇게 적응적으로서 처음에는 인밸러데이트로 동작을 하다가 그다음에 봤더니 인밸러 데이트가 성능이 별로 안좋은 상황이 나오면 업데이트, 브로드캐스트 모드를 바꿨다가 이렇게 2가지 모드를 이렇게 결합한 방법을 사용하기도 한다 

## 
이제 이것이 동작하는 중요한 이유는
버스를 이용하는데 있다.
버스가 모든 동작에 그 집합점이 되기 때문에 버스로 인해서 
저와같은 동작 이가능하다.

## 

## 
요걸로 캐시르 마무리
말로 캐시가 안쓰이는데가 없으니까 캐시를 쓰는데
실질적으로 이게 어떻게 구현되어 있는지 어떤 원리에 의해서 동작을 하는건지
좀 다시 한번 정리를 하고 그다음에 
캐시를 디자인 할때 우리가 여러가지 요소들을 고려할수있는데 
블락 사이즈, 셋어쇼셔 티비티, 우리가 셋어쇼셔티비티 가 만약에 n 웨이라고 되어있는데 그 n이 전체 블락수 하고 똑같이 예를들어가지고 
128개의 블락이 존재하는데서 어느 위치에든 다 갈수있도록 디자인 하면 그걸 우리가 128 way 라고 하기도 하지만 그것을 풀리 어쇼셔티브캐시라고 하기도 한다 그거는 어느 자리에도 위치시킬 수 있다. 캐시블락을
극단적인 경우다.
셋 어쇼셔티브 캐시
거기에 각각의 어쇼셔티비티 에 서 동작할떄 우리가 리플레이스를 어떻게 할것인가 굉장히 중요한 문젠데
lru 라는 방법이 대표적으로 사용된다.
그다음에 write hit 가 나타났을때 우리가 라이트 뜨루를 쓸것인가 라이트백을 쓸것인가 따라서 성능이 달라진다.
그다음에 라이트 미스를 할때 캐시에다가 해당되는 블락을 일단 할당하고 오퍼레이션 하는거를 라이트 엘로케이트 라고 했고
그다음에 캐시에 데이터를 할당하지 않고 그냥 메모리하고만 오퍼레이션하는것 우리가 그걸 라이트 버퍼 를 쓴다고 하는데
이거는 좀 있다. 
읽어보고 
강의자료를 올렸는데 강의 자료를 올려 서 거기까지 좀 이시간에 

## 질문
이개수는 요거를 하나로 봤을 때 그 한개, 요개 4개의 블락이 한셋트로 했을때 256세트 나온다 얘기거든
용량이 예를들면 전체데이터를 잡을수있는 용량이 256 킬로 바이트야 그러면 한블락은 
예를들어서 8바이트야 한블락이
그러면 얘를 8로 나누면 얼마야 
32킬로바이트지,
32킬로지
32000개의 블락이 나올수있는거지 
이거를 만약에 2웨이로 한다 그러면 두블락을 한세트로 묶을수있는거지
투 웨이 한셋트에 두자리씩 들어갈수있짠아
그러면 이런 세트가 몇개 나오냐 그러면 32 킬로 나누기 2개 만큼 나오는거지
왜냐하면 요기가 256 킬로바이트에서 8바이트가 한블락이면 32k가 이런게 32k개 있는건데
이런게 이거를 지금 두개를 한셋트로 지금 만드는게 투웨이니까 그러면은 세트수는 이거 전체를 2로 나눈 수만큼의 세트가 만들어진다.
만약에 4way 다 그러면 
4개가 한세트니까 
4로 나눈거지.

