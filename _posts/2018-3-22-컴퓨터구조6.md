---
post : layout
title : 컴퓨터구조6
---
## MIPS ISA - Very Regular Formats
명령어 카테고리들을 보면, 
메모리에서 레지스터 데이터를 옮기는 명령어가 로드고
레지스터에서 메모리로 데이터를 올려주는 명령어가 스토어다.
조건에 따라서 컨디셔널, 이프문이라든가, 와일문이라든가
언 컨디셔널은 goto문 이 있다.

기계어형식은 32bit로 구성되며 이 내용은 그림에 자세히 나와있고 인코딩되면 어셈블링문장과 기계어문장은 하나씩 일대일대응
주의사항은 c언어 문장은 어셈블리어 문장과 1:1이 아니다. 
대충, c언어 한문장은 어셈블리2~3문장 비슷하다.

## MIPS Arithmetic Instructions(1)
opcode = operation라고 add, sub등을 표시하고 operand의 피연산자는 $s1, $s2 가 된다.
연산에 참여하는 연산자를 source operand라고하고 그결과를 destination에 저장한다. 어셈블리어 코드 순서를 보면,
데스티네이션, 첫번째소스, 두번째소스로 되어있고
어셈블리어는 일반적으로 목적지를 먼저 표시한다. 
머신코드로 인코딩할때 순서는 어셈블리어와 순서가 다른데, rs, rt, rd로 조금 순서가 다르다.(그림을 보면 순서대로다.)

기계어로 바꿔놓는데 기계어 포맷이 add, sub는 R-포맷에다가 코딩을해서 넣는다. R-포맷이 어떤 내용을 다루는지

## MIPS Instruction Fields : R-format
++format(기계어)의 연산은 모든 값이 레지스터에 모두 들어와있고 그 결과값 역시 레지스터에서 계산해서 레지스터에 쓴다.++

r로 시작하는것은 - 레지스터파일 어드레스고 그게 첫번째 소스냐, 두번째 소스냐 혹은 목적지 소스냐 이런걸 판단할 수 있다.

MIPs 32bit(체계를 말하는거 같은데) cpu안에 레지스터가 32개있다. 그 번호를 여기다 써준다.(rs에다 써준다.) 0~31 중에서 내가 쓸번호를 rs에 쓴다. 이 레지스터 넘버 표기하는데 필요한 비트 2의 5승 즉, 32다.

rs first source를 적고, rt 5bit seconde source는 적는번호 rt고 rd는 destination으로 레지스터 넘버를 적는다. 

이 공간이 15bit쓴다.(rs+rt+rd) 그다음에 5비트 shamt고, sift amout 맡는다. shift는 어떤 값을 한비트 왼쪽으로 혹은 오른쪽으로 움직인다. 쉬프트 동작이 필요할때 쉬프트할 비트수를 표기한다. 
++add sub는 쉬프트 필요없으니까 0 이다.++ 쉬프트 동작이 필요한 오퍼레이션에는 쉬프트 횟수만큼 적어준다. 

맨 오른쪽으로 function code라고 한다.

여기 6비트로 뭘할 수 있을지 다 표시해야한다.(funct) 6비트면 구분할 수 잇는 op코드는 2의 6으로 64가지로 명령어 개수를 표현할 수 있지만!!
### 보기 부족하다. 
그래서 왼쪽의 6비트하고 오른쪽의 6비트하고 두개가 결합해서 뭔가 연산을 최종적으로 정의하도록 그렇게 설계를했다. 왼쪽 op 코드 6비트하고 오른쪽 6비트 funct하고 두개를 합해서 어떤 오퍼레이션을 정하도록 했다. 

산술,로직 연산 이런것들 이런것들은 여기서 op 는0으로 적고 실제 펑션에 add나 sub 해당하는것을 적는다.

++로드 스토어 컨디셔널 브랜치 그리고 점프는 op코드에가 값을 바로넣고++ 그것외에 산술 논리연산 op코드를 0으로하고 function code에다가 실제로 add나 sub를 표시하는 코드값 을 넣는다. 
이런식으로 명령어를 설계한다.

opcode, first source, seconde source, destination register number, shift amount, function code 이렇게 구성된다.
명령어를 구성하는 2의 6승만으로 표현하기 부족하기때문에, op와 funct를 결합해서 쓴다.
R-format의 경우에는 op=0으로 두고 funct에 실제적인 값을 명시한다, Jump는 아예 값을 바로 넣는다. 

add 0x20
sub 0x22
rs $s1($ 붙은것은 별명이다. 실제 넘버는 32개의 레지스터에서 실제넘버가 있고 옆에 붙어있는 달러는 닉네임이다.

번호보다 닉네임이 프로그램 이해가 쉽가 $s1 17번, $s2는 18번  $t0는 8번인 machine instruction number가 명시되도록 되어있는 것이다.
32비트 머신코드가 만들어지고, 10진수로 표현한것이고 funct가 0x 표현한건데 16진수 내부적으로는 비트로 표현된다. 직접 적어보면 6비트니까 000000, 17을 5비트 10001 18은 10010 8은 01000으로 머신코드의 2진수로 만들어 볼 수 있겠다. 
여기가 6비트 오른쪽부터 펼친다. sub 0x22 10 0010

## MIPS Register Usage(Software Convention for Interoperability)
앞에 숫자는 레지스터 번호다. 
name은 프로그램을 표현하는데 편리하고 심볼을 쓰므로써 이해하기 편하게 해준다.

$zero constant 0 은 (constant는 값이 변하지 않는다.) 0은 많이쓰기 때문에 zero로 표현한다. 하드웨어적으로 0만을 갖게끔 디자인했다, 항상 0이라는 값을 갖는 특수레지스터다. 값이 바뀔 수 없다.

$t0은 중간결과를 저장해서 쓴다.
$s0~$s7, $t8~$t9, $k0~$k1은 용도를 구분해서 쓰는것이 좋다.
변수가 엄청나게 많기 때문에 레지스터만 가지고 프로그래밍 하는것이 어렵다.
많은 변수들이 메모리 위치해 있기 때문에 연산참여만 레지스터에 올리고 다시 메모리로 돌려보낸다.

## Processor - Memory Interconnections
메모리의 한 블락이 한 워드로 구성된다.(4바이트) 한 주소에 0, 1, 2, 3 그리고 4, 5, 6, 7 이런식으로 어드레스가 간다.
++한워드를 읽어온다면 그 워드에 시작주소가 간다.++
이 워드를 읽어오겟다 하면 read라인에 0이 실려야 하고(가장 앞에있는거) 그담에 4바이트에 들어있는 1이라는값이 읽어줘서 32비트 로 전달하게 된다. 정리하면, 4바이트 읽어오겟다 또 다른거 8,9,10,11 읽어 오겠다 하면 어드레스라인에 8이 실리고 그 시작주소 8이 실리고 그 4바이트 들어있는 값인 10이 32비트로 보내지게 된다. (4 3 2 1, 7 6 5 4 이런식으로 표현이 된다. 가장 오른쪼인 1 그리고 4 가 간다.)
바이트 수로는 32 비트니까 2의 32승 개의 바이트제공되는것이고++(한 블락당, 표현할 수 있는 범위) 이것을 4개씩 한워드로 묶었을때 워드의 개수로 따질때는 2의 30승 워드다. ++

Memory는 byte마다 주소를 갖는다. = ++byte-addressable++ 라고한다.
프로세스에서 read addr/ write addr할때 32다발로 묶여서 메모리에서 주소를 받고 해당번지로 데이터를 보내준다. (32bit 라인이 간다.) 
* 메모리의 기본규격은 한 워드다.

## Processor -Memory Interconnections(2)
4개로 한 워드를 묶으면 2의 30승개의 word의 개수다.
4바이트에 들어있는 값 10을 read data (32다발로 묶어서) 프로세스에게 보내준다.
데이터를 메모리에 저장한다.
Data transfer할 때 레지스터와 메모리 시에 word 단위로 주고 받는것이 일반적이다.

## MIPS Memory Access Instructions
word단위로 데이터를 주고받는게 일반적이다.
word단위로 데이터를 주고 받는 명령어는 lw라는 명령어고 l은 로드, w는 워드, s는 스토어 , w는 워드는 워드로 한워드를 가져와라 써라 
lw는 어디에서 메모리에서 한 워드를 읽어서 레지스터로 가져와라 

스토어는 레지스터의 값을 읽어서 메모리에다 가져다 써라 로드는 메모리가 있고 cpu가 있고 cpu안에 레지스터가 있다. 로드는 여기에 주소에 한 워드를 읽어서 여기에있는 레지스터에 써라.

레지스터는 하나가 필요해 쓰는 목적으로 여기서는 $t0가있다. 문제는 많은 메모리중에서 어느 워드를 읽어와서 주소지정해야하나, 주소지정하는 방식이 만약 32비트 해당하는 어떤 숫자 가 레지스터로 전달되어야한다. 그게 주소가 되는데 앞서 봤다 싶이 0이 되든 8이되는 32비트 해당하는 숫자를 레지스터에 써야하는데 
++한 명령어는 32비트 opcode가 6비트 그담에 써야할 레지스터가 5비트 32비트중에 11비트 날아가서 나머지 21비트 가지고 32비트 주소 표현 불가 절대 주소값으로는 표현할 방법이 없다.++

어떤 레지스터가 있는데 어떤 값이 들어오면 그 레지스터값하고 어떤 상수값하고 두개를 결합해서 32비트를 만들어 버리자 그런 방법을 써서 내가 어떤 레지스터에 값이 들어있다고 가정 래지스터에 바로직전에 값을 넣어놨음 그담에 상수값을 앞에다 써줘 두개를 더하면 32비트 큰 상수가 나온다.

그게 메모리에 전달될 주소다. 레지스터를 ++베이스 레지스터++라고 한다. 앞에 붙어있는 4는 ++오프셋++이라고 한다. 로드/스토어 명령에서 메모리주소는 베이스레지스터와 오프셋의 결합으로 주소를 표현한다 

MIPS는 두가지 기본적인 전송 명령어를 가지고 있다.(메모리에  접근할 수 있는)
lw $t0, 4($s3) # 메모리에서부터 word를 load해라
sw $t0, 8($s3) # 메모리로 word를 store해라
괄호 안에 있는건 basis 로 21bit로(opcode를 뺀) 32bit의 주소를 표현할 수 없어서 앞에 상수값(offset) 통해서 처리한다. base register에 앞에 숫자를 offset 하고 base register + offset 하면 메모리의 주소를 표현할 수 있다.
++load word = 로드로 한 워드를 가져와라, 메모리->레지스터++
++store word = 워드로 한 워드를 보내라, 레지스터->메모리++

## Load Instruction
레지스터에 안에 값은 다른값이 있지만(실제값) 번호를 부여해서 접근할때 편리하게 쓴다. $t0의 값이 메모리로 들어오고 싶다. 이 주소 절대주소를 그대로 써야하는데 ++그걸 표현못한다++ 
##### 방법으로..
명령어에서 어떤 레지스터를 베이스 레지스터로 기준이 되는 어떤 곳을 가리키도로고 한다. $s3가 실제로는 cpu안의 레지스터 어떤값을 갖도록 할려면 0x12004094값을 $s3에 넣는다.(load)
lw $t0 24($s3),이게 의미가 $s3 레지스터 갖고 있는 값을 헥사 0x12004094 앞에 붙어있는 값 오프셋(10진수)인 24를 더한값으로 표현하면 그 값이 내가 가져오고 싶은 메모리의 주소가 된다.

그게 cpu 안에서 (레지스터안에서) 계산이 되고, 앞부분은 자리수가 많고 변화가 없는 분이니까(계산할때는 앞부분에 값이 대부분이 고정되어있다.) 뒷부분에 94를 표현할 1001 0100과 24를 헥사로 18표현을 하고 바이너리로 하면 0001 1000이다. 바이너리 값을 두개 더하게 되면 10101100 이고 (앞부분은 변하지 않으므로) 120040AC 가 된다.

AC 두개가 바이너리에서 헥사로 표현한 값이고 내가 지금 가지고 오고 싶은 메모리주소가 된다. 
이자리에 들어있는 값을 메모리가 보낸다. 안에 들어있는 1234 값이 cpu에게 전달되고 1234가 $t0에 저장한다.
그런데 이때 그러면 이 명령어는 어떻게 표현될까 이런형식을 표현되는 형식은 ++I-format++ 왼쪽 op코드 rs rt 두개의 레지스터번호가 있고 나머지 16비트느는 상수를 표현하는 용도로 사용된다. road/store는 I-format으로 표현된다.
lw는 35고 add는 sub는 0이고 오른쪽 function-code는 썼다. 하지만 I-format에서 이러한 명령어는(lw,sw) opcode에 바로 적는다. rs rt는 뒤에 나오는 번호를 써준다. rs자리에는 s3가 19번 rt자리에 $t0 넘버를써준다. 8번 16비트에 앞에써져있는데 오프셋값을 나머지 16비트로 표현해준다.
그러면 이게 16비트니까 오프셋은 양으로가는 기준을 중심으로 하는 증가하는 오프셋이있고 기준으로 중심으로 뒤로감소하는 오프셋이 있다. ++여기에는 양수도 음수도 표현될 수 있다.++ 16비트로 부호를 가지는 정수를 갖는다고 했을때 값의 범위는 얼마냐면 -2의 15승~ 2의 15승 -1 이다. 

## Store Instruction
rs에 해당되는 레지스터 번호 19번, 19번 레지스터안에 있는 값을 적당히 채운다. ++19번 레지스터에는 메모리의 어느 지점에 시작주소가 담겨져 있을거다 라고 가정한다.++
19번 레지스터 값을 꺼내고 기계어 형식에 16비트의 들어있는값은 사실 immediate instruction인데 여기에서는 기능상으로는 오프셋에 해당된다. 오프셋은 기준으로부터 떨어진거리를 오프셋정의하는데, ++19번레지스터값을 꺼내고 그값에 25를 더하면 그값이 메모리 주소가 된다.++ 메모리에게 던지면 그 주소에 있는 값을 읽어서  보내라하면 그게 오면 8번 레지스터에 그 값을 담는다 1230이가 온다. $t0에 담긴다. 이와같이 오프셋하고 베이스레지스터로 주소를 표현하는이유가 된다.
##### 이러한 방식을 쓰는 이유
첫째, 32비트 절대주소를 명령어 하나에 같이 표현할 방법이 없다. 명령어 자체가 32비트인데 거기에 32비트 주소를 표현하면 그게 다 명령어의 형식에 차지한다. ++레지스터와 오프셋으로 표현하도록 주소지정방식을 고안한다.++

이방식의 장점은 베이스 레지스터가 어레이와 같이 시작주소를 가리킬 경우 ++그로부터 떨어져있는 인덱스 다른지점을 접근하기가 용이하다.++

## MIPS Memory Addressing
lw $t0, 4($s3)
$s3 값을 hex로 표시되어있는데 4만큼 더해서 바이너리로 표현해도 좋고 그값을 레지스터로 저장해라.
sw $t0, 8($s3)
lw와 원리가 같다.

## Compiling with Loads and Stores
Base register는 용도가 array를 사용할때 array 시작주소, 시작주소 베이스레지스터를 가리켜 그 중심으로 바로 그자리 4byte의 배수만큼 떨어진자리로 앞에 offset으로 표현하며 array에 접근 가능하다.
A[8]=A[2]-b 와 같은 문장이 있는데
lw $t0, 8($s3)
sub $t0, $t0, $s2
sw $t0, 32($s3)

c로 이런 문장이 있고 다음은 어셈블리어 문장이 있다.
(단, $s3가 가리키는곳은 어레이의 시작주소를 가리키고 있다.)
$s3에서 8만큼 떨어진 곳 integer라고 한 element가 4byte가 시작부터 바로 그자리에 4만큼 혹은 8만큼 12만큼 떨어진것을 $t0에 A[2] 값이 들어있다.
$t0에 A[2]가 있고, 거기에서 b값을 빼고 $t0에다 넣으면 A[2]-b가 $t0에있다. 그것를 A[8]은 시작으로부터 32바이트만큼 떨어져있다 시작으로부터(A[0]) 32만큼 떨어진곳 A[8]이 된다 거기다가 이값을 써준다.

## Compiling with a Variable Array Index
가정이 b,c,i 에 해당하는값이 레지스터값이 $s1,2,3 각각 이미 들어가있다면 이 값을 compile 하면 밉스 어셈블리어는? $s3이 i의 값을 가지고 있다. $s3하고 $s3하면 더해서 $t1에 넣었다. $t1하고 $t1하고 더해서 $t1에 넣으면 $t1은 $s3에 원래 4배으이 값을 가진다.
++첨자 0,1,2,3 있는데 각 첨자하고 오프셋하고 관계가 첨자의 네배 첨자 i를 안다고 했을 때 그 값의 4배를 곱해줘야 떨어진 오프셋이 나온다++ 곱하기 시 연산을 써야하는데 같은 머신 인스트럭션이라 할지라도 시간이 다르다.
++처리하는 속도는 멀티플라이가 에드보다 더 오래걸린다. 따라서 에드 명령어 2개를 쓰는게 멀티플라이 명령어보다 더 빠르다.++ 더하기로 해결한다. 이렇게하면 $t1은 4곱하기 i 오프셋을 가리키게 되는것이고 $s4는 시작주소를 가리킨다. $s4하고 $t1을 더하면 시작주소에서 첨자 아이의 오프셋만큼 더해진 거리를 $t1이 계산된다. 그러면 그지점에 해당되는 $t1 주소가 되는데 이 자리에 값을 읽고싶다를 표현하는것은 오프셋을 0이라고 표현하면 $t1의 가리키는 바로 그자리 값을 가져와서 $t0에 넣는다 앞에 여기서 지금 $s4가 베이스 어드레스고 여기서 $t1이 이게 오프셋이었기 떄문에 
lw $t0, $t1($s4) 이렇게 표현하면 더 좋을거같은데 밉스에서 이렇게 표현하도록 허용하지 않는다 오프셋은 항상 상수가 된다 16비트 레지스터값은 안됨 이렇게 표현할 수 없다. 그래서 아예 $s4하고 $t1하고 더하는연산을 하고 목표 어드레스 계산을 하고 그러고 나서 앞에 상수 0 을 넣어서 $t1이 가리키는 바로 그자리를 가리킨다. 

lw 할때만 바뀐다.
### Load/Store Instruction Format(I format)
opcode를 바로 적는다. rs의 위치에는 base register를 적고, rt에는 tempory register값을 적고, immediate instruction에는 offset을 적는다.
계산할때는 base register 값에다(Hex 표시된) offset(10진수) 을 더한 값이 내가 지금 가지고 오고 싶은 메모리의 주소가 된다. word address(hex)
이 immediate instruction 의 값이 -2의 15승 부터 2의 15승 -1이 된다. 명령어 형식을 이렇게 표현 할 수 있다.

store도 같다. rs(base register)의 값을 본다. 그게 19번의 레지스터에 있다면 그게 시작주소가 되고 16비트가 immediate instruction에 있다면 offset이 될거다. 24에 1을 더하면 메모리 주소가 된다. 그 주소를 메모리로 던져주면 메모리는 주소에 값을 보내준다. 그럼이게 rt의 위치에 저장된다.($t0).
이렇게 표현하는 이유는 32bit로(명령어자체) 꽉차기 때문에 표현방식이 없다. 따라서 기본주소에 떨어진 거리를 배열로 접근하면 유리하다.

## Compiling with Loads and Stores
변수 b가 $ s2에 저장되고 배열 A의 기본 주소가 $ s3에 있다고 가정하면 C 문에 대한 MIPS 어셈블리 코드는 무엇입니까?
++offset으로 접근하면 가능, Base register 용도 => array 사용할 때 array 시작주소를 Base register가 가리키도록 한다.++

## Compiling with Loads and Stores
lw $t0, 8($s3)
sub $t0, $t0, $s2
sw $t0, 32($s3)
생각해보면 간단하다.


## Compiling with a Variable Array Index
배열 A의 기본 주소가 레지스터 $ s4에 있고 변수 b, c 및 i가 각각 $ s1, $ s2 및 $ s3에 있다고 가정하면 C 문의 MIPS 어셈블리 코드는 무엇입니까?

integer는 4byte씩 차이가 나니까 4*i를 만든다.
add $t1, $s3, $s3
add $t1, $t1, $t1
add $t1, $t1, $s4
##### lw $t0, 0($t1)(x)
왜 안되냐면, offset은 상수값만 허용하기 때문에, 명령어를 쓰고 맞는지 비교한다.
Load/Store-word 단위로 읽고 쓸 때 사용 명령어
Byte 단위로 가져올 땐 고려할점, 4의 배수, 워드를 읽을 때 4의 배수로 읽어야한다.
++Aligument restriction, 4의 배수로 정렬시킨 다음에 word를 읽어야 한다. 걸쳐있으면 word를 읽어들일 때 부분 읽어서 CPU로 보내기 때문에 반드시 4의 배수로 읽는다.++
lw $t0, $t1($s4)
sub $s2, $s0, $s1
++시간이 multiply가 더 오래 걸린다, add 명령어 2개를 쓰는게 더 빠르다.++

데이터를 byte단위로 가져올 수 도 있는데, word로 access 할때 word의 address는 그 word가 시작하는 address가 word의 address다,

0,4,8 ... 4의배수 word를 읽을때 word의 시작 주소는 4의 배수다. 모든 아키텍쳐 ++alignment restriction++ 즉, 4의배수로 정렬 시킨 다음에 읽어야 한다. 4의 배수로 정렬후 word로 읽어야 한다. 
10은 4의배수가 아니다. 10에서 부터 한 word를 읽어온다한다면 한word가 실제로 내가 읽을려는 4바이트가 실제로 2개의 word에 걸쳐져 있다. 메모리가 당황하고 2word에 읽어져서 부분 부분 읽어져서 cpu로 보내야해서 허용하지 않는다. 4의배수로 읽어들인다.(반드시)


## More about Endian
메모리의 한 워드의 값이고, 이 값이 레지스터에 들어오면 레지스터 32비트에 들어가는 값이기도하다. 
맨 왼쪽 유효숫자중에서 값이 제일 큰값이 만약 20번지에서부터 4바이트가 이값을 표현할 수 있어야 한다.
메모리 시스템에서 바이트 순서가 다르게 표현되기도 한다. 어떤 시스템은 20,21,22,23 MSB~LSB라면,
어떤 시스템은 20바이트부터 쓰긴쓰는데 d,c,b,a 이렇게 들어가는 것도 있다. 
옆으로쓰면 d,c,b,a 이와같이 시작주소 워드의 시작주소에 LSB부터 바이트부터 적어놓는 방식은 작은값을 먼저 적는다해서 리틀엔디안 엠에스비부터 적는방식을 큰값부터 적는다해서 빅엔디안 방식 두개의 컴퓨터시스템동네엔 2개의 엔디안 방식이 있다. 
메모리를 눈으로 보는 입장에서는 빅엔디안이 더 낫다. 리틀엔디안 값을 이해하려면 바이트순서를 뒤짚어야한다. 중요한것이 일을 하다보면 메모리에 디버깅할때가 있다 이걸 들어온대로 읽으면되는데 리틀엔디안은 뒤짚어서 생각해야한다.
###### 장점은 
리틀엔디안의 장점은 어떤값을 계산하다보면 32bit를 넘으면 64bit로 자릿수를 늘려가야 한다. 자릿수를 늘려가는 입장에서는 리틀엔디안이 효과적 리틀엔디안은 자릿수를 늘려가면 뒤에다 붙이면 늘려진 자릿수가 여기 그대로 큰자리가 뒤에 붙으면되니까 빅엔디안 자릿수가 에이 앞에 얘를 뒤로 밀어줘야 한다.
++자릿수를 계속해서 확장해 가는 연산에서는 리틀엔디안 더 효과적이다.++

### Big Endian 과 Little Endian
MSB - 가장 왼쪽, LSB - 가장 오른쪽
메모리 시스템에 따라 바이트 순서가 다르게 표현된다.
Big Endian - LSB가 꼭대기고 MSB가 제일 아래다.
Little Endian - MSB가 꼭대기고 LSB가 제일 아래다.
++Little Endian의 장점은 계산하다가 32bit가 넘으면 64bit로 늘려서 기다려야 하는데 자릿수 늘려갈때 효과적으로 뒤에다 쭉늘릴 수 있다.++
++Big Endian은 기존에 있는것을 밀어야 한다.++
메모리 보는 입장에서 Big Endian이 더 편하다.

## Loading and Storing Bytes
주소지정 방식으로
1b $t0, 1($s3)
sb $t0, 6($s3) 
위 두개는 byte를 읽을때, 쓸때 명령어다. 워드로 4바이트 읽고 쓰고, 이진 한 바이트를 쓰고 읽고 한다.
명령어 형식을 보면 0x28(op) 19(rs) 8(rt) 6(offset) 
$t0의 1바이트를 6($s3) 로 써라. $t0는 4byte로 맨 오른쪽에 값을 메모리로 보낸다.
![KakaoTalk_20180322_032715505.jpg](C:\Users\hik35\Desktop\KakaoTalk_20180322_032715505.jpg)

바이트는 하나만 보내고, 워드는 4바이트를 다 보낸다.
가장 오른쪽의 byte에 집어넣는다.
워드 단위니까 나머지 3byte는 0으로 채워넣는것.

바이트를 읽어 들일때 lb 쓸때는 sb,

1byte 읽고 쓰고 동작한다. 
cpu안에 레지스터가 있고 $t0 레지스터 위치에 바이트로 읽어가면  하나만 읽어가서 $t0는 레지스터인데 $t0에 4바이트로 메모리로부터 $t0로 load하면 한바이트만 읽어간다. load시 맨 오른쪽에 LSB에다가 집어넣는다. 
##### 나머지 3바이트를 채워넣는방법(load시)
제일 쉬운건 0으로 채워넣는거다. load byte하고 0으로 채워넣는것 그거를 우리가 zero extension이라고 한다.
다른 하나의 방법은 sign extension이 있다. 부호의 비트로 확장하는데, 효과는 한바이트로 음수를 가지고 오면 load시 lsb에 음수를 넣을것이고 결좌적으로 나머지 비트는 (총)32비트가 음수가 되는게 정상이다. ++음수를 가져와서 넣고 크기만 32비트로 확장했지만 음수가 된다.++
```
int i;
char c;
c = -1;
i = (int)c; //작은 규격을 늘리는걸 타입 캐스팅 혹은 컨버전이라한다.
```
c는 - 1을 갖는게 정상이다 c가 11111111로 표현되는데 i는 c가 갖고있는 1을 사인이고 음이고 나머지 24비트를 복사한다. i는 11111111111111111111111111111111(32bit)이다. 
복사한것을 sign-extension이라고 한다. 
```
unsigned int ui;
unsigned char uc;
c= 255
i=(int)c;
```
같은경우인데 하면 255다. ui에다가 unsigned로 하고 uc 여기도 똑같아 unsigned 255 는 11111111(sign이면 -1)이다.
그게 unsigned integer 32비트에 들어가면은 오른쪽 111111111이 들어가고 나머지, 여기서 확장하면 전혀 다른값이 되므로(sign으로) 따라서, 0으로 채워넣는다. zero-extension이다.
원래 255 가 unsigned integer 에 들어가도 255 로 유지되야 한다.
sign을 확장할때는 (용도가 원래 작은값이 갖고있는) sign을 큰값으로 확장해도 유지될때 그 sign을 그대로 쓴다.
zero-extension은 원래 값을 그대로 유지하고자 할때 zero-extension을 쓰는것이다.

이때 사실은 LSB라고 말했지만 Sign operation이다.
여기 있는 값이 음수면 음수로 확장, 양수면 양수로 확장, 따라서 unsigned opearion은 lbu(load byte unsigned, 이거 틀렸을듯)
lbu - zero-extension
lb - sign-extension 읽어오는것은 load로 설명하고 write는store로 본다.

$t0에있는 1byte를 메모리에 어느 지점에 써라. $t0는 내부적으로 4byte 데이터이지만 1byte를 보내므로 맨 오른쪽의 있는 것을 메모리로 쪽으로 보낸다.
## More about Loads and Stores

##### 2byte로 보내는걸 half word라고한다.
half ward를가져오는건 lbh, ++store는 써버리는거기때문에 상관이 없다. load는 작은값을 가져오면 상위의 나머지를 가져오는게 항상 문제가된다.++
상위 두바이트를 0으로 채울껀지 sign으로 채울껀지 문제가 된다.
(unsigned라는 말이 없으니까 sign으로 채워넣는다.)
1. 가져온값을 unsigned로 처리해야한다.(메모리에서 레지스터로) 0으로 채워넣어야 한다. 끝에 load byte half word with unsigned zero-extension 하라는 얘기고 
2. 왼쪽에 있는애는 sign-extension을 해라 라는 말이다. 

load halfword - lh
load halfword unsigned - lhu
load byte unsigned - lbu
store halfword - sh

## I-foramt의 다른 용도
I-format은 다른 용도로도 많이 쓰는데 아까 두 오퍼런드는 다 레지스터에 있었는데 한 오퍼런드를 아주 작은 값을 4라든지 100이라든지 ++immediate insturction++에다 값을 쓰는 경우가 있다. 

slti 명령어가 이런값을 쓰면 slti opcode s2에 해당하는 레지스터 넘버 t0, 레지스터 넘버 15에 해당하는 immediate 값을 헥사로 0f 이다. 16비트이기 떄문에 앞이 000000거자고 나머지 1111로 표현하는데 이와 같은 인스트럭션을 immediate instruction이라고 한다.

~~이전에는 레지스터를 썻을때 이 레지스터 값을 읽어내서 연산을 해야 됫는데~~
++immediate를 쓰면 명령어 안에 사용해야값이 들어있기 때문에 오퍼런드를 읽어오는 시간이 세이브가 된다.++ 

명령어가 이게 16비트니까 여기 표현할 수 있는값이 제한되서 16비트 범위내로 0이라든지 4라든지 100이라든지 작은값들은 여기에 충분히 표현될 수 있기떄문에 이런용도로 immediate format을 많이 활용한단. 

16비트 범위 값의 범위내에 있는 값보다 작은값들을 많이 활용한다 . immediate 연산을 위해서.

## More about Loads and Stores
### zero extension : 값의 크기를 유지하고 싶을때
### Sign extension : 부호를 유지하고 싶을때
만약에 0x05 를 바이트로 읽어와서 가장 오른쪽 byte에 넣었다 하면, 부호는 양수가 될것이고 맨 왼쪽 비트를 쭉 확장 시킨다.

```
int i 
char c
c= -1
j=(int)c; // 형이 맞지 않으면 캐스트 하는것이 기본이다.
```
값을 넣음으로써 나머지 도 확장된다. 
-1이 1111 1111(two) 워드 단위에서 비어있는 24bit는 
1 * 24 이 될것이다. 이렇게 복사하는것이 sign extension이다.
그러면 unsigned int ui와 unsigned char uc가 있다고 하면
```
ui = (unsigned)uc;
uc = 255;
```
255는 양수값으로 1111 1111 이다. 이때 나머지 24bit가 1이 되어버리면 다른 값이 되기 때문에 0으로 채운다. zero extension 이라고 한다.
signed = 음수면 음수확장
unsigned = 명령어를 1bu(byte unsigned) => zero extension

