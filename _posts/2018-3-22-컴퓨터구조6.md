---
post : layout
title : 컴퓨터구조6
---
## MIPS Instruction Fields : R-format
opcode, first source, seconde source, destination register number, shift amount, function code 이렇게 구성된다.
명령어를 구성하는 2의 6승만으로 표현하기 부족하기때문에, op와 funct를 결합해서 쓴다.
R-format의 경우에는 op=0으로 두고 funct에 실제적인 값을 명시한다, Jump는 아예 값을 바로 넣는다. 

## MIPS Register Usage(Software Convention for Interoperability)
앞에 숫자는 레지스터 번호다. 
name은 프로그램을 표현하는데 편리하고 심볼을 쓰므로써 이해하기 편하게 해준다.
$zero constant 0 은 (constant는 값이 변하지 않는다.) 0은 많이쓰기 때문에 zero로 표현한다.
$t0은 중간결과를 저장해서 쓴다.
$s0~$s7, $t8~$t9, $k0~$k1은 용도를 구분해서 쓰는것이 좋다.
변수가 엄청나게 많기 때문에 레지스터만 가지고 프로그래밍 하는것이 어렵다.
많은 변수들이 메모리 위치해 있기 때문에 연산참여만 레지스터에 올리고 다시 메모리로 돌려보낸다.

## Processor - Memory Interconnections
Memory는 bite마다 주소를 갖는다. = ++byte-addressable++ 라고한다.
프로세스에서 read addr/ write addr할때 32다발로 묶여서 메모리에서 주소를 받고 해당번지로 데이터를 보내준다. (32bit 라인이 간다.) 
* 메모리의 기본규격은 한 워드다.

## Processor -Memory Interconnections(2)
4개로 한 워드를 묶으면 2의 30승개의 word의 개수다.
4바이트에 들어있는 값 10을 read data (32다발로 묶어서) 프로세스에게 보내준다.
데이터를 메모리에 저장한다.
Data transfer할 때 레지스터와 메모리 시에 word 단위로 주고 받는것이 일반적이다.

## MIPS Memory Access Instructions
MIPS는 두가지 기본적인 전송 명령어를 가지고 있다.(메모리에  접근할 수 있는)
lw $t0, 4($s3) # 메모리에서부터 word를 load해라
sw $t0, 8($s3) # 메모리로 word를 store해라
괄호 안에 있는건 basis 로 21bit로(opcode를 뺀) 32bit의 주소를 표현할 수 없어서 앞에 상수값(offset) 통해서 처리한다. base register에 앞에 숫자를 offset 하고 base register + offset 하면 메모리의 주소를 표현할 수 있다.
++load word = 로드로 한 워드를 가져와라, 메모리->레지스터++
++store word = 워드로 한 워드를 보내라, 레지스터->메모리++

## Load Instruction
### Load/Store Instruction Format(I format)
opcode를 바로 적는다. rs의 위치에는 base register를 적고, rt에는 tempory register값을 적고, immediate instruction에는 offset을 적는다.
계산할때는 base register 값에다(Hex 표시된) offset(10진수) 을 더한 값이 내가 지금 가지고 오고 싶은 메모리의 주소가 된다. word address(hex)
이 immediate instruction 의 값이 -2의 15승 부터 2의 15승 -1이 된다. 명령어 형식을 이렇게 표현 할 수 있다.

store도 같다. rs(base register)의 값을 본다. 그게 19번의 레지스터에 있다면 그게 시작주소가 되고 16비트가 immediate instruction에 있다면 offset이 될거다. 24에 1을 더하면 메모리 주소가 된다. 그 주소를 메모리로 던져주면 메모리는 주소에 값을 보내준다. 그럼이게 rt의 위치에 저장된다.($t0).
이렇게 표현하는 이유는 32bit로(명령어자체) 꽉차기 때문에 표현방식이 없다. 따라서 기본주소에 떨어진 거리를 배열로 접근하면 유리하다.

## Compiling with Loads and Stores
변수 b가 $ s2에 저장되고 배열 A의 기본 주소가 $ s3에 있다고 가정하면 C 문에 대한 MIPS 어셈블리 코드는 무엇입니까?
++offset으로 접근하면 가능, Base register 용도 => array 사용할 때 array 시작주소를 Base register가 가리키도록 한다.++

## Compiling with Loads and Stores
lw $t0, 8($s3)
sub $t0, $t0, $s2
sw $t0, 32($s3)
생각해보면 간단하다.


## Compiling with a Variable Array Index
배열 A의 기본 주소가 레지스터 $ s4에 있고 변수 b, c 및 i가 각각 $ s1, $ s2 및 $ s3에 있다고 가정하면 C 문의 MIPS 어셈블리 코드는 무엇입니까?

integer는 4byte씩 차이가 나니까 4*i를 만든다.
add $t1, $s3, $s3
add $t1, $t1, $t1
add $t1, $t1, $s4
##### lw $t0, 0($t1)(x)
왜 안되냐면, offset은 상수값만 허용하기 때문에, 명령어를 쓰고 맞는지 비교한다.
Load/Store-word 단위로 읽고 쓸 때 사용 명령어
Byte 단위로 가져올 땐 고려할점, 4의 배수, 워드를 읽을 때 4의 배수로 읽어야한다.
++Aligument restriction, 4의 배수로 정렬시킨 다음에 word를 읽어야 한다. 걸쳐있으면 word를 읽어들일 때 부분 읽어서 CPU로 보내기 때문에 반드시 4의 배수로 읽는다.++
lw $t0, $t1($s4)
sub $s2, $s0, $s1
++시간이 multiply가 더 오래 걸린다, add 명령어 2개를 쓰는게 더 빠르다.++

## More about Endian
### Big Endian 과 Little Endian
MSB - 가장 왼쪽, LSB - 가장 오른쪽
메모리 시스템에 따라 바이트 순서가 다르게 표현된다.
Big Endian - LSB가 꼭대기고 MSB가 제일 아래다.
Little Endian - MSB가 꼭대기고 LSB가 제일 아래다.
++Little Endian의 장점은 계산하다가 32bit가 넘으면 64bit로 늘려서 기다려야 하는데 자릿수 늘려갈때 효과적으로 뒤에다 쭉늘릴 수 있다.++
++Big Endian은 기존에 있는것을 밀어야 한다.++
메모리 보는 입장에서 Big Endian이 더 편하다.

## Loading and Storing Bytes
주소지정 방식으로
1b $t0, 1($s3)
sb $t0, 6($s3) 
위 두개는 byte를 읽을때, 쓸때 명령어다. 워드로 4바이트 읽고 쓰고, 이진 한 바이트를 쓰고 읽고 한다.
명령어 형식을 보면 0x28(op) 19(rs) 8(rt) 6(offset) 
$t0의 1바이트를 6($s3) 로 써라. $t0는 4byte로 맨 오른쪽에 값을 메모리로 보낸다.

![KakaoTalk_20180322_032715505.jpg](C:\Users\hik35\Desktop\KakaoTalk_20180322_032715505.jpg)
바이트는 하나만 보내고, 워드는 4바이트를 다 보낸다.
가장 오른쪽의 byte에 집어넣는다.
워드 단위니까 나머지 3byte는 0으로 채워넣는것.
### zero extension : 값의 크기를 유지하고 싶을때
### Sign extension : 부호를 유지하고 싶을때
만약에 0x05 를 바이트로 읽어와서 가장 오른쪽 byte에 넣었다 하면, 부호는 양수가 될것이고 맨 왼쪽 비트를 쭉 확장 시킨다.

```
int i 
char c
c= -1
j=(int)c; // 형이 맞지 않으면 캐스트 하는것이 기본이다.
```
값을 넣음으로써 나머지 도 확장된다. 
-1이 1111 1111(two) 워드 단위에서 비어있는 24bit는 
1 * 24 이 될것이다. 이렇게 복사하는것이 sign extension이다.
그러면 unsigned int ui와 unsigned char uc가 있다고 하면
```
ui = (unsigned)uc;
uc = 255;
```
255는 양수값으로 1111 1111 이다. 이때 나머지 24bit가 1이 되어버리면 다른 값이 되기 때문에 0으로 채운다. zero extension 이라고 한다.
signed = 음수면 음수확장
unsigned = 명령어를 1bu(byte unsigned) => zero extension

## More about Loads and Stores
