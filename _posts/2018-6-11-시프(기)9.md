---
post : layout
title : 시프(기)9
---
## 복습
그래서 소켓 api들을 쭉 살펴보고 있는데 tcp를 쓸때에는 우리가 보낼떄는 sned를 사용한다.
send를 사용하는데 요기는 이제 오픈한 소켓 하고 그다음에 메시지가 들어와있는 버퍼하고 몇바이트를 보낼것인가 하고 그다음에 flag 잘쓰지 않는거니까 flag는 0로 보통 하면된다. 
그래서 센더를 하면 tcp 연결된거죠 이미 이 연결된거에서만 가능하다. 연결이라는건 클라이언트 쪽에서는 커넥트를 해야되고 서버쪽에서는 억셉트를 하고 기다리다가 이제 전화가 그게 맞으면 전화가 통화가 된것이다. 
그러면 인제 그때서부터 양자간에 서버가 됫든 클라이언트가 됫든 센더 하고 리시브를 할 수있다고 했다. 그래서 이제 센더 해서 리턴이 됬단 얘기는 저기 상대방에 리모트 컴퓨터에있는 프로세스까지 메시지가 전달됬단 뜻이 아니고 프로토콜에 자기 TCP에 버퍼에 까지만 지금 저 집어넣고 리턴이 된것이다.
그러니까 보냈다라는게 보장된것은 아니다
어찌됫던 이제 그 그러고나서 프로토콜 
프로토콜 TCP는 이제 계속 전달을 하면서 그 ACK 라든가 ACK 가 오면 이제 지워버리고 ACK 가 TIME OUT 될때까지 안오거나 뭐 패킷이 가다가 잘못되면 저쪽에서 체크해서 이거 잘못됬다 라고 보내면 다시 보내는것을 하위 프로토콜에서 하게 된다.
이런 하부적인 얘기는 여러분들이 네트워크 시간에 자세하게 배운다. 알고리즘에 대해서

TCP는 여기서 센더를 해서 여기서 내가 100 바이트 나 200 바이트 보냈다고 해서 200 바이트가 가는게 아니다. 이거 그냥 스트림 이기 때문에 한 바이트가 갈수도있고 뭐 500바이트가 갈수도있고 계속해서 받는쪽에 메시지나 이런게 쪼개지는게 아니기 떄문에 그걸 가져다 받는쪽에서는 신경을 써서 받아야 된다라고 말했다. 그래서 이게 뭐냐면 스트림이다. 스트림 하는 방식이다. 그래서 만일에 이제 그걸 파일 같은것을 보낼때는 내가 10바이트 , 100, 1000바이트 보내는데 저쪽에 100바이트씩 열바에 나눠서 도착을 해도 순서대로 받으면 상관이 없다. 그렇죠
끝날때까지 
순서에는 변함이 없으니까 그래서 그런거는 문제가 없는데 만일에 TCP를 써가지고 보내는놈하고 받는놈이 약속을 했어 내가 메시지가 하나에 200 바이트 씩인데 이걸 끊어서 받아야 하는경우 가 있을거 아니에요 
200 바이트 보내면 200바이트 딱받고 근데 200바이트 보내면 200바이트가 도착한다는게 게런티가 됩니가? 안되잖아요 
스트림이니까 그래서 그쪽에서 200바이트가 될때까지 기다려야 한다. 그래서 계속 모아야 한다. 이런 그런 불편함이 있다. 

그다음에 받는 쪽에서 TCP에 쓰는것은 recv(2)이다 

## recv(2) for TCP
recv 이거는 역시 자기의 소켓이고 이거는 메시지를 받아서 저장할 버퍼가 되겠고 이게 바이트라는 거는 이걸 1000이라고 그러면 맥시멈 1000개 까지 받는다. 맥시멈 1000바이트까지 받아라 이런말임 맥시멈 을 지정해주지 않으면 버퍼가 오버 플로우가 생길테니까 요거 맥시멈을 얘기하는거다. 그래서 여기서 천 바이트까지 받으라고 했는데 저쪽에서 날라온게 저쪽에서 1000바이트 보내고 내가 1000바이트 받겠다고 했는데 날라와서 리턴되는것은 50바이트 만 올수있잔아요 스트림이니까 그래서 여기에 recv 에서 리턴되는 인테자 값이 그게 실제로 받은 넘버 오브 바이트 몇바이트를 받았는가를 리턴하니까 그거를 가지고 자기가 계산을 해서 모으든지 말든지 해야된다 이거임
tcp는 좀 골치아프다. 플래그는 그냥 널이 아니라 0을 주면된다.

반면에 여기서 얘기했지만 tcp 에서 send 하고 receive를 하는거는 이미 전화통화가 연결이 된것이다. 클라이언트 쪽에서는 커넥트를 쓰고 받는쪽에서는 억셉트를 해서 대기하고 있는게 이제 만나서 연결이 되는 경우고 그건 tcp이고 
udp 일경우에는 연결없이 그냥 전보 처럼 연결이 안되도 그냥 보내버리고 마는것이다.
그래서 그때 사용하는게 이제 snedto 라는게 되겠다.
sendto 라는 것에서 to라는 얘기는 누가 받는건가를 지정을 해야 된다는 얘기임 
왜냐하면 전화연결이 안됬으니까 
그러니까 시골에 저기 충청북도 증평군에 있는 어머니 주소에다가 이 전보를 보내주세요 그러면 어머니 하고 연결이 안된거잔아 그러니까 snedto를 할때마다 여기에 보면 소켓 어드레스 to가 있잔아요 
보내는 쪽에 아이피어드레스 와 포트를 지정해서 보내야 한다 이런말이다.
그래서 이거는 아까 여기서는 tcp에서 send 할때는 연결이 이미 된거니까 수신자가 안들어간다.
수신자가 안들어가는데 반해서 udp는 메시지를 보낼때 마다 뭐를 지정해야합니까? 누구한테 보내는건지를 지정을 해야된다 이말이다. 상대방의 받는사람 의 뭐가 들어가야 할까?
아이피 주소하고 포트번호가 들어가야 한다. 
그리고 요 구조체의 길이를 가져다 여기다 줘야하고 여기는 이제 몇 바이트를 보낼건지 그다음에 플래그는 마찬가지로 0을 주면된다. 아까랑 똑같은 뜻이기 때문에 그리고 여기는 보낼 메시지 그래서 이제 udp 를 책을 보면 내가 
내가 몇바이트를 보내면, 1000바이트를 보내면 받는쪽도 1000바이트 보내는 메시지 방식이다. 그런데 그게 커널뻑인지 프로토콜이 아직 불완전해서 그런지 내가 실험을 해보면 예를들어서 내가 500바이트 짜리를 그냥 무한 뤂을 돌면서 엄청나게 많이 보내면 그게 막 붙어서 간다. 그럴 경우가 있다
이거를 믿으면안된다. 그래서 그 만일에 메시지를 잘라야 되는경우에는 메시지앞에 메시지 시작한다는 표시하고 이 길이 가 얼마다 라는 정보를 갖다가 같이 보내주는게 이제 핸들용은 해야 된다 이런얘기다.
핸드 투 핸들러를 
그래서 os를 믿지 말자 
프로토콜이 발전해 나가고 있는 중이기 때문에 그런거 같다.

그래서 여기에서는 항상 snedto는 udp가 사용하는건데 보내는 주소 즉 보내는 ip 어드레스와 포트가 이 소켓 어드레스 에 들어가 있어야 된다. 수신자를 지정을 해야한다. 

그러면 udp를 통해서 받을때에는 연결이 안된 상태니까 그렇죠 그럼 내가 만일에 시골에 있는 어머니가 이제 서울에 있는 자기 아들한테 등록금을 붙이라는 전보를 받았다 이거야 전보가 날라왔다. 우체부가 배달 하겠죠 그러면 전보 에 뭐라고 써있어야 하나? 누가 보냈다 라는게 써있어야 될거 아니냐 
그러면 마찬가지로 recevfrom이 udp를 통해서 받는건데 여기에서 보면 뭐 데이터를 받는거는 똑같다. 맥시멈 천바이트까지 받아라 뭐 플래그는 아까랑 똑같이 0으로 쓰면 된다고 그랬고 이건 내가 만든 소켓이고 여기에 구조체가 들어오는데 요게 뭔가? 소켓 어드레스 프롬 이게 뭐야? 보낸 사람의 아이피 주소하고 포트번호가 날라온다 이거임 
메시지 마다 이게 붙어온다 아까 tcp는 이미 전화 연결이 된상태니까 그런걸 주고 받을 필요가 없는데 udp는 보낼떄는 상대방의 주소 받을때는 이게 어디 이 메시지가 어디서 날라왔는지 가 이안으로 들어와 있다. 이런 얘기다 그걸 보고 이게 누가 보냈는지를 알수있다. 이거다. 이거는 단순하게 보낸 메시지 기반의 방식이라는것을 알수있다. 메시지 마다 주소, 받는사람, 적어야되고 받을때는 보내는 사람의 인포메이션을 얻어와야한다. 메시지 베이스드 라는것을 알수가있다.

따라서 굉장히 큰 파일 같은 거를 보낼때는 어떻게 되겠냐? 파일같은것을 보낼때는 이 udp는 불편하다. 뭘 집어넣어서 보내야 되는게 많아야 하니까 그래서 그런걸 할때는 tcp를 쓰는것이고 요런것들을 이제 우리가 전화로 하는게 sns 같은거 있잔아 단문 메시지 보내는거 여러분들 카톡이나 이런거 그런거를 보낼떄 이제 한번 보내고 이렇게 나눈거에 적당한 그런 형태가 UDP 가된다 이런 얘기가 되겠습니다.


## Structue passing in TCP or UDP
요거는 뭐냐면 요기 짤리네 만일에 내가 네트워크 통신을 할떄 뭐 TCP를 쓰던 UDP를 쓰건 뭔가를 보낼꺼 아니에요 그렇죠 보내는데 이제 주는쪽하고 받는쪽하고 약속을 하는 거에요 난 이제 strcut 를 하나 잘받아가지고 여기 인테저하고 플롯트하고 더블이있는 뭐 이런 메시지를 가져다 이제 보내겠다 그러면은 여기에다가 뭘 집어넣고  이내용을 갖다가 보낼거 아니겠습니까 
이걸 보내서 받는데 이게 뭐냐면 주는 쪽에 기계하고 받는 쪽의 기계가 cpu가 다르다 이거임 cpu가 다르면 무슨일이 일어날수가있냐면 전에도 얘기했듯이 예를들어서 어떤 cpu에서는 이 더블하면 인테져하면은 어떻게 됩니까 인테져하면 네바이트잔아요 네바이트인데 이거는 반드시 메모리의주소에서 짝수나 4의배수에서 시작해야 된다. 라는 그렇게 할당하는 cpu가 있다라는 얘기임 어떤 cpu는 어떻게 됩니까 그런 제안 이 없는 cpu도 있단 말이다 
만일에 여기다가 하나 더 집어넣어서 여기다가 캐릭터 하나 더집어넣어서 여기에다가 메시지 에다가 캐릭터 c를 하나 집어넣으세요
이건 별로 안좋은데 캐릭터 c가 제일 앞에 있다고 하면은 이 struct meaage가 이게 메모리에 allocation을 할거아니야 할당을 했는데 그게 짝수였다 이거에요 그런데 여기에 캐릭터가 하나있으면 캐릭터는 몇바이트에요 한 바이트잔아요 그러면  여기에 인테자 가 오면 이거는 짝수에서 시작해야 된다라고 그러면 한칸이 비어야 된다. 반드시 
그래서 컴파일러가 저걸 컴파일할때 거기다가 패딩을 집어넣어준다 이거임 한바이트를 갖다가 아무것도 없는거를 삽입을 해줘서 인테자 a가 어디에서 시작되도록 짝수번째 메모리에서 시작되게끔 컴파일 하는 기계도 있고 그렇지 않고 그냥 홀수에서 시작, 인테저 a가 홀수에서 시작하게 컴파일 하는 cpu도 있다 이말임
그래서 그런 cpu하고 저런 cpu가 주고받을때 이거를 갖다가 그냥 보내게 되면 어떻게 되겟냐? 상대방에게 갔을때에는 뭐에요? 그게 밀리게 되겠죠 당연히 format이 틀리잔아요 
패딩이 들어갔느냐 안들어갔느냐에 차이에 따라서 그렇게 되서 이제 받는쪽에서 보니까 어 이거 이상한데 보낸게 값이 틀린데 이런 경우가 생길것 아니겠습니까 그래서 그런거에 struct meaage 에 사이즈 라던가 이 얼라이먼트가 cpu 디펜던트 합니다.

메모리에 이 정렬하는거를 패딩이 들어가기 떄문에 그래서 네트워크 를 해서 이런 struct를 보낼때는 이걸 압축을 해서 보내야 된다. 즉, 압축이란 뜻은 무슨뜻이냐면 중간에 패딩을 없애달라 이런뜻이에요 그렇게 할때에는 어떻게 되냐면 요기에 c free process 를 써서 컴파일 할때 이거 인테저 a를 짝수에다 집어넣는거를 막아야되요 그런거 에 상관없이 컴파일 해달라고 합니다 그게 뭐냐면 프로그라마 팩 일 이라는거임 그다음에 여기에 프라그마 팩하고 괄호 를 치면 이안에서 컴파일 이 저사이에 있는게 컴파일 이 되는거는 패딩을 집어넣지 않고 어떻게 합니까? 딱 압축을 하기 때문에 주고 받을떄  서로 오차가 생기지 않는다. 그러니까 cpu 그거 가 어떤 cpu가 있을떄 인테저가 짝수에서 시작되어야 한다 라는 얘기는 홀수에서 시작을 해도 되요 사실은 시작해도 되는데 짝수에서 시작하는게 cpu가 메모리에서 가져오는게 빠르기 떄문에 컴파일 을 그렇게 하는겁니다 그래서 이렇게 하면 컴파일 하면 이거는 압축을 해서 패딩이 없이 variable을 할당하기 떄문에 서로 통신을 주고받을떄 문제가 생기지 않는다.그래서 이런 커다란 struct 를 메시지로 보낼때에는 반드시 그렇게 해서 보내야 된다. 프로그마 팩을 달고 다 사용해야 된다.  프리 프로세스 매크로 입니다.

## close(2)
자 그다음에 이제 udp 를 썻던 tcp 썻던 뭐냐면 이제 통신을 끝내고 싶을떄는 어떻게 합니가 close를 하면됩니다
close를 하면되는데 이 네트워크프로그램을 여러분들이 실습같은거나 숙제같은거를 하다보면 에러가 나니까 자꾸 돌릴꺼 아니야 프로그램이 에러가 안날 떄까지 고쳐서 돌리고 고쳐서 돌리고 그런데 한번 프로그램을 돌릴떄 소켓을 잡았을떄 이것을 자기 포트에다 바인딩을 했잔아요 그렇죠 바인딩을 하는데 그 포트에 바인딩이 된게 해제가 되는데는 시간이 걸린다 왜냐하면 서로 이제 그만하자 이런게 주고 나서 시간이 걸리기 떄문에 프로그램을 에러가 나서 중단된거에다가 대고 그냥 프로그램을 또 새프로그램을 돌리면 소켓 포트가 이미 사용중이라는 메시지가 나올떄가 있다.
그러니까 그거는 프로그램이 아니고 프로토콜에서 포트를 갖다가 프리하는데 시간이 걸리기 떄문에 그렇다 라는걸 알아 둬야 할겁니다. 
암튼 close를 하는거는 이제 바인드 했던거를 다 해제하고 그리고 소켓을 가져다 없애는 그런 절차가 되겠습니다.

## recvfrom(2) for UDP


## Client of an echo program
에코 프로그램이라는게 뭐냐면 서버하고 클라이언트가 있는데 tcp를 이용하는 익으잼플이니까 클라이언트가 서버한테 접속을 해서 커넥트가 이루어진 다음에 서버한테 무슨 메시지를 보내면 고거를 그대로 받아가지고 어떻게 한단 얘기야? 서버가 클라이언트한테 다시 에코백을 해준다 이런얘기다.
메아리를 쳐준다 이런얘기다. 그런 프로그램이다 간단한 예

그래서 max 1024 라는건 그냥 바이트 겠지 바이트라고 생각
포트는 3만 번을 쓰는데 이 3만번이라는건 클라이언트 입장에서 내포트가 아니라 누구의 포트에요 상대방의 포트를 얘기합니다. 상대방의 전화번호죠 쉽게 얘기해서 서버의 전화번호가 되겠습니다
그다음에 호스트 어드레스 라는것도 이게 내 아이피가 아니라 누구의 아이피 서버의 아이피 에요 
그러니까 서버의 아이피하고 서버의 포트가 이게 상대방에 일종에 뭐에여? 전화번호가 해당한다.

자 그래서 뭐 이런 베이러블 들이 있고 요건 소켓 오픈할 디스크립터고 바이트 이런거 다 인테저 입니다
그래서 인제 소켓 어드레스 인터넷을 사용하는 소켓 어드레스 인터넷을 하나 잡았습니다. 뭐냐면 서버 어드레스 입니다
왜냐하면 서버 어드레스를 만들어놔야지 그거하고 전화를 걸수있잔아요 그렇죠 서버어드레스에다가 쉽계얘기해서 뭘 집어넣어요? 상대방의 전화번호를 넣는 행위를 할라고 하는거에요 

그다음에 snddata rcvdata 는 이거는 캐릭터 버퍼, 메시지 주고 받는데 버퍼를 사용할것이고 그다음에 소켓 어드레스 인터넷 을 소켓 어드레스 인터넷에 서버 어드레스를 만들었으면 이게 네트워크의 타입에 따라서 길이가 들쭉날쭉 하다 그랬잔아요 그래서 항상 여러분들이 해야되는건 먼저 이거를 전부다 클리어를 해서 0으로 깔아놔야 된다. 0으로 항상 깔아놔야 된다.
이거 bzero 라는거는 요 서버 어드레스 sizeof(서버어드레스) 만큼의 구조체를 어떻게 한단얘기에요? 전부다 0으로 초기화를 해달라 라는 얘기가 되겠습니다.
mmset을 써도 됩니다.  메모리에 set이라는걸 써도 되고 bzero라는걸 써도 마찬가지다. 
그다음에 인터넷 패밀리에 주소에 패밀리는 AF_INET다 이건 인터넷 주소 체계를 사용하겠다.
그다음에 호스터 어드레스는 아까 보면 무슨 어드레스 에요? 뭐 점 뭐 점 뭐 점 뭐죠 아이피 어드레스 , 닷 노테이션 이잔아요 그렇죠 그런데 실제 아이피 주소는 어떻게 들어가야 되요? 우리가 전에 했던게 기억이 날지 모르겠지만 저런 구조로 들어가는게 아니라 32bit 으로 들어가잔아 32 인테저로 바꿔줘야 하잔아요 그거 그래서 
inet.addr 라는거는 이거 닷 노테이션 뭐.뭐.뭐.뭐 를 32bit 아이피 어드레스로 바꿔달라 진짜 어드레스로 바꿔달라 얘기이다. 32bit 아이피 주소로 바꿔달란 얘기이다. 뭐 점 뭐 점 뭐 점 뭐를 
그다음에 포트가 아까 몇번이었죠 3만 번이었죠 이거는 다 서버의 주소이다. 서버의 포트가 3만 번 인데 htons 라는건 무슨뜻이야? 나중에 다시 나옵니다 그 뭘로 기억하면되냐면 이것도 그거다 우리 여러분들 컴퓨터구조 시간에 뭘 배웠을거냐면 어떤 cpu는 리틀 엔디안을 쓰고 어떤 cpu는 빅엔디안을 쓰는것을 배웠다. 
그렇죠 

리틀 엔디안 하고 빅엔디안 이 cpu마다 다르잔아요 즉 무슨 얘기냐면 리틀 엔디안 하고 빅 엔디안 인테저가 4바이트 있을때 메모리에 들어가는게 한쪽은 오름차순으로 들어가고 한쪽은 4바이트가 꺼꾸로 순서로 들어가잔아요 그런데 네트워크 이렇게 그거를 인테저를 그냥 보내게 되면 어떻게됩니까? 상대방은 나는 리틀엔디안이고 상대방은 빅엔디안 이면 그걸 오해할꺼 아니에요 다른 숫자로 그래서 이거는 뭐냐면 호스트 란 뜻입니다. 호스트 cpu의 포맷을 to a라는건 뭐냐면 네트워크 표준으로 바꿔달라 얘기이다. 네트워크 표준이 리틀엔디안 이건 빅엔디안이건 하나를 선택하겠죠 그래서 네트워크 표준으로 바꿔서 상대방한테 내가 리틀 엔디안 이고 상대방이 빅엔디안이라고 할지라도 그것을 네트워크 표준으로 보내면	상대방이 그거를 표준에 따라서 해석을 할수있기떄문에 네트워크 표준으로 표준엔디안으로 바꿔달라 이말이다. 포트가 6천일때 그래야지 상대방이 포트번호를 오해하지 않으니까 

그래서 요렇게 호스트 호스트 포맷을 내기계에 엔디안을 to a라는거 뭐야 네트워크 엔디안 표준으로 바꿔달라 s는 뭘까요 short integer 이란 얘기다. 16비트 이란 얘기다. 16비트 short integer, 16비트를 호스트 포맷, 호스트 cpu에 엔디안 포맷에서 네트워크의 표준 엔디안 포맷으로 바꿔달라 이거임, 이것을 반드시 써야됨 (htons)

자 그래서 일단은 여기까지 하거는 이제 서버 어드레스, 내가 전화올 상대방에 전화번호를 이제 저장을 만들어 놓은것이다 그리고 소켓을 하나 만듭니다. 소켓을 만드는데 여기보면 
이거 인터넷 소켓이다. 인터넷 ip , 인터넷 체계를 주소체계를 쓰는거다 소켓 stream 이라는것은 stream이 tcp라고 했다. 데이터그램이 udp 라고헀다 이건 tcp 형태를 말한다. 그리고 이제 tcp도 stream 프로토콜 도 tcp만 있는게 아니고 내가 만들어서 집어넣을수도있고 뭐 다른 회사에서 또 tcp 비슷한걸 만들수가있는데 여기 0이라고 한거는 그 프로토콜을 선택하는데 니가 os가 알아서 해달라이거임 그러니까 0으로 하면 이제 뭐가 선택이 되겠습니까? 당연히 프로토콜 tcp가 선택이 된다 이거임 디폴트란 얘기임 
//socket(AF_INET, SOCK_STREAM, 0))<0) 
전에도 얘기했지만 이 소켓은 파일 오픈하는거랑 똑같다고 했다. 파일디스크립터랑 똑같다고 했다.
자 인제 커넥트를 합니다.
커넥트를 하는데 여기보면 커넥트라는건 상대방한테 뭐한는 행위라구요 전화 거는 행위라고 했다. 근데 뭐가 빠졌어? 이 소켓, 이건 내가 쓸 소켓이잔아요 sd 라는게 내가 쓸 소켓에 내 마이 아이피하고 마이 포트 내전화번호를 바인드를 해야되잔아요 왜냐하면 우리 휴대폰으로 전화받으면 뭐가떠요 상대방 전화번호가 뜨는것처럼 내꺼를 바인드해야되는데 바인드가 있어요 없어요 , 바인드 가 없다. 그러니까 로컬 어드레스 로컬 아이피 어드레스하고 즉 내전화번호 클라이언트의 아이피 어드레스하고 클라이언트의 포트넘버를 소켓에다가 바인드를 원래 해야되는데 안했잔아요 그거는 왜 안했냐면 어디서 자동으로 해주기때문에? 커넥트에서 자동으로 바인드를 해준다. 그런말임 그러니까 로컬 아이피 주소하고 로컬 아이피주소하고 로컬 포트 는 커넥트에서 자동으로 알아서 해준다. 내가 포트를 지정하지 않아도 적당한 포트를, 비어있는 포트를 골라 가지고 내 전화번호에 대한 바인딩은 자동으로 커넥트에서 해주니까 그거는 여기서 바인드를 안해도 됩니다. 커넥트를 하는쪽에서는 
그래서 이제 and then 전화를 겁니다. 전화를 누구한테 거는거죠? 서버 어드레스가 있죠 , 그러니까 이거는 뭐냐면 상대방한테 지금 전화를 거는행위를 하는것이 커넥트가 되겠다. 
커넥트를 할떄 뭐가 들어갔죠? 내가 방금전에 오픈한 마이소켓 그다음에 상대방 서버의 어드레스 가 들어가고 그서버 주소체계 길이가 들어간다. 

커넥트를 성공하기 위해서는 상대방이 뭘하고 있어야 된다구요? 억셉트를 하고있어야 된단 말이에요 만일에 상대방이 아직 저쪽에서 약속을했는데 서버프로그램을 아직 안돌렸어 안돌렸으면 커넥트에서 어떻게 되겠습니까? 에러가 나겠죠 그런 경우에는 보통 retry, loop을 가지고 retry 을 해도 상관이 없습니다. 왜냐하면 저기 서버가 언제 올라올지 모르니까 
근데 서버가 만일에 기다리고 있는 상황이었으면 커넥트가 성공을 하게 된다.

그래서 여기보면 auto binding for this client and connect request. 그러니까 클라이언트의 아이피주소에 대해서는 이소켓에 자동적으로 바인딩이 되기때문에 할필요가 없어졌다 이거임 
자그래서 이제 커넥트해서 성공을 했어요 그러면 상대방 커넥트에서 벗어 나와서 리턴 밸리유가 이제 1이 나올겁니다. 1이나오면 이게 성공을 했단 얘기거든요 그러면 상대방하고 연결이 된 상태 그러면 인제서부터 뭘쓸수가 있어요? sende 하고 receive를 쓸수가 있는데 그떄에는 주소같은게 필요가 없는거에요 상대방이 
이미 다 연결이 됬기 떄문에 
그래서 인제 이거 어떻게 하냐면 fgets 라는거는 스트링을 하나씩 읽어오는거죠 스트링을 어디에서 읽어오는거죠? 스탠다드 인풋에서 읽어오는거고 이게 엔터키로 칠떄까지 스트링을 받아오는거겟죠
그래서 max라는 거는 아까 이제 1024까지 글자 까지 받는다고 그랬고 그것을 어디에다 집어넣는겁니까? senddata라는 캐릭터 버퍼가 있었죠 어레이가 거기에다가 이제 키보드에서 치는것을 받아들이는것이다. 스트링을

그래서 이제 스트링이 들어왔는데 몇글자인지를 모르잔아요 그죠 그래서 여기보면 보낼 바이트의 개수는 이 send 데이터에 스트링 랭쓰 라는 함수를 부르면 거기에 몇글자가 들어가있는지가 리턴이 되잔아요 키보드에서 몇글자 쳤는지 그래서 이제 보낼 데이터는 send 데이터라는 캐릭터 어레이에 들어가있꼬 보낼 바이트의 개수는 뭡니까? send_bytes에 들어가있다.

자 and then 커넥트를 했으니까 이제 어떻게하면됩니까?
이소켓으로 센드를 하면 자동으로 상대방한테 갑니다. 그래서 센드 소켓 센트데이터 이 캐릭터 어레이죠 그다음에 몇바이트 보낼건지 그다음에 요거는 옵션이라고 했는데 0을 쓰면됩니다.

그런데 센드 바이트 를 보내달라고 했는데 센드에서 리턴이 된게 뭐에요 센드 바이트가  아니다. 그런얘기는 이건 무슨 얘기냐면 100바이트 보내달라고 했는데 100바이트 를 못보냈다 이런얘기잔아요 
이거는 그냥 -1이 리턴이 된거에요  사실 그건 무슨애기냐 에러가 난거다. 왜 에러가 났을까요 sender 한테 
일반적으로 전화가 연결이 됬는데 내가 보낼라고 했는데 저쪽에서 전화를 끊어버린것이다. 저쪽에서 close 무슨이유로 이제 저쪽에서 상대방이 소켓을 close 전화를 받았는데 스팸같은거 해버리잔아요 마찬가지다. send 를했는데 이미 상대방이 아까 억셉트를 했는데 그놈이 그것을 close해버린거다 마스터 혼자 서버가
그러면 못가니까 우리 학기초에 파이프 배웠잔아요 
파이프로 내가 파이프에다 쓰는데 파이프에다 읽는놈이 다 close해버리면 어떻게 됩니까 그거 못보내잔아요 
똑같은얘기다 이것도 브로큰 파이프 라는 시그널이 날라온다. 
이것도 파이프의 일종이니까

우리 분산?? 되는 파이프는 같은 기계안에서 쓰는거고 이 파이프는 어디에서 쓰는거에요? 기계간에쓰는 파이프 일뿐이다. 똑같이 에러가 난것이다. 상대방이 닫아버린것이다. 그래서 아무튼 sendbyte가 나오면 성공을 했단얘기다
그래서 성공을 했어요 그리고 리시브 바이트를 0으로 클리어를 하고 while(recv_bytes)가  send bytes 보다 작을때까지 작은동안에는 룹을 돌아라
뭘 하고 있습니까? 리시브를 하는거에요 이 리시브는 아까 어디에 사용하는거에요? 상대방이 보내는 메시지를 기다리는거에요 그렇죠 그래서 내가 여기서 이 보낸글자가 만일에 100바이트라고 가정을 합시다 
그럼 100바이트가 지금 성공했으면 어디까지 갔을거에요 서버 까지 갔겠죠 
그럼 아까 서버가 어떻게 하는게 좋냐면 100바이트 받은거는 그대로 다시 보내주기로 했잔아요 지금 부른거니까 에코백을 하는거니까 그래서 상대방이 보내는거 에코백을 해주는거를 다시 받기위해서 뭘했습니까 recv를 했다이거에요 recv를 했는데 서버도 100바이트를 받았으면 몇바이트 보내겠습니까? 100바이트를 보내겠죠 그런데 아까도 얘기했듯이 TCP가 100바이트를 보내면 100바이트가 한꺼번에 간다는게 보장이 안된다 그랬죠 100바이트가 오기는 언젠간 와요 그런데 어떻게 됩니까 잘라져서 올수도 있다이런얘기다.
그래서 여기서 어떻게 하느냐면 recv 를 한번에 하는게 아니라 맥시멈을 정해놓고 recv 데이터에다가 받는데 recv 데이터에서 받는데 이게 100바이트를 받아야 되는데 50바이트만 올수가 있잔아요 그러면 요 받은 n이 어떻게 되겠습니까? 
받은 n이 50바이트만 올거아니에요 그렇죠 그러면 그 이제 100바이트를 보냈는데 50바이트만 오면 이거는 다시 recv 를 또해야되죠 언제까지 100이 넘을떄까지 recv 를 해야되잔아요 그래서 여기서 recv 바이트는 0으로 해놓고 여기다가 + n을 했는데 만일에 저쪽에서 100바이트를 10바이트 씩 끊어서 보내면 이게 계속 룹을 돌면서 10바이트 씩 10바이트씩 받아가지고 recv byte 가 뭐가될때까지 100을 넘을때까지 기다리는것이다. 이런얘기에요 룹을 돌면서 계속 recv를 한단얘기에요 
이게 stream I/O이기 떄문에 그런것이다. 

그래서 recv데이터가 캐릭터 어레이 잔아요 그래서 10바이트를 받았으면 그 10바이트를 저장을 하고 다음번받을때는 캐릭터에서 10자가 10바이트가 가가지고 그 다음서 부터 버퍼를 줘야 되겠죠 그래서 버퍼 어드레스 자꾸 증가시키고 있따. 
뭔얘기냐면 내가 보낸거는 100바이트를 보냈어요 누구한테 server 한테 100바이트를 보냈는데 서버가 다시 100바이트 일로 보냈단 말이에요 근대 이게 이제 10바이트씩 끊어져 올수가 있
20도 올수있고 이런식으로 끊어져 온단 말이에요 TCP 는 그게
근데 일반적으로 100바이트정도는 보내면 그대로 와요 오는데 그거를 믿을수없기때문에 이 쪽에서 이제 이게 recv buffer 잔아요 이게 캐릭터 어레이잔아요 여기가 처음에 10자 오면 받았잔아요 그렇죠 10자 라는거 

10자가 어디로 리턴이되요 n으로 리턴이 되잔아요 n으로 리턴이 됬으니까 그걸 recv byte 에 저장을 하고 다음 번에 recv를 할때는 버퍼를 어디서부터 받아야 되요 여기서부터 받아야 되니까 recv buffer에다가 뭘더했습니가 recv size를 갖다가 더한 자리에서부터 또 받아야 된다 이거임 
그래서 그렇게 여러번엔 쪼개서 받을수가 있기떄문에 쪼개서 받으면서 그거를 누적한 데이터가 어떻게 됩니까 리시브 바이트에쌓이잔아요 그게 뭐보다 커져야 되요? snedbyte보다 커져야 된다 이런얘기임 그래야지 이제 다 받는것이다. 


그래서 recv byte에다가 recv byte 맨 끝자리에다가 뭘 집어넣엇습니까 스트링이니까? null을 집어넣어가지고 프린트를 해야지 이게 프린트가 되겠죠

그러니까 내가 100바이트씩 해서 보내면 여기서 받는게 200바이트 받을수도 있죠 그렇죠 이거는 이것보다 이제 큰거 떄까지 돌라고 했으니까 그게 tcp 의 속성이다. 

자 그러면 이게 클라이언트고 서버를 보겠습니다.

## Server of an Echo Program
서버를 보면 max 1024 데이터 버퍼의 크키고 포트는 3만번 아까 3만번 서버 포트였었쬬 
자기 자기 포트에요 
backlog라는건 이제 서버가 클라이언트를 대기하는걸 5개까지 허용하겠다. 
소켓 어드레스 인 클라이언트 어드레스 하고 뭘잡았습니까? 
서버 어드레스 이 양쪽 어드레스를 다 잡아야되죠 이제 

양쪽 어드레스 다 잡아야 되요 그래서 소켓 하나를 오픈했어요 역시 tcp를 사용하는 소켓을 하나 오픈하고 자 서버는 이제 내가 포트에서 기다려야 되는 입장이기 때문에 자기의 로컬 아이피주소하고 자기의 사용하는 포트를 내 어드레스에다가 어떻게 됩니까? 바인드해야되야되요 소켓에다가 그래서 어드레스 삘링?? 하는게 이거 서버어드레스는 요거는 아까 클라이언트는 이게 남의 주소 였지만 요거는 내 전화번호죠 내전화번호를 만드는것이다 그래서 bzero 서버 어드레스에 AF_INET , 그다음에 여기에 보면 아이피 어드레스는 INADDR_ANY 라는 뭐냐면 내 로컬 아이피 주소를 넣어달라 이말임 자기 기계의 아이피 주소를 넣어달라 얘긴데 여러분들 알겠지만 하나의 컴퓨터 라 할지라도 아이피 주소는 여러개 갖을수가있죠 그렇죠 그렇기때문에 이거는 그중에 아무거나 써도 상관이없다 내가 구지 내 주소, 내기계 내가 지금 쓰는 로컬에 머신에 아이피 주소는 알필요가 없으니까 그냥 inaddr_any 하면 됩니다.

그러니까 자기 자신의 아이피주소다. 
요것도 이제 인테저 이기 때문에 이거 아까 얘기했죠 뭐에요 h, host format을 뭘로 바꿔라? 네트워크 표준으로 바꾸는데 여기 l이라는건 무슨뜻이겠습니가? 롱워드다 이런얘기다. 4바이트 인테져다 아까는 포트는 short integer 였으니까 s라고 한거고 역시 네트워크 표준으로 바꾸고 포트는 6만번 이었죠 이거 내전화 번호 입니다 지금 자기자신의 전화번호를 어드레스에 집어넣는건데 host format을 어디로 ? 네트워크 포맷으로 바꿧다 short integer을 포트에다 넣어라 그래서 자기주소 를 여기다가 집어넣습니다. 그리고 자기주소를 내가 기다려야 하니까 바인드를 해야됩니다 어디에다가 소켓에다가 바인드를 해야된다 이런얘기에요 
아까 클라이언트는 바인드를 했어요 안했어요 바인드 안했다. 그거는 안한게 아니라 커넥트에서 어떻게 했다고? 자동으로 했기떄문에 
그래서 바인드를 합니다 바인드를 보면 내가 오픈한 소켓에 이 서버 어드레스 는 내자신의 주소죠 자기 소켓에 자기 소켓어드레스를 자기 아이피주소하고 포트넘버를 바인딩합니다.
그다음에 그소켓에서 클라이언트가 이제 들어올거에요 들어오는데 그거를 갖다가 5개까지 완전히 받아주겠다.
밀리는거를 허용하겠다. 라고 큐에 길이 클라이언트의 큐의길이를 5로 지정을 합니다. 
자 그리고 나서 뭘합니까?
이제 전화를 기다려야 되잔아요 서버니까 그래서 어떻게 합니까 억셉트를 합니다. 억셉트는 전화를 기다리는것이다
그런데 이 억셉트에는 뭐, 억셉트가 어디에 들어가 있어요?
while(1)에 들어가있쬬 
이얘기는 뭐냐면 클라이언트 가 하나만 들어옵니까? 그렇지 않다 계속해서 여러명이 서버라는거는 여러명의 클라이언트를 상대해야 되는거기 떄문에 한 놈 전화받아도 또 어떻게 합니까? 룹을 돌아서 또 다음 문장하고 만나보고? 계속 기다리겠습니다. 라는거

억셉트는 계속해서 해야되기때문에 항상 룹에 들어갑니다 이거를 일반적으로 서버 웨이팅 룹이라고 합니다 서버는 항상 룹돌면서 저렇게 계속 전화를 기다려야 하루종일 기다려야 되잔아요 하루종일이 아니라 24시간 몇일 몇날이라도 기계가 살아있는 동안에 서버가돌면 기다려야 되기떄문에 항상 while 룹에 들어가고 거기서 그거를 뭐라고 그러냐면 서버 웨이팅 룹 이라고 합니다.

클라이언트 어드레스, 클라이언트 가 누군지 알아요 몰라요 지금? 누가 전화올지 모르죠 아직 전화오기 전까지는 그래서 이거 클라이언트 어드레스는 그냥 사이즈만 잡아놓는거에요 사이즈 
그래서 전화를 받습니다 전화를 기다립니다. 내가 바인드 한 소켓에서 기다리다가 전화가 옵니다. 그러면 억셉트해서 리턴이 되겠죠 석세스풀 리턴이 되겠죠 석세스풀 리턴이 되면 1이 리턴이 되면 이거는 누구한테 전화가 온거에요? 즉 상대방 에 뭐하고 맞는거에요? 커넥트하고 만난거다 이거임  그러면 전화가 연결이 된거다 
그러면 억셉트 해서 리턴이 될때 뭐가 들어오냐면 여기 클라이언트의 주소하고 사이즈가 들어옵니다. 

그러니까 여기에 뭐가 들어와요? 클라이언트 의 아이피주소하고 뭐가 들어와요? 포트번호가 들어온다 이런얘기다.
이게 여러분들 전화받을때 뭐가 떠요? 상대방 전화번호 뜨잔아요 그렇죠 그게 일로 들어오는 것이다. 그러나 이거는 쓸일이 있어요 없어요? 뭐 특별한 경우가 아니면 이거 쓸일이없어요 왜냐하면 뭐 매번 얘기할때마다 뭐 너전화번호 맞니 하고 물어보고 얘기하는 거 아니잔아요 그냥 얘기하잔아요. 
그래서 이거는 그냥 받아놓는것이다. 좌우지간

그런데 여기에서 내 전에도 얘끼했듯이 요 서버가 바인드가 된 소켓은 sd 잔아요 sd,
sd인데 요 소켓에서 기다린다 뜻아니에요 전화를 기다린다 뜻인데 억셉트 해서 통화가 성공이 연결이 성공적으로 연결이 되면 여기에 뭐가 리턴 밸리유가 있는데 여기에 nsd 라는거는 뉴 소켓이다. 이란 얘기다. 새로운 소켓이 하나 리턴이 됩니다. 전에도 얘기했죠 왜 새로운 소켓이 하나가 생성이 되서 리턴이 됩니까? 원래 있었던 서버의 소켓은 sd인데 이거는 계속해서 뭐를 기다려야 되는 소켓이에요? another 클라이언트 전화를 계속해올것이기 때문에 글로 그거를 기다려야 되는 소켓이 sd 가 되버린것이다. 그럼 이제 전화가 통화가 성립이 됬으니까 클라이언트하고 대화를 할때에는 새로운 소켓이 필요하다. 전화기다리는 소켓이 따로있고 클라이언트 하나 붙은 놈하고 메시지를 주고받아야 되는 그런 소켓이 새로 하나 필요하기때문에 그 새로운 셋 소켓이 하나 생성이 됩니다 억셉트 해서 성공적으로 리턴이되면 

새로운 소켓은 뭐냐면 어떻게 하는거다 이제? 방금 전화가 통화가 접속이 된 클라이언트하고 주고받는데 사용할 소켓이다 이거임 이거는 클라이언트하고 사용할 소켓이고 요거는 뭐냐면 전화를 기다리는 소켓이다 이거임 

자동으로 소켓이 하나 오픈이 되서 리턴이 된다 이말임
물론 요게 -1이 오면 이건 에러다 -1 이 오면 에러고 요 소켓 번호가 이제 파일 오픈 한것처럼 3,4,5 이렇게 내려가는거야 이것도 똑같다고 그랬으니까 
그래서 인제 여기서 fork 가 있단말이에요 fork 한 이유는 뭐냐면 fork는 서버 , 원래 오리지날 서버는 계속 뭘 돌아야되? 룹을 돌면서 계속 뭘해야 합니까? 억셉트를 해야되잔아요 그렇죠 억셉트를 하면서 계속 기다려야 하니까 클라이언트 가 하나 붙었으면 그 클라이언트하고 대화를 할 서버는 하나 새로 fork를 해서 child 로 만들어 줘야된다 이거임 그래서 여기서 fork 를 하면 이 child 가 바로 뭐냐면 클라이언트하고 대화를 할 그 child process가 되겠다 fork 가 0보다 작단 얘끼는 child만드는데 실패했다 이거는 실패하지 않으면  일로 오겠쬬

그래서 여기보면 pid가 0단 얘기는 이건 무슨얘기에요? 방금 포크가 된 뭘 얘기합니까? child를 얘기하고 그렇지 않으면 여기 close라는건 뭐에요? 여거는 부모가 되겠죠 부모가 됩니다 그래서 요거는 서버에 child프로세스고 요건 서버 그자체가 됩니다 
그러면 우리가 소켓도 파일 오픈 하는거하고 똑같다 그랬죠 그죠 근데 우리가 이미 알고있는거는 프로세스를 포크를 하면 부모가 오픈할 파일을 자식이 어떻게 되요 ? 다 물려받는다고 했잔아요 그렇죠 그러니까 무슨얘기냐면 부모가 쓰는 파일이 sd라는것도 있고 nsd 라는 두개의 소켓이 생긴거 아니에요 이걸 파일로 보면 요기에다가 자식한테도 어떻게 되는거야 다 전달이 전수가 됬다 오픈한상태로 그러니까 오픈은 두번한건데 close는 몇번해야한다고 4번해야 한다고 말했잔아 그렇죠 그래서자식으로 가보면 자식은 원래있었던 소켓이 필요있어요 없어요? 필요없습니다 이소켓은 뭘할꺼에요? 원래 부모 서버가 계속해서 전화를 기다리는 소켓이고 내가 대화할 소켓이 아니기 떄문에 나는 닫아버립니다. 반면에 오리지널 서버는 뭐가 필요없어요 ? 새로생긴 소켓이 필요가 없죠 이거는 자식프로세스가 진짜 클라이언트하고 얘기할 소켓이기 떄문에 자 그래서 자식 프로세스를 보면 자식 프로세스는 이제 뭘 하는 프로세스에요 인제

클라이언트가 아까 커넥트가 되면 메시지를 보내잔아요 키보드에서 찍어간거를 계속해서 보내잔아요 그러면 내임무는 그걸 다시 뭐해주는거에요? 고대로 들어온대로 에코백 해주는것이다 그렇죠 그래서 여기보면 리시브 합니다 클라이언트 에서부터 리시브를 합니다 맥시멈만 항상 정해줘야되죠 여기서 받는데 아까 자식이 100바이트 보냈다고 그랬잔아요 그러면 여기에 100바이트가 들어와요?

100바이트가 들어온다는게 개런티 가 안되요 나는 5바이트 들어오면 5바이트 받아서 보내고 10바이트 보내면 10바이트 받아서 보내는것이다 그렇죠 자식은 100바이트 보냈어도

그래서 여기서 보면 받았어요 바이트가 0면 이거는 클라이언트가 죽어버린것이다 마치 eof 와 같은것이다 이건 더이상 할필요가 없다 나가버리는것이고 바이트가 0보다 작으면 이거는 저쪽에서 소켓같은걸 닫아버린것이다 이건 에러가 난것이고 
else 이거는 이렇게 하고 받은거를 어떻게 합니까 send합니다 send하는데에 5바이트 받았으면 5바이트 보내는것이다 여기보면 바이트수가 받은 바이트의 개수잔아요 요거는 상대방까지 전달되는게 5바이트란 뜻이라고 했어요? 아니라고 했어요? 이건 프로토콜 까지만 전달되는 거니까 이거는 사실은 에러가 나는게 아니죠 그래서 이건 not byte라는건 에러가 났단 애기고 그래서 이제 받은거를 그냥 보내고 또 가서 받아가지고 보내고 받아가지고 보내고 그냥 들어온대로 받아가지고 보내는 룹이다. 
그래가지고 클라이언트 가 더할게 없으면 어떻게 하겠습니까? 결국은 클라이언트가 소켓을 close 할꺼 아니에요 보낼꺼 다 보냈으면 그러면 내가 recv하면 그게 뭐가 리턴이 되겠냐? 0이 리턴이 될거아니에요 저쪽에서 다 쳤으니까 
이거 뭐랑 똑같아요? eof 하고 똑같다 그져 그래서 0이 리턴이 되면 while loop에서 break를 합니다 break 를 하면 얼로 와요? 일로 내려오잔아요 그쳐 
일로 내려옵니다. 그리고 리턴 0 하고요 
리턴 하면 프로세스 가 없어지는것이다 이거는 exit하고 사실 똑같은 것이다 그렇죠 리턴하는거는 프로세스가 

그다음에 이거는 이제 클라이언트가 대화할 동안에 생겼던 업어지는 자식프로세스고 요거는 오리지날 서버죠 오리지날 서버는 새로생긴 클라이언트가 필요없으니까 close하고 while loop으로 다시 돌아가서 이제 또 뭘합니까 억셉트 하는 룹을 돌게 된다. 요걸 
fork 로 하기 싫으면 뭐하면되요? 스레드로 만들면됩니다 pthread_create 로 해도 됩니다 create 를 할떄 뭐를 아규먼트로 넘겨줘야 하냐면 요거를 아규먼트로 넘겨주던가 아니면 글로벌 베리어블로 만들어서 볼수있게하든가 그렇게 해야겟죠

이렇게 하면 자식프로세스가 많이 생겼으면 어떻게 되겠습니까 자식이 부모가 뭘안했어요? wait을 안하니까 좀비가 되겠쬬 그래서 남아있다 치우질 않으니까 그러다가 결국은 이거는 어떻게 되냐면 서버 자체가 죽어버리면 서버가 죽으면 자기 자식들이 좀비로 있으면 그거를 누구한테 입양을 해요? 자식 아버지한테 입양을 해서 거기서 wait를 하고 init 이 wait를 하고 있기때문에 청소는 되기는 됩니다.

그래서 이거를 한기계에서 시뮬레이션 해봐야 할꺼아니에요 그래서 기계가 두대로 할라고 하면 귀찬으니까 
그래서 서버를 먼저 돌려놓고 뭐로 돌려놓냐면 백그라운드로 돌려놓는다 서버를 백그라운드에서 실행하게 해놓고 그리고 나서 무슨프로그램을 돌려요? 클라이언트 프로그램을 돌려서 키보드에서 이런것을 집어넣으면 고기에 그게 반사가되서 서버에서 에코가 된다.

# 시스템프로그래밍(기)9-2
억셉트에서 클라이언트 주소를 받을 수있다고 하셨는데 클라이언트에서 커넥트를 할때 자기 주소를 보내는데 . 커넥트에서 자동으로 바인드를 했다.
바인딩을 자동으로 했다고
서버는 이제 커넥트에서 자동으로 바인딩을 하는데 억셉트는 바인딩을 안하기떄문에 서버는 자기것을 바인딩을 한거죠 
일반적으로 보내는 쪽에서는 바인딩을 안해도 되요 TCP는 처음에는 바인딩을 해야되는데 UDP는 보내는 쪽에서는 바인딩을 안해도 되요 자동으로 바인딩이 된다. 받는쪽에서는 자기가 이거를 지정해놔야지 상대방이 글로 들어오니까 바인딩을 꼭해야되고 
UDP 예가 빠졌는데 다음에 슬라이드 만들어서 다시 얘기하겠다

호스트 어드레스 지정할떄 INADDR_ANY 라는거는 이거 호스트가 가지고 있는게 아이피 주소가 여러개 일수도있는데 그중에서 아무거나 하나 골라라 이런뜻이다. tcp가 골치아픈게 뭐냐면 저쪽에서 만약에 1000바이트보냈다고 그러면 만약에 100000 바이트 보냈다그러면 그건 패킷보다 크니까 당연히 잘라져서 옵니다 어셈블리가 안해주기 떄문에 보낸 만큼 오지않는다 그래서 그거를 처리해야되는 그걸 처리할떄 쓰는 테그날리지가 몇가지가 있는데 
When the message size is fixed and known
메시지를 갖다가 주고 받을떄 항상 이제 클라이언트 하고 서버하고 야 우린 100바이트씩만 주고받는다 라는게 메시지가 따로따로 보내는걸 여러개 파일같은거 말고 대화를 하는데 100바이트 보내는걸 100바이트 꼭 받아야 되는경우가 있다고 그러면 이렇게 하면되요 
recv 할떄 여기에다가 아까 옵션이 0 이었는데 메시지 피크라는걸 집어넣으면 메시지 피크 라는 옵션을 주면 이거는 뭐냐면 tcp 가 가지고있는 버퍼에서 아직 까지 제거하지 말아달라 
내버려 두라 이말임 왜 내버려 두느냐 하면 이 여기서 그 대신에 tcp 버퍼에 저장되어있는 메시지에 뭘 보내줍니까? 길이를 갖다가 보내줍니다. 길이를 보내주기 떄문에 이 길이가 내가 원하는길이가 아니란 말이에요 예를들어서 둘이 1000 바이트 씩 주고받기로 했어 메시지를 한번에 근데 저쪽에서 1000바이트 보냈는데 나는 1000바이트 받아야 되잔아요 그런데 tcp 쪽에서 먼저 뭐가 들어가요? 100바이트 만 들어왔다 그래서 나는 1000이라는걸 알죠 그러면 피크를 하면 그걸 가지고 오지 않고 그냥 내버려둔다 100바이트 받은것을 그래서 그렇지만 그 100바이트 버퍼에 몇개 가 tcp 버퍼에 저장되어있는지 return 해주게 됩니다 이렇게하면 그래서 내가 원하는건 몇 바이트에요 1000바이트 죠 그렇죠 받은거는 몇 바이트에요 100바이트다 이런얘기다 그래서 이게 커졌으면 이걸 룹을 벗어나도 되지만 그렇지않으면 다시 룹으로 들어가서 또 어떻게 합니까 recv 를 해서 계속해서 기다리는거 언제까지 recv 가 일어나면 또이게 될때까지 기다렸다가 결국은 이 룹을 벗어날때는 뭐냐면 받은길이가 뭐보다 커졋을때 내가 원하는 1000바이트 보다 커졌을떄 
이게 나오게 된다 이말임

그리고 나서 여기서 데이터를 가져오면  그떄서야 비로소 어떻게 되는거요? tcp 버퍼에서 가지고 오는 행위를 한다. 
// recv로 가지고 오는듯

그다음에 아까 이렇게 해도 되죠 사이즈 오브 스트럭쳐 메시지 라는걸 해놓고 이게 내가 만들 메시지의 구조체다 이거임 그러면 이렇게 하고 메시지버퍼 에다가 아까처럼 메시지 버퍼에다가 받는데 그 받은길이를 갔다가 랭쓰라고 하고 이게 10바이트 받았으면 또 올라가서 메시지 버퍼에서 10바이트 지나간 자리에서 아까 받는다고 그랬잔아 그걸 계속해서 반복하는거야 
언제 가 될떄까지 메시지의 받은 크기가 토탈해가지고 여러개 나눠서 받을떄 그 길이가 계쏙 누적을 했으니까 그 길이가 내가원하는 사이즈보다 클때까지 받는다. 

근데 이거는 골치 아픈거는 뭐냐면 내가 서로 1000바이트 를 받기로했는데 이렇게 돌다보면 1200 바이트 올떄도 있잔아 요 그러면 200바이트 가 어디 남아있을겁니까? 버퍼에 남아있을 거아니에요 그것도 자기가 관리를 해야되요 그러니까 이게 프로그램이 좀 복잡해진다. 그런 얘기다. 
내가 짠 프로그램이 있는데 굉장히 머리아픔
그건 암튼 여러분들이 알아서 짜야됨

이런거를 할필요가 없다 파일을 주고받는거면 어떄 야 나 파알하나 보내줘 하고 센드를 했어요 그렇죠 그러면 파일의 크기 까지 받아가지고 그다음에 어떻게 합니까? 파일을 갖다가 이제 보내기 시작하면 저쪽에서 1000바이트 보내든 10바이트, 1000 바이트씩 보내서 보내는데 도착하는데 10바이트 씩 도착해서 내가 그걸 10바이트씩 받아서 파일에다가 저장하면되잔아요 그건 스트림 I/O할때는 별 지장이 없어 

## TCPs stream I/O

그런데 골치아픈건 뭐냐면 파일 같은거 전송할때는 괜찬은데 메시지단위로 주고받아야 되는데 매번 주고 받은 메시지 길이가 일정하지 않다. 어떤떄는 메시지가 1000바이트 보내고 어떤 떄는 500바이트 보내야 될떄가있는데 그걸 끊어서 받아야 되는경우가 있을거 아니에요 그럴 때는 여러분들이 프로토콜 하나 만들어야 한다.
END TO END 프로토콜 종단간에 무슨얘기냐면 이런 식으로 하는거다
어떻게 하냐면 메시지를 tcp 메시지를 갖다가 보낼때 여기다가 메시지 헤더에다가 , 메시지헤더는 아무거나 하나 집어넣고 스페셜 캐릭터같은것을 s라는 글자 하나 집어넣든지 그리고 여기에다가 뭘 주는겁니까? 메시지의 길이를 보내는것이다. 요거는 고정 되잔아요 그쵸 그다음에 이거는 어떻게 되는거야 ? 베리어블 랭쓰가 되는것이다. 그러면 여러분들 먼저 뭘받아야 되요? 메시지 헤더를 받아가지고 요기서 길이를 픽업해가지고 요 길이가 찰때까지 버퍼링을 해서 메시지를 받아야 된다 길이가 들쭉 날쭉 하기때문에 

UDP는 다음시간에 설명 추가

## Data Format Conversion
이제 네트워크에서 tcp가 됫든 udp가 됫든 사용되는 여러 가지 펑션들에 대해서 설명
펑션은 라이브러리 니까 프레젠테이션 레이어에 있다고 생각하면된다.
그래서 여기보면 아까 나왔다.
네트워크 보낼때 만약에 롱워드 , 이 4바이트 인테저를 보내고 싶으면은 항상 어떻게 해서 보내야되?  htonl 
호스트 포맷을 무슨 포맷으로? 네트워크 표준 포맷으로 롱워드를 바꿔 가지고 보내는 식으로 해야된다. 모든지 데이터를 보낼때에는

short integer로 보낼떄 htons 
short integer를 호스트 포맷을 무슨 포맷으로? 네트워크 포맷으로 자그러면 저쪽으로 이제 인테저를 보냈어요 그럼 내가 인테저를 받을때에는 또 어떻게 됩니까?
받을때에는 네트워크 표준으로 받았으니까 local cpu 포맷으로 바꿔야 되잔아요 거꾸로 그게 뭐냐면 네트워크포맷을 무슨 포맷으로? 내 cpu의 포맷으로 롱워드를 바꿔달라 
요거는 이제 네트워크 받은 short 인테저를 네트워크 포맷에서 무슨 포맷으로? 호스트 포맷으로 바꿔달라 

파일 같은거를 보낼떄는 어떻게되요? 그건 상관이없다 그냥 스트림으로 가는거니까 
인테저 같은 끊어서 보낼때 하는거 

이게 뭐냐면 cpu마다 뭐가 다르기때문에 리틀 엔디안 하고 빅엔디안이 다를 수있기때문에

플로팅 포인트 넘버에 대해서는 이런 라이브러리가 없다. 플롯팅 포인트 넘버를 보내야 되면 이건 자기가 알아서 빅엔디안 리틀엔디안인가 를 드론 소프트웨어 만들었었고 시뮬레이션 하는데 저쪽 비행기 cpu가 있고 이거를 비행기를 관제하는 그라운드 컨트롤 스테이션라고 그러죠 거기서 명령도 내고 이러는 거기에도 프로그램이 있잔아요 이게 두개가 계산을 해서 주고받는데 이 비행기 고도 위도 경도 날라오잔아 그게 플롯팅 포인트로 날라오는데 고생을 한게 저쪽 비행기 속 cpu 관제탑의 cpu가 다름 플롯팅 포인터 넘버도 바이트가 전부다 뒤집혀서 오더라고 그런거는 라이브러리가 없으니까 자기가 받은다음에 뒤짚어야 된다. 

그래서 여기보면 플롯팅 포인트나 더블 같은 이런 실수 같은건 여러분 알다싶이 사인 익스퍼넨트 만티사로 구성이 되잔아요 그래서 익스퍼넨트 나 만티사의 크기는 일정한데 문제는 리틀엔디안 빅엔디안 이 순서가 바뀔떄가 있다. 네트워크 프로그램이 이래서 어려움

많이 쓰는게 뭐냐면 bcopy나 memory copy랑 똑같은건데 소스에서 데스티네이션 으로 메모리에서 n바이트만큼 복사하는 그런 루틴들이 많이 사용되고
펑션이

아까도 나왔었죠 bzero 라는건 데스티네이션있는거를 20을 주면 20바이트 만큼 쫙 땅으로 깔아버리는것이다. 저거를 많이 사용하는거는 아까 어드레스 구조체가 길이가 뜰쭉날쭉 하다고 했잔아 항상 나머지 남는부분을 0으로 채워야 되기때문에 이 bzero를 사용을 하고 그다음에 이제 그 오리지널 하고 타겟에 있는 바이트를 갖다가 n바이트만큼 비교해가지고 이게 같은건지 다른건지 큰건지 다른건지 비교할떄는 becmp라는 펑션을 사용한다. 이게 내가 알고있기에 0이 리턴되면 똑같은거고 양수가 리턴이 되면 한쪽이 큰거고 음수가 리턴이 되면 한쪽이 작은걸로 기억

## Little Endian & Big Endian
그래서 다시 한번복습하면 
만일에 16비트 인테저가 있다고 하면 16비트 인테저,
msb라는 자릿수가 큰쪽 
어떤 기계에서는 이게 1 23 4 이렇게 들어가고 
어떤 기계에서는 
101번째 12 100번지 34 가 들어간다 바이트가 2바이트가 그래서 이것을 바꿔줘야 한다 

## Byte ordering Little endian, Big endian
아까 이런거를 할때 더블 워드라든가 이거할때는 htonl 
네트워크 to 호스트 포맷 
호스트 to 네트워크 포맷
근데 그거는 모르겠네 롱롱 하면 몇바이트에요 롱롱 64비트 8바이트 인테저죠 그거는 라이브러리 없는거같아 써본적이없어서

그다음에 플롯트 더블은 자기가 알아서 해야한다.

## select() for I/O Multiplexing
멀티플렉싱이라는게 뭡니까
멀티플렉싱, 여러분들 데이터통신
멀티플렉싱이란 피지컬 링크가 하나가 있는데 보내는놈도 여러개가 있고 받는 놈도 여러개가 있으면 결국은 그놈들이 보내는게 섞일거 아니에요 그렇죠 그 섞어가지고 보내면 받는쪽에서는 그 풀어가지고 수신자를 지정해서 따로 따로 보내줘야 하잔아요 이런거를 멀티플렉싱이라고 한다.

멀티플렉싱할떄는 어떻게합니까 타임 디비전 멀티플렉싱도 있고 뭐 프리퀀시 디비전 멀티플렉싱도 있고
프리퀀시 디비전 멀티플렉싱이 머에요 - 이게 주파수 로 하는거임
그러니까 우리가 전파가 들어오면 전파에 뭐 mbc 전파도 있고 어떻게 되요 kbs 전파 도있는데 그걸 푸는거 아니에요 
그게 프리퀀시 디비전 멀티플렉싱
타임 디비전 멀티플렉싱 이라는건 뭐에요
링크가 이렇게 가면 시간으로 쪼개는것이다 그래서 요번 0.1초에는 몇개 들어가고 그다음 0.1초에는 뭐 요게 들어가고 요런식으로 시간을 나눠서 하는것이 타임 디비전 멀티플렉싱이다

이제 네트워크 도 멀티플렉싱을 하고 싶은경우가있는데 
내가 이제 뭘 받는 입장이다. 받는 입장이라고 치는데 받아야 되는 소켓이 여러군데 있다. 클라이언트가 4개 하고 연결이 됬다고 치자 그럼 내가 클라이언트에서 데이터를 받아야 되는데 4개중에서 받을려고 그려면 리시브나 뭐 리시브프롬을 해야될거 아니에요 뭔가를 받아야 되니까 리시브를 해야되는데 문제는 리시브나 리시브 프롬이 블락되는거 아니에요 메시지가 들어올떄까지 

그런데 내가 이쪽 소스, 이쪽 에서 보내는 놈한테 먼저 리시브를 하고있으면 여기 나머지 3명이 보내는걸 받을수가 있어요 없어요? 못받죠 여기서 블락이 되있으니까 그렇죠 문제는 뭐냐면 4개의 링크가 있는데 거기서 어떤놈이 먼저 보낼지는 모른다
그래서 이게 해결할수가 없어요 여러군데 한꺼번에 들어올떄에는 그걸 어떻게 해결하느냐가 멀티플렉싱 얘기가 되겠다 
그래서 여러분 같은 경우는 어떤 방법을 쓰겠냐?
4개마다 스레드 하나씩 붙여줘서 이 스레드는 여기서 기다리고 저 스레드는 저기서 블락되고 세번쨰 스레드는 저쪽에서 블락되고 이렇게 하면되잔아요 그러면 아무문제가 없다.

나는 프로그램을 그렇게 짠다 멀티플렉싱 할떄 그렇게 프로그램짜는데 옜날에는 뭐가 업었어요? 스레드가 없었음 그래서 fork를  할려고 하면 fork는 너무 무거우니까 프로세스를 만들어야 되기 떄문에 그래서 멀티플렉싱을 할수있는 그런 소켓 시스템콜을 만들어줬는데 그게 바로 selset 이다. selset는 인풋 소스가 예를들어서 이제 받는거는 어디서 받죠 항상? 소켓에서 받잔아요 
내가 얘하고 소켓 오픈한게 소켓1이라고 하고 이친구하고 오픈한 소켓이 소켓2 소켓 3 소켓 4 4개의 소켓을 오픈했다고 가정을 해라 그런데 어떤 놈이 먼저 보낼지를 모른다 이거임 사건이 어디서 먼저 일어날 지 모른다 이거임 그럴때에는 아까도 스레드를 4개를 만들어서 각 소켓에서 기다리면 되잔아요 근데 그게 옛날에는 불가
이런 방법을 썻는데 selet라는거는 여러개의 소켓을 주고 그중에서 뭐하라? 아무거나 뭐가 들어오는 행위가 있으면 리턴해라 이런뜻임 4개중에서 아무거나 먼저 라도 먼저 도착하면 리턴해달라 이런말

자 아까도 얘끼했듯이 소켓은 소켓디스크립터는 뭐랑 똑같다고 했지 파일 디스크립터하고 똑같다고 했다 그래서 이 select을 할떄는 일단 소켓을 여러개를 줘야할거아니에요 기다려야 되는 소켓을 여러개를 주는데 여기에 maxfdp라는거는 만일에 10, 20 으로 주면 내가 기다리는 소켓들이 여러개가 있는데 그거는 20번아래다 이런뜻 이거 맥시멈 이다 이런뜻이다 그렇다고 해서 0번에서 20번까지 다 기다린다라는 뜻은 아님 일단 맥시멈이 20이다 이거다
맥시멈을 뜻하기만 한다. 
내가 찐짜로 기다리는건 뭐냐면 read이다 read 파일 디스크립터 셋이다 이게 소켓의 셋이다 우리왜 시그널 할때 집합같은거 만들었잔아 그래가지고 set이라는건 항상 뭘 뜻하는거져 
여기에 파일디스크립터나 소켓 디스크립터가 있으면 0,1,2,3 이렇게 나갈거 아니에요 	 
그렇죠 내가 오픈한 소켓이 있으면 이게 1이고 이게 1이면 이건 무슨뜻이에요? 나는 몇번 에서 기다리겠다? 5번하고 7번 소켓에서 기다리겠다 이런얘끼임 그렇게 셋을 만들어 놓은게 read_fds 이다

write할떄도 사건이 일어나면 리턴해주는데 write는 보통 쓸필요가 없다 write라는거는 write하면되는거니까 항상 기다리는건 뭐냐면 소켓 에서 들어온 놈을 기다려야 recv 할떄 기다리잔아요 그래서 항상 쓰는건 뭘씁니까 read_fds 을 씁니다.
여기서 파일 디스크립터 라고 한이유는 뭐냐면 아까 누차 얘기했지만 소켓 디스크립터하고 파일 디스크립터는 뭐다 똑같은 거다 
그래서 이거는 뭐냐면 소켓에서만 쓸수있는게 아니라 만일에 0번이 뭐죠 , 파일 디스크립터의 0번이 std_input
std_input에서는 뭐가 하는 이벤트가 일어나요 
키보드를 두들기면 이벤트가 일어나잔아요 그것도 쓸수가 있다 이런얘기다. 키보드에서 일어나던지 네트워크 소켓에서 일어나든지 뭘하든 내가 몇번을 지정했습니까? 지금 여기보면 
만일에 이게 마스크 가 1 이게 fd set이라는건 데 셋에 1 1 1 했으면 뭐에요? 0 번채널 5번채널 7번 채널에서 이벤트가 일어나면 어디서 일어났는지는 모르겠지만 리턴해달라 그게 select다.

익셉션 이건 안써도 됩니다 이건 무슨 사건이 일어난 파일 디스크립터 얘기하는거야 이거는 writing이 일어난 파일 디스크립터 이고 요런거는 쓸필요가없다 
요거는 이제 에러가 같은게생기는 소켓이 없는가 를 들여다 본다. 
보통 이거를 가지고 하겠죠 , 스레드를 여러개 만들지 않으면 

그리고 여기에  타임밸리유는 뭐냐면 이 select라는건 결국 여기서 0번 5번 7번 줬으면, 0번 5번 7번 에서 1바이트가 생길때까지 어떻게 되는거에요 블락이 되는거잔아요 그렇죠 블락이 되는데 거기에 타임아웃을 주고 싶은거에요 무슨말이냐면 5초동안만 기다리겠다. 5초동안에 아무것도 안일어나면 어떻게 하겠다? 그냥 리턴해라 이런뜻이다. 

그러니까 항상 블락 을 가져다 무한정 블락되기 싫을때에는 저렇게 타임아웃 베리어블을 주는데 이 struct timeval 라는건 나중에 나오겠지만 이게 뭐 sec 하고 밀리sec 이런거 주는거에요
단위로 

그래서 그냥 뭐 잘 이해가 안갈테니까 예제를 보면서 얘기를 한다.

그래서 

## Select Usage
fd 엔시스에 리드하는거에요 
그다음에 read, 아까 보면 리스 소켓이라는건 무슨 소켓이겠습니까? 억셉트 하는소켓이다. 그래서 억셉트가 성공하면 새로운 소켓이 항상 리턴이 된다고 그랬다 그죠 
그래서 요거는 이제 소켓을 하나 만들었는데 요거는 뭐할때 쓸꺼다
이름을 이렇게 붙인것이다 억셉트할때 쓸거다
이런말이다. 그래서 요거는 fd_zero(&read_fds) 을 0으로 깔아란 얘기는 이거를 전부다 어떻게 하란 얘기냐 일단 0으로 클리어를 해라 이런 말이다. 그리고 fd_set에 listen 소켓을 read_fds에 집어넣으란 얘기는 여기다가 해당되는 bit을 뭘로 하란얘기에요?1로 만들라 이말이다. 
그러고 나서 이게 사실은 소켓이 하나밖에 없잔아요 지금 그렇죠 하나밖에 없으니까 그냥 select나 accept나 사실 마찬가지 얘기가 됩니다 그래서 select로 들어갑니다 이렇게 기다리면 이거는 지금 set에 뭐가 set되어있냐면은 이건 리슨 소켓만 셋이되어있잔아요 리슨소켓에서 뭐가 들어오는 이벤트가 생기면 리턴을 해달라 이런얘기다.
그래서 리슨소켓에 머가 들어왔단 얘기는 무슨말이냐? 저쪽에서 커넥트되가지고 뭐가 들어온거죠 지금 전화를 건거다 
그러면 여기서 보면 select 에서 리턴이 됬단 얘기는 뭔가 사건이 일어났단 얘기임 그래서 사건이 일어나서 리턴이 됬으니까 여기서 read_fds 	에 가가지고 리슨 소켓때문에 일이 일어났느냐를 물어보는게 FD_ISSET 이라는거임
그러니까 뭐냐면 여기서 사건이 일어났냐 라고 물어보는것이다
지금
그러면 리슨 소켓에 뭐가 들어와단 얘기죠 이게 TRUE 이면 그렇죠 리슨소켓에 뭐가 들어와있으니까 이건 뭘해줘야되요? 억셉트 를 해줘야될거 아니에요 커넥트에 의해서 들어온거니까 그래서 이제 and then 억셉트를 합니다 
억셉트를 가지고 리슨소켓을 하면 뭐가 생성이 되요? 새로운 소켓이 생성이 된다. 그렇죠 새로운 소켓이 생성이 되면 새로운 소켓으로도 이제 데이터가 들어올수도 있고 또다른 클라이언트가 있으면 또 어떻게? 리슨소켓으로도 또 들어올수가 있잔아요 그래서 어떻게 하는거에요? 여기서 클라이언트 소켓 새로 생긴것을 리드 파일 디스크립터 셋 에 따라서 추가하는것이다 그래서 이제 쉽게 얘기해서 뭐냐면

이게 리슨소켓이었다. 그런데 여기에 대해서 뭐가 일어났어요 지금 억셉트가 일어나서 새로운 소켓이 생겼는데 이게 7번이다 그러면 여기에다가 또 1을 셋팅을 해서 이제 두개를 한꺼번에 보겠다 이런 말이됩니다

그래 가지고 이제 이렇게 셋을 하고 룹으로 올라간다 그리고 select를 하면 여기서 셋팅을 해놓은게 뭐에요 리슨 소켓하고 무슨소켓? 뉴소켓이 있잔아요 , 클라이언트 소켓이 있잔아요 그러면 커넥트가 또들어오면 리슨소켓으로 사건이 일어날거고 그렇지 않고 일로 내려오면 이건 뭐에요  클라이언트 소켓으로 일이 생긴것이다 그리서 이거 클라이언트 리스트가 아니라 클라이언트소켓이다

클라이언트 소켓에서 일이 일어났다 이거임 그러면 이제 뭐하면되요 리시브를 하면될거 아니에요 그렇죠 클라이언트 소켓으로 뭐가 들어왔으니까 and then receive 를 하게된다. 이런식으로 하는게 셀렉트 입니다.
기본적으로 이렇게하면 뭐를 안썻어요? 포크를 
아까 억셉트 전화접속이 일어나면 아까 차일드를 갖다가 클라이언트하고 대접하기 위해서 뭐를 했어요? 포크를 했잔아요 포크를 안하고 설렉터에 의해서 그냥 메인 서버가 혼자서 해결하고 있짠아요 
그래서 여러개의 소켓이 있을때 그것을 거기에 대해서 인풋 멀티 플렉싱을 하는데 보통 사용되는게 이 select 라는 시스템콜이다 나는 골치아파서 안쓴다. 읽기도 지저분하고

지금은 구지 할필요 없이 스레드를 만들수있다. 

그래서 설렉트는 뭐 이거 좋아하는 사람은 쓰고 나는 안좋아하기 떄문에 나는 주로 쓰레드를 쓴다. 

##### 숙제
tcp 가지고 뭐하는게 있었어요? 에코백하는 프로그램이 있었잔아 거기서 억셉트가 되면 뭘했어요 포크를 했었잔아요 그것을 스레드로 바꿔서 처리하는걸로 짜와보세요 

## Other socket APIs
그다음에 다음 소켓 api들이 여러개가 있는데 그걸 한번씩 쭉 살펴보면 가장 많이 쓰이는게 소켓의 옵션을 세팅한다라는 셋 소켓 옵션이라는게있고 겟 소켓 옵션이라는것은 현재 소켓의 옵션이 뭔지를 알려달라는 뜻이다. 겟소켓옵션은 

그래서 이제 겟소켓옵션은 잘 쓰이지가 않고 이제 소켓옵션을 특별하게 선택하고 싶을떄에 셋 소켓 옵션을 사용을 합니다.
예를들어서 소켓을 아까 tcp할때는 sock_stream으로 만들었죠 그렇죠 udp로 할떄는 여기안나와있지만 sock_datagram으로 만듭니다. 소켓을 그러니까 그게 udp소켓이고 뭐에요 tcp 소켓입니다
udp 소켓같은거는 뭘 할수가 있냐면 한군데로만 보내는게 sendto 였었다 아까 상대방 을 지정해서 그런데 방송을 할수가있어요 방송한다 얘기는 우리 방송사를 뭐라그러죠 브로드캐스팅 컴패니 라고 그러죠 브로드캐스팅 한단얘기는 내가 하나를 보내면 이게 나랑 연결 우리 로컬 네트워크에 연결이 되어있는 어디한테 간다? 모든 컴퓨터한테 다 보내달라는 신호이다. 그런거를 브로드캐스팅이라고하는데 udp소켓같은 경우에는 option을 뭘로 바꿀수가있어요? 브로드캐스팅 옵션같은 걸 바꿀수가있다. 그래서 무지하게 많다 그런거를 할떄 사용하는게 셋 소켓 옵션이다.

이거는 너무나 종류가 많아기지고 이거 외워지지가 않는다 항상 여러분 프로그램을 짜면 구글 찾아가지고 거기서 코드 따와가지고 하는게좋다 여러가지 가 있기떄문에

왜 여러가지가 있냐면 소켓을 옵션을 셋할떄 이건 오픈한 소켓이 되겟고요 요기 레벨 이라는게 있는데 레벨 이라는건 프로토콜 레벨을 얘기하는데 우리가 알고있는 프로토콜 레벨이 뭐가있어요 지금? 트랜스포트 레이어 뭐가있어요? tcp 하고 udp가 있잔아요
그밑에 네트워크 레이어에는 뭐가있어요? 아이피가 있다 그러니까 소켓의 옵션을 아이피를 내보내서 뭐를 하기
라우팅 하는 레벨에서 뭐를 옵션을 건드릴꺼냐 아니면 tcp나 무슨 레벨에서? udp 레벨에서 건드릴꺼냐 하는 그 레벨을 갖다가 주는것이다. 나중에 나올것이다 뭐가있는지

그러면 거기에 대해서 옵션을 주는데 이게 옵션의 벨리유가 되고요 옵션의 벨리유 라는거 가 있고 또 이 옵션이 굉장히 복잡할경우에는 이 옵션에 따라붙는 옵션이 있는데 그 옵션은 캐릭터 포인터 를 주게 됩니다 주로 이제 스트링이 들어가고 이 스트링 일 떄문에 여기 기계가? 따라붙는다 이런얘기다.  이런것이다 예를들어서 여기서 여기서 뭐 여기서 인테저 옵션이라는것은 만일에 브로드 캐스팅을할꺼냐? 그러면 여기에 솔브로드캐스트 란 옵션이 들어갑니다 근데 브로드캐스팅을 끄고 싶을떄가 있고 키고 싶을때가 있잔아요 그러면은 여기에 뭐가 들어가요? 키고싶을떄는 1이 들어간다 브로드 캐스팅을 끄고싶을때는 뭐가들어가요 여기에? 0이 들어간다 이런말이다 그리고 이거를 캐릭터로 넣어야 하기때문에 그 길이를 가져다 주게되는 그런식으로 사용을 합니다 이거는 예제를 봐야되요 외울수가 없고

## setsockopt()
그래서 여기보면 셋소켓 옵션을 보면 레벨이 3가지가 있다.
레벨이 3가지가 있다. 레벨이라는 프로토콜 레벨이라고 그랬죠 그래서 솔소켓하면 이건 이 아이피가 있고 tcp나 udp 가 있고 그위에 소켓을 쓰고 있는거잔아요 그래서 맨위에 소켓 레이어를 얘기를 합니다 요거를 요거로 주면 요거는 아이피 레이어를 얘기하고 요거는 tcp 레이어를 얘기합니다
여기에서 비우저(리유즈) 어드레스 라는건 이미 다른 놈이 사용하는 포트가 있으면 그게 바인딩이 됬을거 아니에요 포트가 
나는 그포트를 또 쓰고싶은거다 또 쓰고 싶을떄는 이 옵션을 사용한다 바인딩을 해서

일반적으로 저건 안해요
그다음에 두번쨰 
솤 브로드 캐스트라는건 소켓레벨에서 내가 메시지를 udp 에만 가능합니다 udp에만 가능한데 아까도 얘기했듯이 한놈한테만 보내는게아니라 누구한테 보내요 몽땅 다보낸다.
몽땅 다보낸다 하더라도 받는놈은 받는놈에 대해서 뭐를 지정해야되요? 여러 컴퓨터한테 보내니까 아이피 주소가 있어요 없어요? 아이피 주소 없죠 그대신에 뭐는 지정해 둬야 되겠습니까?
포트는 지정을 해서 보내야죠 받는놈은 너는 뭐 100번째 , 저 10000번 포트에서 기다려라 그러면 내가 전부다 브로드 캐스팅 해줄게
그 무슨얘기에요 mbc 를 할라고 11번 틀어야되고 kbs 볼려면 9번 틀어야 되는거랑 똑같죠 그게 포트넘버의 역할을 하는거에요 이게 브로드캐스팅

브로드캐스트 옵션이 없으면 어떻게 해야되요? udp로 보내건 tcp로 보내건 만일에 여러 사람한테 메시지를 보낼려고 하면 어떻게 해야되요? 여러번 반복해서 보내야 되잔아요 그게 귀찬은것이다.

물론 나중에 나오겠지만 여기에는 슬라이드에 안집어넣었는데 어려워서 브로드 캐스트 말고 멀티 캐스트도 있다. 멀티 캐스트는 뭐야? 브로드 캐스트는 전체다 보내는거고 멀티캐스트는 똑같은것을 얘얘얘3명만 골라서 보내는것이다 이런것을 멀티캐스팅이라고 합니다 여러분들이 뭐 멀티캐스팅을 당하는것은 iptv 같은데서 가입한 사람한테만 보내잔아요 방송을 할떄 그러나 vod를 볼때는 어떻게해야되요 사람마다 다 따로 보잔아요 그거는 포인트 투 포인트로 해야된다

그런 용도에 따라 다르다.
그래서 사실은 이거는 네트워크 시간에 많이 배울것이기 떄문에 2~3주 커버불가. 
대충 기본컨셉만 한다 
(rcv | send buf)리시브 오거나 센더 버퍼라는건 소켓 레이어 에 주고받을때 아까 자기프로토콜의 버퍼가 있잔아요 그렇죠 프로토콜의 버퍼가 보통 내기억에는 1k인가 2k인가 그래요
1k인가 2k인가 그런데 이거를 가져다 더 스피드업하기 버퍼의 크기를 키울수도 있다 이런얘기다
일반적으로 이거는 건드릴 필요가 없다.
여기서 여러분들이 항상 저 뭐지 항상 기억해 둬야 하는건 브로드 캐스트 옵션이 되겠습니다(시험문제다)

q. 

요거는 아이피 레이어에 해당이 되는데 TTL value 라는건 타임투 리브라는건 뭐냐면 네트워크에서 홈이라고 부르는 홈이  무슨뜻이에요 영어 홉이
펄떡펄떡 뛴다 이런뜻이다 그래서 무슨얘기냐면 ttl 이 3번이면 내가 네트워크로 무슨 패킷을 보낼때 한다리 두다리 세다리 까지 갈수있다 근데 미국까지 갈려고 하면 어떻게 해야되요 굉장히 많아야 겟죠 이게

근데 일반적으로 제한이 없는데 그거를 제한을 해서 내가 예를들어서 브로드캐스팅이나 멀티캐스팅 같은것을 하는데 내가 보낸 메시지가 전세계로 브로드캐스팅이 되면 되겠습니까 안되겠죠 그래서 요 ttl을 가지고 뭐 64로 제한을 한다던가 3으로 제한 한다던가 저걸 ttl을 0으로 하면 무슨뜻이냐면 요 같은 방에 있는 로컬네트워크에만 적용이 된다 이런뜻이다 number of hops 중개소를 몇번 거칠수있느냐를 결정하는거를 ttl이라고 합니다

네트워크 프로그램은 여기서 보는것처럼 워낙 여러가지 경우 옵션과 통신방식 여러가지 주고받는 기계 cpu도 다르고 이렇기 떄문에 굉장히 복잡해서 이런 스탠다드 만 여러분이 배워가지고 프로그램을 짤수가 없고 아까 얘기했듯이 구글에 다 쳐보면 이 예들이 다 나온다

## Other socket APIs
자 전세계의 컴퓨터들이 뭘로 연결이 되어있습니까 인터네으로 연결이되어있다 그래서 내가 미국에 있는 컴퓨터 한테 보낼때는 3000 바이트 짜리 메시지를 보내면 그게 뭘로 쪼개져서? 패킷을 쪼개져서 중계하는 컴퓨터 나 라우터를 쫓아가면서 몇백번을 거쳐가지고 어떻게 미국까지 간다 그렇죠 
그러면 이 사람이 중간에 중국에 있는 라우터라고 가정을합시다 만약에 중국을 가야된다고 그러면 이라우터에 들어오는 거는 한국에서 미국으로 가는 뭐 저기 누구 케임킴 박사가 홍길동이 케이킴한데 보내는 패킷만 가는건 아니잔아요 그렇죠 일본에서 미국가는거 뭐 중국에 누가 미국에 누구한테 가는거 
미국에 누가 한국에 누구한테 보내는거 가 다 거쳐가는거 아니에요 그러니까 패킷의 입장으로 보면 패킷이 막 여기 
수신지하고 목적지가 다른 패킷이 마구 들어오겠죠 이 라우터로 그럴꺼아니에요 그거 하나하나를 받아가지고 얘는 어디서 얼로 가는거니까 어느쪽으로 보내야지 결정하는것을 모라고 했어요 그거를 라우팅이라고 한다 했다 경로배정이라고 했다.

그런데 중간에 라우터 입장에서는 내가 패킷을 하나받았다고 칩시다 이패킷을 라우팅을 해가지고 자기랑 붙어있는 놈한테 보내겠죠 그런데 문제는 뭐냐면 붙어있는 놈한테 보내는데 붙어있는 놈이 잘받았다 라는 ack 를 보낼때 까지 이패킷을 지우면되요 안되요 안된단 말이에요 왜냐하면 다시 보내야 되기떄문에 잘못받았다라고 하면 그러니까 얘는 굉장히 버퍼가 커지겠죠 라우터라는거는 왜냐하면 전세계에여기서 저기로 가는 패킷들이 모이고 있으니까 잘받았다라는 메시지를 받아야지 그걸 지울수가있다. 그러니까 라우터에 메모리들이 다 있어야될거아니야 버퍼링 을 해, 그걸 디스크에 저장하면 너무 느리고 메모리가 있어야 되는데 
그거를 이렇게 생각해봅시다 그 패킷 하나하나, 전세계에 돌아다니는 패킷 하나하나는 서울시에 돌아다니는 자동차라고 생각을 하고 그렇죠 그다음에 라우터가 가지는 메모리들은 전부다 도로 라고 생각을 해보세요 똑같은것이다 자동차는 자동차마다 출발지하고 뭐가 달라요 목적지가 다르잔아요 그걸 수용하는게 뭐에요 도로잔아요 근데 그 자동차 도로망 네트워크에서는 그 중간에 연결되어있는거 맨마지막 단자를 뺴고 내가 네트워크에 집어넣잔아요 그거를 서브넷이라고 합니다 중개기 이런거에 다 들어가있는거
거기에 라우터 도 있고 컴퓨터도 있겠죠
그런 서브넷 자동차 도로에 자동차가 너무 많이 들어오면 어떻게되요? 길이 막히잔아요 뚫리지를 않잔아요
완전히 정체가 일어나버리잔아요 
똑같이 네트워크에서도 내가 메모리에 버퍼링을 해야되기 떄문에 패킷이 너무나 많이 들어오면 네트워크가 다운이 되버린다. 그거 왜 무슨 어디에 접속이 폭주해서 뭐가 불통됬다라는거 서버가 감당을 못해서 그런거지만 전체에 네트워크망에 n to n 으로 가는 그런 패킷들이 많이 들어오게 되면 메모리 버퍼에 감당을 못해요 그러니까 만일에 이쪽이 라우터인데 지금 패킷이 메모리에 꽉차있어요 꽉차있어서 처리하고있는데 또 다른놈이 패킷을 보내면 이걸 받을수가있어요 없어요? 버퍼가 없기때문에 못받는단 말이에요 그러면 당연히 이게 이쪽에서 또 보내겠죠 그러니까 진행이 안되는것이다.
그러니까 꼭 도로망이 막히는것처럼 네트워크에 서브넷 망 도 패킷이 너무 많이 들어가면 다운이 되버린다. 그거를 뭐라고 그런다구요? Network congestion 이라고 한다
뭐 심플한 말이다 
그래서 네트워크 혼잡상태에들어가게 되면 여러분들이 주로 많이쓰는게 tcp잔아 tcp 
udp는 뭐 수신지가 뭔지 모르고 중간에 이 플로우 컨트롤이 없으니까 마구 보내는데 tcp는 굉장히 똑똑하다 왜냐하면 end to end 프로토콜이기 떄문에
똑똑해서 뭐냐면 네트워크 너무 붐비면 내가 아무리 티비씨피?를 센드를 해도 자기가 버퍼에는 저장을 하지만 그거를 어디 에다 집어넣지는 않습니까? 네트워크 집어넣지 않습니다패킷을 그거를 tcp에 뭐라그래요? 네그 알고리즘이라고한다 메이그? 알고리즘?
집어넣지 않는다 tcp가 똑똑해서
집어넣지 않는게아니라 이런식으로한다 옛날에는 1초에 한번씩 패킷을 보냈는데 네트워크가 바빠지는거 같으면 어떻게 합니까? 2초에 한번씩 보내고 그것도 잘안되면 어떻게 합니까 4초에 한번씩 보내는 이런 알고리즘을 쓴다. tcp가 
근데 나는 그게 싫다 그럴떄는 노딜레이?? 하고 그냥보내라 그런짓하지말고 
//네그알고리즘, 노딜레이 이게먼말이지 

그래서 요 슬라이드 없는데 셋소켓 옵션을 갖다가 쓰는 예를 아까 udp 같은거를 설명하면서 슬라이드 만들어서 다시 말하겠다.