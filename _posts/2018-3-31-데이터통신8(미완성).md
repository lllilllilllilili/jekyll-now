
## 이전 내용 복습
데이터를 다 저장 할 수 없다. 근사치를 요구한다.
Sampling 2가지가 있다. 
(1) a fixed - size Sample
N 개중 하나, 데이터가 쌓이면 처리하기가 힘듬
(2) Fixed Size Sample
Size를 Fix 시킨다. Reservoir Sampling 알고리즘이 이 형식에 맞는다.(하나 들어오면, 하나 빠져나간다.)

Sliding window
Data stream 처리위한 형태, 시간자체가 중요, window time(현재~한달 이 기간만 처리 혹은 트랜잭션 1000번까지 오면 1000번까지만 처리) 이것은 Timeliness matters 문제를해결(가장 오래된 데이터를 죽임으로써) 그리고 Scalability matters 문제를 해결(전체 데이터를 다보지 않고 window 영역에서 볼 만큼만 제한시켜 저장한다.) 이 두문제를 해결한다.
벗어나는 데이터는 버린다.

## Sliding Window : 1 Stream
들어오는 데이터에 대해서 오른쪽으로 한칸씩 이동하면서 Sliding 형태로 보여진다.
(가장 왼쪽 : 가장 오래된 데이터, 가장 오른쪽 : 현재부분, 그 앞의 데이터는 우리가 정확히 알수는 없다.) 윈도우가 슬라이드처럼 움직인다고 해서 붙여진 이름.

## Counting Bits(1)
Sliding Window는 
주어진 문제는 0과 1이 들어오는 stream에서 k bit 위치에 얼마나 많은 1을 확인할 수 있을까?
(단, k는 메모리에 저장할수 있을만큼의 크기이고 N은 굉장히 크다. 또한 새로운 비트가 들어오면 N+1 번째 bit는 가장 오래된 것이므로 버린다.)

(1) solution(1)
k개 속에 1이 있는 비율 (k 속에 있을 1의 개수가 a라 하면) 0이 있을 개수는 (k-a개) 비율을 확인해서 N으로 확장해서 같이 적용해도 문제가 되지 않을것이다.(정확한값을 찾는것은 불가하다, Stream data에서) 
But, 답이 될수도 있고 답이 되지 않을 수도 있다.
(Uniform) 01010101010101010 로 들어오면 문제가 안된다.
(Not uniform) 000011110000111 로 들어오면 비율이 의미가 없어진다.(대부분이 이러한 형태로 인터넷에서 들어온다.)

(2) solution(2)
Not uniform 경우에 해결하기 위한 알고리즘으로 DGIM Method를 고안했다.(Sliding method 극복)
모든 데이터를 저장하지 않고, O(log^2N)의 훨씬 더 적은 Stream Data 양만으로 값을 찾아낼 수가 있다.
에러율 50%, 실질적으로 Worst Case 부분이다.
기존의 방식에서는 빅-오 로 계산할 수 없다, 재수없을시 에러율 100% 될 수도 있기 때문이다.

## Exponential Windows
DGIM Method는 아니다.
Exponential Windows 를 key - value를 가지고 고안해낸 방법이 DGIM Method 이다.
이 알고리즘은 Window를 Exponential(2,4,8...) 로 증가시킨다.
Window의 Header 부분이 현재이고, 현재는 0을 가리키고 있다.
새로운 bit stream 들어올것이고, 하나의 bit stream이 들어오면 window size를 1로 잡는다.
그다음도 마찬가지, but 하나가 더 들어올시 ++같은 size의 window가 3개를 넘을 수 없다.++
1, 1, 1 세개 째에 ++가장 오래된 두개의 사이즈를 합친다.++ 합쳐서 Double Size로 만든다.
숫자는 1의 개수이다.
++가장 최신의 있는거 하나만 남기고 합쳐진 두개는 날려버린다.++
같은 레벨에서 같은 윈도우 사이즈는 절대 허용될 수 없다.
계층구조 처럼 보이지만 아래 열거되어 있는 bit stream을 쪼개 놓은것에 불과하다.

## Idea: Exponential Windows
N속에 1이 몇개 있는지를 파악하고 싶다.
n이 이 윈도우 중간에 어설프게 걸쳐지면 0+1+2+10+ 6?? 믿을수없어 애매한값이 발생한다.
분기점을 기준으로 1이 내부에 있으면 다행이지만, 밖에 있으면 전혀 쓸모 없는 값이 되버린다.

## What's Good?
window 각각에 대해서 logN, exponential하게 증가하므로 logN 횟수
따라서, 전체 Window N개를 볼 필요없이 각각의 window에 대해서는 logN 데이터를 보고 전체 저장은 Worst Case 빅-오(logN^2) 정도만 있으면 count정보를 다 저장할 수 있다.(count 정보는 1을 세는거겠지)
간단하다.

그림에서 보다싶이 경계에 걸리는 값이 불명확하더라도 이전의 window 값들은 확실히 보장할 수 있다.
적은 bit를 가지고 정확한 결과 가치를 준다.

## What's Not So Good?
경계에 걸려서 값을 계산하는게 불명확하다.
경계이전의 바이너리 값이 모두 0이고 경계선으로부터 값이 불명확하면 에러율 100%가 나올 수 도 있다.
이러한 경계에 걸쳐지는 문제를 해결하기 위해 고안된 방법이 DGIM method 이다.

## Fixup: DGIM method
storage window에서 자를때는 0,1 로 들어오는 데이터들을 가리지 않고 2, 4, 8, 16 로 정확하게 잘랐다고 하면 DGIM은 다르다.
차이는,
Exponential window size에서 window size는 bit의 개수다.
window size는 1의 개수가 window size다.(0 무시)
그래서 bit가 1,2,4,8,16 정확히 증가하는게 아니기 때문에 window size는 뭐가 될지 정확히 알 수 없다.(1의 count가 window size이기 때문이다.)

window size가 16이면, 기존의 exponential window는 0과 1이 섞여있고 정확하게 비트자체로 16bit로 fix되지만 
DGIM 에서 window size를 16이라 알려줘도 size를 알 수 없음. 왜냐하면 0이 천개, 만개가 들어와도 window size는 0이다.

block size를 1의 숫자로 표현을 하고 exponential 하게 증가한다.
1만 count한다.
window size도 1의 개수로 측정해서 101이 window size는 2가 된다.
exponential Algorithm을 거의 그대로 따라갔다.

## Timestamps
Timestamps를 유지한다.
각 비트가 들어올때마다 자기 자신의 Timestamps를 가지고 있다고 가정한다.
항상 증가해야 한다. 변경사항이 없다. 현재의 시간값을 항상 증가하는 값으로 정한다.(시간 대신 클락.. 여러 류가 올수있다)
각각 타임스탬프로 받아들이고, 타임스탬프 모듈로 N을 한 값을 timeestamps라고 한다. 일정한 길이로 변하고 증가하는 값임.(무지무지하게 크게 변할수도있음)

알고싶은건 window 속에 있는 데이터 N만큼의 데이터의 상대적인 시간의 순서만 파악하고 싶다.
모듈로 N을 해주면, 타임스탬프 값이 업-투(N) 이다.
타임스탬프 값을 N으로 줄일 수 있다. 정보를 저장해야하는데 저장해야 하는 정보값을 확 줄일 수 있다. (모듈러하는이유, 타임스탬프가 크게 증가할수도 있으니까..?)
타임스탬프를 위해 저장해야 하는 비트는 많아봐야 logN이다. (타임스탬프 값 Max N)
Max N을 표현하기 위해서 필요한 bit는 많아봐야 logN이다.
타임스탬프가 많이 잡아먹지않는다.

## DGIM:Buckets
exponential 에서는 각각 window다. 표현
여기서는 buckets 이라고 표현
bucket size = window size 다.
각 버킷에 대해서 타임스탬프 저장. 많아봐야 로그 앤!
1의 개수가 윈도웅 속에 들어있는 카운팅 할때 필요한 1의 개수, 필요한 비트가 loglogN이다. 비트 숫자를 줄이기 위함, 버킷 사이즈 자체가 2의 POWER 승이다. 로그 버킷 사이즈를 이렇게 만든다.(무조건) 어느 한순간 하나의 버킷에 들어있는 N의 개수, 카운트 값은 2^N 인데 
2^N을 표현하기 위해서는 2^N 전체를 표현할 필요없이 카운트 값이 2의 N승으로 표현되니까 비트를 더 줄일 수 있다. 전에는 자연수니까 logN 이었지만, 카운트가 2의 N승의 형태로 표시되니까 저장할 비트를 더 줄인다. loglogN으로 표현한다.

++어느 한 버킷안에 카운트를 표현할때 2의 k승으로 표현할 필요가 없다.++
k만 저장하면 2의 k승 해버리면 된다. 따라서, 지수승만 저장해버린다.
(제약조건을 비트를 더 줄이기 위해서 2의n승개의 1이 들어가는데 제약조건에 따라 2의 n승, 2의 k으로 카운트를 표시하는게 아니라 지수승만 저장하겠다.) 메모리양이 줄어든다.

## Representing a Stream by Buckets
stream을 버킷으로 표현한다.
1. 같은 사이즈의 버킷은 두개를 넘지 못한다.
2. 버킷은 타임스탬프가 overlap 되면 안된다.
3. 버킷은 사이즈가 솔팅되어야 한다. 그렇지않으면 익스포넨셜하지 않다.
4. 버킷의 각각 아이템별로 타임스탬프 갖고 있고 n 윈도우에 있는 아이템만 보고 싶을뿐, 첫번째 타임스탬프 마지막 타임스탬프 비교 n을 넘으면 마지막에 있는 타임스탬프를 버린다.

## Example:Bucketized Stream
1을 체크해서 1만큼 exponential 하게 증가한다.
같은 사이즈 3개는 안된다.
window size별로 소팅이 된다.

## Updating Buckets(1)
데이터는 계속 들어오는데, n속에 버킷을 나눠놨는데 새로운값이 들어오면 버킷이 다 다르다.
새로운것이 들어오면 n속에 들어오는 버킷을 가져다 업데이트해야됨.

새로운 비트가 들어왔을 때 0아니면 1, 0이 들어오면 깔끔하게 무시하게 된다. (노 카운트)
1이 들어오면 다른 버킷에 연쇄적으로 영향을 줄 가능성이 크다.

1이 들어오면 하나의 자기자신의 window size 1 만큼의 버킷을 만든다.
타임스탬프를 세팅한다. (자기자신의 타임스탬프 세팅)
1인 버킷 사이즈가 3개면 가장 오래된것 2개 합쳐서 합치고 날린다. 반복

## How to Query
모든 버킷을 다 더한다. n에 걸리는 버킷 제외하고, 속에 모든것을 더하면 똑같음
맨 마지막에 있는 버킷에 값은 퉁쳐서 절반만 넣는다.
전에는 바운드가 안됬는데, 이친구는 바운드가 된다. 절반값만 더해줘도 50% 넘지 않는다.
그래도 마지막 윈도우는 정확하지 않다.
