---
post : layout
title : Computer Arch(3)
---
## Computer System Inside
ISA(Instruction Set Architecture) : 개발자 입장에서 보는 컴퓨터의 모습이다.
프로세스가 제공하는 명령어, 프로세스 내부에서 제공되는 레지스터의 구조, 프로세스 내부에서 제공되는 메모리 구조
### Data path
데이터들이 이동하는 설비, 건물에 도로망, 빌딩 설비들이 Data path고 차량 이동 교통 신호를 보내는 신호제어센터 Control 이라고 한다.
Data path는 Cpu에 구성된 설비로 이루어져 있으며, ALU, 가산기, 감산기 등이 있다. 이것을 Control하는것이 Controller다.
Cpu는 산술(+,-, 등), 논술(boolean) 연산을 수행하는데 모든 연산에서 이 기능을 제공하는 유닛이 ALU이다. 그리고 Cpu 내부에서 가장 빠른 메모리로 registers, 내부 버스들이 모두다 Data path에 속한다.
### Control
brain 역할을 하고(어디로 보낼건지 결정한다.) Control과 Datapath 합쳐서 Process라고 부른다.
Data 처리하는를 순차적으로 실행시키는데 Conttrol이 실행한다. 메모리와 버스 장치들을
### Cache memory
Cpu의 속도에 비해 Memory의 속도가 너무 느리기 때문에 Cpu의 가까운 위치에 캐시 메모리를 만들어서 메모리에 있는 정보를 복사한다. 하지만, SRAM이 DRAM보다 acess time 성능이 빨라졌으나 집적도는 떨어지는(사용할수 있는 칩의 면적이 부족함) 
그래서 DRAM을 사용하여 집적도를 높이는 반면 Cache가 cpu 내부에 설치되고 있다. 이러한 다단계 계층 구조가 cpu 내부에서 캐시가 있는것을 on chip이라고 하고 cput 밖에 있는것을 off chip이라고 한다. 추가적으로 cpu가 가까운쪽이 level이 높다. on-chip은 level1, off-chip은 level2. 캐시가 여러단계로 구성할수 있도록 지원해준다.
* 집적도 관련 : 단위 면적당 많은 양의 디털회로 설계할 수 있다면 집적도가 높고, 설계할 게 없으면 집적도가 낮다. 반도체 기술의 핵심인 "선폭과 관련있다"
## Close-up of PC Motherboard
Memory, CPU, Graphic Adapter(Video)는 고속장치라고 한다. 반면, HDD, Network는 저속장치로 이 둘 사이를 중개해주는 장치가 있는 Bus Arbiter이다.
North Bridge와 South Bridge는 일정한 약속하에 데이터를 올려주고 내려준다.
PCI Bus에 Graphic card를 붙여서 속도개선을 하기도 한다.


## Classes of Computers
### Personal computers
우리가 흔히 가지고 다니는 여러 장치들
### Server computers
여러 클라이언트에 서비스를 제공하고 네트워크 기반이다.

### Supercomputers
고해상도와 시뮬레이션을 지원한다. 
최고의 기능이지만, 전체 컴퓨터 시장의 작은 부분을 나타낸다.
기상청, 자돛아 설비를 고해상도 시뮬레이션을 지원한다.

### Embedded computers
장치안에 들어가는 장치로서, 작고, 숨어있다. power 관리를 효율적으로 해야하고, 성능 유지, 대규모생산이기에 cost를 잘 판단해서 결정해야한다.

##The PostPC Era(1)
Tablet과 Smart phone sale는 cpu가 많이 판매되고 있다.
과거에는 개인당 1대의 컴퓨터를 사용했지만, 현대에 들어와서는 개인당 3~4대의 컴퓨터가 쓰이고 있기 때문에 과거의 IP32비트에서 64비트로 확장되서 쓰고있다.(Ipv6)

##The PostPc Era(2)
### Personal Mobile Device(PMD) 
PMD 중심으로 발전되고 있다. ex)Smart phones, tablets, electronic glasses.
### Cloud computing.
#### Warehouse Scale Computers(WSC)
인터넷 데이터 센터가 단일 서비스를 위해 서버가 작용하는데 예를 들면 카카오톡이 있다.
#### Software as a Service(SaaS) 
마이크로 오피스처럼 노트북에 설치하는게 아니라 서비스를 제공한다.
인터넷 접속으로 서비스를 제공받을 수 있다.
### 기본적인 문서작업은 PMD에서 하고 원격으로 클라우드에 보낸다. 저장소만 클라우드에서 이용함
### 아마존이나 구글에서 이미 만들어진 API를 이용해서 우리가 구체적인 무언가를 짜는게 아니라 Rest Api를 이용애서 서비스를 제공 받을 수 있다.

## Embedded Processing Example
자율 주행 차 정도 있겠다.

## Technology Trends(1)
1965~2005 까지 여러 컴퓨터 모델이 발달해 왔다. 특히 주목해야 할것은 MIPS에 관한 내용인데
MIPS는 (Million Instruction Per Second)로 단위시간당 처리되는 명령어의 개수를 의마한다.
MIPS = Millones Instructions Per Second
예를 들어, 0.15MIPS라면 1초에 15만개를 처리한다는것을 나타낸다.

## Technology Tredns(2)
Dram이 성능이 용량이 발달되었다.
무어의 법칙에 따라 용량은 2배씩 증가한다고 했으나 1992년을 기점으로 둔화되었고 4년의 4배로 바뀌기 시작했다.
Cycle time은 access time(cpu가 memory 값을 Read시 걸리는시간)이라고 하며 크게 증가하지 않았다. 용량의 발달에 비해 CPU 속도 개선이 크지 않다.
단위면적당 할 수 있는 일의양/비용은 크게 증가했다. 메모리는 용량을 개선하는데 발전되었지만 CPU는 속도를 개선하는데 주로 발전하였다.(프로세스는 클락속도를 높이는데 경쟁을 두었다.)

## Transistors Per Die Trends
DRAM의 용량 개선했고 CPU는 단위면적당 할 수 있는 일의양/비용에 따라 증가한만큼 그대로 적용되어있음을 확인할 수 있다.

## Processor Performance Trends
CPU는 속도면에서 매년 25% 4년에 100% CPU성능을 지닌다. 
컴퓨터 시스템은 클락 기반 시스템이다.
순차회로는 클락을 요구하고, 클락엣지를 기반으로 값이 변화가 된다. 클락을 빨리 동작시켜야 빨라진다. 
Computer Architecture를 보면 CPU를 계속 발전시키다 보면 클락이 계속 증가해서 전력소모가 증가하게 된다. 그리고 비례해서 열도 발생한다.
냉각제를 사용하는 방법도 사용됬지만 값이 부담이 크기 때문에 이이상의 발전은 무리였고, 칩 내부를 더 소형화 해서 코어를 많이 넣어 효율을 증가시키는 방법을 검토하였다.

## Hard Disk Drive(HDD) Technology Trends
하드디스크도 CPU에서와 마찬가지로 비슷한 문제를 안고있으며, 같은 방향으로 발전하게 되었다.

## CPU Clocking
일정한 속도의 클럭에 의해 통제되는 디지털 하드웨어 작동.
Clock period(=클락 주기 타임, 클락 싸이클) : 상승 엣지 이후부터 이후 상승 엣지 까지 한 주기(싸이클)라고 말한다.
값이 edge에서 바뀌도록 설계 이런 순차회로를 엣지트리거드 시스템 이라고 한다. 명령어마다 클락 개수가 다르다.
ex) 250ps = 0.25 * 10의 -9승(ns) = 250 * 10의 -12승(ps)s (주로 시간에 대해 쓴다.)
Clock frequency(rate) : 초당 주기(싸이클), 싸이클 수가 짧으면 짧을수록 clock frequency가 자주 나타난다. Clock period와 역수관계다. 
ex) 4.0GHz=4000MHz=4.0*10의 9승 Hz (용량에 쓰인다.)
 
10의 -6승 : 마이크로 세크
10의 -9승 : 나노 세크
10의 -12승 : 피코 세크

10의 3승 : 킬로바이트
10의 6승 : 메가바이트
10의 9승 : 기가바이트
10의 12승 : 테라 바이트

## CPU Performance and Its Factors
CPU execution time 은 클락을 세고 그리고 클럭사이클 타임 피어리드알면 컴퓨터가 부팅하고 몇시간 걸렸는지 확인할 수 있다.
CPU 실행 시간 = CPU clock cycles * clock cycle time
			= CPU clock cycles/clock rate
CPU clock cycles : clock의 개수
clock cycle time : 주기
clock rate : clock frequency
### example
Computer A : 10 GHz, 10 seconde
Computer B :  ? GHz, 6 second 라고 할때 Computer B의 frequency는 몇인가?(단, B컴퓨터는 A컴퓨터에 비해 1.5배 더 많은 클럭 개수를 가지고 있다.)
### solution
CPU 실행 시간은 클럭개수/Frequency 이므로 A컴퓨터의 클럭개수는 10 * 10의 9승 Hz 일것이다. 이때 B컴퓨터의 클럭개수는 A컴퓨터에 1.5배 많으므로
B 컴퓨터의 CPU 실행시간 6 = 1.5 * 10의 9승 Hz * 10 / Frequency
25 GHz 이다. (1초에 클락이 25*10의 9승만큼 발생한다. 1Hz= 1초에 클럭이 한개 발생한다.)
클락의 개수는 더 많아 질 수 있다. 절대적인 시간을 나타내는것이 아니다.
컴퓨터 A가 컴퓨터 B에 비해 클락이 더블업 되면서 시간이 40%정도 단축되었다. 

클럭개수가 증가하고 클락 사이클 타임이 짧아지면 클락 개수의 증가는 문제가 되지 않는다.
나중에 나온 프로세스가 클럭 개수가 더 많을 수 있다. 그러나 클럭 사이클 타임이 짧아 질 수 있기 때문에.

backward compatibility : 나중에 나온 프로세서가 이전에 나온 컴퓨터 명령어를 지원한다.

## Power Trends
cpu의 성능이 증가하면 열도 함께 증가함을 보여주는 식을 보여준다.

## Multiprocessors 
### Multicore microprocessors.
칩 당 둘 이상의 프로세서 발생한다.
### 명시 적으로 병렬 프로그래밍 필요
#### 명령어 병렬 프로그래밍과 비교
하드웨어는 한 번에 여러 명령어를 실행합니다.
프로그래머에게 숨겨져있다.
#### 하기가 어렵다.
성능을위한 프로그래밍
Load 균형 조정
통신 및 동기화 최적화.

## For Good Performance
##### 알고리즘
실행 된 작업 수를 결정합니다.
##### 프로그래밍 언어, 컴파일러, 아키텍처
작업 당 실행되는 기계 명령어의 수를 결정합니다.
##### 프로세서 및 메모리 시스템
얼마나 빠른 명령어가 실행되는지 결정
##### I / O 시스템 (OS 포함)
I / O 작업이 실행되는 속도를 결정합니다.
	
## Eight Great Ideas for Performance
##### 무어의 법칙
디자인을 단순화 하게 위한 abstraction을 사용(개체에 핵심적인 요소를 찾아내는것이다.)

##### 가장 빈번하게 쓰는곳을 개선해야 한다.(Amdahl's Law) 
*Amdahl's Law : 컴퓨터 시스템의 일부를 계산할때 전체적으로 얼마만큼의 최대 성능 향상이 있는지 계산 하는데 사용한다.[1], 제원이 한정되어 있기 때문이다.
##### 여러개의 명령어를 병렬적으로 처리한다.
##### pipelining
자동차 생산라인처럼 단계적으로 가공하는 방법처럼 명령어도 단계적으로 처리함으로써 빠르게 처리할 수 있다.(Pipelining), 시간을 같이 쓰면서 동시에 만들어진다.

##### 성능 개선의 걸림돌을 예측할 수있다. 
예를들어, 조건문은 실행되기전까지 아무것도 결정지을 수 없다. 조건을 결정시 이 부분에 성능 결점이 생기는데 이러한 부분을 예측할 수 있다. 미리 일을 하면 좋은데 그럴수 없기 때문에 성능개선을 목적으로 미리 예측한다.

##### 메모리 계층 구조, 캐시 같은것이 있다.
캐시 정점 레벨1,2,3 캐시 그리고 밑에 메인 메모리가 있다.

### raid(redundent array inexpensive disk)
복수배열독립리스크 는 여러 개의 하드 디스크에 일부 중복된 데이터를 나눠서 저장하는 기술이다.[2]
이 방법을 쓰면 하나가 망가져도 나머지 데이터를 가지고 복구할수 있는데 이러한 부분에서 신뢰성을 확인 할 수 있다.
* 고용량 하드디스크(몇년씩의 데이터를 넣으면, 고장나면 손실이 크기 때문에)
* 
## 메모리에서 명령어
Instruction set Arichtecture, 명령어 주로 MIPS의 명령어를 살펴본다.(다양한 기계어가 존재하지만 MIPS 하나를 배우면 다른 명령어 체계를 배울때 적응하기 쉽다.)
### 명령어(Instruction)는 컴퓨터의 언어다.
단어.
형식적인 문법을 가지고 있는 문장이다.
### 동일한 ISA 제품군이 동일한 명령어를 지원합니다. (ISA-family)
backward compatibility(하위 호환성) = 나중에 나온 프로세스가 먼저 나온 프로세스 명령어 체계를 지원하는것이다. 
나중에 나온 프로세서는 먼저나온 프로세서와 내부구조가 다르고, 실제회로 구성도 다르고, 설계공정도 다르고 내부설정도 다르고, 동작 클럭도 다르고, 나중에 나온 프로세서가 클락의 개수가 작을수도 있고 클수도 있고 하지만 명령어 지원 체계는 같다.

### 서로 다른 컴퓨터에는 서로 다른 명령어 세트가 있습니다.
그러나 공통점이 많다.
서로 다른 컴퓨터는 서로 다른 ISA를 지원하고, 명령어가 다르면 코드도 다르지만 큰 축에서는 같다. 
### 초기 컴퓨터는 매우 간단한 명령어 세트를 가지고있었습니다.
간소화 된 구현
### 그 이후 ISA는 복잡 해지는 경향이 있습니다.
CISC(Complex Instruction Set Computer) - 복잡한 명령어를 처리할때 가장 느린 즉, 클럭이 가장 많이 할당되는 명령어를 기준으로 클럭을 적용시키기 때문에 클락이 느려지고 컴퓨터 시스템의 성능이 저하된다.
RISC(Reduced Instruction Set Computer) - 필요한 명령어만 가지고 효과적으로 구성하고, 클락이 CISC보다 적게 들기 때문에 성능면에서 RISC가 효율이 좋다. EX) MIPS
## 메모리에서 명령어(2)
### 멸령어는은 숫자로 표시되므로 데이터와 구별 할 수 없습니다.
### 프로그램은 데이터와 마찬가지로 변경 가능 메모리 (읽기 또는 쓰기 가능)에 저장됩니다.
메모리에다 자원을 올려두고 사용하는 Stored program concept식 이 있다.
초창기에 하드디스크에서 가지고 갔으나 속도가 느린 까닭에 메모리에서 읽어 들여와서 프로세스가 명령어 그리고 데이터를 처리하는 모델입니다.
### Stored-program concept 
모든것을 메모리에 담아놓고 동작한다고 생각하고, 프로세스에서 데이터 명령어들을 차례로 처리하는 모델이다. 여기있는 모든것이 전부 바이너리 데이터로 되어있다.
## Mips(RISC) Design Principles
### 단순한 규칙성을 좋아한다.
사이즈가 고정된 명령어
적은수의 명령어 형식
opcode는 항상 첫번쨰는 6 비트다.

### 작을수록 빠르다.
제한된 명령어 집합
제한된 수의 레지스터가 레지스터 파일에 있다.
제한된 수의 주소 지정 모드(addressing modes)

### 일반적인 경우를 더 빠르게 만들기
레지스터 파일의 산술 피연산자(load-store machine)
명령어가 즉각적으로 피연산자를 포함할 수 있도록 허용한다.

### 좋은 디자인은 좋은 타협을 요구한다.
3가지 명령 형식

## MIPS Instruction Set Architecture
### 개척하는 RISC 명령어 집합 구조중 하나이다.
일정한 형식으로 된 지침의 작은 레퍼토리
파이프 라인 된 실행
캐시 메모리
로드/저장 아키텍쳐

### 나중에 64 비트로 확장 된 32 비트 아키텍처로 시작합니다.
### 현재 많은 임베디드 응용 프로그램에도 사용되고 있습니다.
가정용기기 - 고화질
## 기타
기계어에는 binary digit 으로 되어 있어서, 명렁어와 데이터의 구분이 쉽지 않다, 이것을 OS가 도와주고 제공한다.

## Reference
[1] : https://ko.wikipedia.org/wiki/%EC%95%94%EB%8B%AC%EC%9D%98_%EB%B2%95%EC%B9%99
[2] : https://ko.wikipedia.org/wiki/RAID