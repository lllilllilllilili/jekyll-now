---
layout : post
title : Computer Ach(2)
---
## Why Computer Architecture?
Java는 VM위에서 돌아가는데, 속도가 느리기 때문에 프로세스안에 native Instruction을 translate해서 자동으로 그때그때 translate가 되서 Translation Cache에 데이터가 존재하면 실행해서 가져오고 속도를 증가시킬 수 있다.
## 컴퓨터 성능
Performance Improvement가 선형적으로 증가하는것처럼 보이나, 지수적으로 급격하게 증가하는 형태다.
꾸준히 증가하다가 성능이 2004년 이후부터는 크게 좋아지는것처럼 보이지 않는다. 이유는 성능을 높히는데
열이 많이 나서 상대적으로 비효율적이기 때문이다. 사람들이 생각한것이 칩에다가 기능을 올려놓는 기술이 더 섬세해져서 1마이크로미터 가 요구되는것을 0.5마이크로미터 로 바뀌면 면적이 1/4로 줄어든다.
클럭속도를 높이는데 한계니까 멀티코어를 생각하게 되었고 코어를 많이 만들면서 경쟁을 시작하게 되었다.
cpu가 3개더 들어갈 수 있고, 쿼드 코어 cpu의 개수로 성능을 향상시켰다.
## Abstraction
그때의 핵심적인 개념 포인트를 잡는것이고, 시스템에 가장 중요한 요소를 다루는게 컴퓨터 아키텍쳐의 중요한 부분이다.

## ISA
하드웨어가 처음 만나는 소프트웨어다.
Cpu안에 Register가 있고, Register 한칸에 해당 컴퓨터의 32bit 혹은 64bit에 따라서 크기에 맞게 할당된다. Machine code = machine Instruction 하고, DRAM은 Main Memory라 하고 주소로 접근하며 cpu 밖에 있다. 집적도가 높다. 
Bus라는게 있는데 프로세서와 메모리를 연결하는 선로 역할을 한다.
메모리가 느려서 cpu안으로 메모리를 가져오는 시도를 하는 추세다.

레지스터 : 프로세스에서 계산된 결과들을 저장하는 공간이다.
프로세스가 제공하는 Register, Memory 이중에서도 Register는 프로세스안에 있고 Memory는 프로세스 밖에 있다. 
(컴퓨터 체체가)32bit인게 레지스터 규격과 관련있는데, 레지스터 하나가 32bit 정보를 담는다.
주소개념이 있는 메인 메모리는 cpu 밖에 있으며 우리가 c언어 포인터로 접근할 때 이때 접근되는 장소다.

### ISA(2)
데이터, 명령어 혼합(Binary Code)
PC(Program counter)가 어셈블리어(add r1, r2, r3) 실행되면 하나증가되고 다음 명령어를 가리키게 된다. (PC는 현재 실행시킬 명령어의 주소가 담겨있다. 명령어를 프로세스로 가져와서 처리하는 명령어의 위치를 PC가 가지고 있다.)
프로세스가 제공하는 레지스터, 메모리규격, 명령어있으며
lw 는 load 명령어고, sw는 store 명령어다.

## Below Your Program
### Application software 
우리가 흔히 사용하는 고급언어들이다.
### System software
Compiler - 어셈블리어로 바꿔주는거고
Operating System - 입출력 처리를 도와주고, 없다면 사용자가 입출력을 전부 다 처리해야할 것이다.
### Hardware 
물리적 기능요소. Processor, memory, I/O controllers

### 구조
Application software : high-level
System software : Compiler, Operating System(I/O처리)
Hardware : 물리적인 기능요소

### Levels of Program Code
High-level language - c는 한번 짠 코드는 다른 워크스페이스 에서도 돌아갈것이다.
(컴파일후)Assembly language : 어셈블리어는 다른 디바이스로 가져가서 돌리면 안맞을 수도있기때문에 폐기해준다.
Hardware : 2진수로 비트를 나타낸다.
1개의 어셈블리 문장은 1개의 머신 코드로 대응된다.
모든 컴퓨터의 소스들은 binary digits로 나타낸다.

### Computer System Inside
구성요소 5가지 - 데이터경로, 컨트롤, 메모리, 인풋, 아웃풋
Processor가 Cpu(마이크로프로세스)고, 설비를 제한하는 컨트롤이 있고 구성된 설비는 데이터경로에 있다.
신호등이 컨트롤이고 걷는장소가 데이터 패스(가산기, 감산기, alu) 대기하는 차가 인풋, 아웃풋
cpu 안에 레지스터도 있고 가산기, 감산기 설비들이 있는데(cpu안 구성된 설비)
전송하는게 어디로 갈지 정의가 되지 않으면 안된다. (Controller의 역할)
