---
post : layout
title : 컴퓨터구조12
---
## 컴퓨터구조12
컴퓨터구조12

## add Instruction
add는 r포맷, opcode rs rt rd ... 구조
명령어가 실행되는 과정을 앞에서 instruction fetch, decode, memoery reference, 일반적인 명령, branch 3.4 번재 갈라지는데
이 동작들을 아래와 같이 표현할 수 있다.
pc값을 메모리에 보내서, 거기에 있는 한 워드를 instruction ...
add rd, rs, rt //R foramt
IR <- R[rs] + R[rt] //IR= instruction register 전달된 명령어를 담는 일종에 버퍼 또는 레지스터다. 명령어를 가져오고 가져온 명령어를 해석해서 연산을 실행하는데 rs 번호에 있는 register 값 , rt번호의 register 값 rd 번호의 register에다가 저장한다. 
PC <- PC+4 //PC +4 

세부 동작 표현한다. 이것을 RTL (Register Transfer Level) Description 이라고 한다.

각각을 micro instruction 라고한다.
위에 사진은 machine instruction인데 프로세스에서 실행되는 과정을 각각 보면 세부적으로 단위로 동작이 발생한다.

## sub instruction
sub rd, rs, rt
IR <- mem[PC]
R[rd]<-R[rs]+-R[rt]+1; //빼는 동작이  실제로 구현되냐면 -가 필요한것이 아니라 RT를 부정한다. RT를 부정하는것은 1의보수를 취한다. (부정은, 1의보수) +1을 더한거니까 2의보수라고 한다. A-B 하지만, A에다가 B의 보수를 더하는것도 빼기 연산이다.
PC<-PC+4 

## lw Instruction
I format이다. 
opcode 가 100011, immediate가 offset 값이다.
base register 역할을 rs가 담당
값이 5면 담을 레지스터가 rt다.

1. instruction 을 fetch 하고
2. lw할 주소를 (base+ offset을 더한 주소를 effective address) 만들기 위해서 rs 레지스터값(base) immediate를 더해야하는데 16비트라서 레지스터는 32비트이므로 16비트를 32비트로 확장해줘야 한다. signExtension 한다. offset값이 항상 양이 보장안되고 음도 가능하기 때문에(음수는 음수로, 양수는 양수로 확장하기 위해서) Addr<-R[rs]+SignExt(imm16) = effective addr
3. 그 addr를 메모리에 전달한다. 메모리에서 해당하는 word를 rt번호의 레지스터에 저장한다.
4. 프로그램 카운터를 증가시킨다.

## sw instruction
format은 같은데 opcode만 다르다.
rs가 base register
memory에서 레지스터로 가지고 왔는데, 레지스터 내용을 메모리로 보낸다.

메모리 쪽에는 address line에는 R[rs]+SignExt(imm16)
data line에는 레지스터의 값을 해당 메모리로 보내게된다.
메모리에는 memwrite라는 신호가 들어가야 메모리에 찰칵하고 들어가게된다.
pc+4 하고..

pc는 instruction fetch 단계에서 증가되었다.(중요)
## beq instruction
우선 첫줄은 fetch이고
두번째줄은 같은지 알아보기 위해서 뺀것이고  cond로 저장하고
cond가 0이면 rs=rt 두값이 같으면 zero값이 1이다.(zero 신호 1출력된다. 뺏는데 0이면)
immediate는 offset인데, pc-relative offset이다. (pc를 기준으로해서 얼마만큼 분기할지 결정한다.)
offset을 pc에 더해진다. 새로운 분기주소가 만들어진다.
(pc가 branch 자리에 있는게 아니라 pc+4 증가한 상태로 가져가야한다.
그리고 나서 immediate값이 더해진다.)

beq ... (pc위치)
add ..  
label : lw ..
2word가 떨어졌는데 beq 다음부터 기준으로 offset을 count해야한다.(중요)
immediate 단위가 word offset이다.

branch는 가는 위치가 명령어의 위치다. word의 개수로 표현한다.
memory는 byte addressable 하므로 (메모리는 바이트로 들어와야 해석하고 명령어를 보낼 수 있다.) sign을 확장하고 
signExt(imm16)<<2 // word를 byte 주소로 바꾼다. *4
메모리가 이해할 수 있는 byte addressable 주소가 된다.
branch 하는것은 pc를 바꾸는것이다. 
조건이 안맞으면 다음 명령어를 수행한다. (else 이후 PC<-PC+4)

## PC-related Datapath
instruction fetch고

## Datapath for R-format instructions
step1 = instruction fetch step
step2 = decode step
step3 : execution 시킨다 add면 sub면 각각 = execution step
step4 : write back step, 값을 레지스터로 되돌려 써준다.

datapath가 어떻게 필요한가?
레지스터 파일이 필요하고, 번호가 들어가고 rs,rd,rt 번호가 각각 들어가고 해당되는 번호의 값이 나와야 한다. 번호와 값의 위치가 중요하다.
alu안에는 여러 계산 요소가 있는데, 병렬적으로 계산되고 그중에서 내가 원하는 값 하나가 선택되는데 
alu operation은 mux로 들어가는 신호다.

계산결과가 목적지 register로 들어가야 하므로 write data 위치에 32bit 값이 들어가야하고 register에는 regwrite 신호가 활성화가 되야 값이 담길수있다.  

## Datapath for a Load or Store(1)
memory reference 명령어를 위해서 어떤 data path 필요한가!
step3, step4 무슨일을 하는지 살펴보자
step3 : 유효주소를 계산한다, (base+offset) load/store의 유효주소를 계산한다.계산한 주소값을 이용해서 

step4 : 
write $t1 into memory (해당ea로부터 값을 쓰고 lw일경우 값을 가져와서)

rs,rt 들어올것이고 
load일경우, rt가 write register number로 들어간다.
rs는 read data1로 나올것이고 offset은 명령어 하위 16bit에 있다. 16bit를 32bit로 확장한다. sign extend(조합회로를 거친다.) alu 한곳에 넣는다. 여기에 나온게 effective address 다. 이게 메모리 addr로 전달되고 load는 메모리에서 읽는것이니까 addr을 넣고 memread 신호를 넣는다. 주소의 한 워드를 읽어라 신호를 넣는다. 해당되는 곳의 워드가 읽혀져서 나온다. 나와서 register에 write data 라는 포트로 들어간다(32bit) 이값이 몇번 레지스터에 담겨야하느냐는 rt에 담겨져 있다.이게 load다.

store는 rs는 load와 같은데 store는 write data (메모리쪽)으로 들어간다. rt도 store는 register에서 읽어내서 보내야 함 
rs는 주소계산을 위한 베이스 값으로 쓰일것이고 두번째는 rt의 레지스터는 메모리로 보낼 값이다. rt값이 나오면 메모리의 write data에 전달된다. effective addr가 계산해서 나오면 ++ 이 주소에다가 writedata에다 보낸 값을 store 해줘 ++ 다만 그신호를 memwrite 신호를 넣어줘야 완성된다.  

## Datapath for a Load or Store(2)
++ea 계산할때 base 값이 들어가고 offset 값이 들어가서 두 값이 add가 된다. alu operation이 이중에서 어떤 연산을 선택하는데, 어떤 연산을 선택하냐면 add를 선택한다. ++
add의 의미는 명령어의 add의미가 아니다. alu에서 제공되는 기능중에 하나다.

## Datapath for a Branch(1)
Branch 명령어를 위해서 필요한 data path
step 1, 2는 모든 명령어의 공통이다.
step 3, 4는 명령어에 따라서 조금 달라진다. datapath도 다르게 구성된다.

step3
alu를 쓰는데 comparison을 위한
branch target addr - 브랜치 조건을 만족하면 가야될 위치
계산해야댐 PC에다가 offset(명령어의 하위 16비트-PC relative offset)을 더해야함  pc는 32bit offset은 16bit 이므로 offset을 32bit로 확장해야 하는데 sign extendsion 한다. pc를 기준으로 증가되는 방향 뿐만아니라 뒤로도 갈 수 있기 때문이다. offset이 부호를 갖는다.

step4
여기서 계산된 comparision의 결과와 그에따른 branch target addr의 결정에 따라서 pc가 바뀐다.  이때 필요한것은 alu는 있었고 branch 를 sign extension하기위해서 sign extended도 필요하다. 

Major components
이때 offset은 word offset이다. 이것을 메모리로 주소를 전달할때 byte단위로 환원해서 전달해야 한다. shift left 2 unit(*4 의미다., 워드주소를 바이트주소로 환산해주는 장치이다.)

++alu안에 adder는 comparision을 위해서 쓰고 있으니까 add가 동시에 sign extend 쪽에 add도 할수 없다. (중요)++ 별도의 seperate adder를 준비해야 한다.

## Datapath for a Branch(2)
16bit offset을 나와서 sign extend로 32bit로 sign extension 하는것을 했고 그게 shift left 2를 거쳐서 word가 byte로 환산되서 pc+4와 더해져서 branch ttarget addr 결정

read data1과 read data2를 비교해서 adder를 쓴다. (2의보수를 이용하므로 adder를 쓴다.) 

## R-format + (Load or Store)
앞에있는걸 모아놓은것이다.
선택선의 이름이 중요하다.
신호선은 control이 통제하고 opcode를 보고 판단한다.
load인데, regwrite(값이 레지스터에 쓰여지는경우) - 1
ALUsrc 1이되고, MemtoReg는 0이된다.
++제어선에 어떤 값이 들어가는지 파악하는게 이번시험의 관건이다.++

## R-foramt + (Load or Store) + Branch
branch 기능을 하나더 넣었다.
ppt 참고
지금 이것처럼 만든 data path를 single-cycle datapath 라고 한다.
한 클락 사이클내 동작해야한다. single cycle (설계)
모든 명령어가 한 클락 사이클이다.
약점은 안에 datapath가 한 명령어가 실행될때 한번씩만 사용된다 


## Creating a Single-cycle Datapath
한번씩만 쓰이기 때문에 예를들어 add가 3개가 있는데 add 가 하나가지고 3번 돌리면 3개를 돌리면 따로따로 만들었다. 지나가면서  add가 필요한것을 그때그때 하기 때문에
++add 필요한곳에 중복되서 디자인 되야한다.++ 

instruction과 data가 분리되어있는데 심각한 문제는 아니지만 같은 addr도 윗부분 아랫부분 구분하면 된다. 하드웨어적으로 어디는 instruction, data 구분되서 써야 한다 그러면 약점이다. 
명령어, 데이터건 주소공간에 어디서든 위치할 수 있어야 하는데 

서로 다른 instruction 간에 data path 상에서 공유가 일어날때 혹은 어떤 자원에 대해서 충돌이 일어날때 해결할 방법은 ++ multiplexor ++ 가 사용된다.

## Single - Cycle Datapath
현재 control은 나타나있다.
alu control part 새로생겻다.
전에 봤던 control은 main control이다.
어떤 명령어가 r format 인데 opcode 0, 실제 operation funct code를 봐야 하다. funct 는 5비트까지 할당한다. aluop는 명령어 봤더니 이게 r포맷 명령어일경우 funct를 같이 보고 그에따라서 다시 새부 동작을 결정해주록 하기위해서 만든것이 alu control 이라는 small control이다.

만약에 main control에서 opcode를 같이 넣고 funct code도 넣고 main에서 한번에 신호를 만들어 낼 수 있다. (중요) 왜 2단계로 하냐면 조합회로는 회로의 복잡도는 입력에 제곱에 비례한다. 
opcode가 6비트였는데 6비트의 제곱은 36, main control의 가격이 36이면 되는것을, main 에서 op도 보고 funct도 보면 12의제곱 144 이다. 비용이 굉장히 크게 늘어난다. main의 비용이 그래서 분리시킨것이다. main에서 opcode만 보고 한번더 보는건 하위에서 본다(중요)

6의제곱 control에서 나가는 opcode, 36이다. 144->36 으로 절감되서 해결할 수 있다.

++작은 control과 큰 control로 나누는이유 ++

## Single-Cycle Control
신호들이 어떤 값을 가져야하는지 정의하고있다.
왼쪽 컨트롤신호 의미가 오른쪽이다.
ppt 참고

## Review on Instruction Format
ppt 참고

## Execution of an R-foramt Instruction
현재 pc는 0번지에 있다. pc는 0을 가리킨다.
t1 t2 t3 고유 번호가 있다.(레지스터, 심볼릭하게 다루지만 레지스터 번호로 맵핑되서 처리된다.)
register는 무슨 값이 들어있는지 알 수 없다. 각 레지스터 자기 번호에 맞는 값을 초기값으로 갖고 있다고 가정.

$t1 = 9 $t2 = 10 $t3 = 11 갖고있다고 가정한다.
그러면, 10 하고 11하고 더해서 21 값이 $t1에 쓰인다.
각 선에 어떤 값이 실릴까를 살펴본다.

## R-format Instruction Dataflow
pc에 0이 들어있다. add $t1, $t2, $t3가 올것이다. 해독이 되서 rs rt rd 번호에 들어간다. rs에 10, rt 11 (번호다) 들어간다. rd에 9가 들어간다. 전기적인 신호기때문에 bit의 연결된 신호로 다 들어간다. (하위비트들이 들어갈테지만 의미가 없다. 선택이 안된다. mux에서 add 명령어를 위해서는 필요한것을 선택해서 보내기 때문에 이상한값이 들어와도 연산에 영향을 미치지 않는다.)

자기번호와 같은 값을 가지고 있다고 가정하자. 10번 register 값은 10을 가지고 있다. 10은 10을 가지고 있다. 초기값을 500을 더한다고 하자 초기값은 500 + r number 
10번은 510, 11번은 511이 나온다. 
zero 값은 같으면 1, 다르면 0이 나온다. add와는 불필요하다.
내부적으로 모든게 연산이 된다.

alu result는 510 + 511 = 1021이 나온다.
값으로 확정은 하지 않았지만 이안의 많은 요소중에 무엇을 선택해라 add를 선택하라는 신호가 alu안에 들어가야 한다. 
값으로 결정할것이다. alu 의 add연산인데 opcode 가 0이고 funct 함꼐 봐야 한다. add의 funct code는 32다.
6bit로 binary로 가야대니까 0010 0000 이다.  

ALU op 는 r-format 이고 add라는것

address도 값이 갈것이다. 동작은 안한다. 신호를 안넣어주면 메모리가 동작을 안한다. 둘다 동작을 안시키기 위해서 0을 넣는다.

1021이 memtoReg는 아래것을 선택해야 하니까 0이 들어간다.
영향을 받는 부분이 pc가 4하고 들어가서 4가 나온다. 
하위 16bit로 올라오는거랑 pc랑 해서 값이 나올텐데 PCsrc가 0으로 setting 되서 값이 나오지 않는다.

다음 주소로 pc가 4로 바뀐다.


## R-format Instruction Control
나중에 숫자로 정의해야하는데 심볼로 Op라고 쓰고 Operation이 function code에 의존적이다. Dependent on operation.

ALU Op를 보고 ALU Control의 할일을 결정한다.

## Execution of a load Instruction
decimal로 1234 가정한다. pc는 00이다 가정하면 뒤에 제어신호, 데이터 버스 신호 다 써보라!




## Datapath for a Branch(2)

## R-format + (Load or Store)

##



