---
post : layout
title : 컴퓨터구조1(기)
---
## 컴퓨터구조1
컴퓨터구조1

## 시험관련
시험관련(생략)

## Outline
싱글 사이클 데이터 패스를 배웠는데 몇가지 문제점이 있다. 모든 명령어가 시작에서 끝까지 한 클락 사이클에 완료되는것이 싱글사이클 이다. 문제는 각각의 명령어마다 실제로는 걸리는 시간이 다 다른데도 불구하고 제일 오래걸리는 로드에 클락 사이클이 맞춰졌다. 시간의 낭비. 또하나는 그안에 add니 alu니 여러개가 있는데 사실은 한번에 지나가면서 딱 한번씩만 쓰이는 것들이다. adder 하나가 만들어져서 이걸 위해서도 쓰이고 저걸 위해서도 쓰이면 좋은데 그렇게 2번시도를 못한다. 한 클락 사이클 안에서는
리소스가 역시 낭비된다. 리소스 재활용이 활용도가 떨어진다. 바꿔말하면 결국 어디서 add가 필요하다 그러면, 또 adder를 집어넣어야 한다. 그래서 결국 자원이 중복설계된다. 문제에서 add shift라는 새로운 명령어를 설계했다. 그러면 그명령어는 그냥 add가 아니고 어떤 한값을 거기에 제시된 값대로 shift시간 다음에 add시키는 그런 명령어다. 특수한 명령어다. 그걸 우리가 구현하려면 싱글 사이클 데이터 패스를 alu들어가기 직전에다가 shift는 거기다가 설계해 놔야 한다. 그리고 거기에다가 shift 신호를 집어넣고 그러면 레지스터에서 나오는값이 shifter로 들어가서 shift된 다음에 alu로 들어가게끔 설계를 해야한다. 그래서, 그와같이 자원이 낭비되는 요소가 있는데 그러한 싱글사이클의 문제가 있기 때문에 개선하는 방법이 있는데 첫번째 방법은 지난번에 말한것처럼 한 긴 동작을 몇개의 동작으로 세분화 한다.

## Multiple-cycle Concept
세분화시킨다. 그리고 각각을 독립된 클락 사이클로 구현한다. 세분화된 동작이라는것이 뭐냐면 인스트럭션 패치, 인스트럭션 디코드, 엑시큐션, 메모리 엑세스 그다음에 롸잇백 5단계는 잘기억해야 한다. 그것을 세분화 해서 시도하는게 멀티 사이클이다. 각각의 그 세분화된 동작을 한 사이클에 그래서 기억해야 할것은 그러면 명령어 하나당 소요되는 사이클의 개수는 ++많겠다 ++ 각각 한사이클이라고 했으니까 ++주의할것은 우리가 싱글사이클에서는 모든 명령어가 한 클락 사이클 이었다. 그것을 사이클스 퍼 인스트럭션, cpi가 1이다++ 라고 했다. 그런데 싱글사이클에서는 똑딱 똑딱 이렇게 긴사이클에 됬다면 멀티사이클에서는 똑딱똑딱똒딱 이렇게 빠르게 이렇게 짧은 사이클로 여러 사이클로 움직이는 방법, 사이클의 개수가 많다고 무조건 느리다 하는것은 틀린말이다. 사이클의 개수가 중요한것이 아니라 한 사이클이 얼만큼의 시간이냐? 사이클 타임이 더 중요하다. 그래서 그와 같이 굉장히 짧은 ++싱글 사이클에 비해서 훨씬 짧은 클락 사이클을 적용해서 대신 여러개의 사이클로 한 명령어를 구성하는것이 멀티사이클이다.++ 

add면 같은 리소스, alu라든지 메모리 라든지 여러 사이클중에 다른 목적으로 메모리가 전에는 instruction memoeney와 data memory가 구분되어 있었는데 여기서는 메모리 하나 놓고 instruction fetch일때 메모리 access 하고 데이터 가져올때 같은 메모리 access하고 여기도 alu 하나만 있으면 alu operation할때 alu 당연히 쓰고 어드레스 계산할때도 그 alu를 써서 계산을 하고 브랜드 address도 그 alu써서 계산하고 alu 하나만 있으면 다 연결이 된다. 별도의 adder가 필요가 없다.

single cycle에서는 3개의 adder가 나타났는데 그림을 보면 adder가 다 사라졌다. 단 여기서 주의할건 전에는 여기서 신호가 나오면 쭉 path를 타고 흘러갔는데 ++흘러가다가 마지막에 끝날때 clock이 떨어지면서 그 결과가 그 레지스터에 저장되었는데 지금은 메모리에서 인스트럭션 가져오면 한 사이클이 끝나고 그리고 그담에 거기서 읽어내서 레지스터로 보내는게 한사이클로 끝나, 그러니까 한 사이클이 끝났다는 얘기는 한 사이클에서 나온 결과가 어딘가에 저장이 되어야 한다는것이다. ++그래서 중간중간에 그 사이클에서 각 스탭별로 나온 결과를 저장하기 위한 일종에 버퍼, 결과적으로 얘들도 플립플랍으로 레지스터의 성격을 갖는데 일종에 버퍼가 중간중간에 관련된것이다. ++ 새롭게 마련된 버퍼가 무었이냐면 메모리에 인스트럭션이 가져왔을때 인스트럭션이 들어가야 되는 인스트럭션이 담겨져 있어야 하는 인스트럭션 레지스터가 존재한다. 연두색으로 되어있는 그다음에 레지스터의 번호값을 넣으면 레지스터 값이 나와서 alu로 흘러들어갔었는데 여기서 레지스터 값을 중간에 잠시 담아 두는 a,b라는 tmp가 존재한다. 버퍼가. 그다음에 alu 결과가 나온것을 역시 그결과를 담아두는 aluout이 있다. 버퍼라는게, aluout의 결과가 때로는 ea일수도 있다. load 일경우 ++
그러면 그 address가 다시 메모리로 어드레스로 전달되서 데이터값이나올거아니야 메모리에서 그 데이터값이 나오면 그것을 저장하는 메모리 데이터 레지스터 mdr 이라는 버퍼가 있다. 이것은 줄여서 ir(instruction register) 이것은 줄여서 memory data register 그리고 그게 다시 목적지 레지스터에 들어가서 제일 오래걸리는것은 로드니까 역시 fetch, 디코드, address execuation, 메모리 access, 그다음에 writeback  5단계가 있다. 중요한것은 

++ 버퍼가 필요하다.++

## 파티션을 어떻게 할 것인가?

인스트럭션 패치 디코드 나눠져있기 때문에 그거에 따라서 한것 같긴 하지만, 사실은 실제로 회로를 디자인할때 그 파티션 사이즈가 엊 비슷해야 한다. 인스트럭션 패치, 인스트럭션 디코드, ... 파티셔닝을 했는데 각 각의 파티션은 같은 clock 안에서 끝나야 한다. 인스트럭션 디코드는 약간 길고 패치는 조금짧고 이렇게 할 수 없다. 일단 clock을 하나 정해두면 그냥 같은 clock이 여러개가 흘러간다. 인스트럭션 패치, 디코드, 엑시큐션 ... 그중에서 뭐에 맞춰?? 그중에서도 제일 긴거에 맞춘다. 근데 파티셔닝을 해놨는데 멍청하게 해서 그게 인밸런스가 심하면 패치가 너무길고 나머지는 너무 짧아 그러면 바보같은것이다. 엊비슷하게 하는데 그 엊비슷하게 하는 가장  중요한 기준중에 하나는 ++주요한 operation 별로 하나씩 포함되게끔 파티셔닝을 한다.++ 메모리 access라든지, 레지스터 파일 access라든지 , alu operation 이라든지 

## Multiple-cycle Datapath
이 그림 싱글 사이클하고 대동소이 하면서 약간 다른 부분이 있는데 어떤 부분이 다른지 확인하자. 전에는 pc를 4만큼 증가시키기 위해서 여기에 adder 하나더 있었는데 그것이 없어지고 pc가 어디에 의해서 4가 계산이 되고 있느냐면, alu를 쓰기 위해서 입력 하나가 들어간다. 밑에보면 다른 입력중에 하나가 4가 들어가게끔 준비되어 있다. 모든게 alu를 재활용 하기 위해서 다 연결되어있다. 우리가 이런 표현을 rtl(register tranfer level) 표현이라고 했다.  역시 지난번에 봤던것과 거의 비슷한데.

## Overview of Multi-cycle Execution
다섯단계로 스텝이 분할되고, 모든 명령어가 첫번째 두 스텝은 똑같다. 싱글 사이클과 마찬가지로 첫번째 스텝 pc를 주소에 있는 메모리값을 읽어서 ir에 넣는다. (instruction register에 넣는다.) 여기에 instruction이 들어가 있다. 그리고 pc를 4만큼 증가시킨다. 이게 first step에서 하는 일이다. second step에서 ir에 rs, rt 두 자리에 있는 레지스터를 읽어내서 A,B 버퍼에 집어넣는다. 읽어낸다. 두번째 스텝에서 ++ ALUOut, 브랜치 주소는 어떤 명령어가 브랜치 명령어 라면 프로그램카운트에다 그 명령어의 하위 16비트를 4배한다음에 더해줘서 브랜치 타켓 어드레스를 만든다.그게 브랜치 주소다. 이게 만약에 이때는 만약에 를 가정한다. 만약에 이 명령어가 브랜치 명령어 였다면 그 타켓이 second step에서 계산되게끔 준비를 한다. 물론, 브랜치 명령이 아닐수도 있는데 그럴때는 헛방이다. 사실 ++별로 의미가 없다.++ 하지만, 브랜치 명령일때는 이 계산에 의해서 세컨드 스텝에서 주소가 결정되어 나온다. 하드웨어적으로 다 준비를 해놓고 일을 시킨다. 무조건 계산해! 그다음에 세번째 스텝부터 각각의 명령어에 종류에따라서 하는일이 달라진다. R타입 ALUOperation인데 A와 B에 들어온 값을 가지고 ALUOperation을 해가지고 그결과를 aluout에다 낸다. 보낸다. 이게 세번째다. 그다음에는 네번째는 aluout에 들어온 값을 여기 ir15-11은 rd이다. rd번호에 해당되는 레지스터에다 집어넣는다. 이렇게 해서 R-format 명령어는 4스텝이면 끝난다. 근데 메모리 reference, 로드나 스토어일 경우는 세번째 스텝에서는 a하고 하위 16비트를 sign extend 한 값하고 더해서 이것을 effective address라고 하는데 ea를 aluout에다 넣는다. aluout에서는 address가 들어있다. 이 address를 그다음 스텝에서는 명령어가 load 일경우에는 거기에서 읽어오는 것이고 스토어일때는 거기에다 쓰는것이기때문에 로드일경우는 일단, 그 주소를 메모리에다 전달하고 거기에 있는 값을 읽어온다. 애는 b에 들어있는 값이 rt값인데 여기다 쓰는거잔아. store는 store는 여기다 쓰면 끝난다. store는 메모리에다 값을 던져주면 끝난다. 너 이값을 써라. 그런데 load는 일단, access하라고 한다음에 조금잇다가 그 값이 나와야 한다. 그 나온게 어디로 들어오냐면 mdr에 담긴다. 다음 스텝에서는 mdr에 나온 값을 여기 16-20 rt에 해당되는 번호에 값을 write한다. store는 4cycle만에 끝나고 load는 5cycle만에 끝난다. 브랜치는 똑같이하고 브랜치 주소가 결정되고(2step) 다음 스텝에서 할일은 여기서 나오는 두 레지스터의 값이 같냐 다르냐만 보면된다. 같으면 아까 aluout에 들어있는 브랜치 타켓 주소 있으니까 그값을 pc에다 넣어주면 거기로 가는것이고 같지 않고 무시하고 pc를 변경하지 않으면 pc+4가 그대로 적용되서 다음 명령을 수행한다. 브랜치는 3cycle이다. 자 그런데, 여기는 점프는 프로그램 카운터에 상위의 4비트는 무조건 가져다 붙여주는것이고 이것을 우리가 ++sudo - direct ++ 한다. 0을 세팅해줘도 되지만 0을 세팅하면 256M라는 물리적인 공간이 그대로 고정되어 있기 때문에 그것을 조금더 확장하기 위해서는 상위비트들을 다른 값으로 설정할 수 있는 방법을 쓴다. 그것을 sudo-dirrect 한다 그랬고 그것을 가지고 ir에 26bit opcode를 제외한 26bit가 절대 주소의 역할을 한다. 그것을 4배하면 word값이 byte 주소로 바뀌잔아 그것을 pc에다 넣는다. 그런데 이제 보면 점프도 3cycle만에 끝난다. 그런데 점프가 꼭 3번째 일때 이것을 해야하나? 

## 점프가 3번째 일때 이것을 해야하나?
다른것은 seconde step에서 계산한 a,b,aluout 이용하기 때문에 3번째 step 계산을 해야해. 근데 여기에 jump에 들어가는 pc에 4비트 이미 어디서 결정되어있냐면 이미 2step에서 pc가 바뀐것 그대로 결정된것에서 4bit 쓴다. ir의 26비트 역시 ir 읽어왔을때 할수있는것이다. 사실은 이 동작은 2step으로 끌어 와도 되는것이었다. 그렇게 하면 우리가 처음 2step은 ++명령어를 가리지 않고 실행을 시켰는데 만약에 jump의 3step을 2step으로 가져다 놓으면 두번째스텝부터 opcode가 점프냐 아니냐에 따라서 분기하도록 처리를 해줘야한다. 그것만 구현할 수 있다면 이동작을 2 step으로 올릴수도 있다.++ 그래서 점프를 더 빨리 끝낼 수도 있다. 

3번째 스텝부터 opcode에 따라서 하는일이 달라진다. 그리고 이게 한 클락 사이클이다. 한클락, 두클락, 세클락, 네클락 다섯클락 
로드는 5c, 스토어는 4c, 브랜치는 3c, alu 산술 논리는 4c lock이다.
여러 사이클로 구성된다.

## Instruction Fetch Step
이 동작을 위해서 데이터 패스가 어떻게 구성되는가! 

## Instruction Fetch Step
Instruction Fetch Step에서 지나는 데이터 패스다. 사용되는, 어떤 부분이 사용되냐면 프로그램 카운터가 메모리 안으로 들어간다. 메모리에서 그 프로그램 카운터 주소에 해당하는 워드 인스트럭션이 읽혀져 나온다. 인스트럭션이 읽혀져 나와서 그게 어디로 들어가냐면 인스트럭션 레지스터에 들어간다.(ir에) 그리고 한편으로 프로그램 카운터의 값이 4만큼 증가되어야 한다. 4만큼 증가되는것이 프로그램 카운터가 그값이 mux의 인풋하나로 들어가고 우리가 싱글 사이클에서는 read1에서 나오는것은 바로 들어갔다. 여기서는 mux가 있다 왜냐하면 프로그램 카운터도 alu를 쓸 수 있기 때문에 B에서 들어가는 값이 상수 4. 아래는 4개중에서 하나를 고르는 MUX가 된다. 선택신호가 2bit의 선택신호가 되어야 하고 그거에 의해서 인스트럭션 패치일때는 1번 선택을 할 수 있는 제어 신호가 들어가야 한다. 여기에서는 0번 제어신호를 선택하는 신호가 들어가야 한다. 제어신호라는것은 이게 어떤 명령어다 이다를 알고 그게 어떤 스텝이다라는것을 알면 그때 여러곳의 제어신호에 머가 들어가야하는지 이미 결정이 된다. (어떤 명령어, 몇번째 스텝) 그다음에 디코드  

## Instructio Decode/Register Fetch Step
디코드의 하는일은 이것이고 아까 말한대로 브랜치 타켓 어드레스를 계산하는 과정이고 이것을 위해서 사용되는 데이터패스.
어느부분이 왜 사용되는지 확인해 보자. ir에 들어있던 값중에서 rs,rt에 해당되는 번호가 들어갈것이고 거기에다 레지스터 값이 나올것이다. 그다음에 파란것은 인스트럭션 패치에서 사용되는 부분이었다. 한바퀴 돌고 온것이다. 

## R-format execution step
R-format execution step에서는 A,B 나온값을 Operation 해서 aluout으로 넣는 이동작만 하니까 이것이다. A,B에 들어와 있는 값을 가지고 Operation을 했는데 a는 1번으로 연결이 되고 b는 0번으로 연결이 되니까 제어신호가 들어가는데 지금 세번째 스텝이고 3번쨰 사이클이고 첫번째 두번쨰 패치, 디코드 단계는 지나갔고 세번째 사이클이고 지금 r 포맷 명령어면 여기에 1번과 0번을 선택하도록 제어신호가 들어간다.
## R-format Completion Step
r포맷의 마지막 4번째스텝에서는 alu의 값을 여기에 있는 rd에 포현되어있는 번호의 레지스터에다가 써준다.  

거기에 해당되는 path는 이것이다. aluout의 결과가 담긴 값이 들어간다. write data로 가야한다. write data는 지금 두곳에서 올수가 있다. 메모리에서 나온값이 갈수도 있고 aluout에서 나온값이 갈수도 있다. write data 앞에 mux가 있다. 여기서는 aluout으로 온게 0번으로 연결이 된다. 그다음에 write register라는것은 넘버다. 여기에 들어가는값은 rd-15-11 rd번호이다. 그러니까  write register 넘버가 r-format에서는 rd번호가 여기로 들어가지만 load에서는 rt번호가(20-16) write register넘버로 들어간다. 그래서 이앞에 mux가 있는것이다. 이게 load 명령어이면 rt에 해당되는 번호로 연결해주고  r포맷이면 rd에 해당하는 번호로 연결해준다. 4번째 단계에서 여기서 이 mux는 0번을 선택해서 넣고 이 mux는 1번을 선택하도록 제어신호가 전달이 된다.

## Load/Store Address Computation Step
로드/스토어 3번째 단계에서 하는일을 ea 계산하는것이다. ea를 계산하기 위해서 어떤 부분이 사용되나 확인한다. immediate 부분은 sin extend를 거쳐서 32bit가 되서 여기로 들어가는데 여기서 base register 역할을 하는 레지스터가 이렇게도 나올텐데 여기로 들어갈 수 있는 값이 pc하고 현재 load 중일때 두개였다. 이 mux를 거치는 여기서는 제어신호가 역시 1번이 들어가야 하고 반대로 이 mux는 2번이 들어가야 한다. 담기면 ea가 계산되어 진다. 그다음에 

## Load Memoory Access Step
4번째는 load와store가 하는일이 달라지는데 load는 aluout 에 나온 주소에 해당하는 메모리의 값을 읽어오는것이고 읽어와서 mdr에 넣는다. 주소가 메모리 address이다. 여기 지금 메모리가  input의 메모리 역할도 하고 데이터 메모리 역할도 하니까 address가 프로그램 카운터에서도 올수도 있고 저기에서 어드레스가 올수가 있으니까 mux가 있어가지고 둘중 하나를 선택해주는것이다. 지금 현재는 load 명령어이고 aluout에 해당되는 주소 메모리값을 읽는단계니까 제어신호는 1번을 선택해야하고 만약에 모든 명령어든 다 똑같지만 instruction fetch 단계에서는 이 mux는 0번이 선택되서 pc가 들어가게끔 설정해야 한다. 지금 instruction fetch 단계이다. 그러면 여기에 mux에는 어떤 신호값이 들어가야 하냐? 물어볼 수 있다.
## Load Completion Step
 그러면 읽혀져서 나온게 mdr 레지스터에 들어간다. load에서 읽고자 하는 값이 들어오는것이다. 그리고 이값을 어떻게해 이 값을 레지스터에 담아 줘야 한다. 담는것이 mdr에 들어있는 값을 rt번호에 해당되는 레지스터에다가 담는것이다.

여기에 mdr이 들어갈것이고 그다음에 여기에 rt번호가 와서 이 번호가 들어가도록 여기 mux가 0번을 선택하도록 해야한다. 이거 역할이 굉장히 중요하다.  이거역할이 load일때는 0번이 r-format일경우는 1번이 들어가도록 제어신호가 제대로 들어가줘야 한다. 

## Store Memory Access Step
store는 b에 있는 값을 거기다가 메모리에다 전달하면 메모리 주소와 함께 데이터를 전달하면 끝이다. B의 값이 나왔고 얘를 바로 write data로 보낸다. 이 주소를 메모리 address로 
load와 다른건 load는 아래에 있는것을 읽고 나오는거니까 address만 주면 됬는데 store는 address와 데이터를 갖이 줘야 한다. 여기지금 제어신호는 다 빠져있는데 전에 싱글 사이클로 따지면 여기에 memread, memwrite 제어신호가 있었다. 이경우는 memwrite 제어신호가 여기에 활성화되어야 한다.  

## Branch Completion Steop
브랜치 일경우에 세번째 스텝인데, 분기 할까 말까 결정된다. A,B의 값이 나왔고 A,B 값에 그 비교 연산이 실행이 됬고 비교 연산결과 에 따라서 여기 지금 ALUout에 이미 여기에 branch target addr가 계산되서 들어가 있다. 그리고 A,B를 비교한 결과에 따라서 이 ALU의 값이 PC로 가게끔 할것인가 아니면 아까 그 
그림은 지금 분기가 채택될때 ALU의 값이 바로 될것이고 분기가 채택되지 않으면 여기서 값을 내보내지 않으면 된다. 내보내지 않으면 PC의 값이 바뀌지 않는다. 이미 프로그램 카운터는 +4가 반영되어 있기 떄문이다. 있는 상태다. 어디서 Instruction fetch에서 여기서 pc는 그값이 4가 더해져가지고 그값이 다시 되돌아간 상태이다.

## Jump Completion Step
세번째 스탭에서 데이터패스가 하는일을 보면, 프로그램 카운터의 상위 몇비트는 써야 하는데 프로그램 카운터 현재 있는 값을 읽어오고 그다음에 instruction에 26bit에 해당되는 값을 읽어와서 28bit로 만들것이고 그다음에 그것을 합성해서 32bit를 만들것이고 그게 pc로 들어간다. 문제는 여기 어떤 제어선이 있어서 현재 이게 jump 명령어 이고 현재 3번째 사이클 이면 2번에 있는 값이 들어가도록 제어선을 여기에 입력해주면 된다. jump는 2번

## CPI of the Multi-cycle implementation

각각 사이클이 다르다. variable clock cycle 라고 해서 앞서 언급한 바가 있다.
소비되는 clock cycle이 이와 같은데 만약에 어떤 프로그램에 들어가 있는 명령어의 빈도가 이와같다면 cpi는 어떻게 구하느냐 앞에 생략되어있지만 average 라고 했다 평균 cpi라고 했다. 인스트럭션 하나당 평균 몇 사이클이 걸리냐 싱글 사이클에서는 1이었다. 무조건 요게 각각의 명령어가 나타나는 빈도수를 의미 가중치로 생각해서 가중치 평균을 생각한다. 4.04 평균적으로 클락 사이클을 소개하게 된다.
다시한번 말하지만 클락 사이클이 4라는 값이 나왔다 하더라도 싱글 사이클이 1이라고 해서 싱글 사이클보다 더 걸리느냐 는 절대 아니다. ++한 클락 사이클 타임이 굉장히 짧게 우리가 구성할 수 있다. ++  
## Multiple-cycle Implementation(with control signals added)
제어선을 중앙선으로 주황색으로 나타냈다.
앞에서 우리가 봤던 제어선하고 거의 비슷하다. ir buffer에  irwrite가 들어갔다. buffer 라는것도 일종에 레지스터이니까 그 레지스터의 값이 write 될때 write를 지시하는 활성화시키는 신호가 들어가 줘야지 여기서 들어간 값이 담기도록. 만일 이 값이 0 이면 아무리 값을 넣어도 반영이 안되도록 설계한다. 

앞에서 싱글 사이클에 비해서 어떤 부분이 추가되었는지? 프린트는 잘안보임. 어디어디 제어신호가 들어가는지 이름이 뭔지 봐라  
instruction fetch다 어떤 제어신호가 들어갈지 iorD가 0이 되어야 한다. 그래야 여기에 들어간다. instruction fetch에서는 프로그램 카운트를 4만큼 또 증가 시킨다. pc가 여기에서 alu로 들어가는데 여기에 이 인풋을 제어하는것이 alusourceA라는것이다. ALUsrcA가 0을 선택해야 한다. 0을 선택해야 PC가 여기로 들어가는것이다. 그다음에 또 INPUT을 제어하는 신호가 ALUsrcB다. instruction fetch에서는 ALUsrcB는 1이 되어야한다. instruction fetch단계에서는 3개가 값이 전달되어야 한다. 제어신호가 바꿔 말하면 여기 이미 모든 제어신호가 약속된 제어신호가 모두다 저장되어 있다. 그래서 opcode가 들어오고 클락이 1클락, 2클락, 3클락 ... 4클락이 가면 1clock은 fetch clock이다. 1clock에서, 첫클락이다. 이러면 ALUsrcA 와 B그리고 IorD 제어신호를 넣어서 보낸다. 두번째 clock는 디코더 단계에서는 여기 rs,rt들어간 값이 A,B로 담겨야 된다. 그러면 rs,rt로 들어가는데 rs 는그대로 들어갈 것이고 rt 앞에는 mux가 있다. 두값중 하나를 골라야 한다. 그 신호가 regDst 값이 0번을 선택하도록 해야한다.(이건 놉)
클락이 first, seconde, third, fourth다.현재 4번째 클락이다. 명령어가 opcode가 load다. 어떤 제어신호가 어떤 값을 나타내야 하는지 살펴보자! 메모리에서 읽는거니까 memRead가 들어가야 하고 어드레스가 pc에서도 올수있고 mux에서도 올수가 있다. (aluout-effective address 담고있는 상태) 여 신호가 이름이 iorD값이 이번에는 1번으로 선택하도록 해야 한다. iorD가 0번이면 처음에 PC가 들어간다. 1번이면 거기서 오면 레지스터값이 들어간다. 그값이 나와서 메모리 레지스터에 담긴다.(mdr)

## Finite State Machine
이것을 구현하는대 유한상태기계, 첫번쨰 두번째 세번째 네번째 다섯번째 스텝 다시 첫번째 스텝으로 돌아온다. 또는 첫번째, 두번째 세번째 스탭하고 경우에 따라서는 다시 첫번째 스텝으로 돌아오는 어느경우야 브랜치인 경우가 그렇다. 이렇게 상태가 몇개가 있다. 몇개의 상태가 있냐면 instruction fetch 상태, decode상태, r포맷일 경우는 execution, write back 이런 여러 상태가 있다. 여러 상태들에서 사이클에 따라서 0에서 1번상태로 1번에서 2번상태로 3번상태로 0번상태로 이렇게 정해진 룰에 따라서 상태를 계속 옮겨다니는 그런 시스템을 유한상태기계라고 한다. 옮겨다니는 상태가 있고 당연히, 이 머신은 2개의 펑션을 갖는데 일단 현재 상태에서 신호가 어떤 값이 나가야 하는가. 예를들면 instruction fetch 상태다 그러면 신호는 어떤 값이나가야하는가 그것을 결정하는 펑션이 있는데 그게 output function이다. 밑에다가 이것은 control signal이다.
control signal은 여러 mux나 여러 장치에 내보내는 제어선들 의미한다. 이것이 현재 자기가 어떤 상태에 있는지에 따라서 인풋은 opcode가 먼가에 따라서 control signal이 결정된다.

next state는 내가 지금 현재 0번 상태인데 다음에 1번 혹은 2번 3번 4번으로 갔다가 다시 5번으로 갈수도 있고 0번으로 갈수도있고 다음에 어떤 상태로 갈것이가 현재 어떤 상태에있는가 하고 입력이 뭔가 이것 역시 opcode다. 입력이 뭔가에 따라서 다음 상태가 결정이 된다. 이것을 구하는 방법은 밀리머신, 무어머신이 있었다. 우리는 기본적으로 무어머신을 공부할것이다. 안에 현재 상태를 저장하는 메모리가 있다. 밖에서 인풋이 들어온다. 두펑션이 있다. 하나는 control signal을 output하는 펑션이 있고 또하난 다음 state를 결정하는 펑션이 있다. 그러면 일단 input이 들어오고 

++여기서는 사실은 맨처음에 상태가 정해지면 사실은 요 상태는 이미 여기에 opcode가 해석되서 이 상태로와있는것이다. 여기서 opcode를 또 따로 보지 않는다. opcode는 맨처음 한번만 결정이 되고 다음상태에서는 opcode를 보지는 않는다. 여기에서는 유한상태기계를 두개의 타입으로 무어머신과 밀리머신으로 구현할 수 있는데 무어머신은 다음상태의, 현재상태 의 아웃풋은 현재state만 보면 아웃풋을 내보낼수있다.
무어머신은 간단한다. 현재 상태가 있다. 상태번호가 0번이면, 현재상태만 알면 각각 들어오는 어떤 값을 내보내야 할디 결정이 된다. 다음상태로는 어떻게 가야 하느냐? 그것은 현재상태의 값과 인풋을 (opcode)를 알면 그 다음의 다음상태가 몇번이 되야 하는지 결정된다. 인풋은 다음 상태를 결정할때만 사용된다. 무어머신에서는 

처음에는 0번 state고 그다음에는 opcode에 상관없이 1번 state로 갈것이고 그다음에 1번 state에서 다음에 2번으로 갈지 3번으로 갈지는 input에서 오는 값을 보고 이럴때는 2번으로 간다. 이럴때는 3번으로 간다 이렇게 결정를 한다. 	
얘는 여기에 상태가 0,1,2,3 번호만 일단 결정이 되면 거기에 해당하는 control output이 자동적으로 나오도록
그렇게 설계를 한것이 우리가 사용할 무어머신에 기반한 시스템이다.
여기서는 이게 상태다. 상태를 지금 비교적 간단하게 그렸다.

## Finite State Machine Diagram
5개 상태인데 뒤에가면 더 세분화되어있다. 이걸 먼저 봐야해 안에 이건 볼필요없고 상태가 몇개 나타나! 0번부터 9번까지 10개의 상태가 나타난다. 전기가 들어오면 무조건 0번상태로 간다. 그다음에는 0번상태에서 무조건 볼것도 없이 1번 상태로 간다. 1번 상태에서는 무조건 볼것도 없이 2번으로 처리가 아니고 이번에는 opcode를 보고 여기서 다음 상태로 뭘 갈까는 현재 어떤 상태에 있는가와 그리고 opcode가 뭔가 까지 물어본다. 그다음에 여기서 다음상태로 어떻게 ..? 2번상태에서 갈수있는 상태는 opcode를 보고 이렇게도 저렇게도 갈수가 있다. opcode를 보고 
다음 상태는 몇번인가는 1. 현재 상태가 몇번인가 2.opcode가 몇번이가 그거에 의해서 결정된다. 그러면 그 상태에서 밖으로 출력해야할 제어신호들은 어떤신호들인가 그 상태가 가면 이미 거기에 다 제어신호값이 약속이 되어있다. 우리가 기계를 이렇게 만들었다. 여기서는 2번 상태에 가면 alusrcA,B가 opcode를 이런값을 내보낸다.
자동적으로

이런기계가 있고 상태를 정의해준다 10개의 상태, 0~9 까지 0번에는 신호를 이렇게 내보내줘야 합니다. 거기에 명세하는거 그렇게 어려운일이 아니다. 그렇지. 그다음에 여기서 여기로 갈때에는 이런 opcode의 조건이 만족해야 가는겁니다. 이거 명세하는거 어려운일 아니다. 그렇게 해서 만든것이 유한 상태 기계한 멀티사이클 제어 시스템이다. 이앞으로 조금 돌아와면 전원이 들어오면 instruction fetch, decord 자동적으로 쭉 두사이클.

그다음에 여기는 메모리 access면 메모리 access에, R-format이면 R-format에 해당되는 스텝들이 있다. 메모리 access는 하나 둘 셋, 로드일경우는 셋이다. R타입일 경우는 2, 브랜치는 하나  점프하나 이다.

## Diagram
고민없이 clock이 떨어지면 하는게 1,2 step이다. 그다음에 다음갈때는 갈수있는 state가 여러가지 있는데 opcode를 보고 간다. opcode에 해당하는 부분에 마킹을 한다. 상태에 붙일 이름이다.
우리 편의를 위해서 붙인 이름이고 	시스템 안에서는 번호가 더 중요하다. 

그래서, 메모리에서 읽어서 내야대 instruction을 ALUsrcA =0 PC를 4만큼 증가시키기 위해서 PC가 A의 input으로 들어가야함
iorD는 메모리 파트 어드레스로 PC가 들어갈수도있고 저쪽에서 다른 ALUout이 들어갈수도 있으니까 거기에서 pc가 들어가게끔 해줘야 한다. irWirte는 이거는 메모리에서 나온 instruction이 irbuffer에 담기도록 
ALUsrcB는 PC+4의 4를 선택해주기 위해서 
ALUoperation 00은 괄호하고 add라고 적자
pcWrite는 pc+4로 값이 바뀐다. 
pcSource는 pc로 들어갈 수 있는 값이 pc+4일수도있고 브랜치addr이 들어갈수도 있고 점프어드레스가 들어갈수도이다. 

그다음에 디코드 에서는 간단하다. 여기서 ALUop는 opcode에 따라서 처리하라는 의미다. add, function code를 봐라 라는 의미이다. A와 B의 값은 레지스터A와 B에서 나온값이 선택이 되어야 하고 여기서 A는 0,1 둘중하나에서 선택하는것이고 B는 0,1,2,3 4비트에서 하나 선택한다. 이진수인데 11이 아니라 레지스터 B에서 나온값을 받아들이기 위해서 했다. 그담에 여기까지는 고민없이 왔는데 다음에는 opcode를 보고 다음 스텝을 결정한다. R-type이다 그러면 opcode 6bit가 0이다. r-type이면 6번으로 간다. 넥스트 state는 커런트 state와 opcode를 보고 넘어간다. 두개를 보고 결정한다. R-type execution이다. 당연히 
(*참고로 2번 state에서 op는 opcode dependent가 아니다. 6번부터가 opcode dependent다. 특히 얘는 r-type이므로 function code를 함께 봐야한다.)
그 다음에 소스A,B 
만약에, 현재 1번에 있고 opcode가 load/store면 당연히 2번으로 가야하고 address 계산해야하고 source A,B.. 맞나봐라 맞다.
현재 2번상태에 있고 opcode를 봤더니 store다. 5번으로 간다. 일일이 보면 아주 쉽다.  
/*메모리 address에 ALUout의 값이 전달된다*/
현재 state가 5이고 다음 state는 store명령이 완전히 완료된 상태이고 한명령어가 끝났으니까 그다음 다음 명령어를 다시 시작해야한다. 그러면 고민할것없이 0번 state로 간다. 
현재 state가 8이다. branch를 완료한것이다. 다음 state도 0번으로 간다. load 끝나면 가고 branch가 끝나면 가고 자기 cycle만큼 소비하고 바로바로 돌아가게끔 되어있다.
