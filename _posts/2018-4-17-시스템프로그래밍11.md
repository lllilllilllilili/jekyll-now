---
post : layout
title : 시스템프로그래밍11
---
## 시스템프로그래밍11
시스템프로그래밍11

## Critical Section
쓰레드가 인테저 베리어블을 하나를 공유를 해서 한쪽에서 ++ 또다른 한쪽에서 --해도 결과값이 race_condition이 일어나면 결과값이 다르게 나올 수 있다. 그래서 한쪽이 하는동안에 다른것이 돌아가면 안되고 다른 한쪽에서도 돌아갈때 반대편께 돌아가서는 안된다. 번걸아가면서 돌아가면 결과가 틀리게 나올 수 있다. 아주 드문일이기 때문에 디버그가 힘들다. 

critical section을 양 프로세스간에 지킨 프로세스가 필요하다. 어디가 critical section인지를 알아야 한다. 

## Mutex(Mutual Exclusion) Variables
프로세스 프로세스 혹은 쓰레드 쓰레드 간에 공유하고 있는 부분이 양쪽에 critical, 상호간에 critical 하다면 (다른 사람하고 상관없음, 한 아파트내에 하나의 화장실을 사용하면 문제가 되지 각각 집에 화장실을 쓴다면 전혀 문제가 되지 않는다.)

한 프로세스가 critical section안으로 들어와 있다고 한다면, 그때 스케쥴링이 일어날 수 있다. cpu가 2개인경우, process A가 critical section까지 왔는데 Process B로 스케쥴링이 일어나면 B는 A가 화장실을 다 쓸때까지 기다려야 한다. 
그래서 A가 들어간 시점부터 B는 block이 되버린다. cpu를 내놓고 뻗어버린다. block 된것을 ready로 만들어주는것을 wake up 해준다. (화장실에서 나가면) 그것이 Mutual exclusion이다.

## Mutex(Mutual Exclusion) Variables
pthread에 Mutex 라는 variable을 만드는데 화장실의 이름을 붙이는것과 같다. 
화장실을 share하기 위해서 이름이 필요하다. 들어갈때 lock을 하게 되는데 여기서는 잠근다 라는 의미가 아니라 남이 들어올때 체크하고 없으면 들어가서 문을 잠그고 있으면 block된다. (lock의 의미)
lock을 해서 들어가서 화장실 문을 잠그는것을 ++mutex를 잠궜다 라고 하기도 하고, lock을 소유했다. 해서 lock a mutex 또는 own a mutex 라고 한다.++
커널은 critical section의 덩어리다. 
화장실이 3개가 있다고 가정하면, 화장실 각각에 대해 줄을 서지만(mutex 3개) 
다른 화장실에서는 한줄로 선다. (mutex 1개지만 3개의 프로세스가 들어갈 수 있다., resource 3개)

## Mutext Variables
Order of using a mutex
Mutex variable을 하나 만들고 이름을 붙인다.
애초에 화장실문은 열려있다. 아무것도 안들어간 상태로 초기화를 하고 
여러개의 thread가 mutex에 대해 lock을 try 하려 하지만 동시에 화장실에 도착하는 경우는 하나만 성공한다. 나머지는줄을 서서 기다린다. 순서대로 깨워주게 된다. 그런 프로토콜이다.
양 프로세스에서 lock이랑 unlock을 해줘야 성립하는것이다. (프로토콜) = Mutual exclusion
한 프로세스만 지켜서는 소용이 없다.

lock이 있고 unlock이 있는데 들어갈때 lock을 하고 사람이 있냐 물어보고 있으면 block되고 없으면 들어간다.
나올때는 unlock이라고 한다. 

## Creating/ Destroying Mutexes
trylock : 없으면들어가서 lock을 걸고 있으면 error return 되기 떄문에 block 되지 않고 다른 화장실로 가겠다.
block 되지 않는게 포인트.

pthead mutex 초기화를 진행할때 mutex에 attr을 주는데 attr 는 뮤텍스에 속성이 있다는 말인데 속성은 두가지가 있다. 프로세스간에 쓰는 뮤텍스인지 쓰레드간에 쓰는 뮤텍스인지 리눅스에서는 프로세스간에 쓰는 pthread mutex는 없다. 그러니깐 쓰레드끼리 쓰는 거라고 생각하면 된다. attr가 필요없다. null이 default다.
뮤덱스를 다썻으면 destory 하고 

type으로 struct 구성된 pthread_mutex_t 이렇게 쓴다.
pthread_mutex_t mymutex=PTHREAD_MUTEX_INITALIZER
또는 
pthread_mutex_init(attr)로 해도된다. 초기화한다는것은 화장실을 비워둔다.
채우면 아무도 못들어가니까!

## Mutex
화장실에 들어갈땐 lock을 하고 화장실 이름을 준다.
만일에 누가들어가있을때 다른데로 가고 싶으면 trylock을 한다. 화장실이름을 준다.
화장실에서 나올때는 반드시 unlock을 해야한다. 프로그램을 여러개의 쓰레드 짜고 unlock을 잊어버리면 그러면 그 프로그램은 그냥 죽어버린다. 서버린다. 기다리는애들만 생기니까 진행을 못한다.

반드시 lock을 하면 unlock을 해야한다.

## Advisory Mutex
서로 지켜야 된다. Thread1, 2, 3가 돌아가는데 
A를 공유하고 있고 어떤게 먼저 돌아가냐에 따라서 결과가 다 다르다.
그래서 A=2 집어넣고 다 Critical section인데 
Thread1과 2는 unlock을 했다. 
thread3은 lock , unlock을 하지 않았다. 이 프로그램을 깨진다.
3개가 같이 지켜줘야 한다.

## Example : Using Mutexes
array를 vector 라고 생각하자.
내적, dot product 각각 20 
vector가 dimension이 400이다. 
a는 0부터 399
b도 0부터 399
내적을 구할려면 곱하기를 400번 해야한다. 컴퓨터가 cpu가 4개있는거라고 하면, 쓰레드를 4개를 만들어서 100개씩 나눠서 하자. 그래서 쓰레드1은 0~99 더하고 그리고 mysum에다 계산을 한다. thread2는 100에서부터 199까지 ai+bi해서 mysum에다 집어넣는다. 4개의 thread가 100개씩 나눠서 계산한다. 빨라진다.

mysum은 thread안에 있는 local variable이다. stack에 잡힌다. thread는 stack을 따로쓴다.(데이터는 같이쓴다.)
thread 4개가 있는게 각각 다른 variable이 할당된것이다. mysum에다 집어넣을때 critical section이 아니다. 공유하는것이 아니다. 그래서 total에 다 더해줘야 총합값이 나올것이다. total은 global variable이다. thread 4개가 같이 써야 하는거니까 ++total을 건드리는 부분은 critical section이다++
total이 critical하니까 mutex로 보호를 해줘야 한다.

## 프로그램설명
type define struct, dotdata를 만들었다.
400개의 array의 주소를 가질 포인터다. 
두번째 vector의 주소를 가진 포인터다.
sum 이라는것은 최종적으로 결과를 산출해낼 variable이다.
vector length 100이 들어간다(원래는 400인데 나눠서 처리)

쓰레드를 4개를 만들고 한쓰레드가 계산할 vector의 length는 100개씩 나눠서 계산하자.
쓰레드 4개를 만들거니까 pthread struct 4개가 있어야한다. id를 받아와야 하니까
dotstr은 global variable이다. main이 안나왔음. (struct 전부가)
mutexsum도 global variable이다. 화장실의 이름이다.

main을 보면 double *a, *b해서 pthread attr 해서..
double을 400개 할당하고 있다. a포인터에
마찬가지로 b포인터도 400개를 할당하고 있다.

편의상 1로 초기화하고있다.(for문) 아무값이나 상관없음
벡터들을 초기화 하는것이다.

global variable에 값을 집어넣어야 한다. dostr.veclen = VECLEN; 100을 넣는다. 
malloc한 a의 주소를 struct의 a에 넣고 b도 마찬가지
내적 합계 sum을 0으로 초기화 한다.
나중에 쓰기 위해서 mutex를 초기화한다. 이때 attr는 NULL을 준다.

thead를 만드는데 joinable 이런것은 필요없다. thrae를 creat할때 attr을 null로 주면 joinable thread으로 만들어준다. joinable thread는 끝나는것을 기다릴수있는 thread다. 
thread를 4개를 만드는데 4개가 돌아가는 funct 함수는 dotprod 이다. argument로는 i가 넘어간다. i는 0,1,2,3 이 넘어간다. 쓰레드마다 0,1,2,3 을 4개로 만들어서 각각 argument로 줘서 돌린다. attr은 안쓴다.

4개의 thread가 끝나기를 기다린다. ptrhead_join 이다. loop을 돌면서 하나씩  thread에 대해서 끝나기를 기다리는 loop을 돈다. 끝났으면 결과가 나온다. 마지막으로 mutex를 없애고 나온다.
문제는 dot product가 4개가 생기는데 dotprod 함수는 argument로 0,1,2,3 을 받는다.
mysum은 local variable 이다. critical 하지 않다. thread 4개가 다 따로따로 가지는 variable이다.
argument가 0이 들어오면 argument를 offset에 집어넣고 길이는 100이 들어간다 start는 offset* length
0에서부터 end는 100까지다. argument 가 1이 들어오면 100~200 2이 들어오면 200 ~300 3이 들어오면 300~400 하겠다. 
++dotstr에 a,b의 array의 주소를 x,y로 가져오고 이 주소를 가지고와서 array로 사용해도 상관없다. ++
start 와 end가 0~99 100 ~199 200~299 300~399

내적을 구하는 과정이다. 100개짜리 내적을 구해서 mysum에다 집어넣는다.
각각 thread가 계산한 결과를 mysum에 넣는데 mysum은 local variable이니까 다 다른variable이기 때문에 전혀 신경을 안쓴다. 그리고 이것을 mysum계산한것을 global variable인 dotstr의 sum에다 (global variable) 누적을 시킨다. global variable에 thread 4개가 한꺼번에 건드리면 문제가 생기는 화장실이다. 그래서 앞과 뒤에 pthread mutex lock을 unlock을 했다. 그리고 나서 pthread를 종료한다.

다시한번, Mutex를 안썻다 그러면 값은 제대로 나올수 있는데 가끔가다 틀린것이 나온다.
디버깅하기 어렵다. critical section(thread 4개가 도는것)그래서 반드시 mutex 보호해줘야 한다.
빼먹으면 제대로 나왔다가 안나왔다가 하기때문에 디버깅이 어렵다.

## Condition Variables
synchronization(동기화) : 장을 보러가고, 생일파티가고 누가 먼저끝날지 몰름. 둘이 만나서 일을 처리해야 끝나는것을 알 수 있는데 그게 synchronization이다. 
어떤 프로세스의 진행이 다른 프로세스의 영향을 미친다.반드시
mutual exclusion은 화장실을쓰고 있으면 다른 사람이 쓰지 못하다싶이 영향을 받으므로 synchronization이다. 여기서 말하는 synchronization은 condition을 의미한다. 
++condition은 깃발들때까지 꼼짝말고있어++
++기다려라! 깃발을 들면 그때서부터 진행해라 = condition variable++

condition variable은 critical section하고 같이쓰인다. mutex 하고 같이 쓰이게 된다.
condition을 기다리고 있다는 말은 condtion이 true가 될때까지 block 되어있다.
condition에 대해서 true가 되면 깨어난다. 그것을 condition을 기다리는것을 wait라하고 condition을 true로 만들어서 저쪽에서 깨워주는것을 signaling 한다. signal을 보낸다. signal을 줌으로써 깨운다.

## Creating /Destroying Condition Variables
condition은 이름을 줘서 만들고 
init 단계는 깃발이 내려간 상태로 초기화 하고 attr은 null을 준다.
condition을 다썻으면 destroy 하고 
attr을 만들고 destory하는것은 뺀다. 

pthread_cond_t 라는 타입으로 이름을 myconvar 만들면 PTHREAD_COND_INITIALIZER 해서 초기화를 하던지
pthread_cond_init(condition,attr)을 줘서 초기화한다.(단 attr null로)

## Waiting / Signaling on Condition Variables
condition 하나 만들었으면 pcondition을 저쪽에서 condition에 대해서 signal을 줄때까지 내가 block 되어가지고 기다리는것을 pthead_cond_wait 라고 한다. condition을 보내줄때까지 block되서 기다리겠다. argument로는 condition의 주소가 들어간다. 빨간글씨로 mutex가 들어가는데 나중에한다.

어떤 condition에서 기다리는 놈을 깨워주는 것을 ptrhead_cond_signal call하면 이 condition에서 기다리는놈을 꺠워준다.

broadcast는 만약에 condition을 올라가길 기다리는게 thread가 여러개 있다그러면 그것을 한꺼번에 다 깨워주는것이다. 위에서는 pthread_cond_signal은 여러개가 기다리면 차례대로 하나씩만 꺠워주는것이고 broadcast는 한꺼번에 다 깨워준다. 

# Producer/Consumer Relationship in Pthreads
concurrent 프로그램을 잘짜기 위해선, 유명하게 등장하는 몇가지 문제를 잘 이해해야 한다. 그중에서 lesson 1이다.
Producer/Consumer relationship 프로그램 짜는것인데 
파이프할때 나온 용어다(Producer/Consumer) 파이프에서는 집어넣는놈이 있고 빼가는놈이 있다. 파이프는 커널이 제공 커널이 제공하기때문에 mutual exclusion이 필요가 없다. 파이프가 만들어야 하는경우가 많다. 직접
이것은 직접 만드는것이다.

Producer는 데이터를 직접 생상하는 애고 Consumer는 데이터를 가져다가 처리를 하는 놈인데 그 두개가 다른 thread로 되어있는 경우가 대부분이기 때문에 속도 차이가 나니까 중간에 버퍼가 있어야 한다. 상류에 비가 많이오면 댐을해서 막아놓듯이 버퍼가 있어야 한다. 그게 Producer Consumer relationship이다.

## Producer/Consumer Relationship(2) 그림
자료구조시간에 큐를 가져다 원형 큐를 형성해서 바운디드 서큘러버퍼, 바운디드 버퍼, 링 버퍼 라고도 한다. 이것을 두개 쓰레드 간에 만든다. 그림을 보고 설명을 하면 

Producer thread다. process가 아니라,
producer thread가 돌아가면서 계속해서 ??? loop을 돌면서 데이터를 생성해낸다. 데이터를 생성한후 처리를 하기위해서 파이프 라인으로 consumer에게 보내서 처리하게 되는데 consumer도 따로 돌아가니까 데이터를 처리하는 속도가 서로 다르다. (스케쥴을 어떻게 받을지도 모름) 그래서 중간에 완충지대를 주는데 중간에 큐를 하나 만든다.
array에 큐를 하나 만들어서 집어넣는것은 큐에 rear 라고 하고 끄집어내는것을 front 라고 한다. 

처음에 확인하고 싶은것은 왜 thread를 두개로 짜냐? 하나로 짜지. while loop 돌면서 데이터를 생산해내고 처리하고 를 반복적으로 하나의 thread로 처리하면 안될까? 왜 구지 thread를 2개로 짜서 힘들게 할까! 그래서 중간에 버퍼를 왜 두냐 골치아프게

while(1){
		생산..
       	처리..
}
이렇게 하면 좋겠지만 일종에 파이프라인 프로세싱이다.
프로듀서 할 때 시간이 디스크에서 읽어오는것이라고 치면 데이털르 생산하는것이 
이것을 처리하는것은 계산하는것으로 치자. 계산하는것은 cpu를 쓰고 반대쪽은 디스크를 쓴다.
그러면 두개가 동시에 돌아가면 빨라진다. 빨리지는데 하나로 하면 동시에 돌아갈 수 없다.  디스크에서 읽을때는 cpu가 놀고 cpu가 처리할때는 디스크가 노니까 느려진다. 
++자동차를 만드는데 공정이 2개인것으로 정리할 수 있다. 한쪽은 문짝만 붙이고 다른 한쪽은 엔진을 붙이는것이다. ++
한쪽에서 문짝 달면 엔진 다는애는 쉬고, 엔진 다는애가 일을 하면 문짝은 쉬면 시간이 오래 걸리니까 5번쨰 자동차에 엔진을 달고있을때 6번째 자동차에 문짝을 붙이고 있어야지 parallel processing이된다. 
분업을 하니까 빨라진다. 동시에 일어나기위해서, 위에서는 분업을 하는것이 아니다.
Pipeline processing 이다. thread로 나눠서 한다.

네트워크다 라고 하면, 다른 한쪽은 네트워크에 다른곳에 존재하니까 다른 프로세스와 쓰레드 일수밖에 없다.
둘다 cpu를 쓴다하면 그래도 분업하는게 낫다. cpu가 2개 있으면 동시에 돌아갈 수 있으니까 2개 일수도있고 하나라도 내가 thread를 두개를 만들면 스케쥴을 자체적으로 받을 기회가 높아진다.
여러가지로 분업을 하는것이다.
분업을 하다보니까 버퍼가 생긴다.

내가 문짝을 붙인다음에 넘기면 엔진을 붙일텐데 엔진을 붙이는 쪽에서 일을 늦게 처리하면 밀릴것이다. 그게 버퍼다. 따로따로 돌아가니까 속도의 차가 날수밖에 없다. 중간에 반드시 버퍼가 있어야 하고 pipe 라는 대표적인 예가 있다.

두개가 쓰레드면 두개의 쓰레드가 뭘 공유하느냐 를 알아야 한다. 공유하면 화장실 문제가 생긴다.
보호하기 위해서 mutual exclusion이 필요하다. 데이터를 생산하는것을 따로, 소비하는것을 처리하는것도 따로다 의미
++집어넣을때 array는 공유되지 않는다. 집어넣는데랑, 꺼내가는곳이 다르기 때문이다.++

무엇을 공유하는가? 데이터를 집어넣을려 하는데 받는쪽에서 느려서 버퍼에 꽉차버리면 프로듀서는 기다려야 한다. 컨수머가 데이터를 가져가서 빈칸이 생길때까지 기다려야 한다. 버퍼가 꽉찼는지 안찼는지 알아야 한다.
그것을 count라고 하면 count 라는 variable이 버퍼(array가 100짜리) count가 100이 된다하면 버퍼가 꽉차있다. 그래서 기다려야 한다. 데이터를 하나 집어넣으면 count를 ++ 한다. count가 100이면 기달려야 한다. 거꾸로 consumer process는 데이터를 가지고 올려하는데 프로듀서 프로세스가 데이터를 넣는것을 너무 늦게 처리해서 버퍼가 비면 또 기달려야 한다 데이터가 들어올때까지
count가 0이면 기달려야한다.

버퍼가 100인데 count가 50이다 라고 치면, 데이터를 가지고 나가면서 count를 -- 해야한다. 
count가 100이냐를 봐야하고, 데이터를 집어넣으면 count ++하고, 반대쪽은 count가 0이냐를 테스트해봐야하고, 그렇지않으면 데이터를 끄집어내고 count --한다. count variable을 공유할수밖에 없다.
++배웠던 mutual exclusion이 필요하게된다.++

그래서 다른건 share 하지 않고 count가 shared variable이다. mutual exclusion이 필요하게 된다.

## Producer/Consumer Problem in Pthreads
가장 전형적인 예로
++mutual exclusion만 요구되는게 아니라, 조금전에 condition에서 나왔던 synchronization도 필요하다. 
프로듀서가 데이터를 집어넣을려하는데 count가 100이다. 그럼 기달려야 한다. block 상태가 된다. 빈칸이 생기면 꺠워줘야 한다. 빈칸을 만드는것은 consumer는 데이터가 가져가야 만들어야한다. 빈칸은 consumer 가 만든다. 따라서 consumer가 빈칸을 만드면 기다리고있는 프로듀서를 깨워준다. 이게 synchronization이다.++
++아까 말한 condition이다. 빈칸이 생겼어 너 들어가도대! ++

거꾸로도 있다. count가 0이면 consumer process는 데이터가 없으니까 block되서 기다린다. 그것을 깨워주는것 producer 가 데이터를 집어넣으면서 데이터가 생겼으니까 꺠워줘야한다. 여기에는 mutual exclusion도 필요하고 프로듀서가 컨슈머도 꺠워주는 synchronization도 필요하고, 컨슈머가 거꾸로 프로듀서를 꺠워주는 synchronization도 필요하다.  (총)

이 프로그램은 mutex, 화장실 이름이 하나 있어야 하고
synchronization할때 condition을 쓴다. condition이 두개가 필요하다. (서로깨워주는데 필요한 condition이다.)
producer -> consumer
consumer -> producer을 깨워주는

count 라는 variable 때문에 화장실의 문제가 생기고 mutual exclusion이 필요하다고 했고, producer가 기다릴땐 comsumer가 깨워줘야 하고 consumer가 데이터가 없으면 producer가 데이터를 넣어서 깨워줘야 하기 때문에 condition variable이 두개가 필요하다.
달달 외워야 하는프로그램

위에는 global variable로 thread가 공유한다.
in은 집어넣는 포인트 뒤에보면 ++ 됨 out은 끄집어 나감
화장실 이름은 mutex, codition의 이름은 2개가 필요하다. 하나는 buffer_has_space 버퍼의 공간이 있다, 없다?있느냐 라고 물어보는 condition이다. (프로듀서가 집어넣을시) 마찬가지로 아래는 데이터가 있느냐 없느냐(consumer가 읽을때 필요한 condition) mutex1개와 synchronization을 위해서 condition을 2개 잡았다.

pthread_t로 array 2개 만들고,ptrhaed_creat 로 프로듀서 만들고 컨슈머를 만든다.
argument는 없다. 
두개의 thread가 끝날때까지 main thread에는 기다리고 있다. pthread_join으로
producer와 consumer 서로 대칭적이다.
일반적으로 이러한 프로그램은 무한 loop을 돌거나, message가 크기 때문에 여러가지 처리가 있겠지만 여기서는 loop 1000번을 시행한다.(for loop)
i=0 ~ 999까지 돌면서 데이터를 버퍼에 집어넣고있다.
데이터가 i다. for loop 도는거 자체가 데이터 생산이다. 데이터 생산 하는것은 디스크에서 읽어오는것일수도있고
네트워크에서 받아오는것일수도있고  덩어리가 크다. 여기서는 for loop에서 i가 데이터라고 가정하고 생산하는것이다.
1000번 loop을 돌면서 데이터를 생산했다.++ producer는 그다음에 count가 100이 되면 buffer가 꽉찼다는 의미++
그래서 기다리게 된다. 버퍼가 빈공간을 가지게 될때까지 나는 block된다. 버퍼가 꽉찼으니까

count 를 쓸려고 하면 count 자체는 화장실이다. count를 들여다 보기전에 mutext lock을 걸어야 한다. 카운트가 50이면 건너뛰고 죽지않고 넘어간다. in++ 하고 100 모듈러취해서 저장한다.(100이면 한바퀴 돌아온것이다.)
버퍼 in에다 i를 넣고 count++(데이터가 하나증가)한다. count 100이라서 기다리면 consumer가 꺠워줘야한다.

consumer는 데이터를 하나 꺼내왔기때문에 pthread_cond_signal을 producer에게 보내준다. 꺠워주는역할을 한다.
여기서 pthread_cond_wait는 pthread_cond_signal에 의해서 깨어난다.

count가 0이면 기다린다. pthread_cond_wait를 하는데 buf가 데이터를 가지게 될때까지 기다린다. 얘를 깨워주는것은 producer에 pthread_cond_signal이 깨워준다. signal을 보내서 ++ 상호간에 서로 꺠워주게 된다.)

그래서 count를 읽기 시작해서 count를 ++ 한데가 critical 하니까 mutext unlock을 하고서 다시 락을 풀고 데이터를 생산하대로 올라가서 또 다음 i를 가지고 이런일을 시행한다.
반대쪽도 마찬가지다. 기다리다가 깨어나서 데이터가 생기면 out ++ 하고 버퍼에서 out에서 데이터를 가져다가 처리하는것이 처리가 복잡하다. 여기서는 count--; 혹시 producer에서 기다릴지도 모르니까 signal을 보내줘서 깨워준다.
빈공간을 하나 만들었기 때문에

두개의 쓰레드로 해서 동시에 돌어갈 수 있는 구분은 뭔가? 이익보는것이 뭔가?
mutual exclusion lock해서 unlock 할때가지 내가돌땐 상대방에서 못돈다. 얘가 돌때 상대방도 돌수있는것은 for안에 i가 생성되는 부분과 print하는 부분은 따로따로 둔다. 그것은 같이 돌 수 있다.
여기서는 문장이 짧아서 효용성이 없지만, 엔진붙이는것이다. 저기엔 문짝 붙이는것이고 그게 overlap이 되는것이다.

for loop위에 mutex_lock를 돌리면 thread 프로그램을 짤필요가 없다. 1000개 집어넣는 동안에 못돌아가는거니까 lock은 필요할때 최소한으로 건다.

그다음에 buffer개가 50개밖에없다. 데이터가 잘집어넣고 잘가지고 가는중이다. 들어오면 count == 100, 0 둘다 스무스하게 통과할것이다. 데이터가 잘 돌아가고 있는데 잘돌아가면 기다리고 있지 않은데 그럼에도 불구하고 signal을 보낸다.필요가없다. 이경우는 원활하게 돌아가는 상태에서 기다리고 있지않으니까 signal이 필요하지 않다.
++따라서 condition signal은 무슨 특징이 있냐하면 ++ signal은 무조건 보내고 있다. 기다리는놈이 없을땐 아무효과가 없다.
반대쪽도 마찬가지다. 기다리고 있지 않으면 아무소용없다. condition signal을 보낸것은 size가 안든다. 기다리는놈이 없을때 pthread_cond_signal은 사이즈가 안든다.
쌓이는것도 나중에 존재한다.
예를들어서, 내가 편지보내면 그때마다 한번씩 푸시업 100번하고와 치자. 편지를 보내면 안기다리고 있더라도 main box에 쌓이는데 딴짓하고 있더라도
편지가 3통이 쌓이면, 푸시업 300번 해야한다. 그런것은 쌓인다.
signal을 보냈는데 

++이것은 기다리고 있을때 딴짓하고 있으면 없어져버린다.++  따라서 이건 zie가 안느는것이 있고 mail을 우편으로 보내게되면 쌓인다. 그런 syncronization도 있다. 전자와 후자가 프로그램 짜는게 달라진다. size가 쌓이지 않기때문에 프로그램을 ppt에 있는것처럼 구성할 수 있다.

나머지 하나는 pthread_cond_wait에 mutext 가 빨갛게 들어간 이유
count를 쓰니까 mutex lock을 걸고 들어갔다. cond_wait를 하는데 위아래로 mutex를 했다.
잠을 잘때 나를 꺠워줄 사람이 들어와야 하기 떄문에 안방문을 열어놔야 한다.
cond_wait하는것은 block이 되는데 signal을 보낼줄때까지 꺠워줄떄까지 블락이된다. 블락이됬다는것은 cpu가 다른데로 가버림 block이 되는 시점에 lock이 잠겨있다. 화장실이 잠겨있다. 화장실이 잠긴채로 block이 되면 깨워줄쪽은 consumer인데 signal이 안으로 들어와서 꺠워 줄수없다.
못들어간다. 위에 화장실이 걸렸기 때문에 
프로그램이 안돌아간다. 
++ 화장실 문을 잠꿧어, 잠구고 나서 block이 되어버렸다. cpu는 다른데로 가버린다(block시) 다른거돌다가 다시 왔다. mutex라니까 들어갈수가 없다. cpu도 블락되고 wait도 block된다. 두개가 다 block 되면 꺠워줄 놈이 없으니까 프로그램이 안돌아간다. 데드락이라고 한다. 외나무 다리에서 후진기어가 없는 차가 둘이 만났다. 끝까지 쨰려보다가 끝난다. 프로그램은 뒤로가는게 없으니까++

그러니까 나를 꺠워주는 놈을 위해서 내가 block이 되면 lock을 풀어야 한다. mutex에 이름을 쓴것은 요 mutex에 대해서 lock을 걸었는데 이때는 lock을 unlock해달라는 의미다. 풀어달라는 의미 왜? 이제부터 잠을 잘꺼니까!

block이 되면 consumer가 들어오면(cunsumer의 시그널) for문 안으로 들어올수있다. 그래서 데이터를 끄집어 내가면서 space가 하나 생겼으니까 signal을 하나 보내면 보내는시점에서 pthread_cond_wait이 살아날것이다. 화장실안에 두개가 들어왔다. (또다른 문제) ptrhead_cond_wait도 꺠어났고 pthread_mutex_unlock 도 꺠어있는 둘다 화장실 안에 있다. 깨울려하니까 화장실에서 잠자고 있으니까 할수없이 들어와서 꺠운것이다. 화장실 안에 2명이 있게된다.
둘이 돌아가면 문제가 생기기 때문에 이런 system만들때는 한쪽이 깨워주면 꺠운 쪽(signal)은 잠시 block이 된다. 더이상 진행을 하지 않는 block이 되고, signal이 꺠어나서 cirtical section까지 맞출떄까지 기다렸다가 얘가 마치면 그때서 부터 다시 시작한다. 깨워주고 나서 	잠시 화장실 밖으로 나가서 다시 기다린다. (깨워준 놈의 화장실에서 나올때까지)

거꾸로 ...
좌우지간 꺠워줬다 그러면 둘이 같이 돌아가면 안된다 일반적으로 시그널을 보내는걸 ++시그날러++ 라고하는데
시그날러가 기다려주는것이 보통이다. 그래서 mutex라는것은 내가 block 0을 기다렸는데 block 이 될때는(문을 열어) mutex를 unlock해(문을 열어) 그러나 내가 다시 살아나면 lock을 걸어야 한다. 남이 못들어오게
꺠워났을때는 다시 lock 을 걸어달라. 그래야지 밑에서 unlock하는것이 맞다. 
블락이 될때는 unlock을 시켜놓고 signal에 의해서 깨어나면 다시 lock를 건다.
그러면 lock을 걸었기때문에 돌면 안된다. unlock할때까지 기다렸다가  signaler가 다시 수행할 수 있다.

++
block이 될떄는 unlock을 시켜놓고 시그날러에 의해서 깨어나면 다시 락을 걸어달라 
그러면 lock을 걸었기 때문에 돌면안되고 바깥에서 기다려야 하고 unlock을 할때까지 기다렸다가 signaler가 다시 수행할 수 있다.++

이게 제일 어렵다 1과다.
condition signal이랑 mutex를 만든이유는 접근하기 쉽다. 프로그래머 입장에서
의미가 쉽게 와닿기때문에 위와 같이 설계하였다. 

## 
파이프는 4k짜리로 커널이 만들어준건데, integer 하나씩 집어넣는데 우리가했던 파이프는 4byte를 8byte 길이를 변이적이로 쓸수있다. 

라이브러리를 만든다. 라이브러리를 펑션의 집합이다. math 라이브러리 라해서 sin 함수를 만들었다고 하자. sin 함수를 만들어서 잘 돌아갔는데 유저들이 쓰레드가 여러개인 프로그램을 짯다. 여러개 쓰레드가 sin을 한꺼번에 call 할 수 있다. 그러면 제대로 돌아갈려나?

쓰레드1이 sin function 안으로 들어온다. 들어왔는데 스케쥴링이 일어났다.
sin이 잠시 중단이 된 상태에서 다시 쓰레드 2가 들어온다. cpu가 2개라고 생각하면 sin속으로 thread1 도 들어오고 thread2도 동시에 들어올 수 있다. 하나랑 둘이나 마찬가지다 문제가 생기는것은 
sin이 그냥 function이라하면 global variable인 y를 그냥 쓴다고 하면 문제가 된다. 
쓰레드 1과 2가 global variable y를 공유하니까 critical section 문제가 생긴다.
sin에서 global variable을 쓰면 문제가 없다. 그런것을 안쓰면 멀티쓰레드세이프 라고한다. 또는 쓰레드세이프라고한다.
여러개의 함수가 함수를 한꺼번에 불러도 안전한 함수는 쓰레드 세이프리스가 있다. (멀티쓰레드세이프리스)
이런경우에 global variable을 쓰면 안된다. sin은 global variable을? file open시에는? 안쓰는데 에러 넘버를  global variable로 쓰기때문에 그것은 조심해야 한다.
라이브러리를 누군가 만들어서 제공을 하면 이건 멀티쓰레드 세이프 하는 라이브러리 입니다. 이것은 세이프 하지 않은 라이브러리 입니다. 라는 것을 얘기해줘야 한다. 왜냐하면 라이브러리 안을 자기가 들여다 볼 수 없으니까
++ global variable을 안쓰는것이 멀티 쓰레드 세이프를 지원하고 global variable을 쓰는것이 멀티 쓰레드 세이프를 지원하지 않는다.++
++라이브러리는 기본적으로 멀티스레드 세이프 하게 만들어진다. 만약에 y를 쓰겠다하면 y 위 아래로 mutex를 걸어야 한다.
그래야 멀티스레드세이프가 된다. 
만일에 global variable을 쓴다 그러면, mutex lock을 걸고 mutex unlock을 해줘야지 여러개의 스레드가 이 펑션을 콜해도 안전하다.++

그런데 c++, 자바에서 class가 나오는데 class로 라이브러리 만드는데 클래스라는것은 안에 data store (static하다.) 멤버 펑션이 있다.(여러개있다.) 이 클래스를 가져다 스레드 여러개 한꺼벗에 똑같은 멤버펑션이나 다른 멤버펑션콜해도 마찬가지다.
멤버펑션 A, B있으면 한놈은 스레드가 T1, T2가 있는데 멤버펑션은 data store를 건들인다. 클래스 속에 data store, primary data variableㄷ 등... 북박이다. static이다. 없어지는것이아니다. 함수를 나간다고 해서 안없어진다. 그러니까 mutex가 필요하다. class의 멤버펑션을 라이브러리로 만들라고 하면
mutex를 자동으로 해주는것이 자바에 한 스레드 하나가 들어있으면 다른 스레드가 들어오면 안된다. 다른 스레드가 다른 멤버펑션을 콜하더라도 같이 data store를 건들이니까 critical section문제가 생긴다.

++
class 속에 멤버펑션이 여러개 있으면, 멀티 스레드 세이프 할려고 하면 class안에 스레드는 한번에 한번밖에 들어오지 못한다.++ 그게 자바의 synchroniza object 이다. (ppt 보기)
멀티스레드가 그 클래스 속에 멤버 펑션을 갖다 콜하는데 여러개가 콜하면 data store을 공유해서 문제가 생기기 때문에 한번에 하나밖에 못들어 온다.
그게 자바의 syncronize object이다. 

멀티스레드가 들어와도 괜찬은 라이브러리 루틴은 reentrant 라고 한다. 재진입이란 말이다. 재진입은 thread1이 sinx로 들어와서 다 끝마쳐지지 못했는데 스케쥴링이 일어나서 쓰면 2가 재진입을 한다. 그래도 제대로 돌아간다고 해서 reentrant라고 한다. (=멀티스레드 세이프 하다란 뜻이다.)

커널에 시스템콜을 배웠는데, open, close, read, write는 reentraint reentrant라고 하다.
커널의 시스템콜은 reentrant하게 여러 스레드나 여러 프로세스가 같이 프로그래밍해도 아무런 지장이 없게끔 만들어야 한다. 커널은 전부가 critical section 덩어리다.

## 과제2
프로듀서 - 컨슈머 릴레이션쉽은 원형큐를 썻는데 이것을 링크드 리스트로 바꿔라 
링크가 하나만 있던 두개가 되든 선택사항
링크드 리스트로 바꾸는건데 insertion을 앞에다 하고 끄내가는것은 뒤에서 하든지  혹은 반대로 하던지
링크드 리스트는 길이가 무한이다. 계속 malloc해서 같다가 붙이면 되니까 그런데 길이를 100개로 제한합니다.
링크드 리스트의 element가 100개가 되면 집어넣는애가 기달려야 하고 링크드 리스트에 아무것도 없으면 컨슈머가 기다려야 한다. 링크드 리스트에다 insertion delete 하는것은 위치를 포인터로 수정하는건데 다 critical한 영역이다. 그래서 mutex로 안묶으면 링크드 리스트가 끊어져 버린다.
그래서 프로그램이 죽을 수 있다. 링크드 리스트 건드리는부분은 전부다 shared variable이기 때문에 당연히 mutex를 결국은 

producer 아래에가 insertion하는것으로 바뀌고 .. customer 끄집어 내는것으로 바꾼다.
linked list 길이는 100개로 정한다.
(1:34.. 혹참고하려면)
## 쓰레드를 짤때 모델이 3가지 정도 있다.
Manager/Worker Model
웹서버 있다고 치면 net work 를 통해서 클라이언트가 연결시도를 할것이다. 이 커넥션을 받는놈이 있을텐데 그것이 main thread가 될것이다. 받으면은 그 클라이언트하고 얘기를 할 서버를 만들어 줘야 하는데, 하나는 들어오는 x에 배당하고 y , z에 배당한다.  3개의 스레드가 북밭이 처럼있으면 각각이 웹서버가 된다. 일을 배당해서 클라이언트가 하나 접속하면 x하고 얘기한다. 3명까지 접속가는ㅇ하다. 4번째는 빈자리가 나올떄까지 기다려야 한다. static manager worker model이고 dynamic manger worker model은 들어올떄 마다 쓰레드 만들어준다. 1000개까지 예를들어서 쓰레드는 메모리 차지 하지 않는다.(거의) 별상관이 없다. 오늘날의 웹서버는 스레드로 계속해서 탄생하고있다.

웹 브라우저도 마찬가지다. 외대 홈페이지 웹사이트 들어갔다하면 브라우저 속에서도 스레드를 여러개 만든다. 홈페이지 화면에 이미지, 텍스트 (이미지 받는놈 따로 텍스트 따로 스레드를 여러개만들어서 받는다)
옛날에는 fork해서 프로세스 계속만들었는데 요즘엔 멀티스레드 서버 (웹서버) 스레드로 만든다. 한개가 아니니까 멀티스레드
Pipeline Model
이미 나왔다. 파이프라인은 분업하는것이다. 자동차 공정과정을 생각해보자
프로듀서 -> 컨슈머 ㅓ(공정 3단계)
문짝, 엔진, 도색 3공정이 동시에 돌아가니까 

공정을 3배 빠르게 할수있다. 분업
Instruction pipe line - cpu가 instruction을 수행할때 메모리에서 가져와야 하는데 명령어가 1byte일수도 있지만 여러바이트 일 수도 있으니까 메모리 access를 여러 번 해야하는데 그냥 모든 명령어는 4byte라고 가정하자.
cpu가 메모리로 4byte를 읽어온다. (가정)
4byte를 cpu가 메모리에서 읽어온다.
메모리 있는 단계가 있는데, 메모리에서 instruction 4byte를 읽어왔다.
무슨 instruction인지 decoding 한다.
플립플랍으로 이루어진 , 더하기 ,빼기 하라는건지 알아야 한다.
해석을 해야하는데 2단계다. 해석이 됬다. 
더하기를 하라그러면 메모리에 A+B 하라그러면 A를 가지고 와야함.
3단계 
B를 또 가져와야 한다 4단계
더하기를 하는게 5단계
더한것을 메모리에 다시 집어넣는것이 6단계다.
Insturction 하나 수행하는데 6단계 step이 존재한다.
마치 자동차를 만드는데 천여개의 공정이 있듯이
6단계를 나눠서 따로따로 한다. cpu 속에서 그렇게 한다.
첫번째 Instruction 을 가지고 와서, 디코딩을 하고 있을때 아직 instruction이 끝난것이 아니다.
메모리 에서는 또 다음 instruction을 가지고 온다.
파이프 라인. instruction을 파이프 라인한다라고 말한다.
자동차를 만들때 작은 자동차와 큰 자동차를 만드는데 공정이 다르다.

instruction 단계가 6단계면 무척 잘되었다. 라고 말할수있다.
파이프 라인이 6개로 구성하면 되니까 어떤 instruction은 3단계, 5단계 까지 가야되고 분업하기가 어려워진다. 그래서 instruction 공정을 거의 똑같이 만든게 risc architecture라고 한다.

IBM cpu는 instruction이 파워풀 한대신에 들쭉날쭉하다.
긴게있고 짧은게 있어서 파이프 라인하기가 지저분하다. 하긴한다.
cisc 머신이라고 한다.

파이프 라인 모드에서는 공정이 여러개있는것을 쓰레드로 나눠서 하는데 그것을 stage 1, stage 2, stage3라고 한다.
각각 하는일이 각각 다른것을 하나씩 넘긴다. manager/worker model은 x,y,z 가 같은일을 하는데 비해서 파이프라인에서는 각각 다른일을 하는것을 하나씩 stream을 넘기는것을 파이프라인 프로세싱이라고 한다. 이렇게 하면 빨라진다.


Peer Model
manager/worker 모델과 달리 manager가 없다. 아무거나 들어오면 직접 연결을 해서 하는것을 peer model이라고 한다. peer은 동등하다 라는 뜻이다.


