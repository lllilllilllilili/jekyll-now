---
post : layout
title : 빅데이터7
---
## 복습
지난시간에 우리가 Nosql 데이터 베이스를 잠깐 보고 우리가 끝이났다.
계속 진도를 나간다.

rdms 디비시간에 배웠을 rdms 는 기본적으로 스케일업에 잘 맞는 모델이다. 그러다보니까 
빅데이터 시대에 접어들고 그러면서 스케일 아웃이 더 보편화댐 그런 
클러스터에 맞는모델이 아님
그러다보니까 클러스터에 맞게끔 소위 얘기하는 빅데이터 시대가 되면서
클라우드 컴퓨팅이나 아니면 클러스터 아니면 데이터센터 이쪽으로 넘어오면서 nosql 데이터베이스가 득세시작. 
사실 ?? 데이터베이스가 그렇게 주목
실질적으로 많은 실제 나중에 슬라이드 말고 nosql 데이터베이스 

Nosql 데이터베이스가 득세한다고해서 얘네들이 시장 점유율을 보면 오라클 디비가 rdms가 70%를 먹고있음 아직도 그래서 여전히 rdms 득세인건 맞는데걔네들의 기능을 떠나서 만들어지고 몇가지 30~40년 됨 
그러다 보니까 당연함

nosql db는 실제 20년도 안됨 본격적으로 쓰이기 시작한건 5~6년도 안됨
그 사이에 굉장히 30% 남짓 잡아먹는다 그게 놀라운거임 그리고 트렌드는 NOSQL 굉장한 속도로 점유 해 나가고 있음
2018년 5월 현재 여전히 RDMS가 점유율을 70% 먹고있음 
클러스터 빅데이터 소위 접어들면서 맞는 모델인 NOSQL 데이터 베이스 나오기 시작

not only sql 통상적으로 
기존에 있던 nosql db 모델도 대충 설명했다 기본적으로 rdms 는 릴레이션 모델임 그러니까 R임 RDMS 임 
실제 걔네들의 모델 자체는 여러개의 스키마로 이루어지고 그런 ??? 으로 저장을 하고 걔네들 테이블간에 그런 릴레이션 쉽을 다루는게 rdms이다. 모델이 되는거고 그거가 실질적으로 빅데이터 시대에 struct한 데이터 아니라 unstruct 데이터가 거의한 80~90 점유 하고 있기떄문에 비정형화된데이터를 저장을 하면 사실 rdbms 가 잘 맞지 않는다.
그 비정형화된 rdms가 맞지 않음

그래서 나오게 되는 새로운 모델링이
새로운 모델링이 aggregrate based model 이다. 그것은 nosql db에 맞쳐서 나온 모델이 된다. 그래서 이런 모델링을 할때 

## Relational implementation

기존에 rdms는 좋든 싫든 스키마를 만들고 이런식으로 테이블을 저장을 했었지만 이거를 가지고 affregation base로 모델링을 하게 되면 자 여러분이 aggregrate, aggregate가 먼지 말했다. 여러분들이 디벨롭을 하던지 그런 관점에서 바라보면 실제 연관되어있는 덩어리 데이터를 affregation을 함
그런 관점에서 바라봤을때 이제 이거 같은 경우는 두개의 aggregrate로 나눠가지고 
customer 데이터가 있으면 애하나만 기존에는 
customer 기존에는 기존에 데이터 하나로 구성되어있지만 통상적으로 이 하나만 데이터를 가지고서 데이터를 쓰는건없음

sql은 이 테이블 하나로 데이터가 부족한거임
그래서 프로젝션과 조인을 가져다 열라게 많이해서 끝에 나오는 데이터란 말이다.
끝에 나오는 데이터임
릴레이션으로 데이터를 처리하는데 그얘기는 바꿔 말하면 이 커스터머라는 관점에서 바라볼땐 이 데이터를 access하는데 이 하나만 acccess하는 과정은 거의 없음 그러다 보면 그거 이 customer와 연관이있는 밀접한 연관이 있는 걔네들 
얘네들끼리 aggregation으로 개념으로 로지컬함 묶고 그리고 이제 order 측면에서 자주쓰이게될 그런 관점에서 하나로 넣어줬고 물론 로직컬 결과적으로 이런 데이터들을 하나로 묶어가지고 피지컬 하게 클러스터에 들어가기는 한다. 

결과적으로 이런 데이터를 하나로 묶고 
두개의 관점으로 바라볼수있고 customer 관점에서 하나 바라보고 얘네들 customer가 order 라든지 뭐든것다 다 연관이 있기때문에 이 관점에서 
하나의 aggregation으로 바라볼 수도 있다 라고 말했다. 
이얘기는 뭐냐면 

## A possible aggregation
요관점에서 바라보면 aggregation은 정해진 하나의 정답이 있는게 아니다.  
그것을 여러분들이 디자인 하기 나름이다.
어느선에서 바운대리를 어떻게 테이블을 끊고 아니면 어떤 데이터 테이블 끼리 묶어가지고 하나의 aggregation으로 만드느냐는 
철저하게 그 도메인에 달려있음 
여러분들 그 디벨로퍼 라든지, 아니면 도메인에 달려있는거임 그래서 
도메인 드리븐 디자인이라고함 
거기서나오는 개념이 aggregation임 

그러다보니까 데이터를 어떻게 다루고 그런거에 따라서 달라진다. 바운더리가 예를들어서 그 order 측면에서 바라보게 되면은 
그것을 customer 측면에서 바라보면
그거에 따라서 이 첫번째 우리가 아까 봤던 두가지 모델중에 첫번째도 만들수도 있는거고 그 보는관점에서 두번째도 만들수있음 
옳고 그름의 관점이 아님

테이블 같은 경우는  굉장히 그 스키마가 정해져있고 정답은 아니지만
통상적으로 얘기할 수있는 그런  솔루션이라는게있지만, aggregate base는  달라진다.
그래서 컨텍스?? 내에서 스페시픽하다.
그 컨텍스트나 아니면 도메인이나 그런관점에서 바라보는것이다.
물론 항상 공짜는 아님 이런그 디자인 aggregate 디자인도 당연히 장점과 단점이 나뉜다.
장점은 
장점은 클러스터에 잘맞는 모델임
왜냐면 걔네들 끼리 공통적으로 한꺼번에 access되는 그런 데이터 set끼리 묶어가지고 얘네들끼리 그냥 클러스터에 던져주면된다.

그렇기 때문에 사실은 데이터 어떻게 샬딩? 
데이터 샬딩, 배웠는지 모르겠지만
데이터를 가져다 어떻게 쪼개가지고 이 큰 데이터를 어떻게 클러스터에 뿌릴거냐 라는게 굉장히 명확함 왜냐하면 aggregate base 어차피그 데이터가 동시에 같이 access가 많이 되기때문에 개네들끼리 묶어서 그냥 클러스터에 던지면 됨 근데 rdbms는 그렇지 않음 
rdbms는 그많은 테이블이 있을때 어떤 테이블을 이 클러스터에 넣고 어떤 테이블은 저 클러스터에 넣어야 하냐고 그런 기준자체가 사실상 모호하다. rdbms 는 그렇다. 애시당초 클러스터 모델과는 잘맞지 않는다. 얘네들은 클러스터 모델이라기 보단 스케일 업 모델이다. 굉장히 퍼포먼스가 좋은 큰 머신하나 넣어서 관리를 하는게 실제 성능도 잘나온다.

nosql은 기본적으로 걔네들이 keep in mind 하는게 클러스터를 가져다 빅데이터 시대에 클러스터를 연결도구 만들때는 사실은 거기에 굉장히 잘 맞다. 
단점은 
우리가 aggregate으로 바라보니까 그게 잘 맞는 솔루션 같음 
근데 다시 한번 생각해보면 그러면 aggregate를 나름대로 컨테스트에 맞춰가지고 바운더리 줘서 짜른다고 치자 데이터를 
그러면 얘네들간에 relation은 어떻게 처리할꺼냐 aggregate 내에서 그 데이터 지네들 inter aggregate이 아니라 intra 겠다. intra aggregate 요건 inter 가 맞다. 

inter 가 아니라 intra aggregate 내에서 그 aggregate 하나가 있을때 그 내에서 데이터를 access할꺼라면 그 릴레이션십을 굉장히 잘 표현하는데 
aggregation 간에 관계를 표현하기에는 사실은 한계점이 있음 그런것을 표현하기에는 살짝 안된다 조금은 어려운면이 있음

rdms는 테이블간에 릴레이션을 가져다 서로 조인을 해서 데이터를 뽑아내는 모델 방법이기 때문에  
걔네들은 inter 테이블, 그 스키마 끼리 테이블끼리 그런 데이터를 갖다가 표현하는게 적합한 모델이지만 얘네 nosql base 같은 얘네들은 그런관계를 표현하기는 힘들다.


## Transactions
트랜잭션임 여러분이 잘아는 rdbms에서 acid
rdms는 애시당초 acid를 염두해두고 만들어지는 강력한 모델임 트랜잭션에 굉장히 강력한 모델이다.
그런 반면에 aggregation base nosqldb 같은 경우는 애시당초 acid를 염두해 두는게 아님
왜냐하면 걔네들 목적이 acid가 아님
얘네들은 나중에 나오겠지만 다음 슬라이드, 그 슬라이드  
애시당초 acid가 있는 베이스 라인이 따로 있음 그런 모델을 따른다. 
걔네들이 따르고 있는 트랜잭션을 베이스로 하고 있는 acid property가 아니라 베이스 프라펄티로 따로 있는데 

그 base property를 따르는 그런 트랜잭션을  모델을 얘네들은 베이스로함
그래서 보면 acid
acid 

물론이 acid 전혀 무시할 수없음
데이터 베이스에서 기본이 되는 트랜잭션 관점에서 중요한 모델이라서 이것을 무시하기 보다는 이 단위자체가 작아짐
rdbms는 우리가 처음에 시퀄, sql 주면 모든 트랜잭션을 가져다 하나의 트랜잭션이 저
전체 acid를 따르지만 얘네들 같은 경우는 
aggregate 내에서는 acid 모델을 대부분 다 따름 근데 이 전체에 합쳐진 aggregate들끼리에 그 사이에 그런 트랜잭션 사이에는 애네들acid를 제공하지 않음

물론 요거는 나중에 다음슬라이드에서 나옴
그게 데이터 consistency는 얘네들이 nosql 데이터베이스에서는 acid 안따르면 어떻게 얘네들이 데이터 consistency를 가져다 보장을 할꺼냐 거기에 대한 얘기는 다시한다. 
데이터 무결성을 어떻게 보장하냐 

어쨋든 여기서 말하는건 aggregate 내에서는 그런 acid 모델을 따르기긴하지만 굉장히 전체 모델에서는 acid 모델을 가져다 프로펄티를 따르는건 아니다.

그러다 보니까 이게 결과적으로 어떤지 nosql database는 

결과적으로 데이터를 어떻게 aggreegation할꺼냐 여전히 똑같은 문제로 돌아감 왜냐면 결과적으로
그 트랜잭션을 어느 레벨까지(어느 데이터 범위내 까지 ) 보장해줄꺼냐는 
aggregate 내라고 했잔아 그러면 aggregate 범위를 어떻게 자를건지는 다시 여러분한테 돌아가는거다.

aggregation boundary를 어떻게 짜줄지

이게 그얘기다.

이제부터 하나씩 나올텐데
1,2,3,4 가 나온다.

nosql db 크게 나누면 aggregate에 모델이 있고 nosql 있고 그다음에 잘아는 graph-based 에 nosql data base가 있고 (소셜네트워크라 흔히아는) 그 그래프 베이스에 노시퀄 데이터 베이스가 있다.

그리고 aggregate model 모델로서는 밑에 3가지가 있다. 제일먼저 
key-value / document store 그런식으로 하나더 column-family database 3가지가 있다. 하나씩 하나씩 말하겠다. 물론 굉장히 많음 단순하지 않음

nosql 
aggregate 모델은 밑에 3개가 있음
key, value
document
column-family
3가지가 있다.
하나씩 말씀드린다.
물론 굉장히 많음 단순하지 않음
기대를 하고 그정도에 맞춰서 슬라이드만듬

제일먼저 
key-value data base라고 써져있는데 통상적으로 key-value data base라고 하지 않는다. 물론 책에는 그렇게 나와있는지 모르겠지만 
실리콘밸리 협엽에서는 key-value store 라고 하지 db말은 안씀

대부분다 key-value store라고 거의 보통 많이씀
key-value store는 당연히 aggregate base모델임
그리고 lots of aggregate 라고 나와있는데 요 키와 벨리유로 구성이 되어있는데 자, 이런 aggregate 들이 굉장히 많은게 아니라 무지무지 하게 많다. 왜냐하면 
각 키 하나당 value 어사인되고 
그 키 벨리유 안에 셋, 그 페어가 각각 딴 aggregate임 그리고 그 데이터를 저장하면 저장할수록 그 숫자가 굉장히 무지무지 많이 늘어난다. 이 aggregate들이 굉장히 많다.

그리고 각각 이 aggregate들을 key를 가지고 있음 그래서 key-value store 잔아 여기서 보시면 알겠지만 커스터머 id가 키값이고 벨리유는 어 그 커스터머에 정보들(빌링 어드레스 라든지 아니면 오너 아이디라든지 이것은 정하기나름 )이렇게 해당되는 key에 해당되는 데이터가 value임
key-value store 같은경우는 데이터모델을 어떻게 하냐면 이런식으로 
말그대로 a set of <key,value> pairs 잖아 이게 그냥 딱 정의임
key와 value의 페어형태로 데이터를 갖다가 계속 저장함 이런형태로 데이터를 모델링함

value가 aggregate instance 나와있는데 이 value 자체가 aggregate임 
이 key는 그냥  그 데이터를 access 하기위한 기본키(프라이머리 키)임 디비때 배운 프라이머리 키가 이 key-value 스토어에 그 키라고 생각하면됨
그 primary key 해당되는 데이터가 존재하고
그 데이터를 access 하기 위해서 
그 키를 그냥 쓸뿐임
그래서
이 모든 데이터는 이런식으로 key-value 정의가되고 (key,value) (key,value) ... 형태로 정의이되고
이 실질적으로 이 데이터 aggregate 데이터 자체는
데이터 자체는 value임

애네들은 이 aggregate sturcture 가 visible 하지 않다. 
얘네만 그럼
key-value store 만그럼
뒤에 나오는 document store나 걔네들 같은 경우는 컬럼-패밀리 경우는 이 스트럭쳐가 있음  
이 스트럭쳐가 aggregate struct 요 value
얘네들의 struct가 visible 하지 않다라고 나와있는데(위애) 이 얘기는 실제 여러분들이 이렇게 바라보면은 이 데이터를 갖다가 이 포맷을 보이니까 strucure 되어 있는거 같죠
왜냐면은 key가 있고 value 가 속에 구성되어 있는게 커스터머 라든지 빌링 어드레스 라든지 오더 아이디라든지 아니면 cpu 어드레스 이렇게 되니까 
struct가 있고 거기에 대해서 데이터가 들어가는것 같지만 실질적으로 key-value store에서 이 value는 BLOB 임(바이너리 랄지 오브젝트임)

블랍임 이 key-valueu store에서 이 value는 블랍임
말그대로 바이너리 데이터임 그렇기 때문에 
struct 라는게 존재하지 않음

이 key-value store 에서 데이터를 가지고 왔을때 그 sture를
그 struct를 뽑아낼 수없음
이 말임(왜냐하면 바이너리 파일을 무슨수로 sturce가있어? 바이너리 파일은 말그대로 바이너리 파일일 뿐임)
이얘기임
그래서 이 
이 key value store 형태로 저장되어있는 데이터 이 value를  
value를 access하기 위해서는 그냥 key값을 쓰면됨 key 값을 던져주면 그 key에 해당하는 바이너리를 찾아서 value를 던져준다 물론 이걸 가져다 무조건 
무조건 sequency는 안씀 그냥 빅오(1)임
그냥 해쉬를 써서 곧바로 가서 데이터를 바로 끌어옴 성능이 굉장히 좋음
key-value store경우는

## Key-value database(k-v store)
key-value store에서 조금더 원리를 살펴보면key-value store는 말그대로 value는 유니크한  key에 맵됨
바꿔 말하면 key는 그냥 굉장히 유니크해야 하고 primary key 가 있어야하고 그 프라이머리 키가 벨리유가 어사인된다. 
value는 중복되도 상관없음

그거는 왜냐면 여러분들이
넣고자 하는 데이터가 뭐냐에 따라서 value가정해짐 그치만, key는 분명히 프라이메리 해야하고 그리고 유니크해야함
그리고 데이터를 저장할때는 예를들어서 
set, put을 쓰던지 
주어진 api 따라서 다르다.

그 얘는 여기서 set으로 줘서 데이터를 저장할려면 key를 주고 value는 뭔지 모르겠지만 
우리가 null로 가는 value를 같이 줘야한다.

파이썬 데이터모델중에 데이터 스트럭쳐중에 그 딕셔너리 비슷함 딕셔너리 key value를 집어넣는거잔아 그런 데이터 구조잔아
이 딕셔너리라는게 그런 개념임
똑같다. 그때 걔네들이 파이썬 데이터 딕셔너리 데이터 구조를 넣을때도 똑같다. 
이 딕셔너리 라는게 그런개념임

여러분 사전을 생각해보면은 사전에 데이터 중복이 안되잔아 물론 같은 데이터가 물론 뭐 
 똑같은 단어가 있을수있더라도 단어는 기본적으로 딕셔너리 단어는 유니크하고 그 뒤에 뜻이 나오는거잔아

그관점에서 그대로 바라보면 된다.

## key-value Databases(K-V Store)
데이터 를 넣을때는 key-value 한쌍을 묶어서 같이 넣어주고 
데이터 찾을때는 get, get이라는 ?를 주고 이제 key값만 얹어 주면 거기에 대해서 해쉬를 해가지고 곧바로 가서 그 데이터를 곧바로 리턴시킨다.

store.get 이란 커맨드주고 거기에 대해 해쉬를 줘서 곧바로 return함

key-value store의 기본형태임
key-value는 올거나이즈드 해가지고 해서 뭐니 데이터베이스니 버킷이니 키스베이스로 올거나이즈 된다라고 나와있는데(???) // keys are organized in databases, buckets, keyspaces etc

이게 뭔말이냐면 key 자체가 요 하나의 key-value덩어리들을 요거를 가져다 어떤 contex 상에서 어떤 써런트닝?을 가져다 데이터베이스 라고도 부르기도 하고 데이터베이스 같이 생긴다. 데이터베이스라고 부르기도 하고 어떤 사람들은 버킷이라고도 부름 요것을
버킷이라고 함
어떤 사람은 key space 라고도 한다. 

key space들이라고 봄
어쨋든지 간에 저런 key들을 이런식으로 버킷, key space 이런형식으로 구성이 된다. 그러면 
value 같은 경우는 struct가 visible 하지 않음
왜냐하면 바이너리 형태로 블랍이기때문에 
그 실제 데이터 struct 가 여러분한테 visible 하지 않기때문에 그 데이터를 가지고 올 수있는 방법은 key를 쓰는 방법밖에 없음
이렇게 심플함(key를 주면 그 데이터 자체를 던져준다)

무식한거 같지만 이렇게 굉장히
심플함

얘네들 operation (BASIC operations) 간단함 KV Store provides very simple and efficient operations 하다 라고 나와있는데 
실제 얘네들이 제공하는 api가 이따만큼씩 있지 않음 많지 않음
굉장히 복잡한 메뉴얼이 필요없음
왜냐하면 정말 간단함
제공하는 api는 set아니면 push라고 많이함
데이터를 가져다 집어넣을때 쓰는거 
데이터를 넣고 읽고 업데이트하고 그정도면 다한것이다.
그래서 그런데이터를 넣을때 push를 쓰고 가지고올때는 get을 쓰고 데이터를 지울때는 delete를 쓴다.
실제 replace는 업데이트의 일종이기 때문에 replace를 제공하지 않는 ??? 도 많음
사실은 이 replace는 부수의 일종임

replace는 부수로 대체하는거임
그렇기 떄문에 부수로 대체하는 애들도 많음
실질적으로 읽고쓰고지우고 다함

이렇게 간단하다라는것은 장점이된다.
실질적으로 왜 

rdms가 좋기도 하면서 성능이 별다른 이유는
복잡하기 때문임 근데 이렇게 간단하게 만들면 실제 쓰는사람도 간단하지만 성능도 간결해짐 
성능이나 ??(어빌리티??) 아니면 결과적으로 나중에 그대로 확장성도 좋아짐
그래서 빅데이터 시대때 잘맞는 모델인것이다.


이렇게 간단하게 만들면 성능도 간단해진다.
결과적으로 모델로 확장할때도 확장도 굉장히 좋아짐


그리고 보면은 ttl 제공을함 
ttl은 네트워크 시간에 나옴 ttl 기능도 제공함
ttl 기능제공하면 뭐가 좋으냐?
이 key value store을 캐시모델로 쓸때도 좋다. 
왜냐하면 어느정도 일정 수준이 지났을때 걔네들을 ttl 값을 줘서 expire 시켜버릴 수 있다. 계속 갖고 있을 필요가 없이 왜냐하면   콜드 데이터를 가지고 있을 필요가없음
실제 에제로 보여주겠지만 
이 key-value store는 데이터 스토리지 모델로 많이 쓰지만 
멤캐쉬디 같이 그렇게 메모리 서버로도 굉장히 많이 쓴다.
key-value store는요
어쨋거나 그럴때 쓰는 기능이다.
(What is ttl?)
그렇게 쓰는 기능이다.
그자체 걔네들이 ttl 기능을 제공한다.
들여다 보면은 어떤 기능들도 있냐면 내가 key값을 어떻게 알아
수많은 key를 내가 모르잔아
그렇기 떄문에 어떻게 파이썬도 마찬가지인데
key를 갖다가 쭉 이레이션?? 시켜가지고 키를 보여주는 기능이 있음
(이 key-value store는 memcache
어쨋거나 그 자체에 ttl 기능을 제공을함
어떤 기능이 있냐면 key 값을 어떻게 알아 실제 파이썬도 마찬가지냐 키를 보여주는ㄱ ㅣ능이 있음)
왜냐하면
키를 알아야 검색이가능
그래서 이런식으로 enumeration 해가지고 첫번째 키가 됬던지 아니면 어떤 부분의 센서의 키가 됬던지 간에 키를 가져다 이렇게 집합적으로 묶어서 리스트로 던져주면 그런 기능이 있다.

물론, 모든게 다 그렇다는게 아니라 기본적으로 basic operation이 그렇다.
그래서 데이터를 가져다 access할때는 key를 주면 그냥 이 
전체키가 됬던지 부분의 set의 키가 됬던지 묶어서 던져주는 
모든게 디팬드임
데이터를 access할때는 key를주면 
바이너리 파일인 요런 데이터를 던져준다.
굉장히 많이쓰이는

## Popular key-value databases
많이 쓰는 애플리케이션임
모델임 프로그램임 
이중에서 
redis가 넘버원임
이 redis의 경쟁자 memcacheD임(실제 메모리 서버로 구현할때 제일 많이씀 상용으로 많이씀)
ROCKSDB(페이스북이 만든)
leveldb(구글이 만든)
이런 유명하게 많이 쓰이는 nosql database 모델임

여기는 별로
key-value 경우 redis 경우가 number 그리고 redis 경쟁자 memcacheD(데몬)
실제 메모리 서버를 구현할떄 아주아주 많이씀
페모리서버에 많이쓴다.
RocksDB(2013-페이스북)
leveldb(구글)
이미 유명하게 많이쓰이는 nosql db 모델이지만 
amazon dynamoDB db모델 제공
재밌는게 모든 사람들이 rdms 
그럼에도 불구하고 
nosql
실질적으로 rdms 90%이상 잡아먹음
오라클이 nosql 시장에 들어감
얼마만큼 트렌디한지 알수있음
여기있는 storage 모델 웹서버 앞선에서도 쓸수있고 메모리 서버에서도 많이 쓰인다.

어쨋든 그런용도로 많이씀
여기서는 버릴거 하나도 없다.
redis가 king 버릴거하나도없다

## Document databases
두번째
document database 
아까 말했다 싶이
key value store에서 value는 aggrigate 모델자체는 블랍이다. 그 바이너리 object임 그러다 보니까 어떤문제가 생기냐면 
내가 바이너리고 아까 전에 그 struct가 visiable 않다고 했져 그러면은 내가 원하는 그 데이터만 딱 꼬집어 보고 싶은데 고게 안되는것임 불가능 좌우지간 끝나고 나니까
내가 원하는 데이터만 
캐시같은 모델은 그럴 필요가없다.
캐시 모델은 그 데이터 자체를 읽은걸 ?? 가지고 오는게 아니잔아

key-value store는 storage 모델로도 많이 쓰지만 아까 말씀드렸다 싶이
cache 서버에 cache모델에서도 쓰임
근데 캐시 모델, 캐시는 어떤 데이터 그게 있으면 그 데이터가 있으면 그냥 던져주면 그만임
그만큼 파싱을 해서 데이터 일부분을 던저주고 자시고 할 필요가없음
그렇기 떄문에 key-value store는 잘맞지만
여러분이 만약에 이런식으로 아마존을 구현했다고 생각해보자
아마존 온라인 그 커머셜 서비스를 만약에 구현한다고 해을때 어떤 커스터머가 있고 
이 커스터머 에서 커스터머 데이터를 가져다 다 갖고 올필요 없이 커스터머 id 정보로 커스터머 내에서 이사람의 그 예를들어서  중간 부분 데이터를 가지고 오고 싶은것일 수도 있고 빌링 어드레스만 가지고 오고 싶을 수도있고 얼만든지 그럴 수 있다. 그런용도로 나온거임
이 document data base는요

document 스토어라고도함
일단은 먼저 보면 얘들도
aggregate base 에 데이터모델링도 함
당연히 각각 이런 많은 object 들이 
아주 굉장히 많다.  그리고 각 	
각 aggrigate도 당연히 얘네들도 key 값이 존재
여기 같은 경우는 커스터 마이드 라든지 여기 많이 머어도 ip 라든지 이런 식으로 
이런식으로 key값은 당연히 존재

그리고 
데이터 모델은 어떤식으로 모델이되냐면 
이게 하나가 자체가 데이타 다큐먼트 스토어긴한데
얘네들 역시도 key와 value 형태 비슷하게 구현이 됨
그 value가 그게 아니라 이때 얘네들의 value는 document 일뿐이다. 블랍이 아니다.

그래서 얘네들은 각각 구성자체가 key값과-document로 구성되고 이때 documnet가 이제 이 다큐먼트가 이제 aggrigate가 되는것이다.

그리고 보면은
얘네들의 struct는 visible함
key-value struct는 visible 하지 않았음
왜냐하면 바이너리 자체로 던져주니까 그런데

얘네들은 
다규먼트 형태로 저장이되서 얘네들은 데이터가 저장되는 그 struct가 보인다.

visible하다. 
그래서 우리가 만약에 어떤 aggrigate 나어떤 데이터에다 access하고싶으면 요 데이터 있잔아
요 실제 다큐먼트 속에있는 
다큐먼트도 보면 얘네들 struct 라는게 구성되어있잔아 orderdate 라든지 아니면 item 이라던지 payment 라든지 쉬핑 어드레스 라든지 요런식으로 다큐먼트가 각각 정해진 
다큐먼트상 포맷이 정해져있음

sturct가 있음
그래서 얘네들은 조금더 복잡한 쿼리가 가능하다. 
이중에 어떤놈만 뽑아내 라는 쿼리가 가능해 key-value store는 덩어리 자체가 리턴되는 바이너리, 블랍이기때문에 불가능했다.

다큐먼트 경우는 그 자체가 self-contained 그런 데이터 struct를 가지고 있고 그리고
실제 네임과 value의 pair 형태로 attribute가 구성된다.
이거 자체가 단게 아니라
요형태가 제이슨 형태임

이거자체가 json 임
json 뭐야? 자바 스크립트 로직 로테이션 임
그냥 쉽게 얘기하면 xml 알잔아 
xml 같은것이다.

자 그게 자바스크립트형식으로 표현되어 있을뿐이다. 이게 json이다. 이렇게 생겼다
xml도 물론 걔들을 ??? ... 찍고 이런식으로 하긴한다.

요거 자체가 json임
어쩃거나 이런식으로 json 형태를 갖다가 데이터를 표현하늗네
이데이터를 표현할때 자세히 보면 앞에 네임이 있고 각 벨리유있음
네임 있고 벨리유 있고
자 그런식임
xml도그런식임

xml도 
해당되는 네임 - 벨리유 넣어줌 그 쌍임

데이터 형태자체 이게 그애기임
이 얘네
다큐먼트 스토어 경우 다 그런식으로 구성됨
다큐먼트 스토어 에서 얘네들이 json 디슨을 쓰기 때문에 그런다.
비쓴은 바이너리 재이슨일 뿐이다.

비슨?

어쨋거나 이런식으로 xml 이나 json 형태로 쓴다.
그러기 때문에 구성이 그렇게 된다라는뜻임

그러자 attribute value의 경우는 value 경우는 타입이 당연히 있음
왜냐하면 struct들이 애네들의 struct 된  네임인데 여러분 여기다가 뭐 네임인데 숫자를 집어넣겠냐고 
어느정도 다큐먼트 store에서는 얘네들의  struct 가 있고 struct가 존재하기때문에 스키마 같은 그런 비슷한 데이터 타입이 존재함
그리고 다큐먼트 스토어 같은 경우는
타입이 있다.

이런식으로 타입이 존재하면은 좋은점도 많음 뭐냐면, 데이터베이스를 저장하거나, db 매니지할때 이게 잘못된 데이터가 들어갔는지 안갔는지 구별이됨(체크가능) 데이터베이스에서는 무결성이라고 함
그 무결성을 체크할 수있는 기능이 된다.
key-value store는 저런 struct 라는게 존재하지 않기때문에 그런 무결성을 체크하는게  미리 체크해서 뭐 에러를 날려준다던지 그런기능자체가 불가능 그런데 얘네들은 가능함
이얘기가 그얘기다.

데이터에 validation을 가져다 체크할수있음
계속 말했지만,
데이터 다큐먼트 경우 스키마가 존재한다
물론 형태가 조금씩 달라서 그렇지 어쨋든지 간에 저런 
그런 세미 스트럭쳐가 존재하기때문에 
얘네들은 어느정도의  
implicit한 스키마존재하는 형태임
그래서 

데이터 스토어경우 는
모든 다큐먼트의 attribute를 다 access 가능하던지 아니면은 거기 일부분만 access 가능하던지

근데 왜그런지는 설명드렸음
어느정도의 스트럭쳐가 존재하기때문에 거기에 따라서 조금은 더 세밀한 그런 쿼리가 가능함
이게 그얘기임
물론 그러다 보니까 이게 결과적으로 쿼리 power를 증가시켜주는 역할을 하게된다.

## Data Accesses in document stores
json이라고했다.
그리고 이게 데이터 엑세스, 다큐먼트 스토어 저장되는 데이터 형태라든가 이런식으로 저장이 됨 
만약에 어떤 쿼리를 가져다 이 다큐먼트 스토어에서 쿼리를 날릴때 
조금더 스페시픽하게 날림

그런 모든 order을 갖다가 다 업데이트하는데 이게 뭐냐면 
Refactoring Databases product
라는 이런 ?? 다포함하고 있는 그런 모든 order을 가져다 주문을 다 찾아줘 라는 이런 여러분들이 뭐랄까 rdbms 할수있음법한 쿼리를 가져다 얘들도 그대로 날릴 수 있음 왜냐하면 
implicit한 스키마가 내부적으로존재함 이런식으로 검색이 가능하다 
두번째 새번째는 중요한건 아님
얘네들 보면은 order 오브젝트에서는 자기의 프라이머리키인 orderid가 존재하고 
커스터머 id도 같이 이런식으로 다 존재한다 
이게 레퍼런스 라고 하는데

여러분
rdbms 배울때 프라이머리 키랑 비슷한 개념이다.레퍼런스 를 다른 테이블에다 레퍼런스를 제공을 해주는것이다 프라이메리 키한테(x) 
폴링키임
포링키 역할이 비슷함
이게 있어도 되고 없어도 상관없음
이 포링키가 존재하는 이유는 그 어쩃든 간에 레퍼런스를 주기 위함 
그걸 따라서 좀더 이제 쿼리를 수월하기 위함
반드시 존재해야하는건 아님
이게 두번째 새번째 그런 얘기임

offset 간에 reference를 주기 위함 쿼리를 수월하기 하기 위함
두번째 세번째 다 그얘기임

## Popular document databases

다큐먼트 데이터 베이스 예제임
실질적으로 얘네들은 괜히 하는 얘기가 아니라 용도에 따라서 맞고 덜맞고 존재함 key-value store에서
몽고 db가 왕임

뭔가 여러가지 나옴
아까 말했던 key-valeu어느하나 버릴게업ㅄ다라고하는데 실질적으로 걔네들 용도에 맞고 덜 더 맞고 존재

얘네들은 몽고db왕임
실질적으로 초기에는 카우치베이스 카우치 db 같은 회사임
조금은 다름 그게 어쨋ㅅ든 원래는 카우치db가 왕을 먹고 있었는데
몽고 db가 나중에만들어지면서 그냥 다 잡아 먹음
몽고 db가 비교를 한단거 자체가 
실제 document 가 몽고db 비교를 하기힘들정도로 시장을 다잡아먹고있다.
다잡아 먹고 있다.


## Key-Values vs Document stores
그러면 
key vlaue store랑  다큐머너트 스토어 비교해보고 
key value 스토어는 말씀드렸음
key 가 존재하고 value가 존재한다.
그 value가 블랍이다. 그런형태로 구현이 되는데 mostly meaningless bits 다.

바이너리이니까

그리고 우리가 원하는것 맘대로 이 value에 원하는 어떤 형태든지 다큐먼트가 됬든 사진이 됫든 비디오됫든 다집어넣얼수있음 바이너리 형태잔아 
그러니까 그 어떤 데이터 든지 다 집어넣을수 있음
그래서 얘들이 스키마 쓰는거임 그리고 키값을통해서만 그 밸리유 access 할 수 있고 그 밸리유를 가지고 따로 파싱을 한다던지 밸리유를 가지고 쿼리를 할 수있는 방법은 없다. 기본적으로 키 벨리유 스토어에서는
밸리유로 파싱불가
key -value 로 형태로 세트로 들어가기 때문에 이데이터 갖다가 key-value store에서는 무조건 key를 이용해서  
key를 이용해서만 데이터가 access가능하다.

그리고 이제
다큐먼트 store, 데이터베이스 경우
어떤 당연히 얘네들도 key값은 존재함(프라이머티키 값은 존재하고)
그리고 aggregate 가 되는 그 key 에 value에 해당되는 그게 다큐먼트일뿐건인데
그 다큐먼튼데 걔네들이 얘네들은 
struct가 있는 다큐먼트형태임.
그리고 access하는데 
key value보다는 조금더 flexible함
왜냐하면 얘네들이 어느정도 비슷한 스키마를 가지고 있다.
얘네들 다큐먼
그래서 다큐먼트 스토어가 키벨리유  스토어보다는 조금더 그 쿼리 의 파워가 훨씬더 쎼다 실제 키밸리유스토어 보다는 
다큐먼트 스토어 몽고디비의 점유율이 그냥 훨씬더 높다. 몽고 디비는 왕임

키 밸리유 스토어 다큐먼트 스토어했고 2가지 했고 다음시간에 나머지2개를 마치고 그리고다른부분 nosql 아셔야할 컨시스턴시 라든지 얘기를 할것이다.
