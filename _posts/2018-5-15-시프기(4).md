---
post : layout
title : 시프기(4)
---

얼람 타이머을 주고 시그널을 줘서 로그인을 하고 5초에 한번씩 
삑소리 내고 (안치면)
5번까지 트라이 
이그젬플 프로그램
반드시 기억해라

## Example Program(alarm() & getchar())
프롬프트 들어오면 
시그얼람이 들어오면 내가 만든 시그캐처로가라
시그 캐처 에서는 타임 아웃 5초 지나감 이게 트루고 이의미는 벨을울리고
써먹어야 해서 시그 캐처에는 중요한게 ++ 자기자신 시그 얼람 오면 다시 들어와! 다시 세팅해서 하는것이 안전 ++ 왜냐하면
일회용 os 버전도 있음 그래서 다시 세팅하는것이다.

시그널 set, 시그 인터럽트는 시스템콜하는도중 시그널발생하면 
시스템콜 도중 i/o 하기 위해서 블락 되있다.(초기상태고) 
블락된것을 중단하는게 시스템콜 먼저 처리 아니면 시스템콜 완료 후에 시그널 처리 두가지종류가 생기게 된다. 우위를 어디로 둘꺼냐!

디스크 리드 하는것 블락 되있는건 시그널 당시 들어온다 하더라도 디스크 i/o 금방 종료 그래서 시스템 콜 끝난후 시그널 처리 (1단계적인것이 있고)

getchar는 언제 칠지 모르니까 유저가 시그널 발생 시그널먼저 처리
그래서 getchar 하는 도중 5초 지나가는 도중 시스템콜 도중에 시그널 발생할때 시그 인터럽트 할때 이 시스템콜을 끊고 에러 리턴해달라 세팅 시스템콜 중단 (2단계적인것이 있고)

리눅스에 블락상태, 블락이라 배웠지만 task 인터럽트블, 태스크 언인터럽터블
태스크 인터럽터블은 인터럽트 얘기아님, 시스템콜 도중 블락되어있는데 시그널 들어오면 시스템콜 짤라라 => task_interrueble

태스크 언인터럽트블 블락인데 디스크 아이오 하면서 블락, 시그널 들어오면 짜르지 말아라 뜻이다. =>task_uninterruble

시그 인터럽트 겟캐릭터 하는데 시그널 발생하면 짜르고 에러 리턴해라 그래서 for loop을 해서 5번 룹을 한다. 
일단 타임 아웃 폴스 프롬프트 사인찍고(이름이 찍힌다 라는것같고)
타임 아웃 5초 세팅 하고 그리고 나서 겟 캐릭터 하면서 이름을 받아들이는 룹을 한다.

겟캐릭터 받아들이는게 개행문자면 이름이 입력완료 널캐릭터 집어넣고 룹을 빠져나오게 된다. 노말한경우 5초안에 이름침 (완료된경우)

일반 캐릭터를 쳤을때 그것을 마이라인에 넣는데 다만 겟 캐릭터의 리턴 값이 0보다작으면 에러 리턴, 이유는 시그널이 들어와서 중지가 되고 삑소리 나고 들어온다. 그럴때도 브레이크 한다. (어쨋든 시그널이 들어온거니까)

for 벗어나면 노말케이스 이름을 다받은경우, 얼람이 발생해서 그런 경우있다. 얼람 꺼야 한다. 얼람제로다 

타임드 아웃 이 아닌걸로 끝나면 이름을 다 받은경우(!false 되니까)
loop을 벗어나서 돌아가면 되고  그렇지 않으면 loop으로 돌아가서 얼람을 재설정 5초로 설정하고 겟캐릭터 받는 그런 loop을 예제. (반복적으로 돌아간다.)

프로그램 짜서 돌려보자. 외우는게 아니다. 숙제아니다.
## Interval Timer
얼람(5)는 5초있다 시그널 보내라는 의미이고 일회성이다.
경우따라 뭐가 작업을 하는데 주기적으로 돌아야해! 그러면 예를 들어서 무인헬기 프로그램에 헬리콥터속에 탑재가 되는
미션을 주면 위도 경도따라서 날라가는 헬리콥터를 서브모터로 날개 각도를 조정하고 그런게 1초에 50번 돌아야한다. 50hz로 20msec 마다 주기적으로 해야 안정적이다.

공장 자동화 센서 부착. 센서 여러개 주기적으로 읽어서 처리이고
앞으로 프로그램 concurrent 프로그램 하나는 timed 주기적으로 돌아가야하는 작업과
이벤트 드리븐 어디서 시간은 모르지만 메시지 캐릭터 쳤다던가 이벤트에 의해서 작동 비주기적이다. 그렇게 구성

주기적인 작업 사용 interval timer 이다. 많이쓴다.
## Interval timer
윈도우 (os마다 다른형태이고) 다 다른 형태 api 존재함
그래서 interval timer를 정해진 interval 마다 시그널 보냄
시그널핸들러로 들어와서 주기적인 일 수행
인터벌 타이머는 아이 타이머 라고 함 리눅스에서
setitimer는 아이타이머는 인터버 타이머 맞춰놓음 (맞춰놓는다?? 정해놓는다??)
위치(which)는 타이머 종류의미
컨스트 스트럭트 아이타임벨 의 벨리유는 뉴 인터벌 이라고 줌 
스트럭트 아이타임벨리유는 타임.h 정의되어있어서(시간 value로 줌) 나노 세컨드 세컨드 단위를 줌
1초로 주면 얼람이 1초마다 들어옴
올드 인터버는 만일에 itimer 쓰고 있었으면 옛날꺼, 옛날 인터버 는 어떻게 썻냐 쓸필요가 없으면 null임
getitimer 는 타이머 현재 상태 값 물어본다 인터벌이 얼마로 되어있냐 물어봄 타이머 쓸때 setitimer 상관없음 
interval 1초 주면 1초 한번씩 시그널 집어넣어줌 프로그램에
1초 계산 하는 방법 which 에 따라
itimer_read은 실시간 1초에 한번씩 집어넣어줌 얼람하고 똑같은 시그널 발생 시그얼람 발생 잘못짬 나중에 더 좋은 타이머 나옴 
얼람하고 같이 못씀
itimer_virtual 시간 1초 재긴하는데 유저모드 돌고 커널모드 도는데 유저모드 내가 돈 시간만 계산해서 1초 마다 보내달람
프로세스 하나 여러개 자기에 디펜드하게 자기가 돌아가는 시간만 계산 시그 얼람 을 넣어달람 (유저모드에서만 체크하는듯??)
itimer_prof 유저모드하고 커널하고 쓰는 시간 합쳐서 1초를 계산

리얼타임을 많이씀 1초마다 한번씩 뭔가 시그널 집어넣줘 itimer read 쓰면됨
여기에는 interval 값을 시간 value 주는것 setitimer , set interval timer의 약자 
두번째 아규먼트(const struct itimerval *value)

## Interval Timer
여기에는 시간 벨리유가 두개 들어간다.
```java
struct timeval{
	long tv_sec; 
    long tv_usec; //마이크로 세컨드
}
1초, 100마이크로세컨드 설정하면 이값이 될때마다 한번씩 넣어달라
1초하면 usec를 0으로 하고 sec를 1로하면된다.
이것은 시간을 주는거고

struct itimerval{
	struct timeval it_interval; //간격마다 시그널을 집어넣어주게 시간설정가능
    struct timeval it_value; //5로 세팅하면 지금에서부터 5초 가 지난다음에 시작 그다음서부터 5초부터 넣기 시작해서 1초간격으로 시그널 달라
    처음 넣는시간
}
하나는 주기적인 인터버, 1초로 세팅하면 1초에 한번씩 집어넣음

if it_interval =0;
//0으로 주면 first value 한번 넣고 말아라 얼람하고 같아진다(한번만 쓴다.)
if it_value=0;
//타이머를 꺼라 더이상 쓰지 않음
```

## Interval Timer
프로그램 5초 마다 돌아가는 공장 상황 감시 프로그램
이 타이머를 써야댐
증권시장도 interval timer 써야함
```java
void alarm_handler(int signo){
	printf("Timer hit\n");
    do the periodic job;
    alarm_sighandler(signal(SIGALRM,alarm_handler));
    //signal(SIGALRM,alarm_handler); //다시 세팅
}

int main(){

	struct itimerval delay; //시간을 주는 변수 구조체 잡고
    int ret;
    signal(SIGALRM, alarm_handler); //시그얼람이 들어오면 얼람 핸들러로가라! 주기적으로 얼람이 들어올때마다 들어왔다. 주기적으로 해야할 작업 추가!
 인터벌 타이머가 계속 집어넣어줄때마다 돌아감
    delay.it_value.tv_sec=5; //first alarm 5
    delay.it_value.tv_usec=0; // 5초 지나서부터 얼람 넣기 시작, 그때부터
    delay.it_interval.tv_sec=1; //1초간격으로 나한테 얼람을 줘 5초 가지나서 1초간격으로 찍힘
    delay.it_interval.tv_usec=0; //delay라는 struct setting
    ret=setitimer(ITIMER_REAL, &delay, NULL); //itimer set한다. 실시간으로 해! delay struct에 5초, 1초 집어넣음 3번째 아규먼트 필요없음
    if(ret){perror("setitimer"); return;} //일반적으로 메인 프로그램 할일 없으면, 주기적으로 하는일 여기서 한다 얼람 핸들러속에서!
    메인 할일 없으면 이런 룹넣는다. 밑에것!
     while(1){
    	pause(); //할일 없을때 넣는다. 뭐가 들어와? 시그 얼람이 들어와 5초 지나서 
        
        메인은 시그널 핸들러만 받으면서 룹을 돈다.
    }
}
```
이 프로그램의
실질적인 작업은 시그널 핸들러 속에서 얼람 핸들러속에서 주기적으로 하는일을 여기서 센서 감지, 비행기 자세 고친다 그런것을 하게됨


## POSIX Timer(Advanced)
실시간 시스템 타이머 짜는 프로그램을 쓰게 된다.
interval은 오리지널 버전 그러나 이건 성능업 버전
시그얼람을 넣지 않음 시그널 자기가 선택 가능(30개가 됨)
시그얼람 안쓰면 얼람 sleep 같이 못씀 그래서 sleep 도 쓸수있음
sleep 싫어함 잘못됨 정확한게 아님 
시그널 선택할 수 있음
signal_handler 대신 handler_thread
시그널 돌아올때마다 쓰레드 돌아가게 할 수도 있음
옵션이다. 선택가능
장점이 뭐냐! 
timer_create 타이머를 만들면서 인터벌 주고 시그널 선택하고 메뉴얼 처보면 나옴 좋은것은 
인터벌 타이머 쓸때 1초마다 한번씩 가는데 작업이 길어짐 1초가 넘어감 그러면 굉장히 안좋음 (클락 인터럽트 1/1000초 들어옴 인터럽트 핸들러속에서 1/1000초 넘어가면 다음일 못함, 클락 인터럽트가 1/1000초 넘기는 경우 있음 오버런 이라고 함) 오버런 되면 하나가 하나를 놓친다. 시그널 핸들러가 안끝나서
timer_settime
timer_gettime
timer_getoverrun //니가 시그널 핸들러처리도중 시간 길어져서 시그널 놓친거 개수를 알려준다. 놓친 시그널의개수 시간이 길어져서!
시그널 핸들러 왔을때 오버런 카운트 읽어보면 1이다 그러면 하나 놓쳤다. 시간 업데이트 어플이면 하나더 증가시켜야 한다. 2면 두번 놓친것

timer_delete //없애는것

쓸때는 POSIX 쓰는게 좋다.
Example 써놨다. 참고로 봐라
숙제는 interval timer으로 시행

지금까지 시그널이 들어오면 시그널 핸들러하고 는 어느 입장 프로세스 입장에서
pthread, thread 프로그램 잘짜야 한다. java thread 됬든(팁)

멀티 쓰레드 프로그램에서 시그널하고 쓰레드 관계 어떻게 되냐
시그널 핸들러 메인에서 정의했다. 인터벌 타이머를 만들었다. 시그널 1초 마다 달라고 하고 메인이 쓰레드 50개 만들었다. 쓰레드 50개 경쟁적 돌아간다. 그때 시그널 들어오면 배달은 
시그널 핸들러 하나 있음 쓰레드 10개 만듬 얼람 걸고
시그널 핸들러가 쓰레드가 10개 라고 10번 콜 되는게 아님
쓰레드가 시그널 핸들러 물려받음 형제끼리(쓰레드는 형제 자매간)
시그널이 1초에 한번씩 발생하면 10개 쓰레드가 그 중에서 막 돌고있다가 그당시에 돌고 있는 쓰레드 에게 시그널이 받는다. 받아서 시그널 핸들러로 간다.
쓰레드 10개 라 해서 시그널 하나 들어왔는데 시그널 핸들러가 10번 돌아가는건 아니다.

멀티스레드 환경은 생성된 쓰레드는 메인이 만든 시그널 핸들러를 물려받음
시그널 발생하면 어떤 게 결정되지 않음 그중에서 돌고있는 한놈한테 전달이 되고 이놈이 시그널 핸들러로 감
여러번 가는것은 아니다. 걱정 하지 않고 써도 좋다.

옛날, 프로세스 쓰레드 
프로세스 시그널 보내면 쓰레드 전체에다 보내는 형식 
그러나 이제는 아님
쓰레드가 생성이 되고 나서 시그널 핸들러 만들면 자기한테만 해당(10개가 만들어진다는건가?)
시그널이 잠시 못들어오게 막는게 시그널 블락킹 이라 하는데 시그널이 블락 되있으면 블락되지 않은곳으로 가고 시그널이 모든 스레드가 다 블락 되있으면 이 시그널은 대기가 된다. 
++결론, 멀티스레드 에서 시그널 쓰는건 문제가 안된다. 메인이 시그널 핸들러 만들어놓고 스레드돌리면 됨 ++ 
인터벌 타이머가 시그널 핸들러로 들어가는건 마찬가지임.

## 과제
슬라이드 잘못됨 고쳐야함 2개의 숙제 step1 step2 나눔
주기적 돌아가는 시스템, thread 시스템 만듬

```java
//Make a thread that runs every 1 sec by using an interval timer
//the time-triggered thread 만든다. 시간에 의해서 격발, 주기적, 1초에 한번씩 돈다, 쓰레드 만든다, 시그널 핸들러 1초 한번씩 도는게 아님 쓰레드가 돔
평소 쓰레드는 블락되있음 1초마다 이 쓰레드 한번씩 꺠워줘야한다. 깨워줄때 cond_signal이다. 깨워주는 놈은 signalhandler가 깨워줌
시그널 핸들러가 1초에 한번씩 들어옴 그래서 쓰레드 깨워줌 그래서 타임 트리거드 스레드는 스레드 생성된 뒤 하는일은 이거다. while 돌면서

mutex_lock(); 
while(pthread_cond_wait(&condtion_name, &mutex)){ 
//cond_wait 하면 condition 이름은 적당히 주고 
//이거가 블락이 되서 기다리게 되면, 이것을 시그널 핸들러가 1초에 한번씩 깨워줌 1초에 한번씩 살아남 깨어나서 현재 시간을 찍어보면 1초가 지났다 라는걸 알고 하고 싶은일 있으면 함 끝나면 loop으로 돌아와서 다음 next 1초 기다림
일반적 타임 트리거드 스레드 하는일임
cond_wait 쓸려면 &mutex 써야함 그래서 mutex_lock을 하고 mutex 풀고 끝난뒤 unlock을 하자. 
	mutex_unlock();
    print current time; //주기적인 일을 함
    mutex_lock(); //lock을 걸어야 cond_wait함 lock이 걸려야 cond_wait 할수있다.
}//논문도 top-down 식으로 쓴다 큰거-자세히 
//밖에 사람은 원리를 보는게 아니라 서비스를 본다. 유저 인터페이스 설명
//기여한다. 새로운것. 만족해야함
//body, 누군가 이것을 1초에 한번씩 깨어줌 깨어나면 뭔가 일을함

Main thread 
itimer 을 쓸려면 sigalarm_handler 만들어야함
//Set the SIGALRM handler
//Make a condition variable and initialize it; 쓰레드를 위한 condition_variable 만들고 init 해야함

//Create the time-triggered thread //스레드 만듬, pthread_create 통해서 thread 만듬
//Create an itimer(tick = 10msec) //itimer 만듬, 10msec, 1/100초 한번씩 시그널 집어넣음 근데 이것은 1초 한번씩 깨워야 하니까 시그널 100번 들어오면 깨우면된다. 시그널 들어오는것 개수를 센다 100개가 들어오면 thread를 cond_signal 해줘야함, alarm_handler로 가보면 mutex_lock & unlock하고 
//while(1){pause();};

Main's SIGALRM handler
Mutex_lock(); //다음에 이유나옴
//ticks++ tick은 시그널이 들어온 횟수임 tick은 처음에 0 초기화함
//if(ticks % 100 ==0){ 100번 시그널 들어옴 0이면 
	ticks=0; //0으로 만들고
    pthread_cond_signal(&condition_name); //condtion_name을 깨워줘서 이놈이 돌아가게 만든다. thread가 저 
    그럼 저 thread는 1초에 한번씩 돌아가게 됨
    }
    set SIGALRM handler again;
    mutex_unlock(); 
}

```
//해보고 확장해보면 일반적인 시스템으로
피리어딕 시스템, 피리어딕 스레드들을 주기 다 다른 피리어딕 스레드가 여러개 있는 시스템을 돌릴 수 있는 시스템 만들어봄
거의 커널임

## Program Assignment(Timer Step2)
### Making a time-triggered thread management system for several
스레드가 여러개 가 있다. 주기적인 스레드.
주기적인 스레드가 다 주기가 다르다. 지멋대로 세팅 가능

threads(Step 2)
pthread_condition cond array[10];
스레드 10개 있다. 컨디션도 10개 각자 깨워줄수있음 그래야
pthread_mutex API_Mutex;
critical data 건드리는건 뮤텍스 필요 그래서 만듬
시스템커널속 시스템콜을 비슷한것을 만듬 
유저 레벨에서 클락 인터럽트핸들러 만듬 비슷한거
struct TCB TCB_array[10];
프로세스 있으면 pcb가 있음 
태스크가 스레드가 10개 까지 있을 수 있음 
그래서 커널은 스레드 관리해야함 그것을 tcb(태스크 컨트롤 블락) 이 블락은 스레드 정보들어감(스레드 마다 주기가 다르다. 그것을 기억함)
스레드 마다 주기 기억해서 스레드마다 깨우기 위해서 몇초 남았는지 알고있어야함 다 다르다.깨어나는 시간이 다름 기억하고 있어야함 스레드 마다 간직하는 struct 만들었는데 TCB 라고 만듬

### Make an API: tt_thread_register(period, thread_id)
//period in milli-sec, thread_id =0,1,2, ...  스레드 아이디 만드는 순서대로 0,1,2 만들때 번호줌 이것이 어레이 인덱스 되게 하고
tt_thread_register 라는 시스템콜 비슷한것을 만듬 
시스템콜이 아니다. 라이브러리다. 유저레벨 하니까 그런데
커널을 이렇게 만들 수있음 
tt_thread_register // time_triggered thread register 뜻. 주기적인 스레드로 나를 등록해주셈 시스템한테 
뭐가 아규먼트? period 주기가 얼마다! 나는 누구다 알려줘야함
만드는순서대로 0,1,2,3,4 붙이기로 했음 스레드 아이디를 준다. 이것을 라이브러리 펑션이다. 커널 시스템콜과 같다. 들어와서 tcb를 건들여야함 tcb에 뭘 집어넣느냐?
-pthread_mutex_lock(&API_Mutex);
-TCB[thread_id].period=period; //주기가 얼마야
-TCP[thread_id].thread_id=thread-id //몇번째 쓰레드
-TCP[thread_id].time_left_to_invoke=period; //1초마다 한번씩 깨워달라하는데 다음에 깨워줄 시간까지 얼마가 남았느냐 기억 그게 처음에는 period가 됨
이런것을 넣는다.
tcb를 건드리는것은 커널 이라이브러리 에 공유 데이터 여서 mutex 검
어레이를 써서 공유데이터 없음 사실 하지만 이안에서는 시스템콜해당 되서 공유 데이터 등장함 
tt_thread_register 들어오면 api mutex lock 걸고 이런 setting 다하고 mutex_unlock 풀고 유저프로그램으로 돌아감
-pthread_mutex_unlock(&API_Mutex);
tt_thread_register 스레드가 좀 생기면 tt_thread_register 통해서 자기 주기를 등록해야함 내가 만든 커널에게

아까는 while loop 이렇게돔 
이제는 기다리는 펑션 만듬(api 라고함) 타임트리거드 스레드임
주기가 될때까지 나는 기다림! 그런 펑션인듯

### Make an API: tt_thread_wait_invocation(thread_id) 
//이것도 역시 mutex_lock 검 커널속에서 있는거라고 생각이됨

-pthread_mutex_lock(&API_Mutex);
-pthread_cond_wait(cond_array[thread_id], &API_Mutex);
//cond_wait함 블락 되는게 그 방법밖에 없음(cond_wait해서 기다리는방법), 자기 스레드 마다 만든 컨디션이 있다고 했음 그 컨디션주고 api mutex에 lock을 풀고 cond_wait 기다림

++실제로 tt_thread_wait_invocation 해서 들어와서 대기함 주기가 ??? 할때까지++

-pthread_mutex-unlock(&API_Mutex);
### Time_triggered threads
타임 트리거드 스레드는 이렇짬
실제 스레드 생성이 되면 이렇게함
-tt_thread-register(myperiod, thread-id); //tt_thread-register call해서 자기 스레드아이디가지고 주기를 포함해서 나를 등록함
주기가 1이면 1초에 한번씩 깨워줌
-while(tt_thread_wait_invocation(thread_id)){  //기다림
wait_invocation하고 있으면 1초가되면 시그널 핸들러가 깨워준다. 
2초로 등록했으면 2초마다 한번씩 깨워주고 
3초면 3초마다 한번씩 깨워줌 깨어나서 현재 주기적으로 해야할일 하고 다시 
while loop으로 돌아감 
	print current time;
}

### Main thread
-Initialize condition & mutex variables; 초기화하고
-Set the SIGALRM handler //만들고
-Create several time-triggered threads; //스레드 3개 만듬
//3개의 스레드는 register, wait_invocation 함(왜 두개지?) 
-Create an itimer;(tick=10msec) 이건 타이머만들고, interval은 10msec 함 
-while(1){pause();}; 메인프로그램은 할일이 없음 그래서 pause 들어감
이렇게하면 1/100초 한번씩 시그널이 들어옴
그러면 시그널핸들러로들어감 

### Maian's SIGALRM handler (itimer handler) 
-pthread_mutex_lock(&API_Mutex); //mutex api, 얘도 TCB 건드러야 하니까 MUTEX를 쓴다. 
-for(i=0; i<num_threads; i++){ 
태스크가 10개 있음 그래서 다 봐야함 주기가 다달라서 
그래서 num_threads 만큼 loop 돔, 각각 스레드에 대해 
-TCB[i].time_left_to_invoke -=10; 10msec 지나갔으니까 10을 뺌 이걸 빼서 지워두댐 아래 if에 있음

if((TCB[i].time_left_to_invoke-=10<=0){} 이게 0보다 작으면 깨워야할 시간이 됨 그러면 깨워야 되지만 다음에 또깨워줘야함(다른 스레드 인가??)
	TCB[i].time_left_to_invoke =TCB[i].period; 
    time_left_to_invoke를 다음 period 만듬 또 빼나감
	pthread_cond_signal(&cond_array[thread_id];
    만약에 주기가 10개가 다 똑같은 주기다 그러면 cond_signal이 몇번 날라감? 10번 날라감 그러나 주기가 다 다름 해당하는 스레드한테만 cond_signal 날림
    이렇게 스레드 10개 감시, 그리고
    }
}
pthread_mutex_unlock(&API_Mutex);
//mutex_unlock하고
Set SIGALRM handler again;
//시그널핸들러 빠져나옴

훌륭한 주기적인 시스템 완성.

간단하다.

Q. 
어려울때 피하거나 하면 안됨, 써먹을대가 많다.

## setjmp() & longjmp()
안씀 잘
파일 오픈함 read함 open 하고 read/write ..??? 프로그램 짤텐데
open, read/write 에러가 발생하면 어떻게함? 처리를 안한다 보통
그렇게 짜면 안됨 에러처리해야함 건전한 프로그램이됨
에러에 대해서 대비해야함

큰 프로그램을 짜면 메인이 펑션 콜하고 그 펑션 또 펑션을 콜하여 대6줄까지 내려감 (스택이 쌓이는듯) 깊이가 5개가 펑균

귀찮은게뭐냐면 펑션이 5단계 밑으로 콜하면 맨밑에서 에러가 생기면 에러리턴해야함 단계적으로 올라옴 main까지 돌아올려면 5번 리턴해야함 귀찮다 이런게 시간도걸리고

귀찮음 맨밑바닥 에러발생하면 제일 위에있는 메인으로 직접 오게하는 방법있음
중간과정 skip, 한꺼번에 돌아오면 빠름 그게 롱점프다.longjmp임

longjmp는 펑션을 콜콜콜 해서 내려감 밑바닥에서 이상한 문제가생김 저 위로 올라가게하는 것 롱점프임 에러가 발생했을때 저 위로 스킾해서 올라갈려고 하면 위로 어디로 돌아가야하는 세팅을 해야함 (돌아오는자리) 그게 setjmp()이다.

setjmp는 저 밑으로 내려갔다가 한꺼번에 call return 무시하고 스택 전부없애고 왕창 한꺼번에 돌아오는게 longjmp고 longjmp하기전에 돌아올 자리를 정의를 해두는게 setjmp임.

setjmp하면 buf_env 라는건 한꺼번에 돌아오면 펑션 콜 할때마다 스택의 로컬 variable, 리턴 addr, 아규먼트 데이터 쌓여있음 콜할때마다 스택에 그걸 한꺼번에 전부다 파악해야함 한꺼번에 돌아올려고 하니까 그 내용을 저장해주는 버퍼임
혹시 나중에 뒤져볼라면 뒤져보셈! 이런거다.

일반적으론 안씀

setjmp하면 무슨 뜻? 나중에 어디선가 lonjmp하면 이자리로 돌아와! 뜻
setjmp를 call 하면 돌아오는게 2가지임 하나는 처음 call했을때 단순하게 뭘하는것? 돌아올자리를 setting하려고 call 설정만함 이때는 설정해놓고 한참 내려갔다가 나중에 lonjmp하면 다시 어디로 옴? setjmp 할 자리로 돌아올때에도 그때도 setjmp로 돌아오기때문에 리턴할때 2가지가있음

ppt에 return 2가지 케이스 존재함 
처음에는 처음 콜했을때 돌아올자리를 설정하기 위해서 call했을때 그때 리턴할때는 0이 리턴됨
나중에 longjmp에 의해서 리턴이 되면 일로 돌아오는것은 여기서 return하는것과 똑같은데 여기서 longjmp를 하면서 여기서 뭔가 값을 남김 이값을 리턴함

이것을 가지고 처음 콜한건지 나중에 뭐에 의해서 돌아온건지 (롱점프에 의해서) 알 수가있음

## setjmp(), longjmp() usage
그래서 setjmp 하면서 buf_env는 현재 stack 상황저장함
logjmp하려면 스택에서 쌓인게 있으니까 pop을 해나가야함 그게 이게 요거랑 같아질때까지 pop을함 
여기서 만든 이 buf_env를 여기서 알아야 longjmp할수있음 
이 env를 가지고 바로 setjmp한 자리로 돌아가게됨

```java
예. 메인 프로그램 
static jmp_buf env; //점프 버퍼 이미 정의됨 setjmp.h에
static은 이 파일내에서만 씀
void main()
{
	switch(setjmp(env)){ //셋점프를 점프함 처음 콜하면 0이 리턴 처음콜함 성공 브레이크해서 나옴 프린트에프하고 펑션콜 막함 그게 귀찬으니까 롱점프를함 env를 가지고 리턴 벨리유는 1임 
    롱점프하면 다시 셋점프 콜한 자리로 감 
    가서 리턴이 되는데 리턴케이스가 1임 
    이것은 롱점프에 의해서 돌아옴
    롱점프는 메인이 펑션 콜하고 콜콜 막 내려가서 밑바닥에서 롱점프하게 되면 예전에 셋점프 자리로 돌아오게됨
    	case 0:
        	printf("...");
           	break;
        case 1:
        	printf("...");
        exit(1);
        default:
        	perror("longjmp");
            exit(1);
    }
    printf("...");
    longjmp(env,1);
}
```
## Variable Types and the gcc optimizing compiler(1)
프로그램이 variable 인데도 변수 값이 바뀌지 않으면 자기가 알아서 상수로 바꿈
무지하게 똑똑함
옵티마이즈를 쓰고 셋점프, 롱점프를 쓸때에 variable들에 write type scope를 알아봄

```java
static void func1(int, int, int);
static void func2(void);
static jmp_buf jumper; 

int main(void)
{
	int at =1; //이건 local variable임 stack에 만들어짐
    register int reg=2; //register인데 가능하면 register에 할당해줘!
    register의 개수가 cpu마다 다름  integer 을 register에 할당(가능하면)
    volatile int vol=3; //상수인것처럼 보이지만(값이 안변하지만) 다른 어디에선가 바꿀수있으니까 옵티마이징 컴파일러가 상수로 바꾸지말아라 변수로 내버려 두셈
    if(setjmp(jumper)!=0){ 셋점프에 낫이퀄 제로, 제로인경우에는 처음 call한것임 제로일때에는 요게 안걸림 요것은 롱점프로 돌아옴 
    	printf("..."); //값을 찍는것임
        ++longjmp해서 at하고 register, volatile 찍어봄 output은 
    (여긴가 윈가?) 원래는 11,12,13으로 바꿔놈(func2에서 올라왔음)
    func1은 11,12,13을 찍음, func2 해서 롱점프 돌아왔음 11,12,13이 됨
    만약에 옵티마이징 컴파일러 쓰면 똑같이 하긴 하는데 
    어! 이거 이거 11,12,13 바꾸기 이전이네 그런데 printf 했네 
    옵티마이징 컴파일러가 셋점프까지 모름 여기서 찍는것도 상수로 바꿔버린다.
    1,2,3 으로 바꿔버림 바꾸기 전이니까 옵티마이징 컴파일러로 찍으면 1,2 하고 vol에 의한것은 13으로 나옴
    	
        ++
        exit(0);
    }
    at=11; 처음에 콜할땐 일로내려옴
    reg=12;
    vol=13; //1,2,3 이었는데 11,12,13으로 바꿈
    func1(at,reg,vol); //func1 콜함 아규먼트 넣어서 call by value 가지고 call함
}

static void func1(int i, int j, int k)
{
	printf("in func1(): automatic =%d, register =%d, volatile =%d\n", i, j, k); //11,12,13 나옴, 
    printf 한다
    
    func2(); //콜함
}
static void func2(void)
{
	longjmp(jmper, 1); //일로들어옴 , 위로 돌아옴
}
```
이것도 돌려봐라!

## Results
결과
그냥 컴파일 ,11,12,13 임
옵티마이징 컴파일 1,2,13 결과가 다르게 나옴


# Memory Mapped File
파일에다가 뭔가를 save하고 파일을 읽어올려하면 오픈하고 read/write하고 close해야함 그런데
워게임 시뮬레이션 장교를 위함 
중간에 정전이됨, 변수들이 많음 (변수들이 변하는값들 정전이되면 날라감)
시뮬레이션 돌아가면서 백업을 받아야함
디스크에다 세이브해야함 
시간마다 백업을 파일에다가 open해서 write close하면되는데 귀찮음
그래서
메모리 variable을 파일에다 mapping해서 메모리에 쓰면 자동빵으로 파일까지 감
open read/write close 할필요없음
메모리 variable int=a했는데 a=3 집어넣으면 a 메모리에 3이 들어갈 뿐만 아니라 파일까지 들어가서 자동 세이브 되는게 메모리 맵드 파일임

대부분 큰 struct가 됨 그 struct를 한꺼번에 그것을 파일에다가 연결고리 만들어놓으면 메모리에서 variable에다 struct에다 쓰면 파일로감
(메모리에 있는것을 파일에다가 미리 백업해두는 형태인듯)

## 일기예보
왜틀리냐?
앞날 예측, 어케함?
과거 정보를 가지고 시뮬함
시뮬 할려는데 방정식있어야함
방정식 파라미터 몇천개
어느지방에서 바람이 얼로 불어옴
아프리카 캐냐에서폭풍 일어남
그런 파라미터 천개 방정식을 가지고 돌려봄 
앞날 예측
그래서 일기예보나옴
파라미터 100개, 1000개 후자가 더 정확
그래서 뭐가 필요함? 슈퍼컴이필요.
그거전에 천개의 변수를 찾아내서 방정식을 만들어야함 그게더 중요
기상학자가 함
일반컴퓨터가지고 시뮬레이션안댐 계산이 너무 많으니까
1000개 파라미터 가 시시각각 변함

## 증권시장
석유값에 영향을 미치는게 몇천개 파라미터 일것임
그렇게 해서 시뮬레이션 예측하는게 시뮬레이션임
시뮬레이션 할때는 오랫동안 돌려야 하기때문에 천개의 파라미터 전부 세이브함
그런것을 메모리 베리어블을 파일에다 맵핑하면 자동빵 세이브댐

## Process Address Space
text, data (bss 까지 합쳐서 data임 bss는 uninit 하지 않음) 나누는 이유 나중에 설명
heap
stack

main이있고 main 위에 integer a=0, b, c
int a =0, b;
int c =3, d; 
이런식으로 int 4개가 있다고 함 모두 global variable임
init 하지 않은건 b,d 임 이건 bss로 들어감
a,c는 init해서 data로 들어감
왜이렇게함? 
페이지 캐시 배웠는데 목적은? 디스크 아이오 줄이기위함
inode cache, name cache, d entry cache 다 디스크 아이오 줄이기 위해서 커널이 얼마나 노력하는지 알수있음
main

프로그램을 컴파일 하면 디스크에 무슨형태로 있음? a.out 형태로있음 a.out에는 (디스크에) 텍스트 하고 데이터 들어감 프로그램에 뭔가 값을 저장하고 있어야 하니까 
heap, stack은 필요없음 그건 a.out에 없음
그건 왜냐하면 프로세스가 되야지 돌아갈때만 필요함 메모리 올려놓은다음에 만들어줌
내가 프로그램을 a.out 두들기면 a.out이 디스크에서 메모리로 올라옴 text data 올라오고 heap stack 만들어줌

b,d 도 global variable임 데이터임 이것을 모아서 bss 모아서 따로 만드는 이유는 a.out 에서 가지고올 필요없음 왜? 값이 정해져 있지 않으니까 
그러니까 b,d는 자리만 만들어놓고 0으로 깔아놓으면댐 값이 안정해져있음
a,c는 디스크에서 읽어와야함 초기값이 있어서
b,d는 a.out에 들어갈 필요없음 크기만 알면댐
b,d가 있으니까 8byte 있다고 하면 나중에 저 프로글매 올릴때 bss 들어간것은 디스크에서 읽는게 아니라 메모리에다 할당을 그공간만큼 해서 0으로 깔아버리면 디스크 아이오를 줄인다. 그래서 data bss 구별을 함
(디스크 아이오를 줄일려고 그러나 보다.)

## Memory Mapped File
struct를 갖은것
어떤 메모리 어레이 라고 해도 좋음
메모리 area를 파일에 맵핑 함으로써 자동빵으로 세이브가 됨
그래서 읽는건 메모리 읽는게 파일에서 읽는건 메모리쓰는게 파일에 쓰는것임
물론 이것은 페이지 캐시까지 임
두번째 목적은 여러개의 프로세스가 하나의 파일에다가 메모리를 똑같은 공간을 맵을 했다. 이친구도 나라는 파일에다가 자기공간을 맵핑했고 이친구도 자기공간을 나라는 파일에다 맵핑을 하면 
얘가 쓰면 여기도 영향을 미침 다 share하니까(공유하는 다른 애인듯..)
방금 뭐가 됨? 프로세스간에 통신이됨 통신 기술로 사용가능함

## Memory Mapeed File
사용하는 시스템콜임
caddr_t mmap(caddr_t adr, size_t len, int prot, int flags, int fildes, off_t off);
mmap 
메모리 맵핑해달라
아규먼트 많다. 자기가 맵퍼하고 싶은 메모리에 스타팅 어드레스 (메모리 위치), 길이(메모리길이), prot 여기에 대해서 읽을수 있느냐 쓸수있느냐 권한임, flags는 맵핑 다음 장설명, 파일에다 맵핑 파일 오픈해서(파일디스크립터받음) 오픈한 파일에 디스크립터, offset을 줌(메모리 area를 파일에처음으로 맵핑할꺼냐 100byte 건너가서 거기서부터 맵핑할꺼임? 위치를 지정해줌) 
일반적으로 offset을 0으로 주면됨(처음부터면)

flags - mapping scan

그림으로 보면

## File-memory Mapping by mmap()
그림으로 보면 내가 프로세스 있음 
자기가 데이터, 힙이 됬든지 stack이 됬던지 malloc을 하면 heap에 생겼을 것이고 데이터 공간이면 data 공간에 있을거고 
어느 일정 공간 크기는 같아야 함
파일에 offset만큼 가서 여기서부터 여기까지 mapping시키는게 mmap이라는 시스템콜임
여기다가 쓰면 파일까지 가고 여기서 읽으면 파일에서 올라옴
자동으로 세이브됨 
파일 I/O 할 필요없음

맵핑할때 어드레스 주는데, 그것을 malloc하면 주소 잡아옴
그건 어디에 있어 heap에있음. heap 공간이댐
글로벌 변수에 ??? array잡음(main에?) array stating addr 맵핑 주소 잡으면 거기다 맵핑되고 맘에로 정할수있음

addr을 안주면 맵핑을 하는데 어디에 맵핑하는지 모름 그러면
커널이 프로세스의 빈공간 잡아서 적당한곳 맵핑시켜줌 
그때 주소를 알아야할것이냐 그게 일로 return 됨

## "prot, flags" arguments
prot은 (프로텍션) read만 하면 write할수있느냐 execute 할수있느냐 이런 ??? 주는것임
flag이다. 맵핑스캔이라고 되어있음
flag가 뭐가 있냐면 map_shared를 제일 많이 씀
map_shared라고 하면 내가 디스크에 쓰는게 
메모리에 쓰는게 디스크 파일까지 나감
디스크 파일까지 나가야지 다른 프로세스 똑같은 파일에 맵핑하면 공유할 수 있음
당연히 디스크 까지 나간다 라는 파일에다 싱크로나이즈가 됨 
그렇기 때문에 프로세스 간에도 공유할 수 있음
map_shared

그런데
디스크에 있는 파일은 어떤 경우는 손상시키고 싶지 않음
디스크에는 맵핑하는데 읽어오기만 할껏임 디스크에 있는 내용을 바꾸고 싶지 않음
map_private 씀
디스크 에서 원본 읽어옴 내가 메모리에다 쓰는게 디스크까지 가지 않음. 원본은 손상되지 않음
map_private 쓰면 프로세스간에 송신이 안됨 write 반영 안댐
디스크 파일 변하지 않음 읽어오는 용도
writing하는것도 메모리 반영되고, 디스크 반영되지 않음

map_fixed라는것은 내가 준 주소에다 맵핑하는데 맵핑 불가능하면 커널이 적당한 자리를 잡아서 그렇게 하지 말라! 꼭 내가 정한 자리에다가 맵핑이 안되면 에러리턴해줭! 0으로 주면 0이 null이니까 커널이 적당한 자리???? 뭐야 방금 에러리턴한다메!!!!!

## Release a memory mapping
munmap은 해제하는것이다. 해제하는데 나와있는 그림처럼 
여기에 있는 요만큼의 area를 요만큼 맵핑했다.
해체할때도 뭘 주냐면 addr하고 길이 줌 
이사람은 전체 해제 한게 아니라, 반만 해제하고 반은 남아있음
부분적으로 해제하는것이다.
부분적해제는 별로 안쓰임

## File copy example by using mmap file(1)

```java
#define FILE_MODE S_IRUSRIS_IWUSR //디파인 파일모드는 유저가 리드할 수있고 유저가 write 할 수 있다. 이것은 이제 에러 생겼을때 콜을 하는 루틴이다. int val


void mperr( call, val)
char *call;
int val
{
	perror(call);
    exit(val);
}

int main(int argc, char *argv[])
{
	int fdin, fdout; 
    caddr_t src, dst; 소스 데스티네이션
    struct stat statbuf;
    if(argc!=3)
    	mperr("usage : a.out <fromfile><tofile>",1);
        fromfile이 뭐냐면 a.out 돌리는데 input, ouput file 이름 줘
        여기있는것을 일로 카피해(옆인거같아)
    if((fdin=open(argv[1], O_RDONLY))<0){
    	인풋 파일 들어온것을 readonly 모드로 오픈해
        첫번째 아규먼트의 promt파일 오픈했다. 에러난거 처리다 아래는
    	fprintf(stderr, "can't open %s for writing", argv[1]);
        exit(2);
        
    }
    if((fdout=open(argv[2], O_RDWR|O_CREAT |O_TRUNC, FILE_MODE))<0){
    output파일을 만듬 만들때 여기다 create 옵션을 줘서 없으면 만든다.
    파일을 create 생성 함 
    만약에 파일이 있으면 싸그리 지우고 새로 만들어줌
    파일 모드는 유저가 리드 와 라이트 할 수 있다.(리드 라이트 모드로 오픈했다.)
    파일을 카피할려고함
    이것을 mmap 파일 이용해서 할려고함
    맵핑을 해야함 그럼 파일을 메모리 맵핑할려면 
    파일의 크기를 알아야함 (인풋 파일의 크기)
    
    fprintf(stderr, "can't creat %s for writing", argv[2]);
    exit(3);
    }
    if(fstat(fdin, &statbuf)<0)
    인풋 파일의 크기를 알기위해서 fstat가 파일의 상태를 돌려주는 시스템콜을 씀
    state 버퍼에 파일의 상태임 거기에
    파일의 사이즈가 리턴됨 (?????state 사이즈)
    파일의 크기 byte 단위의 파일크기가 리턴됨
    (뭔말인지 모르겠네)
    
    추가설명) input file을 read 모드로 오픈함 이 크기가 지금 st_size다 이게 지금 200byte라고 하자 파일의 크기가 
    이걸 알아야함 맵핑할려면 
    지금 뭘 만들었냐면 create output file 하나 만들었음 
    파일을 하나 만들었음 output 파일은 크기가 없음 아직 아무것도 쓴게 없음
    파일의 크기가 없으니까 200byte에 메모리에 맵핑 할 수 없다. 
    이것은 맵핑할 수있다. (이것은 파일이 있으니까 200byte 짜리 있으니까 맵핑가능, 이것은 input file을 말하는듯..)
    이것은 파일을 creat 했지만 아직도 아무것도 쓴게 없어서 파일의 크기가 없다. 사이즈가 st_size가 0이다. 이것을 200byte 짜리 맵핑 할려고 하면 불가
    fdout, 두번째 파일에 st_size -1 이것은 인풋 파일의 사이즈임 199가 됨
    그래서 output file에서 SEEK_SET이라는건 파일에 처음으로 기준으로 해서 199만큼 가라 (lseek를 했으니까, 마지막에다 뭘쓸라고 함)
    fdout에 마지막에 null char 씀 여기다가 글자를 하나 썼다. 글자를 써야지 비로소 200 byte 짜리 파일이 됨 아무것도 없으면 안됨
    ++그래서 저게 200byte 면 이것을 199 칸만큼 가서 그자리에서 null 캐릭터 하나를 씀으로 이것을 얼마짜리 파일로 만드냐? 200byte짜리 임시파일로만듬++ 그래야지 맵핑이 되니까! 
    
    
    	mperr("fstat error", 4);
    if(lseek(fdout, statbuf.st_size-1, SEEK_SET)==-1)
    	mperr("lseek error",5);
    if(write(fdout,"",1)!=1)
    	mperr("write error",6); //마지막 null을씀 
그 다음에 맵을 한다.
	if((src=mmap(0, statbuf.st_size, PROT_READ, MAP_SHARED, fdin,0))== MAP_FAILED)
    mmap, 몇바이트? 200바이트임
    read모드로 맵핑을 함 맵 shared 함.
    input 파일을 0, 처음서부터 200바이트 맵핑해라
    맵핑 하는 장소는 아무데라도 좋음. 0을 줌 
    이것의 의미는 커널이 적당한 자리잡아서 메모리에다 맵핑을 해달라함
    커널이 맵핑한 자리가 소스로 리턴됨 
    
    여기에 프로세스가 있는데 (그림)
    프로세스에 여기에 소스(src) 가리키는 곳에 200byte로 맵핑이 됨 
    두번째는 
    mperr("mmap error for input", 7);
    if((dst =mmap(0, statbuf.st_size, PROT_WRITE, MAP_SHARED, fdout, 0))== MAP_FAILED)
    두번째는 output 파일도 맵핑함 write 모드로 맵핑함
    amp_shared이고 fdout은 0에서부터 200바이트 만큼 맵핑하는데 장소는 아무데나 좋음
    당신이 맵핑을 하면 주소를 dst 달라음
    이 파일은 여기다가 맵핑 주소가 dst 온다(포인터임)
    
    파일을 카피할려고하면
    mperr("mmap error for output",8);
    memcpy(dst, src, statbuf.st_size);
    맵핑을 했으니까 소스에서부터 dst까지 200바이트를 메모리 카피해라
    memcpy (메모리에서 메모리로 카피) 200byte 카피해라 이렇게하면 output파일까지 나감
    if(munmap(src.statbuf.st_size)!=0)
    	mperr("munmap(src) error", 9);
    if(munmap(dst, statbuf.st_size)!=0)
    	mperr('munmap(src) error"),9);
    exit(0);
}

```

##  result
./a.out myfile mycopy
하면 myfile 있었는데 mycopy가 생긴다. 이런의미임

msync는 메모리 맵핑 해서 파일로 나갔지만 디스크까지 간게아님
페이지 캐시 까지 감
디스크 간다는 완전한 보장이 없음
msync하면 갔다 완전히 디스크에다 써라
usb 뽑기전에 하드웨어 안전제거와 마찬가지

## flags
async는 디스크에다 sync 하는데 i/o 할려면 많이 걸림
걸리는 시간동안 기다리지말고 명령만 내려놓고 즉시 리턴해라 나중에 끝남
그러면

ms_sync 는 디스크 i/o 에서 완전히 sync 가 끝날때까지 기다려야 함 block되서


## memory copy
mem copy 라는 시스템콜임
소스에서 dst 까지 메모리 to 메모리 카피
얼마만큼 기냐? (기냐? n은 길이임.) 위의 예제이 보면 알 수 있음.