---
post : layout
title : 컴퓨터구조 7
---
## 들어가기 앞서

## MIPS Control Flow Instruction
Branch 명령어를 살펴볼껀데, 조건에 따라 등기지점을 지정하는 명령어 이다. Branch target 은 라벨이라고 표현하며, 라벨을 절대 주소로도 표현 가능하다. 
이렇게 하지 않더라도, pc로부터 얼만큼 떨어져 있는지 떨어진 거리를 offset으로도 표현할 수 있다.

절대주소를 쓰지 않는 이유는 값의 범위만큼 움직여야 하기 때문이다. 그 자리에만 하지만 pc로 움직이면 더 많이 움직일 수 있다.

라벨은 offset으로 메모리에 표현되고, pc값을 기준으로 얼만큼 떨어졌는지 (offset) 라고 정의하는데 branch는 명령어 위치가 4의 배수에 해당되고 움직이게 된다.

중요한것은 Branch 명령 수행시 pc는 다음 명령어 주소를 갖는것이다. 100~108 사이의 라벨 offset을 구한다면 현재 100을 가리키는경우 1word만큼 떨어져있다. 

## Branch 명령 사용 예제
if(i==j) f=g+h;
else f=g-h;

bne $s3, $s4, Else
add $s0, $s1, $s2
j Exit
Else : sub $s0, $s1, $s2
Exit :
라벨은 해당 명령어의 주소를 의미한다.
어셈블리는 어셈블러를 통해서 기계어로 바꿔준다.
j Exit가 없으면 ELSE로 간다. 하지만, ELSE는 코드상 우리가 원하는 위치가 아니다. 
Else part에 word offset은 2다.
16bit wordoffset은 가 들어간다. 라벨까지의 차이를 word offset으로 else 라벨에 저장하는게 기계어의 번역 과정이다.
(pc는 다음 수행할 명령어의 주소를 가지고 있다.)

## Assembling Branches
bne $s0, $s1, Lbl //not equal
beq $s0, $s1, Lbl //equal

Machine Foramts 은 bne 5, beq 4, rs, rt, offset 자리를 채워넣는다.
맨 앞자리는 opcode 위치이다.

## Specifying Branch Destinations
메모리 주소에 명시되고 32 bit 필드가 명시해야 한다.

## Disassembling Branch Destinations

## Offset Tradeoffs
하위 16비트에 byte->word offset을 저장할까
1. 가야할 위치가 word 주소이다.(4의 배수가 word만큼 차이가 난다.) => 14비트만 의미있고 2비트는 낭비함, 16bit를 충분히 고려해서 사용하는게 더 의미있다.
2. 메모리는 byte 주소를 인식한다.(byte-addressable)

## less-than Conditional Branch
slt(=Set on less than)
slt $t0, $s0, $s1 ($s0, $s1을 비교해서 $t0에 1이나 0이 저장된다.)

Instruction format(R-format)
opcode : 0, rs : 16, rt : 17, rd : 8, shmt : 0, funct : 0x24
(slt function code 0x24)

#### Alternate versions of slt
slti $t0, $s0, 25 (immediate 값)
sltu $t0, $s0, $s1 /// sltu는 unsigned를 표현하는데 부호를 갖지 않는 상태에서의 값을 비교한다. 즉, 가장 큰값으로 표현된다. 비트패턴을 어떤값으로 해석이 더 중요한 측면이다.

sltu $t0, 1, -1 일때 32bit로 표현해서 -1의 값이 실상 255가 된다. 따라서 $t0에는 1의 값이 저장된다.

```java
if(x<y) // slt 로 적용
```
```java
unsigned x,y;
if(x<y) //sltu로 적용해야한다.
```

## 기타 Branch 명령어
사용자의 편의성을 고려하여 의사명령어, 수도 인스트럭션을 제공한다. 다음의 MIPS 코드는 2개로 나눠지는데
less than을 표현하기 위해서
slt $at, $s1, $s2 //$at는 어셈블러가 어셈블하는 중에 쓰는 Tempory용 레지스터이다.
이런식으로 짝을 이뤄서 동작하게 되고, 2개의 문장을 사용자가 안써도 편하게 해준다.

less than or equal to ble $s1, $s2 Label
greater than bgt $s1, $s2, Label
great than or equal to bge $s1, $s2, Label

less than : 앞에꺼
greater than : 뒤에꺼

ble $s1, $s2 Label
slt $at, $s2, $s1
beq $at, $zero, Label

bgt $s1, $s2, Label
slt $at, $s2, $s1
bne $at, zero, Label

bge $s1, $s2, Label
slt $at, $s1, $s2
beq $at, $zero, Label

## Unconditional Jumps
J-type instruction format
점프 대상은 텍스트 (코드) 세그먼트의 아무 곳에 나있을 수 있습니다.
j-type은 op 6bits 이고, address가 26bit이다.
실질적으로 address에 값을 넣을때는 word단위로 써준다.(4로 나눈값) = byte addr/4

##### Direct addressing mode, absolute addressing mode
addressing in jump instruction
j 10000 # 브랜치 주소 = 10000 (in words)
##### word address
브랜지 주소 = 10000 * 4
j 10000 # 실제 브랜치 주소 = 40000 (in bytes)

## Unconditional Jumps(2)
MIPS는 Pseudo-direct addressing을 지원한다.
PC의 상위 4비트를 변하지 않고 사용되어진다.
Target address=PC(31...28) 여기에 표시되는것은 byte가 표현되므로 x4를 한것, PC(31...28):(address x 4)
Address boundary of 256MB 다.
//상위 4바이트를 빼고 28비트는 256M-1인데 상위 4비트를 0으로 고정시키면 순수 256Mbyte가 최대가 될것이다.

메모리에서 받는 address는 32bit다.
pc가 갖고있는 값에 맨 꼭대기 4bit를 가져다가 0대신 쓸 수 있으면 pc가 가리키는 곳으로부터 순수 256Mbyte 공간을 access 가능하다. 고정되지 않고 더큰 메모리 크기를 사용할 수 있다.
(pc의 위치에서부터 전에는 256Mbyte-1을 갔다면 지금은 256Mbyte를 자유롭게 왔다갔다 할 수 있는 위치)
이것을 ++Pseudo-direct addressing++ 이라고 한다.

Target address
from PC(4bits) from instruction's address(26bits) 00(2bits)
지금 여기서는 byte로 표시되어 있기때문에 26bits와 2bits와 나눠져 있다고 생각하면 될것 같다.

## 먼거리(16-bit 이상의 offset)로 분기하는 방법
다음의 machine instruction을 살펴보자.
beq $s0, $s1, L1_too_far_away

becoms
	bne $s0, $s1, L2
    j	L1_too_far_away
  L2:

만약에, Lavel의 위치가 너무멀어서(=너무 커서) 16bit를 벗어나게 되면 Label로 표현할 수 없게 된다. 따라서 J-Type instruction format을 사용해서 op가 6이고 나머지 26bit를 활용한 등기주소를 표현하면 16bit보다 더 넓은 범위의 주소를 표현할 수 있게 된다.


