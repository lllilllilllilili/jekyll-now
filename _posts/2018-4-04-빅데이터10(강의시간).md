
## Bloom Filter -- Analysis(2) 4/4
n은 key값의 개수
k는 Hash function의 숫자
Hash funcion이 증가하면, Hash funcion만큼 bit array에 저장해야한다. 
![mmodulen.PNG](C:\lllilllilllilili.github.io\images\mmodulen.PNG)
이 값을 계산해보면 8ln2(ln2=0.69 = 0.54 approximately) bloom filter가 6개가 필요하다.

## Bloom Filter: Wrap-up
Bloom Filter는 false negative는 return 하지 않는다.
false positive는 존재 할수있음(Hash collision에 의해서 발생하는데 줄일수있다.)


![빅데이터1.PNG](C:\lllilllilllilili.github.io\images\빅데이터1.PNG)
Bloom filter는 하나로 길게 잡는것이 편하다, 따로 잡으면 struct를 따로 잡아야 된다. k로 쪼개면 false positive 확률은 kn가 n이 된다. 결과는 똑같고, 전자가 구현하기 쉽다.

###### Suitable for h/w implementation
간단한 bloom Filter를 app으로 처리하는것이 아니라 H/W 로 만들어버리면(전처리만 처리해도) app에서 처리해야하는 부담이줄어든다.

## Counting Distinct Elements
Stream data가 들어왔을때 Unique한 element를 셀려고 한다. 중복된것은 제외한다.

###### Problem
빠른시간내 처리, Unique한 data 처리 => Hash struct

###### exmaple
Amazon 팔린 품목을 처리할때 Unique Item을 count할 수 있다면 전체 팔린 품목중에 원하는 Unique Item을 찾을 수 있다.

## App
crawled 해보면 Web pages에 word가 중복된것이 없고 Unique한것만 있을때 spam 을 사용한다.

통계치를 찾고싶을때 Web site에 Unique만 찾아서 센다.

## Using Small Storage
1Billion bit = 1Giga item
Stream 저장하는데 저장할 공간이 부족할 수 있다.

## Flajolet-Martin Algorithm
Hash function 을 Mapping으로 쓰는것이 아니다.
들어오는 n(window) element가 있으면 이것을 표현하기 위한 bit => logn 
최악의 경우, 각각이 모두 Unique경우 logn bit만큼(최소한) 필요
Hash value를 logn bit에 저장한다. binary stream 형태로저장 그리고 이것을 분석한다. Hash 함수를 가지고 logn bit 에 Hash value를 저장하는 이유는 높은 확률로 같은값(각각 element), 잘 분배될 수 있다. 계속 반복, 
각 logn bit가 0101010 ... 저장 그 bit의 제일 끝에서 0이 몇개가 나오지를 count(연속적인 0의 개수를 파악) Max값을 저장(Max가 나오면 update 방식)

Max tail length가 몇개 bit다 라고 나온다.0000 , MAX가 4라면 유니크한 아이템이 2의 4승개다.




