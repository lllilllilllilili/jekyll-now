---
post : layout
title : 시프(기)8
---

## 시프(기)8
파이프에 관한 내용이다.
어 파이프는 두개의 파일 디스크립터를 받는데 그 두개는 각각 리드랑 라이트 오프셋을 가리키고 입력 인수는 파이프 생성과 함꼐 반환되는 두개의 파일디스크립터이다.
파이프는 초기에 빈상태로 생성이되고 정상적으로 작동하면 0을 리턴합니다.
이거는 언 네임드 파이프다.
포크하기전에 파이프를 이렇게 만들어놓으면 이파이프 디스크립터 2개를 차일드도 물려받기때문에 서로 통신을하고 프로그램이 끝나면 자동으로 파이프 자체가 없어지는 즉 가족 간에쓰는 파이프를 이름이 없는 언네임드 파이프라고 합니다.

파일디스크립터 0은 읽기용사용 1은  쓰기용으로 사용이 되어있는데요 
어 포크 이전에 생성된 파이프는 차일드에서도 상속이되서 일반파일이랑 같이 사용을 한다. 그리고 포크에 의한 관계에 있는 프로세스들이 상속해서 사용하는 파이프를  언네임드 파이프라고한다.

설명을 하면 설명을 하면서 내려간다.
알고있는거지만 앞으로도 이제 회사 발표 pt 한다 그러면 저렇ㄱ ㅔ한자리에서서 하면 안된다 왔다갔다  하면서 한다. 듣는사람한테서 좋은 메시지 전달 그렇게 하는 스타일은 

-교강
이제 파이프로 오픈한다음 포크를 하면 부모도 2개가 생기고 파이프도 2개가 생기니까 이게 4개 채널이 오픈되는거잔아요 한쪽에서 보낼꺼면 이거만 필요하고 이거는 필요없으니까 이쪽에서 close하고 이쪽에서 받기만 할꺼면 어떻게 합니까 쓰는쪽을 close한다 이거임 그래서 다음 페이지로 가면 
이거는 이제 저 차일드에서 쓰는거죠 차일드에서 읽어오니까 쓰는거고 부모가 받을때는 요거 요거 를 클로우 하는거다 라는 이런 얘기가 되겠다.

우선 파이프를 아까 말한것처럼 파일 디스크립터 2개줘서 생성을 하고 만약에 
슬라이드 제목이 뭐여
뭐하는겁니까 여기 에 로그인한 사연 .. 설명을 하고 

## who | sort
who는 쉘커멘더 , 그래서 누가 로그인을 했는지를 이름을 디스플레이 하는게 후죠
sort는 뭐에요 이것도 쉘커멘더죠 쉘커멘더죠 원래 키보드 에서 들어가는거를 리스트를 엔터엔터 치면 그것을 어떻게 합니까 자동으로  솔팅을하는 셀커멘더가 되겠다 근데 후라는 쉘 커멘더하고 뭐에요 소트 커멘더를 두개를 따로따로 돌리면서 그 사이를 뭘로 연결을 한거에요 ?
저기 막대기 있는게 바로 파이프죠 
그래서 who에서 나오는 아웃풋을 그대로 내보내지말고 sort를 거쳐서 로그인 네임을 이름 순서대로 소팅을 해서 디스플레이 해달라 얘기다. 그죠
설명을 하고 프로그램

그래서 파이프 에 만들고 에러가 나면은 에러메시지를 출력합니다. 
파이프를 하면 에러가 생기겠습니까 안생기겠습니까 안생기겠죠 그러나 혹시몰라서 여러분들 프로그램 짤때 시스템콜을 하면 대부분 -1이 리턴되는거에 대해서 처리를 하는게 좋다 이런부분이 프로그램에 몇퍼센트를 차지한다 그랬어요 30% 차지해야 한다고 그랬다
그리고 파이프가 잘만들어졌으면 읽기 용 디스크립터를 닫고 
복사 하고자 하는 저 dup2() 저게 복사하는 함수 첫번째 인자로는 복사하고자 하는 파일 식별자를 넣고 두번째는 복사되는 파일 식별자를 입력으로 준다. 여기서는 읽기용 을 줘서 
여기서는 쓰기용 파일 디스크립터 복사본을 만드는 식이고 
그러니까 첫번째 차일드 두개를 만들었잔아요 내프로그램이 
첫번째 차일드는 뭐가 돌아갈꺼에요 나중에 who 라는 프로그램이 돌아갈거아니에요 두번째 차일드는 소트 가 돌아갈껀데 
who에서 뭘로 나옵니까 스탠다드 아웃으로 나오는것을 뭘로 돌려야되요 파이프에 write 채널로 돌려야지 나가겠죠 그래서 dup2 를 해서 파이프에 write 채널을 어디에다 스탠다드 아웃풋에서 카피를 해버렸다 깔아뭉개고 그러니까 who 라는 프로그램이 돌아가더라도 자기가 printf 같은 것을 한다고 그러면 그게 얼로 나갑니까? 모니터로 나가는게 아니라 항상 파이프 로 나가게된다.
그럼 파일디스크립터 제로는 필요가없으니까 다 닫았고 그다음에 fs1은 스탠다드 아웃에다가 복사 를 하니까 또 필요없으니까 닫았고 그리고 나서 execlp에 who who char0는 멉니까, 실행할 파일이랑 인수 목록을 인자로 줘서 다른 프로그램은 실행 시키고 자기는 종료 하는 ..? 그러니까 자기는 없어지고 첫번째 차일드 대신에 뭐가 올라온거 ? who 라는 프로그램이 올라올꺼 아니에요 그렇죠 who 라는 프로그램에 아규먼트 카운터 하고 아규먼트 벡터가 있는데 아규먼트가 몇개가 들어가는거에요? 여러분들 shell을 칠때 제일 처음에 있는게 프로그램 이름이 첫번째 아규먼트로 들어가고 두번째 에 있는게 또 아규먼트로 들어가잔아요 그래서 첫번째 아규먼트 who 가 두번째 아규먼트 ?? 는 없다 이런얘기임 
그래서 who 라는 프로그램을 돌린것이다 who라는 프로그램은 당연히 뭘로 시작을 합니까 main으로 시작할거 아니에요 그렇죠 거기에 아규멘트 벡터 두개를 준거입니다. 

그다음에 다시 쓰기용 파일 디스크립터 안쓸꺼니까 닫고 다시 읽기용을 스탠다드 인 저기에복사시킨다음에 
그러니까 sort 는 원래 키보드 에서 받아야 되는데 키보드에서 받을껄 어디에서 부터 받으라고 파이프 에서 받으라고 하는거죠 그렇게 
거서 한겁니다 
exit(3) 는 머에요 
종료이긴 한대 execlp를 하면 메인 프로그램대신에 뭐가 올라옵니까 이제 소트 가 올라오니까 일로 와요 안와요? 정상적인 경우에 일로 안오죠 그런데 일로왔단 얘기는 이거 하다가 모에요 에러 리턴 했단 얘기 아니에요 뭘 못찾아서 sort 같은 것을 못찾아서 그래서 exit 한다 얘기임 에러 났을때 얘기임 이건 

요거는 부모죠 
그래서 close close 하고 
그다음에 저 wait 파이프 id 
프로세스 아이디 에다가 
감시할 자식 프로세스 아이디값으로 0을 주는데 0은 현재 프로세스 그륩 아이디랑 같은 그륩의 자식프로세스 가 종료되면 복귀하라는 거고 두번째 에다가 자식 프로세스에 종료 상태 정보를 인수로 주고 새번째에는 대기를 위한 옵션으로 인수를 주는데 0은 자식프로세스가 종료될때까지 블락하라는 의미이다. 
앞에 0은 뭐냐면 프로세스 그륩을 얘기하니까 내가 지금 만든 차일드 몇개에요? 2개잔아요 2개를 다 기다려 아무거나 주는것을 기다리겠다 얘기고 여기서부터는 뭡니까 죽을때까지 블락되서 기다리겠다. 그러면 첫번째 자식이 죽으면 뭐가 리턴이 될까요 1이 리턴이 될거아니에요 그렇죠 첫번쨰
1이니까 다시 로그로 들어가서 -1 이 아니니까 
두번째 자식이 죽을때 또 어떻게 되요 또 1이 리턴되니까 또 waipid 할꺼 아니에요 근데 waitpid 들어왔는데 이제 자식 2개가 어떻게 됬어요 다 죽어버렸으니까 더이상 기다릴게없어서 뭘 리턴합니까 -1을 리턴을해서 빠져나온다
이런얘기임

그래서 -1 리턴 안되면 프로세스 종료 를 합니다 
음?? 
아이거 자식이 다죽을때까지 기다린다 얘기임 좌우지간 

그다음에는 

## popen(3)
인풋, 아웃풋 파이프를 오픈하기위한 용도로 쓰이는 건데요 첫번째 인수로는 실행할 명령어를 주고 두번째로는 타입을 정해주는데 read로 타입을 주면 명령어가 실핼하면 명령어가 표준출력으로 출력한 문자열을 읽기위한 용도로 파이프를 오픈을 합니다.
그리고 라이트 를 주면 커멘드에 표준 입력으로 데이터를 전송하기 위한 파이프를 오픈을 합니다.
그래서 정상적으로 작동이 되면 파일 포인트를 리턴하는 

popen 어떻떄 쓰는거냐 파이프하고 뭐가 달라요
저거는 인풋, 아웃풋
???

그러니까 이거는 조금전에 우리가 뭘했습니까 who | sort 했잔아요 그게다 쉘 커멘더 잔아요 그러면 프로세스 를 따로따로 만들고 우리가 익스플리싯하게 파이프를 하나 만들어서 복잡한 과정을 거쳐서 그대로 연결시켜줬잔아요 
그것을 간단하게 하기위해서 어플리케이션 을 하나 띄우면서 파이프 하나 붙여서 만들어달라는 얘기다. 그래서 이그림으로 보는게 다음 페이지 그림 없어요? 그림을 보면저기 부모가있고 그다음에 커멘드1을 가져다 돌리면서 커멘드1에 파이프를 하나 자동으로 만들어서 나는 여기서 읽겠다 라는 얘기고 내가 중계를 해가지고 받은것을 얘는 라이트 파이프랑 같이만들어 지기때문에 얘한테 라이트 를 해서 누가 중계를 하겠단 얘깁니까 부모가 중계를 하겠단 얘깁니다 커멘드 1에서 who에서 나오는것을 내가 받아서 이거를 누구한테? sort한테 부모가 중개를 해주겠다 라는거다.
이렇게 되면 프로그램이 간단해지기때문에 다음 페이지 에 프로그램을 직접보죠 뭐

## pclose 
close 하는거니까

프로그램 보고 하면된다.

## popen(3)
프로그램 저 
명확하니까

프로그램

## "who|sort" by popen(3), pclose(3)
아까 똑같은 프로그램은 복잡했었잔아요 왜냐하면 포크해가지고 하나는 execlp who돌리고 
하나는 execlp해서 sort 하는데
파이프를 내가 만들어서 연결시켜줘야 되는데 
그걸 간단하게 하는게 popen이다
그래서 popen해서 who r 하면 리드하면 이건 뭐냐면 who를 가져다 돌리는데 그놈한테 자동적으로 파이프를 만들어서 붙이고 그 채널이 뭐냐면 read하겠다 내가 read를 하겠다 이런말이다
여기 read한다 이런얘기다 내가 
그다음에 또 뭘 만들어요 child를 sort를 자동으로 만드는데 얘는 write 채널을 사용하겠다 이런말이다 그러면 나는 어디서 fpin에서 읽으면은 어디서 읽는게 되잔아요 실제로 who 에서 나오는거를 내가 읽는다 이런얘기다 who에서 나오는걸 내가 읽을 채널이 읽을 채널이 이거다 이거에요 그다음에 sort에다가 내가 write 할 채널이 이거다 이거임 그러니까 나는 어떻게하면되요 
어디서 읽어요 지금 fget에서 어디서 읽고 있습니까? fpin에서 읽고있잔아요 
fpin에서 읽어서 그걸 얼로 토스를 하면되요, fpout으로 토스를 하면 이거는 이거는 어디서 들어온단 얘기에요 이게지금
who에서 들어온단 얘기고 이거는 어디로 나간단 얘깁니까 sort로 나간다 이런얘기다 그래서 그냥 fork 하고 execlp할필요없이 아까 한것을 간단하게할수있는 방법이 popen이다
프로세스하나 차일드 를 만들면서 거기에 파이프를 아예 붙여서 버리는게 popen 이다 굉장히 간단해졌죠 
그다음에 이거는 이제 그냥 파일 디스크립터 가 아니라 우리 스탠다드 i/o 라이브러리 에서 쓰는 대문자 파일 있잔아요 파일 포인터 로 사용한다는게 다른점이고 그래서 에프 투 데스? 죠 
후에서 나오는 그것을 받아서 그것을 누구한테  소트한테 보내주는 걸 누가한다? 부모 프로세스가 한다 이런말이다.
아까 프로그램하고 사실은 같은 프로그램인데 훨씬 간단하게 할수있는 방법이다 이런말이다.

## mkfifo(3), Making a Named Pipe
그다음에 네임드 파이프를 만들떈 저거를 써야되는데 네임드 파이프는 지우지 않는한 영구히 존재하며 이름을 갖고 있는 파일 을 말하고 어 
네임드 파이프는 왜씁니까 서로 상속관꼐가 없는 프로세스들끼리 언제라도 시스템에 존재하는 파이프 통신을 하기 위해서
이건 구글에 있는거 
네임드 파이프라는건 프로세스간에 똑같이 파이프 를 통신을 하고싶은데 우리가 여태까지 했던것은 누구하고 누가 썼습니까
부모하고 자식간에 파이프를 썼었단 말이에요 전부다 그런관계였었는데 근데 그게 아니고 저쪽에서 로그인해서 돌아가는 프로세스 가 하나 있고 또 다른데서 로그인해서 누가 프로세스 하나만들었어요 이프로세스는 서로 족보관계가 있어요 없어요 전혀 족보관계가 없죠 
그런 전혀 별개의 프로세스끼리 파이프를 가지고 통신을 하고 싶단 말이에요 그러니까 포크 를 할때는 그냥 파일 오픈한것을 물려받으니까 파이프에 이름이 없었잔아요 이름이 없었는데 인제는 뭐냐면 전혀 별개의  프로세스 가 파이프 통신을 해야되니까 뭐가 실체가 있어야 될거 아니에요 
그래서 그걸 네임드 파이프라고 해서 네임드파이프는 실제로 뭐겠습니까 파일 입니다 ㅇ파일 인데 파일의종류 중에서 무슨 파일이 있었오요?
피포 파일이라고 있었잔아요 폴스트인 폴스트아웃 파일이라고 그파일의 이름도 있고 이름이 있는데 포인터가 두개 가 되는 그런 파이프를 우리가 피포 파일이라고 하고 그파일에 이름이 있으니까 두개가 통신하고 싶은것은 이제 그 파일의 파이프에 이름을 가져다 서로 약속을 해야죠 예를들어서 나는 뭐 ss라는 파이프를 쓸꺼야 너도 ss 라는 것을 오픈해서 글로 주고받자 하기때문에 그 파이프에는 파일이고 그게 실제로는 그다음에 어떻게 됩니까 이름이 존재하는거다 이런얘기다. 
그러니까 이거는 만들때도 파일을 하나 만들어 놔야할것이고 그다음에 지울떄도 파일을 지우는 형태로 해야됩니다 그러나 그게 실제로 디스크 파일 아이오 를 하는거는 아니죠 파이프의 크기가 얼마에요 버퍼의 크기가 우리 했었잔아요 파이프에다가 파이프에서 읽는놈이 파이프에서 쓰는놈이 없으면 기다려야 하잔아요 
그렇죠 그다음에 우리 pthread에서 서큘러 버퍼 할떄도 갔다 가 서큘러버퍼에다가 집어넣는놈이 버퍼에 꽉차면 어떻게 해야되요? 기다려야 된다 파이프는 그 버퍼의 크기가 4k 라고요 4kbyte 즉 파이프에다가 쓰는놈도 가지고 가질 않아가지고 4k에 꽉차버리면 기다려야 한다 똑같다.
그러니까 파이프도 싱크로나이제이션도 똑같이 있는데 그거를 여러분들에서 pthrread 에서 했던것을 누가 해주고 있는겁니까 커널이 안에서 다 해주고 있는겁니다 
그래서 4k 바이트니까 디스크 한블록 이잔아요 사실은 그러니까 파일이 한블락 크기로 생기면되는데 그게 디스크 까지 갑니까 안갑니까 
파이프 에다 쓰고 읽을때 당연히 안가죠 
우리 뭐배웠어요? 디스크 파일 리드 할떄 어디서 읽어요? 페이지 캐시에서 읽었잔아요 페이지 캐시는 어딨어요 메모리에 있잔아요 그러니까 파일은 존재하지만 사실은 디스크까지 가지도 않고 페이지캐시 에쓰고 페이지 캐시에서 가져가는 형태가 된다. 
즉 파이프에다 쓰면 어디다 쓰는거에요 페이지 캐시에다가 쓴다 그게 4k 가 꽉차면 기달려야 하는거고 읽어가는 놈은 어디서 읽어가는 겁니까 메모리에 페이지 캐시에서 읽어가니까 사실은 디스크 기반으로 통신은 아니다 이런얘기다 파이프를 파일처럼만들지만 사실은 메모리를 기반으로 한 통신이 된다. 라는거임 그리고 이름을 정해야되기 때문에 반드시 이름이 있는 그 만들어줘야 되는 데 그게 네임드 파이프다 라는거임 
그래서 인제는 우리는 언네임드 파이프를 할때는 이름이 없었잔아요 이름이 없었고 그냥 오픈하면 됬었는데 이제는 파일을 만들어 놔야되요 미리 
그래야지 들어오는 프로세스 끼리 알아가지고 그걸 오픈해가지고 파이프 통신을 할꺼아니겠습니까
그래서 네임드 파이프 파일을 만드는것이 뭐에요 make pipo다 이거다 아규먼트로는 뭐가있어요 캐릭터 포인터 패스라는건 파일의 이름이다 루트밑에 뭐밑에 뭐밑에 파일에 이름이있는것이다 모드라는건 뭐였어요 우리 우리 시험에도 놨던 read write exe 이거 
OWERT, GROUP 똑같이 만들어놓은다 파일 만드는것과 똑같다
그래서 다만 이름이 뭐에요 시스템 콜이 메이크 피포 다 그래요 그래서 
파이프 파일 하나 이름이 있는 파일이 만들어지고 그거를 사용하게 된다. 파이프통신을 할때

## Client/Server with a Named Pipe
그러고 나서 클라이언트 와 서버 관계인데 클라이언트는 뭔가 요청을 할때 퍼플릭 피포에다가 라이트를 하고 서버가 퍼블릭에서 읽어서 그것을 프라이빗 피포에다 라이트 해주고 그럼 클라이언트는 다시 프라이빗에서 그걸 읽어오는 식으로 작동합니다.
이유는 설명

이관계는 모든것을할때 한문장 이유가 있어야된다. 그렇다고설명하면 안되고 
네트워크 나오는게 뭐가있어요 파일 서버 같은거 ftp 서버 같은거 있잔아요 그거 음원서버 이런거 있잔아요 그러면 거기에 접속을 해서 음원을 다운 받았는거 그런게 파일 트랜스퍼 서버 프로토콜 쓰잔아요 그걸 우리가 파일 서버 라고 하는거아닙니까 
그거를 한번 만들어본거에요 네트워크 를 사용안하고 그냥 같은기계안에서 네트워크 흉내를 내는것을 파이프를 통해서 만들어본것이다.
그래서 저기보면 저 젤 위에 있는 게 서버 잔아요 서버 프로세스가 돌아가 는 거에요 
서버 프로세스가 돌아가고 그게 뭘 가지고 있습니까 디스크 를 가지고 있다 그죠 거기에 여러개 파일들이 있다 이거야 
뭐 방탄소년단에 페이크 이런게 있다 이거임 빌보드 1등
그런 파일들이 쭉있어요 음원파일들이 

그러면 이제 클라이언트는 뭡니까 이제 서버에다가 뭘하는거에요 접속을 해서 이제 bts에 뭐를 다운을 받겠다라고 이제 요청을 해야될게 아니에요 
그러면 서버한테 클라이언트가 요청을 할라고 하면 거기에 원래는 우리가 내 강의시간에 배우는 뭘 이용을 해야되요 
소켓 같은 거 그런것을 오픈을해서 연결을 하고 그게 tcp를 쓸건지 udp를 쓸건지 뭐 이런 복잡한 과정을 거쳐야되는데 그거를 그냥 한기계에서 흉내를 한번 내보는것이다 그러면 서버하고 클라이언트 프로세스가 통신 할수있는게 지금 우리가 배운게 뭐가 있어요 
파이프 하고 메시지 큐 같은것을 배웠잔아요 그걸 아무거나 써도되요 그래서 파이프를 쓰는건데 클라이언트가 서버한테 접속을 해서 야 bts 에페이크 러브 라는걸 보내야 될게 아닙니까 그런데 그 파이프는 다 알고있는 파이프로 해야 되죠 ? 

그렇잔아요 서버가 정해 놓은 그 파이프 로 해야되니까 그래서 다 알고있다 라는 뜻에서 뭐가 되는거에요 이름이 
퍼블릭 이다 이거에요 이건 뭐에요 세상에 다 알려져있다 
멜론 뭐 이런것처럼 다 알려져있는 파이프다 이런얘기다.

그래서 클라이언트가 파일을 다운을 받고 싶으면 일단 누구한테 알려져있는 멜론, 유명한 파이프에다가 뭘쓰는겁니까 어떤 파일을 보내줘 
하는겁니다 어떤 파일을 나한테 보내줘 라고 여기다가 리퀘스트넣는것이다 클라이언트가 여러개면 어떻게 되는거에요 
파이프 에 쌓이는것이다 클라이언트가 여러개가 되면 그거는 내가 어디로 접수를 받는거에요 지금 퍼블릭 피포로 접수를 받는거에요 
받았아요 서버가 리퀘스트를 받았으면 이제 디스크 파일에서 파일, 음원파일을 읽을 것아니에요 보내줘야 되는데 
클라이언트 한테 보내줄려고 하니까 어디로 보내야 될지를 알수가 없잔아요 
왜냐하면 이거는 클라이언트가 write 하기 위한 용도이지
클라이언트가 받기 위한 용도가 아니란 말이에요 그래서 클라이언트는 얘한테 신청을할때 뭐를 만들어야 되냐면 자기에 
개인 적인 파이프를 하나 만들어놓는겁니다 예 ? 
무슨얘기에요 내가 파이프를 하나 만들어놓고 이름을 가져다 xx 라고 했어요 이 파이프를 그러니까 bts에 페이크러브라는 음원파일을 어디로 보내주세요 xx 로 보내주세요 하는거다 그럼 이거는 누가만든 파이프에요 그러니까 이거는 클라이언트가 만든 파이프고 이거는 누가만든 파이프에요 서버가 만든 파이프고 이거는 유명한 파이프 다 아는 이름 이다. 이거다.
그래서 일로 보내는게 뭘보내야 됩니까 이제 bts 에 페이크 러브 라는 파일이름을 보내야될거고 
그다음에 뭐도 보내줘야 되요? 서버한테 모도 또 보내줘야 합니까
이 파이프 의 이름도 보내줘야 되잔아요 그래야지 자기가 서버가 어디로 보내줄지를 아니까 내 전화번호를 보내야 될거아니에요 
좌우지간
그렇죠 그러니까 내 이게 전화번호같은거니까 내가 만든 나의 프라이빗 파이프에 뭐를 이름을 일로 보내면 서버가 그 파이프 에다가 어떻게 됩니까 
파일을 갖다가 보내서 내가 접수를 하게 된다 이런얘기다.
그러니까 프라이빗 파이프는 클라이언트 마다 따로따로 가지고 간다 만들어서 가지고 들어오는거고 
퍼블릭 파이프는 이거 뭐에요 서버에 항상 존재한느 파이프다. 
이거는 이제 시뮬레이션을 하는거고 저게 내가 강의시간에 지금 하고 있는 소켓으로 바뀌면 그게 뭐가 되는거에요 
똑같은 네트워크 서비스가 되는것이다 그렇죠 
그거를 파이프로 흉내를 내는것이다 그 프로그램을 

## Client/Server with a Named Pipe
저게 겟 스트럭트 겟 리퀘스트 라는건 
뭐냐면 저게 프라이빗 피포 라는거는 클라이언트 가 만든 파이프의 이름 아니에요 
그렇죠 내가 받을 
나의 전화번호를 얘기하는거죠 
그파일의 이름하고 내가 원하는 방탄소년단의 모다 파일 이름 갖다가 적어서 저기다 스트럭쳐 에다가 적어서 저걸 누구한테 보내야 되는거에요 
이제 서버한테 보내야 되잔아요
서버에 어디로? 
퍼블릭 파이프로 보내기 위한 구조체다 이런얘기다 저걸 채워서 보내는것이다
quit은 이거 에러났을떄 perror하면 에러메시지 왜에러났는지 적어주잔아요 
그다음에 퍼블릭이라는건 tmp에 pubfifo라고 이름이 되어있잔아요 
서버가 이미 만들어놓은 뭐에 이름이에요 네임드 파이프 이름이다 이거임
접속을 할려면 일로해라 이거임
엔체크는 뭐고 리트라이얼로 이제 n 3번한다 이런얘긴데 그거는 조금잇다 왜 나오는지 보자 

## File server Example
시그널 함수를 선언을 하는데 퍼블릭 피포 파이프 
저 언링크에다가 퍼블릭을 넣어서 쓰니까 퍼블릭 피프 파이프에 연결개수를 1줄이고 그다음에 현재 프로세스 아이디를 받아서 출력하고 
1주는게 아니라 서버는 이거 하루종일 도는거 아니에요 그렇죠 하루종일 돌고 클라이언트는 생겼다가 없어지고 생겼다가 없어지고 그럴꺼아니에요 그렇죠 그거를 받을때마다 생겼다 없어지고 생겼다 없어지는데 서버를 더이상 쓸필요가 없으면 서버를 컨트롤 C같은거 시그널 보내서 죽여야 되잔아요 그래서 서버를 죽이기 위해서 시그널을 하나 보내면 그 시그널 핸들러로 들어온거에요 그래서 어떻게 한겁니까 
이제는 퍼블릭 파이프가 필요있어요 없어요 
퍼블릭 파이프가 필요 없으니까 언링크 언링크는 파일 지우는거라고 그랬잔아요 
그렇죠 1을 감소 시키는게 아니라 퍼블릭 파이프를 지워버리고 이제 끝나는거에요 프로그램이 
이거는 끝나기 위한것이고 
그무슨얘기냐면 그냥 컨트롤 C를 하면어떻게 됩니까 
서버를 백그라운드로 돌려놓고 그냥 컨트롤 C하면 서버 가 죽기 는 죽는데 뭐가남아요 퍼블릭 파이프 가 남아있잔아요 그러니까 청소 하기 위해서 시그널 핸들러를 만든것이다 
그래서 시그널 들어가면 뭘 지워라 퍼블릭 파이프도 이제 지워라 다 끝난거다 
이런 얘기가 되겠습니다

실험을 위한거니까 이제

이거는 뭐에요 
서버죠 그렇죠 서버에 관한 코드 인데 
시그널 저기 이프문을 먼저 보면 시그널 핸들러로 처리하려는 시그널이랑 그옆에 시그널 핸들러 함수명을 넣어주고 에러가 나면 
sigint가 머하면 들어오는 시그널 이에요 컨트롤 c를 눌르면 들어오는 시그널 이잔아요 
컨트롤 c를 눌르면 서버가 그냥죽으니까 그냥 죽지 말고 시그널 캐처로 가서 뭐하고 죽어라 퍼블릭 파이프 지우고 죽어라 하는얘기다 그거 만들어놓은것이다 그다음에 
서버가 시작이됬다 그럼 뭘 만들어야 되요 이제 퍼블릭 파이프를 만들어 놔야 될거아니에요 그래야지 클라이언트들이 접속을 하니까 그래서 어떻게 했습니까 파이프를 하나만들어라 mkfifo 그렇죠 그다음에 퍼블릭 이 이름이죠 아까
파이프의 이름 tmp밑에 퍼블릭 피포라는게 있었죠 이거는 뭐에요 read write , 오너가 리드 라이트 엑스 그륩할수있고 
유저 아덜스가 리드 라이트 익스큐트 할수있게 파이프를 만족하는 하나를 만들어놨다 그래서
파이프 파일을 네임드 파이프로 하나 오픈했다 이제는 클라이언트가 신청을 어디로 하는거에요 이 파이프로 신청을 한다 인제

그다음에 혹시나 에러가 나면 2로 종료되게 말을하고 다음에
그래서 네임드 파이프 는 일반 파일쓰는거랑 똑같이 생각하면된다 저기보면 네임드 파이프 를만들었으니까 그걸 뭐했어요 오픈했잔아요 그져 오픈 
fdpub에다가 오픈 하고 인제 클라이언트 는 뭘하겠습니까 룹을 돌면서 저 파이프에서 읽는것을 기다리면 되겟죠 클라이언트가 접속을해서 파이프 에다가 뭘 넣줄 때를 기다리는 되는것이다 
뭐하고 있어요?
그다음에 맨처음에 그 클라이언트,,, 프라이빗 파이프 
에 같이 선언했던 파일 네임에 읽기 전용으로 저 파일디렉토리에다가 그거를 열고 또 안열리면 에러를 내고 중단하고 
지금 리드를 했어요 어디서 읽어요 퍼블릭 파이프에서 읽잔아요 그쳐 퍼블릭 파이프에서 푸시 를 하는 스트럭쳐에다가 읽어들이잔아요 그put에는 아까 뭐가 있다고 ? 파일에 이름 하고 클라이언트의 개인용 파이프의 이름이 들어가있잔아요 그쵸 그래서 처음에 파일네임이 들어왔어요 이게 이제 방탄소년단의 노래다 이거에요 이 파일 이름이 
그러면 인제 이거를 오픈해서 보내줘야 되니까 리드모드 로 오픈해야될거 아니겠습니까
그렇죠 그래서 노래가 있으면 오픈을 하고 노래가 없으면 에러 처리하는것이다
그쵸 이거는 노래가 있는 노래가 있으면 이제 그 노래 파일을 갖다가 음원 파일을 갖다가 오픈을 했습니다
만일에 노래가 없으면 어떻게 해요 while loop을 벗어나서 다시 돌아가든지 에러 처리를 해야될것이고 그다음에 이제 오존파일? 을 오픈하느냐 성공했어 그다음에 할것은 음원파일을 갖다가 어디다 떼려 줘야되요? 개인용 파이프에다가 때려줘야 될거 아닙니까 그 개인용	파이프의 이름을 클라이언트가 보냈을거아니에요 그게 put.프라이빗 피포 잔아요 
그러니까 클라이언트가 만든 파이프 를 갖다가 무슨 모드 로 오픈해야 되요? 라이트 모드로 오픈해야겠죠 왜냐하면 거기다가 음원을 써줘야 되니까 그래서 이걸 했습니다
그런데 O_NON 블락이라고 했어요 이건 무슨얘기냐면 이건 무슨 경우에 대비한거냐면 클라이언트 가 이 리퀘스트를 보냈는데 좀 노파심에서 보낼려고 하면 반드시 뭘 만들어 놓고 보내야되요 ? 자기의 프라이빗 파이프 를 만들어놓고 받을 파이프를 만들어놓고 보냈어야 되잔아요 
그런데 이놈이 파이프를 안만들어놓고 실수로 보냈을수도 있잔아요 그걸 대비한것이다
그래서 오픈을 해서 원래 는 이게 오픈이 되어야 되는데 -1 이 리턴됬단 얘기는 클라이언트가 뭘 아직 안만든거에요 리퀘스트를 보냈는데 프라이빗 피로안만들었다 말이에요 그래서 에러가 나면 어떻게 합니까
더 한번 더 기회를 줄게 
그래서1초동안 뭐에요 기다리다가 다시 이거를 몇번 반복을 해요 성공할때까지 3번 반복 하는 기회를 준다 3초동안은 기다려줄게 이런뜻
그래서 여기서 FDPRIV에 다가 오픈이 결국 성공을 한단얘기는 클라이언트가 보내준 파이프의 이름을 가지고 보내줄 파이프을 갖다가 오픈하구요 그래서 음원파일은 fd에 있는거고 여기위에 
음원 파일은 fd에 있는거고 그다음에 이 음원파일을 보내줄것은 fdpriv 에 있는거죠 그래서 3초동안 룹돌면서 기다려주는것이다 
근데 이제 안만들었다 라는것을 그냥 주구 장창 기다릴순없는거잔아요 그러면 다른 클라이언트 서비스를 못하니까 그래서 프라이빗 피포가 없을경우에 대비해서 O_NONBLOCK 이란 얘기는 블락되지 말아라 , 기다리지 말아라 이런얘끼다 
없으면 즉각 어떻게 해달라? 에러 리턴해달라 이런얘기다 
만일에 이걸 깨면 클라이언트가 프라이빗 파일 을 갖다가 만들때까지 주궁장창 기다릴꺼 아니에요 그러면 다른 클라이언트를 서비스 해줄수가 없잔아요 그래서 그걸한거에요 
그래서 이제 음원파일도 찾았고 그다음에 파이프 도 보낼 파이프도 찾았다. 그러면 보내는거죠 
파일에서 읽어서 음원 파일에서 읽어서 그것을 어떻게 합니까 프라이빗 파이프로 보내줌 
언제까지 EOF에 걸릴떄까지 
그리고 CLOSE하고 이제 뭘로 돌아옵니까 다시 이 룹으로 돌아와서 다시 모해? 다른 클라이언트에 뭘 읽어들어여 리퀘스트를 갖다가 또 읽어들인다 라는거임 
요기에 요건 파이프를 이용한거지만 요게 이제 뭘로 바뀌면 소켓으로 바뀌면 이게 네트워크 이되는것이다
네트워크 서버 & 클라이언트가 되는것이다

## 클라이언트
프라이빗 피포를 가져와서 네임드 파이프 를 만들고 파일 소유자한테 읽기 쓰기 실행권한을 줍니다. 안되면은
저건 sprintf 저거는 무슨문장이에요 get이라는건 아까 프라이빗 피포에 파일 이름을 넣어서 보내줄 스트럭쳐져 
그러니까 내가 이제 프라이빗피포 파일을 만들을라면 이름을 , 작명을 해야되잔아요 작명을 어떻게 하는거에요 tmp/name에서 tmp 밑에 뭐에요 내 겟 로그인에 로그인 네임 이잔아요 그걸 붙여서 뭘로 만들라 라는 얘기에요 
프라이빗 파일을 하나 작명을 해달라 얘기임 그걸 어디다가 카피해요 ? 프라이빗 피포라는 스트럭쳐 속에다 카피하는것이다.지금 
sprintf 해가지고 거기다 찍으니까 그래서 저게 그러니까 sprintf 는 뭐냐면 나의 프라이빗 피포 에 이름을 만든거죠 지금 
만들어서 어떻게  합니까 mkfifo 해가지고 이제 프라이빗 피포 파일을 직접 만드는거죠 직접 만드는것이다
get.privfifo 에 거기에 이름이 있으니까 그거를 read write 모드로 만든다 .
그다음에 
퍼블릭 파일 디스크립터 에는 쓰기전용으로 퍼블릭 피포를 열고 이거는 누구에 파이프죠?
아까 서버가 만들어놓은 파이프죠? 유명한 파이프 다 이거다.
이 여기서는 우리가 파이프가 됬건 이게 네트워크에서는 뭐가 되는거에요? 소켓이아니라 상대방의 아이피주소하고 상대방의 포트번호가되는것이다
열고 그다음에 파일이름 문자열을 복사해서
이거 메인 돌릴때 뭐 방탄소년단하고 딱 쳤으면 이게 얼로카피가 되는거에요 파일이름 으로 카피가 되는거죠
그래서 복사한것을 퍼블릭 파일 디스크립터에 쓴다.
퍼블릭 파일 디스크립터에다 뭘쓰는거죠? 
자기의 퍼블릭 피포의 프라이빗 파이프의 파일 이름하고 노래이름하고 두개를 지금 쓰는거잔아요 서버에 파이프에다가 
프라이빗 피포를 읽기전용으로 저 파일 디스크립터에다가 열고 
인제 저걸 열었어요 프라이빗 파이프를 열었어요 왜 열었어요? 서버가 글로 보내주니까 그거를 
그거를 읽어들이는거죠 버퍼 사이즈만큼 읽어서 그거를 write, 스탠다드 아웃풋으로 그냥 내보낸다 
이거를 인제는 원래는 노래면은 인제 유지프라이어 한테 보내야 되겠죠 그쵸
그다음에 프라이빗 파일 디스크립터 닫고 프라이빗 피포 도 종료하고 
프라이빗 파이프 파일도 필요가 없어졌죠 이제 그쵸
그래서 이것도 지워버린다. 지워버리고 이제 깨끗하게 끝낸다 이거임 
다 종료 
