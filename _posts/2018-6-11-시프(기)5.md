---
post : layout
title : 시프(기) 5
===
## 시프(기)5
프로세스 종료하는 종료후에는 정상적으로 비정상적 두가지가 있는데 정상적 종료할때는 부모 프로세스로 구성
비정상적인 종료는 시그널핸들링에 의해서

## Process Termination
프로세스 가 끝날때는 네임에서 리턴하거나 
익스플리싯하게는 하게는 우리가 exit을 하잔아 
exit 써놨는데 

exit(3)이라고 써있는것은 라이브러리 
저거는 라이브러리 콜이라는 얘기임 3은 라이브러리고 
리눅스 메뉴얼에서 2는 시스템콜 의미 
exit 이라는 라이브러리르 콜하면 결국 밑에있는 시스템콜 _exit(2)를 콜한거나 마찬가지다. 그래서 위에걸 쓰나 아랫걸 쓰나 마찬가지고 보통 정상적으로 리턴할때는 exit에 값을 뭘주냐 0을 주면 정상적으로 끝나는거고 이외의 값으 주면 비정상적으로 끝났다 라는것을 얘기를 하게된다. 
abort는 스스로 프로그램을 죽이는건데 abort를 하게되면 어떻게 된다 그랬죠? 코어 덤프가 일어난다. 프로그램이 중간에 종료가 되기 떄문에 나중에 디버거를 돌릴수있게 프로그램이 메모리에 올라가있는걸 그 상황을 그대로 디스크에다 가 어떻게 덤프를 해주는데 그게 코어라는 파일로 생긴다
그걸 코어 덤프라고 한다고 했다 그리고 exit을 하게된다. 이제 시그널이 들어오게 되면 예를들어서 파이프를 갖다가 오픈해가지고 내가 파이프에서 기다리고있는데 writer가 싸그리 없어진다라던가 아니면 여러 파이프에서 write를 할려고했는데 reader 가 하나도 없어져버린다던가 그러면 그건 이제 broken pipe라는 시그널이 발생해서 디폴트 핸들러로 가게되면 이제 당연히 죽게된다. 시그널은 많이 있으니까


## exit& _ exit
위에 얘기했던거네..

## atexit(3)
프로그램을 죽이는거 
자살하는 시점에 저기 저 아규먼트 에 들어가있는게 뭡니까 펑션 포인터죠 펑션 이름을 주면 완전 히 죽기전에 죽으면서 저펑션을 콜해준다 이런얘기다. 저 펑션속에서 뭐 하겠냐? 죽으면서 마무리작업하는거지 유서쓰는거지 
그러니까 유서쓴다라는건 무슨얘기냐면 만일에 여러분이 malloc 이라든가 new같은것을 동적메모리 할당같은것을 했다 그러면 그런것을 시스템에 어떻게 해야대겠냐? 반납을 한다라는거야 자지가 뒷정리를 하고싶은거야 그런 펑션을 따로 만들고 싶으면 저렇게 할수도있다.


아래 코드에서 
```
#include<stdio.h>
void greet();
void caller(void (*myFunction)(void));
//이 콜러라는거가 뭐가 되는거냐 함수가 된다 이거임
그리고 요기에 void 괄호하고 앞에다가 이렇게 함수이름 앞에다가 요렇게하면 myFunction이라는 아규먼트가 뭐다 얘기냐? 펑션의 주소를 갖는 포인터 다 이거임 이게 무슨뜻이냐?
//caller라는 함수가 있다. caller 라는 함수가 아규먼트로 뭘로받냐? 아규먼트로 펑션의 주소를 받는 함수다 이거임 여태까지 펑션의 아규먼트는 인테자라든가 캐릭터라든가 이런것만 가졌었는데 그런데 다른 함수의 주소를 아규먼트로 받아서 콜러라는 함수는 뭘 불러준단 얘기냐 이 함수를 불러준단 얘기임
//caller에다가 여기보면 여기 
int main()
{
	void(*sayHello)(void);
    //이거는 이제 펑션포인터는 저번에 시그널 다룰떄 펑션포인터가 나왔었다. 포인트로 받으면 캐릭터포인터도 있고 스트럭쳐의 포인터도 있고 인테져의 포인터도 있고 여러가지 종류가 있는데 펑션을 가리키는 펑션의 주소를 가지는 포인터를 만들때 그거를 뭐라하냐?펑션 포인터라고 하는데 펑션 포인터를 이렇게 디파인 한다 
    //caller 에다가 여기보면 sayhello 라는건 sayhello는 펑션의 포인터임 sayhello애다가 뭘 집어넣었냐 
	printf("Calling greet() directly.\n");
	greet();

	printf("\n");
	
	printf("Calling greet() via a pointer\n");
	sayHello=greet;
    //sayhello에 greet를 집어넣었다. greet는 함수다. sayhello라는 변수가있는데 이 sayhello라는건 greet라는 함수의 주소를 갖는 포인터 변수가 된다말이야 greet함수를 콜해도 되고 sayhello라는 함수를 call하면 뭐가 call이 되겠냐? 마찬가지로 greet가 call이 된다. 이렇게 하나 저렇게 하나 마찬가지다. 함수를 가리키는 포인터를 가지고 함수적 사용을 해도 되고 그 sayhello라는 포인터가 greet의 주소를 가지고 있기떄문에 결국 뭐가 call이 되냐? 결국 greet가 콜이 된다 이거임
	sayHello();
	printf("\n");
	
	printf("Calling greet() via another function\n");
	caller(greet);
    //여기보면 greet라는 함수는  print error ???하는것이다. 여기 caller라는 함수를 디파인했는데 caller 라는 함수는 아규먼트로 뭘받냐? 펑션의 주소를 받는다. 그래서 펑션의 주소를 받아서 이게 펑션이 a가 들어올지 비가 들어올지 모르는상황이다 아규먼트니까 이게 a가들어오면 뭘 콜한단 얘기에요, a를 콜한다. 아규먼트로 뭐가 들어오면 b가들어오면 b라는 펑션을 콜한다 이거임 그래서 이거 새로 나오는 여러분들이 아마 안해봤을텐데 함수의 주소를 받아서 해당되는 함수로 콜할수도 있따. 이거임 
    그때그떄
    여기보면 caller에 greet라고 했는데 caller 함수에 greet함수의 주소가 이 아규먼트로 들어갔기때문에 얘가 마이펑션하고 콜하면 결국 누가 콜이된단 뜻이냐? 그리트가 콜이 된다 얘기임 
    그래서 프린트 헬로우 월드가 찍힌다 이거임
    그래서 함수를 아규먼트를 받을수있는 예제가 되겠따.
}

void greet()
{
	printf("Hello, world\n");
}

void caller(void (*myFunction)(void))
{
	myFunction();
}


```
## atexit() Example(1)

```
#include<stdio.h>
#include<stdlib.h>

#define TMPFILE "/tmp/mylog"
static void myexit(void);
여기에 myexit이라는 펑션이 하나 있잔아. 그래서 프로그램 돌다가 이제 끝날쯤에 되가지고 atexit 한다는 말은 뭐냐면 내가 프로그램이 종료가 되는데 종료가 되서 완전히 클린 업이 되기전에 뭘 뿌려달란 얘기냐 myexit으로 가서 아까 뭐한다고 했어 뒷정리 한다고했다. 예를들어서 myexit에서는 unlink(TEMPFILE), 프로그램을 삭제하는것 이게 원래 프로글매속에서 뭘 만들었냐 ? TMPFILE이라는것을 하나 만들었잔아요 append 모드로 근데 이게 TMP 파일이기 떄문에이 프로그램이 끝날때는 어떻게 해야됩니까? TMP 파일을 지워야 겠다 그런 뒷마무리 작업을 한다 이거임 물론 exit하기전에 에러가 생겻으면 이제 파일을 만들었으니까 지워되는거 아니에요 근데 여기에다가 코드를 넣으면 지저분해 보이니까 그걸 몰아가지고 여기 myexit에서 TMP 파일을 만든것을 unlink한단 얘기는 파일을 지운단 얘기니까 뒷마무리 한다 라는 그런말이 되겠다. 이렇게 하면 코드가 더 깔끔해 진다. 
int main(void)
{
	FILE *fp;
	if(atexit(myexit)!=0){
		perror("atexit error");
		exit(1);
	}
	
	if((fp=fopen(TMPFILE, "a+"))==NULL){
		perror("fopen error");
		exit(2);
	}
	fprintf(fp, "This is temporary log entry of pid %d\n", getpid());
	close(fp);
	exit(0);
}

static void myexit(void)
{
	if(unlink(TMPFILE)){
		perror("myexit : unlink");
		exit(3);
	}
}

```
## wait()
부모 프로세스 자식프로세스가 각각 
//wait for a death of a child
그래서 wait라는건 요기서 wait는 부모 프로세스가 자식프로세스의 죽음을 기다린다. 그렇죠 기다리는데 child를 여러개만들었으면 어느 child 가 죽을지 모르잔아요 그래서 child가 하나 죽었으면 그 죽은 child 의 아이디를 여기에다가 return value로 돌려준다. 그래서 이거를 내가 원하는 놈이 죽었가를 비교하면서계속 while loop을 돌릴수있었다. 
그런데 사용하고 이거는 뭐에요?
pid_t wait(int *stat_loc)
exit을 하면서 아까 뭘 남겼습니까?
프로그램 죽을 때 값을 하나 남기잔아
그 값이 일로 리턴이 된다. 
그러니까 child 가 어떤 값을 남기고 죽었는지 exit 할때 그값을 요값을 조사 해보면 알수있다. 그런얘기 그래서 약속을 하는거야 너 죽을때 0보내 그러면 내가 잘끝난걸로 알게 죽을때 1보내 그러면 이거는 뭔가 하다가 문제가 생겼는걸로 알게 그 exit할떄 
아까 exit할때 뭐가 있었었냐 ? exit할때 이거 status 보내잔아 형태 이거를 보내는거를 wait해서 받는다 이런얘기가 된다. 
그러니까 받아야되니까 뭘 줬습니까? 주소를 줬잔아요 포인터로 줬다. 
## Confirming Exit Status of the Child with Macros
wait 
요거는 뭐냐면 wait해서 얘 상태가 오잔아요 상태가 오면
이게 이제 어떻게 해서 죽었는지 그 history거기에 있다 그래서 그 일일히 그값을 알수가 없으니까 이거는 매크로를 써서 
WIFEXITED 하면 non-zero value를 return 했다. 프로세스가 노멀하게 리턴이 됬단뜻이고 
예를들어서 
WIFSIGNALED 는 리턴은 먼저 
시그널떄문에 차일드가 죽었다. 
이런 여러가지를 가져다 체크할 수 가 있다.
이건 뭐 외울수가 없다 메뉴얼을 봐야한다. 이런게 있다라고만  기억을해두자

## Confirming Exit Status
```
#include<sys/types.h>
#include<sys/wait.h>
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>

#define EXIT_CODE 1 

int main(void)
{
	int status;
	pid_t pid, rcode;
	if((pid=fork())==0){
		printf("child : pid = %d. ppid = %d, exit code = %d\n", getpid(), getppid(), EXIT_CODE);
	//포크했으면은 포크 == 0니까 이거 이거 다음에 나오는게 child process 잔아요 그쵸, 그래서 child 프로세스는 차일드의 자기의 getpid 는 자기의프로세스 id를 리턴하는거아니에요 
    자기의 id하고 ppid는 뭐에 아이디입니까? 부모 프로세스의 id 를 찍고 exit_code를 찍는데 exit_code를 해서 누구한테 넘깁니까 ? 부모 프로세스한테 넘기기로 한것이다. 약속을 한것이다. exit_code는 1로 되어있으니까 1을 넘긴다
   
    exit(EXIT_CODE);
    //여기 exit을 하면 여기 기다리다가 깨어나잔아요 여기의 status는 뭐가 들어오는거냐 
	}
	printf("parent : waiting for child %d\n", pid);
	rcode = wait(&status);
    // 그러면 부모는 여기서 wait를 한다. wait를 할때 return code는 바로 뭐냐면 child 의 아이디가 되겠죠 죽은 child의 아이디가 될것이고 여기서 exit을 하면
    여기 exit을 하면 여기 기다리다가 깨어나잔아요 여기의 status는 뭐가 들어오는거냐 EXIT_CODE가 들어온다 이런 말이다.
    그래서 잘 끝났느냐 이러면 
	printf("parent : return pid = %d\n", rcode);
	
	if(WIFEXITED(status)){
    //잘끝났느냐, 1이면 잘끝났다라는게 나올거고 시그널에 의해서 죽었느냐를 물어볼려면
		printf("normal termination!. exit status = %d\n", WEXITSTATUS(status));
	}else if(WIFSIGNALED(status)){
    //이거를 하면되고
		printf("abnormal termination!. signal no = %d%s\n", WTERMSIG(status), WCOREDUMP(status) ? "(core file generated)" : "");
	}else if(WIFSTOPPED(status)){
    //child가 돌아갈떄 ctrl+z 를 눌르면 이게 일시정지가 된다. 그랬을때 나오는 이런 경로를 따질수가 있따 얘기임 
		printf("child stopped!. Signal no = %d\n", WSTOPSIG(status));
	}
	exit(0);
}

그래서 이프로그램을 돌려보면 child는 자기의 id , parent 의 id 그다음에 child가 죽었을때 부모 내놓은 아디는 자식의 아이디가 되겠다. child 가 죽으면서 넘긴값이 뭐란 얘깁니까? 1이란 얘기다. 그래서 normal termination이 됬다 그런 말이다.

```

## waitpid()
특정한 프로세스 에게서만 
프로세스 그륩은 뭐라그랬냐? 같은 그륩에 있는 프로세스가 여러개있단 얘기는 무슨뜻이라고 했냐?
여러분들이 로그인을 하면 뭐가 떠요? 쉘이 뜨잔아요 쉘이
쉘을 뭐라고 그런다고 했습니까? 쉘을 뭐라그랬어요? shell 이 이렇게 뜨면 shell이라는 프로그램ㅇ ㅣ뜬거 아니에요 
이 shell을 일반적으로 뭐라고 call하냐면 session chair라고 부른다. 
session chair라는건 회의할때 주죄하는 사람이다. 
그러니까 이 다음서부터 여러분들이 프로그램을 돌리면 전부다 누구의 자식이에요? 쉘의 자식이다. 그래서 그 자식들은 전부다 쉘하고 그륩아이디를 가지는것이다. 그래서 이거는 일반적으로 
waitpid를 쓸때 pid를 주는데 이게 뭐 150 이면 꼭 누가 죽을떄까지 기다려라 150번이 프로세스가 죽을때까지 기다려라 가 보통인데 이거를 -1를 주면 이거는 뭐냐면 아무 차일드나 죽을때까지 내가 만든것중에 기다려라 얘기고 이거는 뭐냐면 (pid == -1)
그륩아이디 중에서 애니 child 가 죽을떄까지 기다려라 라니까 이건 무슨말이면 내가 만약에 fork 한 프로세스는 아닌데 shell이 뭐 들어와가지고 내가 돌려놓은 프로세스 같은게 있잔아요 그거는 어떻게 되는거에요? 같은 그륩에 있는것이다 .뭐그런것을 얘끼하는것이다.근데 일반적으로 이걸 쓸때는 pid 가 0보다 큰 경우에 많이 쓴다. 그래서 뭐 할때 어떤 특정한 프로세스가 죽을때까지 기다릴 경우에는 waitpid를 쓰게 되는것이다.


## Exec Family 
무슨 글이냐면 전에도 얘기했듯이 
exec 시스템콜은 무엇이냐
어떤 프로그램이 돌아가다가 exec수행하면 여기에 뭐 푸라는 프로그램이 있으면 내 프로그램이 지워지고 뭐가 올라오는거에요 메모리로 푸라는 프로그램이 올라와서 새로 돌아가기 시작하는거죠 그러니까 내프로그램에 pid 가 변화가 있습니까 없습니까?
변화가 없기때문에 어떤 특징이 있냐면 나를 만든 부모가 있잔아요 그 부모 는 그냥 그대로 유지가 되죠 그렇죠 exec 을 해도 그러니까 이놈의 아버지가 나의 아버지이기도하다
그다음에 프로세스가 똑같으니까 만일에 이놈이 오픈한 파일이있으면 얘가 물려받습니까 안물려받습니까? 그것도 물려받느낟. 왜냐하면 쉘이 여러분들이 포크 를 한다음에 a.out을 돌릴때 shell에서 a.out하면 shell 이 뭘 합니까 먼저 포크를 한다음에 child shell이 exec 을 해서 a.out을 불러들이는거아니에요 
그때 shell이 오픈한 파일을 다 물려받기때문에 std input, output error 다 shell하고 똑같은걸 쓰게 되는거죠 그래서 exec 을 해도 open 파일들을 물려받는다. 그러면 exec 이라는건 뭐냐 프로세스를 만드는게 아니고 프로세스 속에 새로운 프로그램을 뭐하는거에요 load 하는것이다. 그래서 여러분들이 이거를 만일에 윈도우로 비교하자 그러면 윈도우에서 shell이 떠있다. 
리눅스에서 shell이 떠있다 근데 내가 뭘 돌렸다 
아래 한글을 떼랑 하고 쳤다 그러면 그 shell 대신에 무슨 프로그램이 올라온 겁니가 ?아래 한글 이 올라온것이다 그자리로 그러니까 exec 라는게 실제로 디스크에서 프로그램으로 어디로 load 하는 역할을 하는거에요? 어디로? 매모리로 왜냐하면 프로그램이 돌아가야 되니까 그래서 프로그램을 디스크 에 있는 a.out이나 디스크에 있는 아래한글 뭐 파워 포인터이런것을 가져다 메모리 로 올리는 역할을 하는게 리눅스에서는 exec 이다 얘끼임 
그런데 exec 이 무엇을 올립니까? 새로운 프로그램을 올릴꺼 아니에요 근데 그게 무슨 프로그램이야? c 프로그램이면 뭘로 시작하겠습니까? main으로 시작할거 아니야 그렇죠 근데 이제 메인 여러분 들 뭐 쓰는거알아요? 아규 먼트 카운터 하고 뭐 씁니까? 아규먼트 벡터 쓰잔아요 아규 먼트 카운터하고 아규먼트 벡터는 다알다싶이 ./a.out 에 a b 이라고 주면 아규먼트 카운트가 3이 되는거죠 
그다음에 이거를 포인트하는게 아규먼트 벡터에 제로가 이것을 포인터하죠 이 스트링을 이거는 캐릭터 포인터니까 그다음에 이게 아규먼트 벡터에 1이 이걸 포인터하고 아규먼트 벡터에 2가 이거를 포인터 하고 아규먼트 카운트는 3이 되는거아니에요 그렇죠 
그래서 이런 프로그램을 돌릴때 shell에서 내가 돌린다고 하면 a.out하고 아규먼트 a b를 주면된다. 그러면 아규먼트가 들아가잔아요 a b 가 
근데 문제는 shell에서 a.out 을 돌린게 아니라 뭘로 돌린거야 exec 으로 돌렸다. 어떻게 exec 에 뭐가 붙겠죠 여러가지가 있으니까 여기에 ./a.out 돌렸단 말이에요 shell에서 돌린게 아니란 말이에요 그러니까 여기다 뭘줘야대 a 하고 b를 아규먼트로 줘야될거아니에요 프로그램에서 exec을 하면서 그래서 여기에 a 하고 b같은것을 줘야하는데 이거를 주는 방법이 가지가지다 여러가지 방법을 줄수가 있어서 변종이 생기는 거다 이거임
그래서 l도 있고 v도 있고 p도 있고 e도 있고 그렇다 
어떤 방식으로 주느냐 에 따라 서 약간의 차이가 있다 라는 얘기임 그리고 여러분들이 이렇게 하면 이게 뭐가 뜬거에요? 
shell이 뜬것이다. 
shell에서 여러분들이 리눅스에 들어가가 지고 프린트 printenv를 쳐보세요 env 는 무슨뜼? 환경이다.
내가 지금 shell에 로그인 
shell을 가지고 로그인해서 시스템을 쓰고있는데 내가 들어오는 환경에 대해서 모든것을 알려달라 이런얘기임 
env 알려달라 이런얘기임 

## env

그러면 env 에는 뭐가 있을까요? 
생각나는거 뭔가 많아서 긷억을 못하는데 
예를들어서 윈도우에서 이거하다가는 컴파일 할때 컴파일 할때 씨프로그램을 컴파일 하면 인클루드 파일 
인쿨루드 디렉토리 같은거를 알으켜 줘야 할떄가 있죠 내가 새로 만든  인쿨루드 파일 같은 경우는 디렉토리에 있는지 
그러니까 그런게 뭐냐면 예를들어서 만일에 어떤 인쿨르드 파일같은것을 못찾으면 그거는 어디서 찾으라라는것 . 밑에 usr 밑에 jg이라는 디렉토리에서 니가 디폴트로 찾아보는데에서 찾아보고 없으면여기서 찾아라 이런것을 path라는것을 준다. 
그러면 인클루드 파일을 찾을때 시스템 에 디파인이 안되어있으면 어디서 찾습니까?? 저기로 찾아들어온다. 이런게 인바이러먼트 다. 프로그램이 돌아가는 인바이러먼트다.  또 어떤것이 있을까요?
리눅스에 로그인 하면 여러분들 한글 같은거 쓸수있죠 edit 할때 한글쓸 수있잔아요 한글같은게 파일에 입력이 되잔아요 그럼 한글이 나오는 글자 모양을 뭐라그래? 폰트라고한다. 무슨 아래한글에 보면 궁서체 돋음체 맑은고딕 이런거 있잔아 그런거 폰트라고하잔아. 그러면 내가 폰트를 뭘 사용하는지 
이런것도 여기에서 주게된다 이런거임 
예를들어서 이게 베리어블 이름은 모르지만 한글 폰트는 뭘로 사용하는지 디폴트는 뭘로 사용하는지, 디폴트 디렉토리는 뭔지 그다음에 이게뭐 옛날 같으면 인제 옛날같으면 피씨가 없었을때는 뭘 쓴다고 했죠 서버하고 쓸떄 
pc 같이 생긴 터미널이 이 있다고 했다. 거기에서 로그인을 하면 서버하고 연결이되서 화면에 나온다. 그 연결을 할떄 뭘 사용하냐면 시계열포트를 사용한다. 
시리얼 커뮤니케이션을 사용하는데 이더넷보다 느린것이다. 
시리얼 이라는건 신호가 어떻게 가는거야 여러분들 데이터 통신에서 배웠을지 모르겠는데 시리얼이라는건 신호가 이런식으로 가는거야 
이게 일로가면 뭐야, 이게 0란 말이야 그래서 이제 컴퓨터 끼리 통신을 한다든가 내 터미널하고 서버하고 통신을 할때 이 시리얼을 통신을 한다고 보고 그 시리얼 통신을 할때 맨끝에 붙는게 뭐에요? 
뒤에 요고 저 1의 개수가 짝수인지 홀수인지 체크하는것을 패리티 비트 라고한다. 
그다음에 요 1 0 를 가져다 보내는 요 간격을 가져다 결정하는 걸 뭐라그래요? 요게 한 빗이잔아요 그러면 여러분들이 이더넷으로 할떄도 뭘 써요 100메가 bps를 쓰잔아요 100 메가 bps에서 이더넷 할떄 100 메가 bps가 이게 무슨뜻이에요?
비트퍼 세컨드 잔아요, 그러니까 이게 무슨얘기에요? 1초에 몇 비트보내느냐 하는 얘기다. 이더넷은 빠른거고 이거는 보통 옛날에 이런식으로 보냈다. 9600 bps로 보냈다. 터미널이 붙어있으면
1초에 9600 bit으로 보낸다. 그런데 보내면서 9600bit으로 보내면 받는놈이 뭘 알고있어야해? 9600이라는걸 알아야지 9000번에 1초 에 한번씩 샘플링 해가지고 1인지 0인지 체크할거 아니에요 
그러니까 4800으로 보낼수도있고 뭡니까? 9600으로 보낼수있고 12800으로도 보낼수있고 여러가지 옵션이 있는데 그런 옵션도 나의 env 다. 
내가 얼마나 빨리 데이터 ?? 
그런거를 뭐라고 하냐면 env (인바이러먼트)변수라고 한다.
요거를 set해놓으면 여러분들이 어떤 프로그램을 돌릴때 요런 환경변수가 작용을해서 아까 얘기했듯이 뭘 나타내냐, 인쿨르드 파일같은 거를 못찾으면 요기를 찾아간다 라든가 설정할수있다. 그러면 내가 이제 좀전에 얘기했던것처럼 이그젝을 통해가지고 이그젝을 통해서 뭘 돌립니까? main이라는 프로그램을 불러 올리잔아요 지금 올리는데 필요한게 뭐가있어요? 
좀전에 얘기했듯이 만일에 아규먼트 카운트하고 아규먼트 가 벡터가있으면 은 exec 을 할때 이걸 줘야될꺼아니에요 그렇죠
그다음에 그 env 바꾸고 싶어요 
나는 여태까지 맑은 고딕을 썻었는데 뭘로, 굴림체로 바꾸고 싶으면 이 폰트를 가져다 바꿔줘야 할꺼아니에요 
그런거는 어디에다 집어넣습니까 인바이러먼트 벨리어블 에다 집어넣서 exec을 할수있다. 이런 얘기다. 그러니까 프로그램을 돌릴때 아규먼트 카운트하고 아규먼트 벡터라든가 그다음에 프로그램이 돌아가는 환경변수 같은 걸 지정하는데 뭐를 통해서 exec을 통해서 할수있는데 그 아규먼트를 주는 방법에 따라서 무슨 옵션이 있어요? 
l도있고 v도 있고 p도 있고 e도 있다 이런얘기다. 그런것들이 조합이 되기도 한다. 자하나씩 보기로하죠

## execl()
예를들어서 execl 하면 l이라는 
아규먼트 리스트라는건 뭐냐 
아규먼트 리스트는 아규먼트 벡터 이거 
이거를 하나씩 리스트로 준다. 이런얘기임
그래서 execl 한번 가보죠 
여기 path는 a.out이 되겠죠 그다음에 아규먼트가 뭐가있어요 지금 a하고 b가 있잔아요 그 아규먼트에 string에 넣고 뭘줍니까 포인터를 하나둘 셋넷 네가다 쭈르륵 나눠서 준다. 
그게 뭡니까 execl 이다 라는거임 (필기를 봐도 좋을듯싶다. 메모하면서 좀 나한테 맞게 바꿈 입맛에 바꿈)

그렇게 해서 아규먼트 카운트하고 아규먼트 벡터를 가지는 프로그램도 exec을 통해서 늘릴수가있다. 이런얘기다. 
여기에 뭐만 없습니가? 아규먼트 카운트는 빠져있다. 요게 개수를 셀수가있다. 
execl 이라는 펑션은 아규먼트 개수가 정해져있습니까? 정해져 있지 않습니다. 아규먼트가 3개 여도 4개여도 되고 
printf 도 마찬가지다. 
printf 도 앞에 따음표에 나오는게 어떻게 찍어라는게 하나가 들어가고 variable이 두개 가 나와도 되고 세개가 나와도 되고 아규먼트 개수가 자기 마음대로다 
그런 펑션처럼 아규먼트 개수가 정해지지 않는 그런 시스템콜이 execl이다.
## execv()
이거는 어떻게 하는거에요 
아규먼트 벡터에 리스트를 주는것이다. 이건 무슨뜻이냐
여기에 뭐가 있냐면 포인터에 어레이가 있다. 뭐에요
아규먼트 벡터에 제로는 뭘 포인트 해요 
argv[0] -> a.out
argv[1] -> A
argv[2] -> B
sttring의 주소를 하나 둘 셋 을 가지고 있는게 뭡니까 포인터의 어레이이다. 그러면 아규먼트 벡터에 아규먼트 벡터라는건 
아규먼트 벡터에 포인터라는 건 뭐에요 
어레이에 포인터라는 뜻이 있잔아요 
아규먼트 벡터라는 에러이 포인터란 뜻이잔아요 
그러니까 이거는 뭐냐면 이게 뭘 포인트 한거에요? 이 주소를 포인트한것이다.
이걸 포인터하면 어떻게 됩니까 
이걸 어레이처럼 계속 쓰는거지 
이게 다시 1학년으로 돌아가는것 같은데 
인테저 어레이가 있습니다. 그러면 인테저 어레이가 i에 0하고 i에 1하고 i에 2 이 3개가 있는것이다. 근데 인터저 포인터 p를 만들었다. 
p에다가 i를 넣으면 어떻게되냐 
p는 뭘 포인트 하냐?
어? p는 전문용어 이 주소를 어레스의 시작주소 
어? 시작주소, 영어로 베이스 어드레스 
어레이의 베이스 어드레스를 들어가지고 p라는 포인터가 이것을 가리킨다. 
그렇죠 i라는 어레이는 주소니까 
이렇게 하면 어떻게 대요?
이거돼 안돼 
어? p2 = 5 집어넣으면 안되? 됩니다.
어디에다가 5 집어넣으란 얘기에요? i2 에다넣어라
이건 무슨뜻이에요 p가 포인트하는곳으로 찾아가서 두칸 더 내려가가지고 거기다 집어넣으란 얘기니까 
이거 equal i2 하고 똑같다.
이거 마찬가지다. 아규먼트 벡터를 포인터하는 포인터가 이렇게 있다면 이제는 아규먼트 벡터 0,1,2 라고 쓸수있다. 

그래서 여기보면 아규먼트 벡터에 리스트가 이렇게있으면 스타팅 어드레스를 갖다가 주면서 서로 하는게 execv() 인데 
물론 아규먼트가 없으면 뭘 쓰면되요?
아규먼트가 없을때는 NULL로 주면된다.

## execle()
여기 E란느건 무슨뜻이냐?
env vector 얘기했었죠 아까 env 가 폰트가 뭐고 그다음에 패스가 뭐고 여러가지 베리어블이 있는데 그 예를들어서 아까 패스라는 인바이러먼트 베리어블이있으면 여기에 루트 밑에 jg 디렉토리 가라가 저장이 되있거든요 마치 뭐처럼 
아규먼트 벡터처럼 심ㅍ? 포인트가 패스라는게 되어있다. 
이게 env 벡터에 들어가는것이다.
그래서 여기보면 여기에 아규먼트 0,1,2,3 쭉나가고 맨마지막에 
char const *envp[] 또 가지고 있다. 이건 무슨말이냐면
이것도 어레이다. env variable 이 여기에 뭐도 있겠습니까?
폰트 이런것들이 있고 이 스트림을 가리키는게 있는데 
이거 스타팅 어드레스를 주는것과 같다. 이거임
sheell에서 들어가 env variable이 뭐가 있는가를 알아 보려면 아까 뭐가 있다고 print env 가 있다.
그래서 요거는 아까 리스트 라는  거는 무슨뜻이냐 ?
아규먼트를 쭈르륵 나열한거라고 했잔아요
그다음에 v라는건 요렇게 뭐에요? 포인터라고 주는거라고 했고 
그다음에 e가 붙으면 env vector에 주소를 가져다 주는것이다.

## execve()
## execve()
역시 v니까 아규먼트의 포인터를 주는것이다.

## execlp()
이거는 뭐냐면 이건 뭐야 
p라는건 lp 하면 이제 파일의 이름이 들어간다.
패스의 이름이 들어간다 파일의 이름이 들어간다 
커런트 디렉토리를 쓰는거고
여기에 여기에 패스라고 하는거는 무슨얘기에요?
파일의 이름인데 풀네임이다.
루트 밑에 뭐 밑에 뭐밑에 해서 풀네임을 준다. 

## execvp()
vp라고 하면 여기에 파일 이름 하고 v 가 들어가니까 아규먼트 벡트를 주는것이다. 여러가지 옵션을 줄수가 있다.

옵션을 눈여겨 봐야겠다!


## system()
시스템이라는건 내가 이제 shell에서 하는게 뭐냐 예를들어서 디렉토리 에 있는 파일을 보고싶어 어떻게 합니까 ls 하잔아요 그런데 c프로그램속에서 ls 를 돌리고싶으면 system하고 어떻게 하는겁니까 system("ls")이렇게한다.
그러면 ls라는 프로그램이 돌아간다.

데이터 베이스 시스템을 돌려놓고 데이터 베이스 질문던지는것을 뭐라그래요?
1930 년 7월 태어난 사람 질문던지는것을 뭐라그러나요 쿼리 라고 한다. 
쿼리 랭기지 중에서 sql 이 많이쓰임 
db 많이 쓰는게 mysql 이잔아요 sql 이 쿼리 랭기지다.
빅데이터 잘안쓰지만 
sql 데이터 
1970년 1월 3일 태어났으면 성이 김씨 인사람을 찾아주세요 이 디비에다 하면 그게 쿼리가 되는데 이런 쿼리 같은것을 db도 돌려놓고 날릴떄 이거 많이쓴다. 여기다가 뭘 집어넣느냐 말이에요? ls대신에 뭘집어넣느냐? 디비의 쿼리를 집어넣으면 db에 언라인으로 알고 프로그램에서는 db 에다가 물어볼수가있다. 
//쿼리문을 이런식으로 쓰면 물어볼수있게된다.
