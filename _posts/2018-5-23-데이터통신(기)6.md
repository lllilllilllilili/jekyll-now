---
post : layout
title : 데이터통신(기)6
---
## 복습
크로스바에 대해서 숙제를 해봤다.
회선교환 스위치 중에 이런 멀티스테이지 스위치에서 저 가운데 있는 두번째 스테이지 k값을 몇개를 해야 이 패스가 모든 인풋에 대해서 출력으로 갈 수있는 패스가 보장이 되는가 라는거임
그런것을 구하라는거임
저 노란 박스 하나하나가 다 크로스바임 저게
n by k면 이렇게 n개가 있는거고 이 인풋이 아웃풋이 k개 가 있음 
n개가 있고 output이 k개가 있는 이런 크로스바 박스임
자 벌써 k는 n보다는 커야됨 그래야 들어오는거에 비해서 나가는 길이 많아야 패스가 보장이 되겟다.
적으면 패스가 보장된다고 할 수 없음
어쨋든 각각이 박스가 다 크로스바고 
여러분들이 지금 가운데 스테이지에 박스를 몇개를 둬야 할지를 숙제를 하라고 했는데 
내 크기 가 크로스에 
크로스라는사람에 의하면 2n-1 보다 크거나 같아야 된다는 그 조건을 제시했고 여러분들의 숙제는 이 조건에 대해서 왜나왔는지 체크를 해보라는 
거였다.
## 학생설명
이조건이 왜 필요한지를 

이게 왜 필요한 말인지를 모름
입력간에 n개의 입력 출력면에서 n개의 출력을 가졌을때
여기 크로스바에서 한개의 입력이 비어있고 출력 단에서 한개의 출력이 비어있을때 그 입력과 출력 을 연결을 보장하기 위해서는 
중간에 여 크로스바 ?? 
크로스바에서 나올수 있는 연결수가 n-1개고 
여 크로스바에서 바를 수 있는 연결수가 n-1개 인데
중간에 있는 k개 크로스바를 n-1개를 점유하고 있고 최악의 경우에 저 여기있는 n-1개의 크로스바에도 여기 n-1 점유하고 있으면
마지막에 1개를 더연결시킬려면 추가로 1개가 더 필요해서 2n-1임

제대로 설명했는데 정확히 설명을 했는데 이해를 한사람!
같이 고민을 안해본사람은 설명을 들어도 모름 무슨 얘기를 하는지 ! 
이런 얘기를 전달하는 방법을 나름 고민해서 생각을 해보면
앞단의 크로스바를 하나만 생각함
여기에 n개의 인풋이 들어와있음 여기 중간스테이지에 여러개 있다고 하자 쭈욱 여러개 몇개 인지 모르지만 k개가 있음 또 다른 n개에 해당하는 또다른  오른쪽에 해당 하는 노란 박스중에 어느 하나를 생각해보자
이렇게 자 이상태에서 아무 
이속에 어느 하나의 유저가 a라고 하는 유저가 어느 n중에 하나를 b라는 유저와 통화로를 맺어야 한다 이거임
이 통화로를 맺고 싶을때 항상 맺을 수 있는 자원이 제공이 되어야한다. 항상이라는 얘기는 최악의 경우에도 자원이 제공이 되어야하는데 따라서 최악의 경우를 생각해보면 여기 n명중에 a를 제외한 나머지 n-1 
즉 박스는 다 일일히 하나씩 연결되어 있잔아 이렇게 
따라서 이 n-1 명이 지금 어 연결되어있는 모양새가 이렇고 n-1개 이게 n-1개 
이 a를 제외한 나머지 n-1명은 지금 이미 n-1개의 중간 stage로 연결이 되어있단 말임 
이그림은 중간 stage로 링크로 하나씩만 연결이 되도록 스위치는 구조가 이렇게 되어있음 하나씩만
중간 stage로는 하나씩만 가게 되어있음
n-1 개가 쓰고 있다면 여기 n-1개의 중간 stage 박스가 있어야 하는거고 최악의 경우를 생각해보면 여기 n를 제외한 나머지 n-1명이 연결이 되어있는데 공교롭게도 이 n-1은 예를 제외한 이걸 제외한 나머지 n-1 개로 연결되어있다. 가정할 수 있다.
얘는 나머지 애들은 이 앞에있는 또다른 무슨 첫번째 형태의 누구와 뭐 연결되어있는 상황인데 그런놈들은 이런식으로 연결이 되어있다.
여기에 또다시 n-1개의 최악의 경우에 n-1개의 중간 stage 에 박스가 필요한거임 이게 최악의 경우이기때문에 이 최악의 경우에 a와 b가 연결이 될려고 하면은 하나만 더있으면 바로 그놈 그놈이 연결이 되줄 수있다 라는거임 한개만 더 있으면 최악의 경우를 생각했을때 그경우에 한개만 더있으면 a와 b가 연결이 된다는 거임 
그럼 저와 같이 n-1개가 두개 더하기 한개만 더있으면 된다 이거임 k가 최소한 이 조건을 만족하면 a와 b는 항상 패스가 연결된다 이런 얘기를 할 수 있다. 최악의 경우에 

자 이해할 수 있지, 크로스 란 사람이 저런 구조에 3 stage 구조에 회선 교환 스위치에서 필요한 중간 스테이지 개수를 중간 스테이지에 크로스바 스위치 개수 를 얘기하는거고 
두번째 생각해볼것은 그렇다면 지금 크로스 포인트 개수가 이 k*각 맨 앞뒤에 있는 각각의 노란 박스(n) 개의 크로스포인트가 있고 그게 몇개가 있져 N/n개가 있다. N/n개가 있고 k*n이고 더하기 중간 스테이지가 N/n개씩 와야하니까 즉 책에 있는 식임 지난번에 이미 우리가 이 k를 저기다 집어넣어서 이 n값을 찾아야 하는 그 관계임 N/n이 약분이 되면 이 
2kN +(N/n)^2 라는게 이게 넘버 오브 크로스 포인트임 
넘버 오브 크로스포인트는 2kn + k(N/n)^2 되어있다 라는거임 그러면 k가 이런 조건을 만족할때 라고 할때 
그러면 이다음에 이슈는 이 조건을 만족하는 저 stage 갖고있을때 n을 뭘 택하면은 저기 지금 전체 N을 small n으로 여러개로 쭉 나눴는데 과연 small n은 몇 으로 하는게 과연 얘를 미니마이즈 하느냐 이런 숙제가 그다음 숙제였다.

n은 아직 변수임 정해진게 아님 그래서 n을 구하려고하는거임 그런데 
n을 정하려고하는거임 근데 정하는 방향은 뭐냐면 토탈이 함수값이 최소값이 되게끔 하는것이다. 크로스 포인트를 최소화 하고 자 하는 n 을 구하라는거임
이 조건을 k대신에 이 조건을 집어넣어서 결국 미분을 하는것이다 n에 대해서 미분을 해서 미분값이 0가 되는 n값을 찾는거임
숙제 여러분들이 k대신 2n-1 을 넣어보던지 마찬가지임 이값이 얼마나왔지 k를 2n-1 대신 집어넣어서 식은 알아서 짜보셈 넣어보면댐
n으로 미분해서 =0가 되는 n값을 찾는거임 그러면 저 함수는 n에 대한 함수니까 n에 대해 미분해서 0가 되는 값을 찾는다 라고 하면은 그게 미니멈 값 
물론 맥시멈 값일 수도있는데 n에 대한 어떤 맥시멈인지 미니멈인지는 또다시 미분 을 2차미분을 해야되겠지만은 미분하면 미니멈값이 됨 
그래서 그게 나온값이 여러분의 숙제였음 
여기서할필요는 없고 n은 루트 N/2이다 이런값이 나옴
n에 대한 여기 분모에 있고 이게 지금 바로 k가 있는데 (식이 잘못됬음 위에 적어놨음)
중간 stage에 k개가 있음 여러분들이 아마 이거 하면 서 고민을 하긴 했을꺼임 이게 2n-1 을 해도 집어넣으면 명확하게 이게 안나옴
k를 약간 양보를 해서 2n 숫자를 집어넣으면 정확히 이값을 얻을 수 있음 그래서 한번 융통성을 보이는거임 이걸 넣었더니 도대체 수식이 복잡하고 그렇다 그러면(조건이 k가 2n-1보다 크거나 같은거니까) 이것을 넣어 k를 2n-1 보다 크거나 같은거니까 2n을 넣어보면은
하나 큰값 간단해보이는값을 넣어보면 좀 간단해 보이는값을 넣어보면
2n-1 대신 2n 넣어서 미분하면 아주 간단하게 나옴 
간단하게 어디서 간단해지냐면 n이 분모가 n의 일차식밖에 안되니까 미분을 하니까 
미분을 해서 0로 만드는게 간단함
여기에 약간의 트릭이있음 이문제는 k대신 2n을 넣어서 풀면 정확하게 이값을 얻을 수 있고 자그럼 이값을 여기다가 집어넣는거임 여기에 n에 다가 집어넣어서 정말 크로스 포인트 개수가 줄어드는지 한번 확인해보자는게 이 책의 그다음에 나오는 예임

## 8.4
그다음 예가 이거임
인풋이 200개고 아웃풋이 200개인 스위치를 만들려고 하는데 
하나의 크로스바 스위치를 사용해서 만든다면 당연히 4만개 
200 * 200 4만개의 크로스 포인트가 필요한데 
지금 우리가 생각했던 3 stage로 바꾸는 서킷 스위치로 구현하면 과연 몇개의 크로스포인트가 필요할까를 이제 비교해보라는 문제임
먼저 n값을 구해야함 n이 small n값 
N은 200이니까 n은 여기 10 이 나옴
10이 나오고 k는 요 크로스 criterion에 의하면 2n-1이니까 19개가 필요한거다 중간 stage 에 그 네모난 박스가 20-1 = 19개가 필요하다.
자 그런 구한값들을 여기다 넣어보면 크로스 포인트 개수가 나온다. 그 크로스 포인트 개수를 구해보니까 9500개다 한 stage로 하나로 크로스바 스위치로 만들면 4만개의 크로스 포인트가 필요했는데 3stage로 만들어보니까 9500개면 되더라 
게다가 9500개는 패스를 100%보장해주는 것이다. 획기적인 개선이다. 4만개대신 9500개만 사용하면 되는것임 그래서 이렇게 발상의 전이다.
복잡해보이는 3stage로 개조를 했더니 크로스 포인트 개수 훨씬 줄어들더라 이말이다.

근데 재미난 일임 하나의 stage 쓰는거 보다 훨씬 효율이 좋다.
그다음 이게 공간분할 이었고 
지금 우리가 회선 교환 스위치에 구현하는 방법이 공간 분할 스위치 지금은 시분할 스위치를 얘기할 것임
시분할 스위치에서 주요 한 포인트는 타임 slot interchange 라는 tsi 라는 장치임 
바로 tsi 가 여기 들어감 

## 스위치 구조(시간-분할 다중화)
자 여기 tdm 시간도 나오고 
tdm 방식 
이와같이 하나의 프레임이 있고 그 프레임속에 4개의 유저가 한칸씩 사용하는것이다 그야말로 tdm 이다.(시분할 tdm 임)
시간 분할 멀티플렉싱 
이렇 게 한다음에 tsi 가 무슨일을 하느냐 얘의 순서를 뒤바꾼다. 순서를 바꾸는 원칙은 무엇이냐 ? 얘들이 목적지 가 누구냐에따라서 요자리에 갖다 집어넣음 얘는 3번째 유저한테 여기로 가라고 하면은 얘가 할일이 맨앞에 있는 놈을 3번째로 집어넣는다. 얘는 4번째 유저다 그러면 얘를 4번째가져다 집어넣고 이런식으로 tsi는 말그대로 타임 slot interchange 라는 타임 슬랏으로 서로?? 구현 한다? 이거 져
목적지 순서에 맞게 재배치 하는것이다 그게 바로 스위칭이 되는것임
스위칭! 

누구든 이 4명은 아웃풋 4명 누구하고 내가 데이터를 교환할 수 있게 저런 패스를 만들어 주는것임
tsi가 
실제 구현되는 모양새는 이렇다고 얘기를함

동작 기본 원리만 알고있으면됨

## TSI
여기에 의하면은 어떻게 되어있냐
이 첫번째 slot이 연결, 첫번째를 얘가 있다 
세번째 자리로 보낸다 이거임 
그러니까 a가 3번한테 간다 라는 얘기임
그런 개념적인 얘기를 그린거고 
두번째 slot 시간이 되면은 얘가 두번째로 와서 그다음에 누구와 연결이 되냐 2번째는 2하고 연결이 되는 누구하고 되야 겠죠 그런식으로 얘와 slot마다 매 slot 마다 이 접점이 부지런히 돌아간다. 
접점을 만들어 주는 그런 식임 

## 스위치 구조 
지금 스위치 구조 2가지를 봤는데 
공간분할 스위치는 어 문제점을 우리가 얘기하면은 크로스포인트 개수가 항상 관심이 대상이고 대신 빠르다. 
타임 디비전 스위치는 딜레이가 문젠데 이런 구조에서 왜 딜레이가 문젤까를 생각해보면은 이 구조에서 이게 왜 딜레이가 문제냐 
지금 이 4번째 slot에 들어오는 놈은 얘들이 다 처리되기를 기다려야함 그렇다. 순차적으로 처리되는 타임 디비전니까 

앞에 있는 사람이 처리되기 까지 기다려야 한다는거임
이게 가령 4유저가 아니라 100개의 유저다라고 하면은 맥? 페이지 유저는 앞에 99명이 처리되기 위해서 기다려야 한다. 타임 디비전에서 딜레이가 발생할 수 있다는것이다.

스위치 규모가 커질수록 딜레이가 더 증가될 수밖에 없는구조다 반면에 크로스바포인트는 동시에 처리가 됨 동시에 크로스 포인트를 동시에 
어느 접점들을 연결해주면은 동시에 n개의 패스가 만들어짐 굉장히빠름 크로스 포인트 개수가 문제가 됨(벗)

타임 디비전 스페이스는 느리다. 그러나 크로스포인트라는 문제점은 전혀 없는 스위칭임 그래서 또다른 사람들이 고민을한게 이 두가지를 조합시키면 어떻까?

공간분할 스위치 와 타임 디비전 스위치를 조합해서 스위치를 만들자. 굉장히 노력함 이와 같은 스위치를 만듬 여기서 보면 맨앞과 맨뒤는 타임 디비전 tsi 들이 있음

중간에 공간 분할 스위치가 있음 그래서 tst 구조라고 한다 이거임 이러한 스위치구조를 앞과뒤는 타임 디비전 스위치고 가운데만 스페이스 디비전 스위치다. tst 의 구조를 갖는다. 이거는 사람들이 생각해낸 두가지 조합중에 하나일 뿐임
스위치 인제 이런 그쪽 전문 서적을 살펴보면은 이게 여러가지가 있다 이거다. 
tssst tsst 이런 배치하는 방법들이 여러가지가 있고 각각의 배치에 대해서 무엇이 좋다 나쁘다는 결국 여기서 얘기하는 딜레이 문제 결국 목적지 까지 가는 패스가 보장이 되느냐 이런 priority를 갖고 이 여러가지 구조들을 제시했다 이거임

그중에 우리 책에서는 가장 간단한 tst 구조만 보여주고 있다.
보다싶이 이 중간에 있는 이 스페이스 디비전은 이 앞에있는 tsi 아이들 간의 스위치를 해줌 스케일좀 커지느..? 이럴때 보고 
12 by 12 죠 12명에 인풋과 12개의 아웃풋이 있는데 이런 구조에서 전체를 tsi 만들지도 않고 전체 를 공간분할로 안만들고 이렇게 조합을 해서 만들면 결국 우리가 해결하고자 하는것은 얘의 빠른 기능 
왜냐하면 여기 지금 아까 tsi 하나로 되어있으면 12번째는 11명이 처리가 될때까지 기달려야함 
여기는 4명 단위로 끊었기 때문에 3명만큼의 맥시멈 
3명만큼의 딜레이만 기다리면된다.
빨라졌고 크로스포인트 입장에서는 전체 12 by 12 144개를 쓰는게아니라 단 9개만 크로스 포인트를 했다.이런점에서 크로스포인트 개수도 줄고 빨라지고 크로스포인트개수도 줄어들고 해서 절충형으로 이런 스위치가 만들어졌다.

여러분들이 봤을때 여 항상 패스가 연결되었는지 면밀히 살펴봐야댐 인풋과 아웃풋간에 항상 패스가 연결된 구조인지 뭔가 여기에 병목현상이 생기지 않을까 라는 우려를 해야됨
사실, 여러분들이 이그림에서 문제가 있는 사례들을 얼마든지 만들 수 있다. 뭐 가장 간단한 사레가 여기 한명과 여기 한명이 동일 한 아웃풋을 가게되면 사실 동일 한 아웃풋도 아니지 
여기 한명이 이리로 오고 여기 한명이 이리로 각각
여기에 인풋에 서로 다른곳에 있는 두 유저가 아웃풋의 네그륩 어느 하나의 네그륩 속에 있는 그 유저에게 연결을 되고자하면 문제가 생김 여기에 병목이 생긴다. 그렇다. 여기서 나오는 놈하고 여기서 각자 유저들이 동시에 길을 뚫어서 나온다 그러면 여기에 가기위해서는 패스가 하나밖에 없으니까 요놈과 요놈이 동시에 접점이 만들어져야 여깃는 유저와 여깃는 유저가 여기 있는 두 유저에게 연결이 될 수가 있다.

안되는거임
동시에 여기 두유저가 여기 두 유저와 연결될 수 있는길이 하나밖에 없기때문에 안되는것임 그러니까 이문제는 이걸 해결할 수 있는 방법 을 지원을 해야지 이구조를 쓸려면 당연히 이런게 후리로 (프리로) ? 주어진게아니라 이거에요 이러한 장점이 
그러기 위해서는 이 tsi 쪽에 면밀한 제어가 들어가야 함 
같은 그륩으로 두개의 유저가 있으면 얘들의 순서를 얘들이 동시에 스페이스디비전 스위치쪽으로 데이터를 보내지 않게끔 서로 처리하는 루틴을 조절해서 바꿔야함 시간을 엇갈리게 만드는 제어가 있어야함

우리가 자세히 들어가보지는 않지만 tsi를 제어하는 그 알고리즘 굉장히 복잡할 수 있음 이런것들을 다 고려해서 이 소프트웨어가 
스위치 동작되는 소프트웨어가 다 저런점을 고려해서 만들어 져야 한다.

개념적으로 저런구조가 쓰일 수 있다는 얘기지 실제 구현하는 측면 가보면 여러 가지 문제를 해결하기 위한 또 다른 여러가지 모호한 내용들이 
이 스위치가 어떤 문제가 있는지 다 같이 공감?
스위치를 간단하게 만들 수 있다. 동시에 가지 못하는 상황을 내가 만들어 낼 수 있음 그래도 해결 됬을 테니까 걱정 할 필요 없음 소프트웨어 가 되니까 순서만 뒤바꿔주면되니까 얘들

지금까지 서킷 스위치 였고 패킷 스위치 구조를 본다.

## Structure of packet switches
패킷 스위치는 이렇게 큰 구조가있고 인풋 , 아웃풋 포트 중간에 스위칭 패브릭 이라고 하는 3개로 구성이됨
인풋 포트나 아웃풋 포트는 뒤에서 얘기하겠지만은 각각의 포트들은 라인을 들어오면 라인에 식은 패킷이 들어오면 
먼저 전기 신호가 들어오면 bit로 바꿔야 되고 따라서 피지컬 레이어 가 동작을 해야하고 거기로부터 피지컬 레이어가 동작되면서 다시 데이터링크 레이어 두번째 링크 레이어가 작동이 되면서 내가 받아줘야 될 데이터인지 아닌지 여기서 판단함
내가 지금 뭐가 금방 왔는데 이 여기에다가는 mac 어드레스 이 데이터 링크 계층에서 지금 갖고 있는 mac 어드레스랑 일치되는지 아닌지 판단을 해야됨 그래서 요만한 박스속에 박스가 뒤에 필요?
필터레이어가 있어야 하고 그속에 데이터링크 레이어가 있어야 하고 그다음에 큐가 있어야함 왜 큐가 있어야 하나 패킷스위치는 자원이 미리 할당되거나 내가 수용하는 만큼만 받아주거나 이런 과정이 전혀 없음 
무조건 다 ??? 임 그러다 보니까 이 라인으로 들어온 데이터들이 지금 이 뒤에서 스위칭 패브릭이나 이 스위치 능력을 넘어선 만큼 계속 들어올 수 있음 buffer를 둬서 잠시 처리될때까지 기다리는 대기실을 둠 바로이 3가지 주요한 박스속에 들어있음 
인풋포트

아웃풋포트는 그거에 역임 나가야 되는데 또 이 링크가 지금 처리속도가 이 스위치 속도를 따라가지 못할때 지금이 output 포트는 예를 보여주는건데 여기 열심히 수행하는데 이리로 데이터가 지금 동시에 3개 4개가 오면은 한 순간에 하나만 처리할 수 있기때문에 여기 또 buffer가 있어야하는 문제가 있어 그래서 output을 살펴보면 
이렇게 되어있음 큐가 있어서 스위치에서 빨리 처리되는놈들을 보관할 수 있어야 하고 다시 여기서 데이터 링크 레이어, 피지컬 레이어 다시 이 프로토콜 역순으로 배치한 이후에 전기신호로 바꿔서 내보내는것임

그래서 인풋 포트와 아웃풋 포트 각각 2개 레이어씩 가지고 있는 하나의 장치가 된다.

바로 중간에 스위칭 패브릭 이라고 하는 부분이 여기가 크로스바 형태로 쓰든 메모리 스위치를 쓰든 버스 구조를 쓰든 여기는 이제 그러한 종류에따라서 여러가지 쓸 수 있음 근데 인풋 아웃풋 은 일반적으로 기능을 들여다 보면은 여기 인풋 아웃풋 속에 저런 기능들이 필요하다.

아웃풋 쪽에는 결국 다시 디캡슐레이션 해야되고 그다음에 비트를 전기 신호로 바꿔서 내보내는 역할을 함

입력 출력에 대한 얘기고 중간에 스위칭 패브릭의 모양을 살펴보는게 이번 챕터의 마지막 주제다.
요 구조가 뭐가 될까 아까우리
서킷 스위치에서는 이게 크로스바일수도 있고 뭐 멀티 스테이지로 만들기도 ..? 해보고 그랬다
이 패킷 스위치에서 중간단계 그림은 뭘까? 
거를 지금 보여주려고 하는것임

일단 이 패킷 스위치도 일종에 뭐 라우터 들임
라우터 들이 3가지 구조를 가지고 있음 하나는 메모리 구조
메모리 구조는 들어오면 메모리에 쓰는거임 메모리에 쓰고 나서 그 저장된 목적지 주소를 보고 어디로 내보내야 겠다 라고해서 바로 제론이? 읽어낼때 그놈을 해당되는 포트로 갔다가 연결시켜주는 
메모리 구조에 스위치 일수도있고 이게
그게 그중에 하나다 스위칭 패브릭 구조중에 하나가 메모리 스위치
또는 버스구조 
여기 버스가 하나 큰 버스가 하나 있어서 다 실어 보낸다. 실어 보내면은 목저지에 해당하는 링크로 빠져나감 
빠른 버스를 두는 구조 이게 버스구조 스위치라고 말함
그런데 그 두가지 스위치들은 좀이 어떤 기술의 한게 성능의 한계 
메모리 리드 라이트라고 하는 그 부분이 메모리는 메모리만드는 기술쪽에 서의 한계가 있음
메모리를 초당 몇번 읽어낼 수 있느냐가 물리 반도체에 기술에 의존하는것이다. 
메모리 access 단계가 몇 나노 세컨드 잔아 그게 바로 메모리 한번 읽을때 그거를 쓸때 걸리는 시간을 말한다. 그거보다 더 빨리는 못한다. 이 반도체 만드는 기술이 그러다 보면은 이 스위치 성능이 메모리 성능에 의존하다 보니까 어 다른걸로 하자 그래서 이제 메모리 스위치 구조는 옛날 얘기가 되었고 버스구조를 따져보자 버스구조

이게 큰 속도 가 빠른 
고속도로 가 하나있어서 모두 고속도로에 실어 보내는거죠! 
그러면 목적지 톨게이트마다 쭉쭉 뽑아내면은 되는데 그것도 역시 버스구조는 어떤 문제를 갖느냐 한순간에 하나만 데이터를 실어야함 버스에다
여러개를 동시에 버스에 실어 보내면은 충돌이 난다. 데이터사이에 그런문제 가 있어서 성능의 한계가 있고 
버스구조
메모리구조, 메모리 스위치 구조 버스스위치구조도 있지만 우리책에서는 
그냥 그런게 있다 라고만 소개를 하고 
세번째 구조가 바로 이런 멀티 스테이지 구조임
또다시 멀티 스테이지 가 나옴

우리 서킷 스위칭에서 멀티 스페이스 스테이지 얘기를 했었는데(아마 위에있는 내용일듯) 패킷 스위치에서도 이런 멀티 스테이지 구조를 얘기하고 있음 
여기서도 보다싶이 노락박스가 있음 노란박스는 모두다 2 by 2 
2개 들어오고 아웃풋 2개인 크로스바 스위치 
아주 간단한 스위치임
그런것을 여러개 붙은거임 
2 by 2 면 정확하게 이놈밖에 없음
두개 가 들어와서 두개로 빠져 나가는 이런 ?
이런 엘리먼트들이 여러개있음
이 그림에서 보여주고 있는것은 

## 스위치 구조
8 by 8 짜리
패킷 스위치를 보여주고 있음
그래서 이름이 배냐 스위치(banyan switch)라고 함 
반야드 트리란 말 아냐? 나무 중에 바냔 트리 
바냔 트리 나무 이름임
독특한 특성을 갖는 나무인데 바냔 트리라는게 
주로 인도 에 많이 나는 저런 모양
나무가 큰 나무가 있음 줄기가 이렇게 내려오면은 줄기가 
나무기 ..? 돌아오는 나무인데
줄기가 땅에 내려옴 그럼 다시 나무가 만들어져 이게 자기 주목이고
주목에가 가지가 땅에 나오면은 여기서 뿌리를 내리고 다시 나무가 된다.
이게 이쯤에서 뿌리를 내리면 다시 나무가 되서 자라나고 해서 
나무 한그루가 숲을 이룬다.
이런 큰 숲을 이루는 나무 
이게 반야 트리임
실제 이런 나무가 있음
이 나무이름에서 따온 이 스위치 구조를 반야 스위치라고함
왜 저렇게 했을까? 이 스위치 기능을 살펴보면서 이런 스타일의 나무이름을 땃을까?

이게 2by2 스위치고 8개 인풋이있고 8개의 아웃풋이 있음 이것도 역시 모든 인풋이 모든 아웃풋 의 패스가 만들어져야함 굉장히복잡함 서로연결되어있는 연결선들이 이상함 
저런것들이 왜 저렇게 저런 모양을 가질 수 밖에 없는가 이 스위치에 중요한 특징이 하나 있음 셀프 라우팅이라는 기능임
셀 프 라우팅을 보자

지금이 3번에 들어오는 인풋이 목적지가 6번으로 갈려고해 
110 이라는 목적지 요 스위치 내부에서의 요 아웃풋 번호를 목적지라고 하는거임 여기 들어온 놈이 6번인가를 나가야될패킷이다 라는것임 그러면 여기다 집어넣으면 이 연결을 따라가서 저절이 이리로 간다. 어떻게 이게가능하냐 이 연결이 되게끔 해놨다. 
자 여기에 맨 큰 자리부터 1 
6이라는 숫자가 110 임
1, 3번이 어디 연결되어있냐 여기 연결되어있음 
이게 다 사연이있음 연결형태가 

맨 첫번째 에 있는 1을 보는거다. 1이면 아래로 가고 0이면 위로가고 이 모든 2by2 이 스위치는 로직이 한가지 
하나밖에 없음 내가 지금 보고자 하는 어느 bit number가 0이면 위로 1이면 아래로 애는 누굴 뭐로 보냐면 msb 로 본다 1 
얘는 그 다음 자리로 1 을 본다.
얘는 그 다음 자리인 lsb를 본다 0
집어넣으면 6으로 저절로 가있다 
이게 셀프 라우팅 기능이 있는데 
이 스위치는 셀프 라우팅 기능을 구현하기 위해서 이 복잡한 선들을 연결하고 있다. 이거임

저선들을 내가 가령 없애버리면 저 선을 그릴수있느냐? (중요)
선을 그리는 원리는 알아야 선을 그리는거지 외워서 그릴려면 알 수없음
책에는 이런 상세한 설명이 없지만 내가 한 20년전 쯤에 이런 스위치 그냥 그 스위치라는 강의 를 더듬어서 해보면

아마 모르는거임 아무나 모르는거임 가령 자 이 목적지가 
여기 목적지가 
000 얘들을 여기 바이너리 넘버로 쓰면은 101 100 0
000
001
010
011
100
101
110
111
이와 같다. 이런 목적지로 지금 내가 내보낼려고 하는 
근데 아무데서나 들어왔는데 얘가 지금 101 로 가고 싶다. 그러면
이 digit 개수가 앞에 stage가 여기있는거임 
여기 박스가 
아까 그림에 3개의 stage에서 저것들 가지고 뭔가 컨트롤 하는데 로직은 그거임 첫번째 stage는 얘를 보고 그거갖고 나눌 수 밖에 없는게 가만히 보면은 msb가 0인게 위에 다 모여있음 이렇게
1이라는게 아래로 모여있음 바이너리 넘버를 보면 우리가 저런 구별이된다. 
그러면 얘는 기본적으로 할일이 뭐냐 기본적으로 할일이 맨 첫번째 비트를 보고 얘가 0이냐 1이냐를 보고 0이면 이 반을 잘라서 이 위로 보내고 
1이면 아래로 보내고 왜냐하면 0이면 이리로 모여있고 1이면 이리로 모여있음 
그래서 여기에 있는 스위치들을 일일 히 보면은 하나 둘 셋 네개가 있음 얘들이 0이면 다 이쪽으로 보내는 역할을 함 다이렇게 
1이면 아래부분 에 그림이 있어야함 이거져 
그 속에 여기에 또 4개가 있으니까 얘들 일일 히 분배하는것임 
얘는 여기서 오고 끊? ?? 
... 진행중
얘는 이리로 가고 이그림을 잘 그리면 이렇게됨
0이면 아래로 가고 1이면 위로감
애는 0이면 위로가고 1이면 아래로가고??
요 그림이 나옴 저 연결이 바로 이그림임
첫번째 연결 자세히 보면 
두개 나오면 하나는 0이면 위에 4개중에 하나로 가고 1이면 아래 4개 중 하나로 가고 
그래야 뒤에 목적지 ?? 주소들이 나눠져있음
자그러면 안으로 들어오면 다시 똑같은일을 하고 있음
일단 얘는 해결했고 이안에 4개중에 보면은 위에 2개가 0이고 아래 두개가 1임 그러면 얘들을 판단하기에 여기에 똑같이 스위치가 있는데 
0이면 이중에 위로 보내야 하고 1이면 아래로 보낸다.
여기도 마찬가지고 0이면 이리로 보내고
이와같은 커넥션이 만들어져야겠다. 
그게 ?? 임
저런 커넥션이 왜 만들었는지 원리를 목적지 주소에 바이너리 넘버를 쭉 살펴보면은 커넥션의 성격을 알 수있다. 저렇게 만들었기 때문에 저렇게 이 엘리먼트들간의 링크를 이런 구조로 만들었기때문에 셀프 라우팅이라는 기능을 갖게 된거임 저 스위치가 물론 패킷이 라는게 기본적으로 
패킷이 하나 있는데 애는 기본적으로 최종 목적지 주소를 갖고 우리가 이미 프로토콜 공부할때 최종 목적지 주소가 있는거임 그 주소는 있는건데 일단 요 스위치 내부에서 그 목적지를 갈려면 가령 이리로 가야겠드라 할려면 이 패킷 위에다가 요기 옆에다가 이 스위치 내부에서 하는일이죠 101을 여기다가 앞에 헤더 헤더를 하나 붙여주는거임 그래서 저걸 보고 이 스위치가 동작을 함 101 해서 101 순식간에 그 패킷을 보내주면 101 버리고 원래 패킷만 가지고 처리하게 된다. 
요 내부에서 쓰이는 로컬한 주소 요 목적지 , 라우터 주소들을 이용해서 셀프 라우팅이 이루어진다.  그런 스위치임

그래서 이런 이게 복잡해 보이지만 여러분들이 그릴 수 있다. 원리가 뭐냐만 알면 그릴 수있음 
이게 가령 8개 stage 4개로 5개로 바뀌면 어 이게 인풋 8개인데 16개로 바뀌면 이 규모가 더 커짐 그렇게 해도 이 엘레먼트간 연결되는 원칙을 알고있기때문에 그들간에 연결을 다 할 수가있다. 아직 원리중에 설명안한게 바로 이거임 과연 이건뭘까 왜 구지 이런 복잡한 연결을 했을까 조금잇다 나옴
어쨋든 이스위치는 셀프 라우팅 기능이 있다라는 재밌는 
그래서 셀프라우팅의 사례들을 보여준다. 이 근데 저게 다냐 
문제가 있다. 우리가 이런 연결이 있고 뭔가 보안을 해줘야될 사안이 생기는데 항상 이 모든 유저는 모든 아웃풋에 연결이 될 수 있느냐? 안그럴 경우를 우리가 대변? 했다라는얘기임 
지금 여기 유저가 101 5번으로 가야되고 밑에 유저가 100 으로 가야한다. 4번으로 가야한다. 그러면 로직에 따라서 가보면 양쪽이 다 11이니까 에도 아래로 가고 얘도 아래로 간다. 그러면 여기서 그다음에 가야할께 가운데가 여기서 준다. 그러면 위로 보내야 하는데 둘다 동시에 위로 보낼 수가 없다. 둘다 보낼 수 없음.
이게 블락킹임 여기서 얘기하는 이터널 블락킹임
이 구조는 뭔가 잘만들어 져있는거 같지만 결정적으로 인터널 블락킹 문제를 갖고있는 그 블락킹 문제를 갖고 있는 구조임 그래서 이문제를 어떻게 풀까? 사람들이 고민을 함 그래서 그 해결방법이 이 라인속에 있다 그리고 이앞에 어떤 장치;를 더 붙여야하는데 그장치 를 붙인 구조가 이제 10분뒤 소개함.

블락체인 강의 세미나가 있는데 3시 30부터 백년관 제일큰 계단식 강단 거기

이 이런 멀티 스태이지 스위치가 내부 블락킹 문제를 가지고 있다 보면은 여러분이 확인을 했음 
같은 목적지를 가야하는데 분명히 서로 다른 목적지 인데도 불구하고 중간에 갈길이 충돌이 나버리는데
분명히 목적지가 서로 다름에도 불구하고
이거는 반드시 해결해야할 스위칭을 쓸 수 있는 부분임
이런 문제가 남아있는 상태에서는 쓸 수 없다.
그래서 배냐 스위치를 손을 바야겠다. 어떻게 해결할 것인가? 바로 이과정에 스위치 할때 수학이 들어온다.

과연 이게 어떤식으로 운영을하면 외부에 이터널 블락킹 문제를 해결할까 라고 해서 찾아낸 사람이 배처 란 사람임 
그래서 배처 네트워크라는걸 만듬
배처 네트워크 라는걸 만듬
앞에 배처 스위치라는게 붙고 여기에 아까 바냐 스위치는 뒤에 붙고 해서

## Batcher - Banyan switch
바냐 스위치 앞에 이런 놈들이 보강되면서 이터널 블락킹 문제가 해결이 됬음 이터널 블락킹 문제는 어떤 식으로 해결을 했느냐
그 결과는 너무 간단하다 이거임
너무 간단함
이 인풋 에 들어온 맨위부터 아래대로 순서대로 이제 8개중에 하나가 목적지가 된다. 스위치 내부에서 그러면 이 각각의 인풋 이라는 목적지를 봤을때 목적지 주소를 가지고 sorting 하면 된다는거임 
그래서 가장 적은 아웃풋주소를 갖는 놈을 맨위에 점점점 큰 아웃풋 주소를 갖는 놈이 맨아래 
여기 소팅을 인풋에 들어오는 그 패킷들을 바로 주소를 갖고 소팅을 해서 정렬을 시키면은 블락킹 문제가 없어진다. 결과는 매우 간단한데 이걸 찾아내기까지 수학적인 근거를 찾아낸다. 굉장히 복잡함 
각각 에들어온 요놈들을 목적지 주소별로 소팅을 해서 다시 정렬 시키면 된다. 이거임 그러면 다시 정렬을 시키는데 요놈은 왜있느냐 이놈이 소팅 네트워크임 요놈이 배처-네트워크 스위치라는게 소팅 시키는거임 
가령 여기가 두개밖에 없다고 하는데 7번이 목적지이고 얘는 2번이 목적지 다 라고 하면은 가령 두개만 보낼 수 있는 상태라고 치면은 얘는 7번이고 얘는 2번으로 가야된다고 하면은 요걸 통해서 나오면 어떻게 되? 요놈이 소팅 되서 맨위부터 오 
요게 2번으로 갈려면 요기가 7번으로 갈놈이 요 뒤에나온다 이거져..
여기서 솔팅을 해서 이놈들을 목적지주소로 소팅해서 위에서 부터 차곡차곡 채워넣는거임 위에서부터 
맨위부터 채워넣는다. 그래서 여기 6개만 보낼 패킷이 있으면 
배치 네트워크에 아웃풋에는 위에서부터 6개까지만 인풋이 와있음 목적지 순서대로
얘는 뭐냐
이렇게 목적지 순서대로 나눠보니까 같은 목적지 로 가는놈들이 있을 수도 있음. 그래서 저 배처에 아웃풋이 이럴수가 있음 이거 배처인데 가령 인풋이있는데 이놈들의 목적지가 
5
4
3
2
6
5
2
7 이라고 쳐보자
그러면 아웃풋이 
얘들을 순서대로 나눈다. 2번으로 갈놈 소팅 3번으로 갈놈 소팅
이 순서대로 감 그다음에 7번
2
2
3
5
5
6
7 이순서
바꾼거임
패킷의 순서를 
배처 네트워크가 바꿈 
동시에 두개의 동일한 인풋으로 아웃풋을 두개가 있는 이런 문제들은 이터널 블락킹 문제가 아니라 애당초 안되는거임 
이 목적지 하나에 동시에 두개가 갈수없음 그래서 트랩이라는 무슨일을 하느냐 트랩은 이 
2
3
4
5
6
7
이 뒤에 요런 버퍼링을 시켜놓음 5번은 요놈은 여기에 버퍼링을 시켜놓고한 아웃풋에 하나만 내보내고 출력 내보내고 중복된 아웃풋 애들은 버퍼링 하는 네트워크가 바로 trap-module 이라고 함 

그래서 반드시 바냐 스위치가 들어올때는 동일 한 아웃풋을 갖는놈들은 두개이상 나올수가 없고 아웃풋 주소 대로 소팅이 된상태로 딱 그 들어오는거죠 그러면 이 구지 이렇게 복잡하게 이 라인들을 복잡하게 한 이유들이 뭐냐 를 보면은 
구지 무엇인가를 보면은 
왜그랬을까?
왜 구지 마치 이 네트워크를 셔플 네트워크라고 부름
책에 없는 얘깅미 셔플링 한다 고 함
섞는 거임 
우리가 카드 놀이할때 카드 를 두개를 나눠서 셔플 섞을때 카드가 두 그륩으로 나눴을때 이렇게 섞을 때는 여기서 한장 여기서 한장 
이렇게 서로 한장씩 엎어지는 방식임
카드가 셔플링 한다고 하는게 
바로 요모양이 딱그거임 요모양이 어떻게 되느냐 요 4개와 4개를 각각 카드 양쪽에 나눈놈이라 생각하면 셔플되는게 보인다.
한쪽에 맨위에있는거 다음에 다른 그륩에 맨위에 있는 놈이 들어오고 
그다음에 두번째 애들이 들어오고 세번째 애들이 들어오고 내번째 애들이 들어온다. 이 네트워크를 셔플 네트워크라고 함 

스위치 쪽에서는 그렇게 부름
셔플 네트워크가 과연 왜 이렇게 직접 연결을 안하고 왜 셔플을 했을까? 이게 소팅 됬다고 했죠 그러면 바요 여기서 이놈에서 나갈 수 있는놈이 두개밖에 없는데 두개밖에 없는데 
두개다 연결을 하면 두개밖에 없는데 한놈은 위 그륩으로 가야되고 한놈은 아래 그륩으로 가게끔 바냔 스위치는 그렇게 만들어져 있다. 셀프라우팅을 위해서 아까 우리 봤듯이

그러면 가령 2와 3이 갈려면 둘다 여기있잔아 
여기에 있어 
0
1
2
3
이 4개중에 위에 있는 내그륩으로 가야하는데 보다싶이 그 네그륩으로 가는길은 이거 하나밖에없음 이리로 보내버리면 아래 네그륩밖에 안되는거잔아 ???
2 3 이 아니라 4부터 시작하는 주소밖에 못간다 이거임 
바냔 스위치는 이 구조가 이렇게 되어있음 그래서생각한게 
아 그럼 위에 갈 수있는 놈들이 결국 많으면은 여기 소팅했을때 4개가 위로 가는 놈이 되고 아래4개가 아래로 가는 놈들이 될것이다.
왜 소팅을 했으니까 
목적지 주소 4개 위에 4개 나가는 놈이 최대한 꽉차면 여기고 아래에 해당하는 놈들이 4개가 있는거임
셔플하는거임 그래서 4개가 모여있을텐데 이 네놈을 각각 그대로 연결했다가는 큰일남 왜냐하면 이 위로 갈 수있는길이 두개밖에 없음 
여기 4개 가 들어오는데 없음 그래서 얘들이 갈 수있는 길이 몇개가 있냐는 4개가 위로 갈 수 있는길이 4개 있고 그렇고 
분산을 그래서 얘들을 각각 분산을 시켜야한다.
그렇게 직접 연결하는게 아니라 맨 이놈 그다음 이놈 그다음 이놈에 연결을 해준다. 똑같은거 오면은 이 아래에 있는놈들은 이렇게 연결을 해줘야한다. 이렇게 연결을 해줘야한다. 왜냐하면 이 아래잇는 놈들은 이 아래쪽에 올 수 있는 애들인데 걔들의 패스는 어쨋든 일단 올라가더라도 내려올 수 있는 길이 다 있다 라는거임 바냐 스위치에 의하면
그래서 여기 바로 셔플링 해야 할 사연이 생기는거임
솔팅 됬다는 전제하에 셔플링이 필요한거임
얘들이 소팅된 순서대로 쭉 나열되 어있다. 그가정에 셔플링이 있어야 반드시 이 소팅한 효과가 발휘될 수 있다.
이게 그렇게 할 수 밖에 없다. 셔플네트워크를 여기다가 만들 수 밖에 없다.
구지 이걸 왜 했을까? 그래도 한번 물어보는게 좋겠다.
(일자로 들어가면 아래서 들어가는 쪽 이 없기때문인가?? 이것을 물어보자)

셔플링 방식

얘는 소팅하는 네트워크 (destination 기준으로 소팅을 하는 ) / trap이라는것은 동일한 목적지로 가는 놈들은 하나만 나가게 하고 여기서 나머지는 여기 저장 시키는 방식(중복된 패킷 방지) 그리고 나서 바냔스위치는 셀프라우팅 기능이 그대로 구현이 되면서 이 전체가 결국 배처 배냔 스위치가 이런구조다.
배처 - 배냔 스위치 
이 배처 - 배냔 스위치는 인터널 블락킹 문제가 없는 해결이 된 스위치다. 소팅이라는 간단한 장치를 고안함으로써 이터널 블락킹 문제가 해결됬다는 재미있는 얘기다. 
문제들을 어떻게 해결해야할까 과거 선배님들이 어떻게 해결했는지 재밌는 형태다. 

6 문제가 숙제다.(아침에 해야지)

네트워크 레이어에서 라우터를 배울때 이구조를 다시보게됨
이와같은 스위치를 쓰는거임
인풋 포트와 아웃풋 포트에 각각 피지컬 레이어 링크레이어가 들어가있고 메모리 버퍼를 가지고 있고 결국 스위칭은 여기서 이루어지는건데 이 스위칭이 이루어지는 구조는 메모리 스위칭 방식이 이고(메모리 몽땅 쓰고 읽어낼떄는 다른순서로 읽어내면 그게 스위칭이다 이런개념임 ) 메모리 스위칭
또는 버스구조(실제 라우터중에 버스구조 를 쓰고 있는 라우터들이있음 굉장히 하이 웨이를 만들어 놓고는 이 순서대로 쭉 실으면 그때 그때 해당되는 아웃풋 가져가서 ? 이게 스위칭 네트워크 근데 그거는 한순간에 한데이터만 올려놓을수있기 때문에 여전히 리미트가 있다는거임 그다음 구조가 아까 우리가 본 구조라는거임 배냐 스위치 구조

이런 스위치가 운영이될려면 사실 설명이 보안되어야 함 우리가 지금 이런 구현될려면 실제 8개 들어온 인풋 패킷 사이즈가 똑같아야 함 왜냐하면사이즈가 같아야 함 왜냐 한단한단 지나가면서 이 아웃풋에 나오는 메모리 크로스바 스위치라고 했는데 크로스바 스위치는 접점이 붙었다 떨어졌다 하는 시간 개념의 컨트롤 이루어내야하는데 패킷 길이에 따라서 이 접점을 얼마나 유지하고 있어야 하나 패킷 끼리가 다 다르면 이 중간에 있는 크로스바 포인트들이 접점을 유지하고 있는시간 이 다 다르면 이 스위치 운영이 안됨 동일 한 사이즈 의 패킷들이 다 들어와 있어야 하고 그래야지만 이스위칭이 제대로 동작이됨 
그런데 패킷 네트워크에서 패킷 사이즈에대한 동일 한 사이즈라고 말안함 패킷 사이즈를 업퍼 바운드 1500byte 이내다 이런 그 크기는 동일한 사이즈라고말안함 

그럼 패킷 사이즈가 이 이내에서 어느놈은 100 byte 고 어느놈은 500 byte인데 이게 어떻게 동작이 된다는거냐 당연히 우리가 설명은 안했지만 
이 스위치가 동작되는 앞단에서는 패킷을 다쪼갬 다 동일한 사이즈로 단 어떤 사이즈로 받던간에 단 가령 예를들어서 100byte 짜리로 다쪼갬
500 byte 들어왔으면 5개로 쪼개서 100byte로 쭉 세워서 처리하고 그다음 처리하고
이런식으로 여기다가 묶어 낸다. 아웃풋 속에서 500 byte 묶어서 그다음 스위치로 보내고 한다. 복잡한 일들이 우리는 보이지 않지만 일어난다. 
이게 동작이 될려면 다 처리되는 패킷 사이즈가 동일해야함 그래서 우리는 애기를 안했지만 그런 류 스위치는 동작을 하고 있어야 한다. 
제한을 갖고 현재 쓰이는 인터넷들이 저런 구조를 갖고 운영이된다.

# chapter 9
9장은 바로 전버전 교재는 없었던 내용인데
이게 뭐 추가됬지만 그냥 데이터링크 레이어
지금까지 본게 피지컬 레이어임(8장까지가) 우리 전체 레이어 중에 피지컬 레이어 배움
9장 부터 데이터링크레이어를 배움 그래서 데이터 링크를 소개하는 챕터가 5판에 오면서 추가됬고 4판은 없었음 이런 챕터가 없엇음

근데 이챕터는 그냥 혼자 봐도 될 내용이고 9장은 크게 두개로 나눠짐 이렇게
인스트럭션 , 링크 레이어 어드레싱(다행스럽게 저번에 봤음)
패킷 하나 목적지까지 갈때 어드레스 종류가 4가지가 있는데 오로지 네트워크 레이어 ip주소만 가지고 가느냐? 그게 아니다.
네트워크 안에 들어가보면 그거로부터 링크 레이어에서 정의한 mac 어드레스가 알아야 패킷이 갈 수있음 
그래서 각 네트워크 별로 링크 레이어 어드레스 를 얻어내기 위한 arp라는 프로토콜이 있다. 그걸 통해서 ip주소를 갖고 링크 레이어 주소를 얻어내서 그 다음 노드의 링크 레이어 주소를 얻어내서 그걸 보낸다음에 또 다시 그 노드는 또 arp 을 통해서 다음 노드까지 보낼 방법을 또 arp 를 통해서 링크 레이어 어드레스를 얻어낸다음에 보낸다. 이런 절차를 설정한 그림이 바로 9장에 뒷부분임 그부분은 여러분이 안다고 생각하고 모르면 복습하고 넘어감 9-1만 간단히 보고 9장을 넘어간다.

## 9-1 Introduction
데이터 링크 레이어 소개함 링크가 뭐고 노드가 뭐냐
이 데이터 링크 레이어는 노드와 노드사이에 통신을 담당하는거고 
그 노드 노드 사이는 링크 라는것으로 연결되어있음 
따라서 데이터 링크레이어는 링크와 노드라는 개념을 처음 소개하는 장이 된다. 

그리고 링크의 종류를 포인트 투 포인트 , 브로드 캐스트 종류가 있다.
두가지가 있다. 그리고 마지막으로 링크 레이어 라는게 두개의 레이어 로 서브레이어로 나뉠수있다. 
링크가 이렇게 두가지가 있다고 했는데 포인트 투 포인트 와 브로드 캐스트 링크가 있다 보니까 각각에 대한 컨트롤 메카니즘이 다를 수 있음 우리가 알고있는 이 맥 프로토콜 이라는게 맥이 뭐져! 맥이 뭐에 준말이냐 
멀티플 엑세스 컨트롤 다중접속제어 라고함(MAC)
다중접속제어는 브로드 캐스트 링크에 해당한다.
이거는 포인트 투 포인트는 링크를 단독으로 사용하는거고 링크를 
브로드 캐스트 링크는 여러유저가 같이 사용함
이 여러 유저들 간에 어떤 컨트롤해야됨
멀티플 엑세스 컨트롤 이라는 맥 프로토콜 이 이 데이터 링크 레이어에 적용되는데 바로 브로드캐스터링크에 적용되야 겠다.
그래서 데이터 링크 레이어를 이렇게 두개로 나눈다. 서브레이어로 나눠서
dlc 서브레이어(브로드 캐스트 든 포인트 투 포인트든 링크 제어를 위한기능이 일반적으로 다들어있음 ), mac (브로드 캐스터 기능을 전담하는게 여기들어있는거고  )
그중에 브로드캐스트 경우에는 mac이 사용되야 하기때문에 mac 레이어는 별도로 이렇게 서브 계층으로 나눈다. 
이 두개 합쳐서 데이터 링크 레이어인데 데이터 링크 레이어를 개념적으로 두개의 서브 레이어로 나눴다. 라는것을 소개했다. 
그부분이 1절의 뒷부분에 있음 

2절은 아까 말했듯이 주소 링크 레이어 주소를 어떻게 얻어서 어떻게 패킷들이 전송이 되는지 많은 그림을 통해서 설명을 하고있는데 이미 오래전에 살펴봄 그래서 그부분 생략함

## Communication at the data-link layer
데이터 링크 관점에서 보면 이런 그림이 그려질 수 있음 
이 쭉 보면은 계속 데이터 링크 레이어를 거쳐서 거쳐서 간다.
이 그림에서 이제 우리가 눈여겨 볼게 바로 요 라우터들 에 프로토콜 스택을 보면 우리 이 end 시스템은 이 다섯 개 레이어로 그대로 그려져 있고 여기 데이터 링크 레이어가 2번째다. 
이 그림은 뭘 설명하냐면 여기있는 데이터링크의 경우랑 이 라우터의 데이터링크 레이어가 서로 통신한다. 
이렇게 도와 가면서 패킷전송을 이룬다. 개념적으로 보여주는데
모든 장치를 거쳐갈때마다 서로 링크 레이어 간에 뭔가를 주고 주고받아서 가는 모습을 보여주고 있다.
그런데 주목할것이 이라우터들이 이 프로토콜 스택에 양쪽에 나눠져 있음 요렇게 나눠져 있는 까닭 
라우터들은 나눠져 있는데 end system은 나눠져 있지 않다.
이 나눠져있는 까닭은 이 라우팅 상에서 요 링크와 얘와 얘기 할때와 얘와 얘기할때의 데이터 링크 레이어의 기능이 다를 수 있음
여기 서있는 이 lan 스위치의 데이터 링크 레이어 기능과 다음 홉에 있는 요 라우터 의 데이터 링크 레이어 에 기능이 서로 다를 수있음
여기는 뭐 이더넷이라는 그 데이터 링크 레이어 쪽에 이더넷 이라는 기술로 데이터가 오가고 있고
여기는 다른기술이다 그러면 분명히 데이터 링크 레이어의 프로토콜의 내용이 달라야한다.
그래서 라우터 입장에서는 애를 상대하는 부분은 요부분이고 얘를 상대하는 부분은 요부분이다.
그래서 듀얼 스택이 된다.
듀얼 스택 저렇게 아래 레이어들이 서로 다른 식으로 그림이 그려진다.

이 라우터들이 다 그렇죠 ? 각 링크별로 이 요 듀얼 스택 형식으로 이루어지는것을 볼 수 있음
저건 다시말해서 링크에 디팬던트한 프로토콜 레이어 기능이 구현된다.이런것을 저기서 얘기된다. 동일한 프로토콜들이 아니라 서로 다른 ?? 친구들이 들어온다.
가다가 어디서 무선이 될수도 있단말임 무선에 관련된 데이터 링크 레이어는 또 다른 형태 , 
기록들을 가지고 있어야 하니까 양쪽에 각각 서로 다른 프로토콜 스택을 갖는식으로 그림이 만들어진다.

그다음 내용은 이 지금 아까 그림을 단순하게 그리면 이렇게된다. 더 단순하게 그리면 이렇게됨

## 9.1.1 Nodes and Link
Figure 9.2 : Nodes and Links
결국 노드와 링크 로 내 패스를 정의 할 수 이것임
근데 노드라는것이 엔드 시스템 일 수도있고 라우터 일수도 있음 
여기는 잘 이해가 가는데 링크 라는곳에 뭐가 맵핑되느냐? lan이 링크로 들어오는거임 

그 포인트 투 포인트 access 도 여기보면 lan 도 link ?? 이런것들이 링크로 들어옴 

랜이나 왠이나 다 링크라는 개념적으로 링크 라는 방식으로 표현할 수 있고 라우터들 그리고 end system을 노드로 표현하는 이와 같이 하나의 패스를 도식화 할 수 있다는 얘기임
개념적인 말이다.

데이터 링크 레이어는 피지컬 레이어 가 위에있으니까 피지컬 레이어의 서비스를 받아서 뭔가를 수행하고 있고 네트워크 레이어가 이 데이터 링크 위에있음 따라서 데이터 링크 레이어는 그 네트워크 레이어 에게 서비스를 제공함
레이어 인 셈이다.
여기 써있다. 데이터 링크 레이어는 서비스를 받는데 physical layer 부터 서비스를 받고 그리고 네트워크 레이어로 서비스를 제공함
위로는  서비스를 제공하고 아래 서비스를 받는 개념임
그래서 그러면 데이터 링크에서 제공하는 서비스가 무엇이 잇느냐?

그냥 불친절함 사실 이챕터는 책을 보면 되니까?

## A communication with only three nodes
데이터 링크 레이어에서 프레임이 있는 기능이라는게 
받으면 얘가 하는일은 디캡슐레이션을 먼저함
레이어 2에서 만든 해더 내용을 들여다 보고 
그걸 잘라낸 다음에 데이터 그램, 네트워크 레이어 부터 남아있는 부분을 네트워크 레이어로 올린다음에 내려오면 다시 여기서 인캡슐레이션을 할것임
이쪽 링크에 해당하는 해더를 데이터 링크 레이어 해더를 또 붙여야함
여기서 디캡슐레이션 여기서 인캡슐레이션 해서 보냄
바로 프레임 , 우리 그 데이터 링크 레이어에서 주고받는 단위를 프레임 이라고 부르고 있고 
네트워크 레이어에서는 데이터그램이라고 부르고 있음

차이가 뭐냐 이 데이터그램뒤에 앞에 데이터링크레이어 헤더가 붙어있는게 프레임임 바로 이 헤더를 
패킷을 받으면 디캡슐레이션 패킷을 받으면 띄어서 살펴보고 올린다음에 여기서부터 이제 목적지는 다음 노드는 누구다 라는것을 내놓으면 얘의 mac주소가 다시 변경되서 표기가 된 새로운 해더를 붙여서 내려보냈다.  
그래서 프레이밍 작업이 데이터 링크 레이어에서 중요하게 이루어져야하고 그 외에 플로우 컨트롤 이라는게 이노드와 이 노드 사이에 서로 서로 얘가 이 노드가 처리할 수 잇는 양만큼만 보낸다 이런게 플로우 컨트롤임 또는 
또는 패킷을 하나 받았는데 이속에 지금 에러가 있는지 없는지 체크한다. 에러 컨트롤 
이런게 다 지금 데이터링크 레이어 에서 수행이됨

## Figure 9.3 : Dividing the data-link layer into two sublayers
슬라이드에는 그게 없음 9장에 책을 보면 그런내용이 있음
데이터 링크 레이어를 무슨일들을 하느냐?
그 내용들이 가령 에러 컨트롤이 바로 다음 10장에서 다룰 중요한 주제임
각 챕터 별로이제 여기서 얘기들이 나오기 떄문에 구지 그냥 제목 정도만 얘기하고 넘어간다. 그다음부분이 서브 레이어 로 나뉘어져 있다 라는것을 여기서 보여준다.
데이터 링크 레이어는 아까 얘기한데로 dlc와 mac이라고 하는 두개의 서브 레이어로 나뉜다.

에러 컨트롤임 각 챕터별로 여기서 얘기하는 이제 얘기들이 나오기 떄문에 구지 그냥 제곱 정도만 얘기하고 넘어감 
그 다음부분이 이 sub layer 로 나눠져 있다라는것을 보여준다 이렇게 
데이터 링크 레이어가 dlc와 mac 이라고 하는 두개의 서브 레이어로 나뉜다.

근데 나뉘는 사연에는 링크가 포인트 투 포인트는 브로드캐스팅 기본적인 ...)
기본적인 데이터링크 레이어를 수행하고 얘는 주로 브로드 캐스트 링크  mac 기능이 필요하다. (맥 프로토콜 두번째 레이어에서) 링크를 사용하는데 mac 프로토콜이 저기 두번째 자리이고 에서 정의 되어있음)

이 mac 레이어는 뒤에 13장에 인가 또 거기서 자세하게 들여다 본다.
dlc는 12장에 나옴 각각 다른 챕터들이 있으니까 여기서는 큰그림만 보고 넘어감 

링크 레이어는 이미 아까 얘기듯이 이 그림을 봤죠? 이 엘리스로부터 밥까지 가는데 
엘리스가 가지고 있는 주소는 밥에 인터넷 주소 밖에 없다는것임 
a만 알고있고 가령 패킷이 이런 네트워크를 통해서 
이패킷이 이런 네트워크를 통해서 어떻게 여기까지 갈 수있는가?
바로 여러가지 address
데이터 링크 레이어 에서 정의한 어드레스 들을 결국 활용해서 나한테 시나리오가 뒷부분에 주욱 쭉 나와있다 이거임 이게 맥 주소 구조임

이걸 48 bit짜리 맥주소임 데이터 링크 레이어 에서 만든 주소임 
우리 인터넷 장비, 네트워크 접송 장비는  주소를 가지고 있어
가지고 있어야 데이터를 받을 수 있으니까 

이모든것이 애플로 계획된 브로드 캐스팅이다. 
누구나 이 접속되 있는 모든 장치가 다 아날로그 신호가 되는거 주소가 됨 


그다음 주제가 ARP

## 9.2.2 ARP
저것을 통해서 IP 주소를 사용해서 데이터 링크 주소를 얻어오는 과정 그 얻어 오는 프로토콜이 ARP다. arp 를 사용해서 어떻게 이루어지는데
ARP는 네트워크 레이어에 있고 이것을 통해서 패킷을 어떻게 전송되는지 그땐 얘기안했지만 ARP 프로토콜이 만드는 패킷 구조 이런것들이 있는데
여러분들 이 살펴보면됨 ARP 패킷은 Request 또는 reply가 있고 
request는 내가 지금 알고 있는 ip주소는 이건데 이 ip주소에 해당하는 mac주소를 달라	 
이게 바로 request임 1이라는값을 넣고 내가 지금 그 주소를 여기 어딘가 써야됨
소스 프로토콜 어드레스 라는게 자기꺼 
데스티네이션 프로토콜 어드레스 라는게 목적지 이놈에 대한 하드웨어
맥 주소를 원한다 이거임
긱하는거?? dps 에는 
리플라이에는 여기를 채워서 헤더 장치가 저 부분을 채워서 보내주는거임
그래서 결국 그 다음 홉에 그 주소를 얻어와서 보낼 수 있는거임
여러분들이 이부분을 복습해줘야 하는 상황으로 넘어간다.
다시 또 설명할 필요없다. 
arp 통해서 패킷이 왔을때 어떻게 넥스트 노드에 데이터 링크 주소를 얻어오고 그걸 다시 패킷에 집어넣어서 패킷을 보내고 이런 과정이 9장에 상세히 나와있음 
이렇게그림을 너무 잘그렸음
시나리오를 잘 따라가면 거쳐가는 각 장치마다 세세한 기능들을 보여주고있음
이그림은 R1에서 지금 수행하는 기능들이 있고 그다음에는 R2에서 수행되는 기능 그다음에는 BOB에서 수행되는 내 END SYSTEM에서 수행되는 기능
이렇게 쭉 보여주고 있음
굉장히 잘되어있음
자습 하도록한다.

앞으로 다룰 내용을 크게 말하면 10장에서의 에러 
데이터 링크 레이어중에 데이터를 받았는데 이속에 에러가 있는지 없는지 방법
에러를 고치는 방법, 에러 커넥션까지 에러 컨트롤기능이 있고 이뒤에는 아까 얘기한 맥 
맥 기능
맥 기능이 데이터 링크 레이어에서 굉장히 중요한데 맥 기능에대해서 여러 챕터가 있음 
유선, 무선 나눠서 설명할 수있음
크게 보면 2가지를 이번학기 나머지 부분에 카바할 부분이다.

멀티플 엑세스 컨트롤 
미디어 엑세스 컨트롤 다 책마다 이게 어디 멀티플, 이 둘중에 하나로 혼용해서 쓰고 있음
맥 하면 저중에 하나만 쓰는게 아니라 미디어 엑세스 컨트롤 멀티플 엑세스 컨트롤 다 의미가 다 통한다. 지금
미디어 브로드캐스팅 미디어를 어떻게 제어할껀가 
멀티플 엑세스는 여러가지의 여러 명이 멀티플 동시에 접속할려고하는데 어떻게 제어할껀가 다 같은 맥임




