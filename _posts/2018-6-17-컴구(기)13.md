---
post : layout
title : 컴퓨터구조(기)13
---
# Computer Architecture: I/O Systems

## Review : Major Components of a Computer
아이오 시스템 인풋 아웃풋 입출력 시스템에 대한 부분
이거 학기초에 이그림으로 부터 시작함
다시한번 정리하면 크게 프로세스 메모리 그다음에 장치들로 컴퓨터시스템이 구성되는데 
프로세스라고 하면은 데이터 패스 와 그것을 제어하는 프로토콜 유닛으로 구성되어있다 라는거
데이터패스는 우리가 싱글 사이클 데이터 패스 멀티사이클 데이터패스 그다음에 파이플라이닝 
여러가지 형태로 구현되는것을 살펴봤다
메모리 시스템은 현재 우리가 사용하는 컴퓨터 시스템은
여러계층에 메모리 하이러리커를 구성하는 거잔아
피라미드 구조로
뒤에는 용량은 작고 엑세스타임은 굉장히 빠른 아랫쪽 용량은 크고 엑세스 타임은 느린 여러계층으로 구성되어있고
그것은 왜 그렇게 구성해요? 많은 용량을 확보하면서 빠른 엑세스 타임에 이점을 같이 병합할려고 그 
병합하는 방법이 뭐에요 아주 핵심적인 방법이 캐싱이다.
캐싱을 이용하는거까지 살펴봤었고
오늘 입출력 장치를 살펴볼텐데 입출력 장치에 중요한 매트릭, 성능평가 기준

## Input and Output Devices
기본적으로 뭐 퍼포먼스 성능이죠 그쵸
그다음에
사람이 칠때는 몇자 못침

## 아이오 퍼포먼스 측증
밑으로 갈수록 데이트 레잇이 단위시간당 전송시간이 높다 우리가 성능을 측정할때 기본적으로 
대역폭
단위시간당 데이터 전송량
또는 전송량 데이터의 전송량으로 우리가 측정할수있지만 몇바이트 몇비트일때 또는 단위시간당 그 아이오 오퍼레이션 예를들어서 리드면 리드 라이트면 라이트 몇번이나 할수있는가 아이오 오퍼레이션으로 측정하기도함 데이터전송 량으로 하지말고

어떻게보면은 우리가 이렇게 수로를 만들면 단위시간당 물이 얼마나 흘러들어오느냐 이거고 
리스판스타임은 응답시간, 레이턴시라고도 불림
이거는 인풋아웃풋이 완료되는데 걸리는 랩 타임 = 토탈 타임 총 경과시간 그것을 우리가 리스판스 타임이라고 한다.
특히 예를들면 어떤 오퍼레이션이 시작이되면 그 오퍼레이션이 첫번쨰 오퍼레이션이 걸리는데 완료되는 데 걸리는 시간이 중요함 뒤따라서 데이터 올라오면 첫번째 오퍼레이션 도착한뒤에 따라오는데 첫번쨰 오퍼레이션은 레이턴시로 측정을 하고 그다음 오는건 데이터밴드위쓰로 측정한다.

이거는 우리가 

## A Typical I/O System
메모리 장치가 하나는 싱글 버스를 공유하는 경우
이런 경우는 드물다
메모리 장치하고 아이오 장치하고 성질이 다르다 훨씬 속도가 높기떄문에 같은 고속도로 못쓴다.
어떤 장치들이 고도의 도로가 있는데 거기 스포츠카도 다니고 우마차 다닌다고 생각해봐 거기에 어떤 
누구를 배려야대 천천히 달리는 마차 배려 어느 시점에서는 정지 시켜야되고 어느 시점에서 재개 해야하는것을 그속도를 맞춰야하니까
기가헬스로 동작하는거하고 메가헬스로 동작하는게 같이 물려있는데 여기서 맞춰줘야되고 프로토콜 규칙도 마춰줘야댐 얘가 손해임
현대는 분리한다. 고속은 고속끼리 저속 저속끼리
교환할일은 브릿지 다리 같은 역할을 칩을 둬서 걔가 양쪽에서 오고가는 데이터를 교환할수있겍끔한다.
일반적 형태다 컴퓨터의

## 20 페이지에 그림이 나온다
프로세스가 하나있고 여기 칩이 있고2개있고
아래 칩은 저속의 장치들을 컨트롤
위의칩은 고속의 장치들을 제어
여기보면 메모리 그다음에 여기 그래픽카드 agp 엑셀러레이티드 그래픽스 포트 또는 프로세서
굉장히 고속 디스크 레이어 에서는 그다음에 기가빗 이더넷 이런 장치들은 굉장히 데이터 전송량이 높기떄문에 따로 얘들끼리 버스를 컨트롤한다.
그 pc에 일반적인 아키텍쳐
이거를 노스 브릿지 이것을 사우스 브릿지라고 별명을 붙임

## 
중요하다. 이그림은 전체적인 시스템 아키텍쳐를 머릿속에 넣는데 있어서
버스가 중요한 역할을 한다.
캐시 코히얼언스 
이 버스라는건 이 버스에서 뭐가 오고가는지 귀를 대고 있으면 다 볼수있다.
지난번에 그 캐시 커얼런스 프로토콜 스누피 프로토콜이 있었는데
얘가 버스에다가 뭔가를 브로드캐스트 하잔아 방송을 하잔아 캐시컨트롤에게 이주소를 가진 캐쉬는 지우란 말이구나 이렇게 자기 스스로 거기서 오래된값을 소거해버리는 
이게 굉장히 쉽게 장치들이 서로 쉐어하는 미디어 매체다
단점은 뭐지 여기 매달려있는 개수가 제한된다. 무작정 제한
보통 뭐 16게쯤 장치 매달면 이 버스가 이렇게 데이터가 포화되서 그 뒤부터는 성능이 오히려 떨어진다 그런 단점이 있다 버스
구현이 쉬워서 많이 사용한다.
장치에는 컨트롤러가 있고 얘가 지시하는거에 대해서 동작을 하는 패시브 디바이스고 
프로세스부터 명령을 받아서 그 명령을 얘한테 전달하는 역할을 하는 컨트롤러가 있다. 항상 장치는 컨트롤러가 있다.
예를들면 프로세스가 아이오 컨트롤러에서 데이터를 읽어라 명령을 내리면 얘가 얘한테 어느 위치에서 얼마만큼의 데이터를 읽어내라 그래가지고 여기에 로컬 버퍼를 가지고 있다. 이 장치에서 잠시 사용하는 스몰 메모리 갖고 있는
아이오 컨트롤러에서 중요한 특징중 하나다.
이 버퍼에 데이터가 있지만 실제로 프로세스가 엑세스 할려면 그 데이터가 메인메모리로 와야 엑세스 가능
그것을 옮겨주는 역할을 그 역할을 누가하냐 프프로세스가 개입해서 할수있고, 문제는 프로세스가 이 장치가 그 원하는 자기가 요청했던 오퍼레이션을 완료했는지 안했는지 프로세스가 알수있는 방법이 없다 
프로세스는 2가지 방법이 있는데 여기에다가 현재 상태에 해당되는 변수를 둬서 그값을 계속 읽어본다 완료됫니 아직도 아직도 계속 프로세스가 상태를 체크하는방법 => 폴링이라고 한다. 프로세스가 장치의 상태를 체크하는방법

그게 문제점이 뭐야 프로세스는 좀더 유익한 설계된 장치임 프로그램 계산같은거 근데 얘한테 일을 시켜놓고 프로세스가 다른 일을하지못하고 계속 아까 내가 끝났던 일 끝났냐 폴링 체크 룹을 돌면서
프로세스는 낭비된다. 그래서 어떤 메커니즘 도입했냐면 폴링에 대조되는 방법으로 인터럽트 방법을 고안했다.
폴링, 인터럽트 대조되는 메커니즘이다 

프로세서가 나 데이터 읽어줘 그리고 명령ㅇ ㅓ내려 프로세스 개입 안해 자기가 하던일을 계속한다. 그러면
여기서 완료됬을때 장치가 알려줘야 되는 방법이 있는데 어떤 방법으로 주인님 다끝났습니다 그게 인터럽트 신호선을 통해서 알려준다.
익셉션 배울때 그떄 인터럽트 나왔다 전체에서 당신이 아까 요청했던일이 끝났습니다.
인터럽트가 걸리면 핸들러로 간다. 하던일을 멈추고 그 인터럽트 처리 하는 인터럽트서비스루틴 분기해서 인터럽트 를 처리하고 다시 복귀하는 굉장히 중요하다 그 과정 파이플라이닝 중요하다 
그거 인터럽트 신호선이 프로세스로 들어가는거 그렇게 설계되어있다 잘 기억해둬라

## 아이오 시스템 퍼포먼스 예
그래서 아이오 시스템을 설계를 하는데 
아이오 시스템도 프로세스 아키텍쳐 설계하는것처럼
엔지니어들이 고려해야될 요소많음
각장치 밴드위스 레이턴시 또 중요한건 물리적인 재원 뿐만아니라 위의 어플리케이션 특징들 (아이오 많은거 적은거) 특징에 따라서 아이오 설계해야댐
일단 사람이 처음에 하는일 중에 시스템 기본적인 하등웨어 구성 , 어플리케이션 돌렸을때 어느 포인트가 가장 약한가? 위크 포인트라고 , 바틀렉 이라고 함
위에서 이렇게 돌아가면 애때문에 안되 그렇게 하면 약한 포인트가 있어 그 포인트를 찾아내야됨
뭐 어떤 경우는 프로세스가 제일 성능이 떨어져서 프로세스가 약한 포인트가 될수있고
프로세스가 막강한데 메모리 밴드위쓰가 약해서 더이상 그 성능을 발휘못할수도있고
또는 버스에 대역폭, 버스도 용량이 있잔아 초당 몇메가 바이트 
그이상 데이터를 주고싶어도 못주지 그렇지
아이오 컨트롤러 아니면 아까봤던 하드디스크 장치 자체가 문제일수있음
다양하게 위크 포인트들이 있을수있는데 어디가 제일 약한지 찾고
그 위크 포인트를 다시 재구성하는 결함이 있으면 적어도 함에 결함에 맞게 프로그램 조정하든가
아닌 밑에 아이오 장치를 보강하던지 이런 재구성밥ㅂ업 쓰면나온다

## 예제
어떤 프로그램 디스크 아이오 함
어떤식으로 하냐면 
한번 에 64킬로바이트 데이터를 읽고쓰고 토탈로
하는 그런 그 오퍼레이션을 한다 
근데 그 디스크 오퍼레이션 한번할때 사용자가 짠 프로그럄애서 돌아가는 명령어는 20만개다.
20개를 써서 64 킬로바이트 데이터 처리 가정이 프로세스는 약 초당 30억개 명령어 정도 서포트함 유저 오퍼레이션에서 유저가 20만개 인데
우리가 os , 사용자가 이만큼 일을하면 상당부분 밑에 시스템에 요청해서 도와줘야함
os가 도와줘야하는데 디스크 오퍼레이션을 os가 돕는데 사용하는 인스트럭션이 10만개
토탈 명령어수 30만개의 인스트럭션이 한번에 64킬로바이트 디스크 오퍼레이션하는데 소요되고 있다.
메모리 아이오 버스 걔의 트랜스퍼 래잇 = 밴드위쓰 초당 1000메가 바이트 
그다음에 디스크 위에 컨트롤러가 있었지 그걸 아이오 컨트롤러 라고했는데 범용적으로 많이쓰이는 컨트롤러가 스캇시 임 밑에 장치를 순차적으로 복수개 붙일수있는 장점이다.
이 스캇의 컨트롤러는 컨트롤러 자체가 프로세서로 데이터를 직접올릴수있는 그런 능력을 갖고있는데 초당 320 메가 바이트 메모리이고 데이터를 올수있는 컨트롤러가 직접
물리적으로 7개까지의 디스크를 관리할수있는 붙일수있는 그런 특징을 가지고 있다고 가정

맨 밑에있는 디스크 드라이버는 얘도 읽고 쓰는 능력이 제한되어이씅ㅁ
초당 75메가 바이트 정도는 읽을수있는데 이이상은 읽아내지못해 이이상은 읽어내지못해 속도에 대해
그리고 여기 에버리지 시크 플러스 노테이셔널 래이턴스가 600 미리 세크라고 했는데 이건 
우리가 그 하드디스크는 원판이 돌아가면서 암이 움직이는 구조
원판이 돌아가는거와 암이 움직이는건 전기 전자적인 성질 아니고 이거는 기계적인 성질이다.
이거는 우리가 메커니컬 타임이라고한다  시크는 원판에서 자기가 위치로 암을 움직이는 시간이 시크 시간이고 
노테이션타임은 원판이 돌아가는 시간을 말한다 그래ㅐ야 자기가 원하는 포인터로 가서 데이터를 읽는다.

이 시간이 약 6msec로 가정하래 여기서 뭐가 제일 약할것인가 
프로세스가 약하냐 메모리 아이오 버스가 약하냐 아니 스캇 컨트롤러 약하냐 디스크 드라이버 약하냐 
일단 저렇게 오퍼레이션하면 각 프로세스와 메모리 에서 일단 몇개까지 이 아이 오퍼레이션을 서포트할수있는가를 따져볼수있다.
초당 넘버오브 아이오 저와 같은 프로그램이 동작하면
저거를 한 아이오 라고 할때 저렇게 하면 몇개까지 아이오 브레이크 지원 
일단 초당 30억개의  인스트럭션 서포트할수있죠
아까 거기에 3 빌리언이라고했음 그런데 아이오 오퍼레이션 하나당 인스트럭션은 몇개가 소요되냐면 30만개 그렇죠
이거는 유저가 20만개 os가 10만개
그러면 순수하게 인스트럭션의 수로만 따지면 요게 한 아이 오퍼레이션에 소요되는 명령의 개수다
그러면 안 아이오 오퍼레이션당 이만큼 쓴다면 30억개는 몇개의 아이오퍼레이션을 지원할수있는가
이거를 이걸로나눈다 그러면 만개의 아이오퍼레이션을 이 프로세스 성능을 따지면 10000개의 아이오 오퍼레이션 서포트할수있다.
## 
그러면 메모리에 모리 측면에서 메모리 버스 측면에서 보자 
메모리에서 한번 데이터 인스톨 오퍼레이션을 하는데 얼마만큼 데이터가 오고 가려면 64킬로바이트라는게 메모리 버스에서 오고갈거야
그런데 그버스의 대역폭은얼마라고 했어? 천메가 바이트 퍼 세크 그러니까 1초에게는 천메가를 보낼수있는 속도 의 고속도
그런데 한번에 한 오퍼레이션이 64k라면 결국은 1000메가를 64k로 나누면 얘는 초당 15625 아이오 오퍼레이션을 서포트 할수있다.
그러면 누가 바틀렉이야?누가약해 성능이?
프로세스가 약하다 프로세스는 만개밖에못해 일초에
얘는 만오천육백개 가능 일초에
누구한테 맞춰줘야할까 약한놈한테 맞춰준다
만오천개를 올려도 얘가 감당못함
만개에 맞춰서 만개의 아이오 오퍼레이션에 맞춰서 시스템에 아래쪽에 장치라든기 개수라든지 재조정 해줘야 한다.

## Disk I/O System Example
그림으로 따지면 재는 만개의 아이오 오퍼레이션을 할수있는것이고 
쟤는 15266개 
??컨트롤에서 올릴수있는 얘의 능력은 320 메가 바이트 정도 데이터 올릴수있고 그다음에 디스크에서 데이터를 뿜어낼수있는 능력은 초당 75메가 바이트이다. 최대능력이

우리가 이제 프로세스가 바틀렉이라는걸 알았고
디스크 드라이버가 능력이 어느정도 75메가 바이트 퍼 세크로 데이터를 올려낼수있고 대신에 seek  + rotational latency 이 기계적인 시간이 6미리 세크정도 걸리기 떄문에 그러면 64킬로바이트를 읽어내서 올려야 되는데 걔입장에서는 
디스크에서는 시간이 얼마나 걸릴까 시간으로 환산해보면 
디스크 아이오 시간은 seek + rotational + 64킬로바이트를 전송하는데 걸리는 시간 틀랜스퍼 타임
이거 두개는 6미리 세크라고 알려줬져 근데 트랜스 퍼 시간은 얼마야 쟤가 초당 75메가 바이트를 전송할수있는 속도를 가진앤데 걔가 한번에 지금 아이오 오퍼레이션에서 보내야되는 데이터 사이즈는 64킬로바이트 
64킬로바이트 보내는데에는 시간이 얼마나 걸릴까 그러면 64킬로바이트를 이 속도로 나눠주면 된다.
이게 약 0.9 정도 나온다 6.9 세크 
한 디스크가 64 킬로바이트를 위로 데이터를 올려주는데 걸리는 시간이다.

그러면 한 아이오 오페레이션에 디스크가 6.9밀리 세크 정도 걸린다고 했으니까 1초에는 이런 오퍼레이션을 몇개 할수있느냐?
1초 나누기 6.9지 그런데 단위로 천 밀리 세크로 하면 약 146개의 아이오 오퍼레이션을 초당 감다알수있다. 디스크 하나당 
146개 이상을 서포트 할수는 없다 최대
자 그러면 아까 프로세스가 약하다고 했는데
프로세서가 지금 초당 만개의 아이오 오퍼레이션을 지원
그러면 프로세스가 10000개의 아이오 오퍼레이션을 쓸려면 이와같은 146개를 지원하는 디스크를 몇개까지 쭉 병령어 내달아 놓고 지원받을수있는가 약 100000/146 = 69개 
그러니까 디스크를 약 70개 정도 매달아 놓고 걔들로부터 부분적으로 데이터를 읽어내면 프로세스가 원하는 데이터를 충분히 인지함

## 
그러면 디스크에서 데이터를 전송하는 디스크 트랜스 퍼 레이트, 그거는 트랜스 퍼 레잇이라는거는 어 단위시간당 전송양이니까 트랜스 퍼 사이즈/트랜스 퍼 타임 인데 아까 한번 데이터 아이오 오퍼레이션해서 올리는데 걸리는 시간이 6.9 라고 했고 
그떄 데이터를 올리는 양이 64 킬로바이트라고 했으니까 
디스크 하나당 사용하는게 9.56 메가 바이트 

아까 하나당 9.56 쓰고 이런 디스크를 70개 쓴다고 그랬고 
10 잡고 70개 쓴다그러면 70개의 디스크가 토탈 요구하는 밴드위쓰가 700 메가 바이트 퍼 세크 죠 근데 버스가 용량이 얼마야 
1000메가 바이트 퍼 세크죠, 버스가 제공할 수 있는 용량 보다 적죠 디스크에서 70개 가 올라온다고 해도
그래서 이 70개를 밑에다가 매달아놓는건 전혀 문제가 없다
이 70개가 지금 움직이느냐 스캇이 컨트롤러 하나당 아까 몇개씩 매달수있다고 했지? 7개씩 매달수있다고 그랬죠
69개가 그 스캇이 컨트롤러 여러개의 분산되서 나뉘져 들어가야되겠다 스캇이 컨트롤러가 몇개 필요해? 10개 필요하다
9개까지는 7개씩 
맨 마지막 에 있는거만 마지막 에 있는것만 6개가 필요하다 이렇게 해서 10개의 스캇시 컨트롤러가 필요하다.
데이터를 좀 분석할수있는데

핵심, 버스라는 구조인데 

## 
버스 장점
다양한 장치들을 
다양성 
비교적 제작하는 비용이 적다 
단점은 
쉽게 바틀렉이 발생한다
병목이라함
물을 빼낼때 물이 한꺼번에 몰려들어서 잘 안나옴 병목
버스 이 대역폭이 결국은 아이오 최대 아이오 성능을 제약하는 제약 요소가 된다.

또 뭐에 버스는 제약을 받냐 길이 제약
무슨 네트워크 버스라든지 유에스비 라인이라든지 몇미터 이상가면 신호 감쇠가 일어나서 동작 제대로 안함
거기에 붙일수있는 장치에 대한것 버스는
버스는 어떻게 동작하냐면 기본적으로
양쪽 주체가 있고 거기에 버스가 매달려있는데 
어떤 동작을 이니시에잇 하는 뭔가 요청하는놈이 있고 요청에대해서 응답하는놈이있는데 
요청하는놈을 버스 마스터라고한다 요청자
거기에 대해서 반응하는놈을 버스 슬레이브 라고한다

둘사이에는 버스라인이 있는데 신호선은 크게 두가지 신호선이 있다 컨트롤 라인 하나는 데이터라인
데이터라인은 말그대로 데이터가 실리는거임 데이터는 실제 데이터도 데이터지만 어드레스 그다음에 걔한테 전달하는 커멘드 이런것도 데이터라인에 실려서 간다
컨트롤 라인은 뭐하는거냐 내가 저쪽에 뭔가 요청한다 저쪽이 알았다 그다음에 나도 알았다 서로 상대방의 의사를 확인하는ㄷ 필요한 신호들
먼가를 할려면 두개가 같이
커멘드를 데이터 라인에 싣고 리퀘스트 라인을 올리고 그다음에 저쪽에서 알았다라는 에크널러지를 보내고 그다음에 저쪽에서 준비됬으면 데이터라인에다가 데이터를 싣고
그다음에 데이터가 준비됬다는 신호도 알려주고 나는 그걸 받았으면 난 잘받았다 라는 신호를 서로 이렇게 
군대 수기 처럼

## 버스 트랜잭션
마스터가 일으키는 마스터 커맨드와 어드레스를 요청하는걸 넣고 상대방에게 먼가 요청하는 그런 페이스가 있고
그다음에 슬레이브 입장에서는 실린 데이터를 갖고 그다음에 취하고
메모리와 장치 사이에는 아이오 장치 가 먼가 데이터를 요청하고 메모리에서 그 데이터를 제공한다든지 반대로
메모리에서 데이터를 요청하고 아이오장치가 데이터를 공급한다던지 이런방식들이 전형적인 버스의 오퍼레이션

버스는 
프로세스 메모리 버스 (proprietary - 제조사마다 자신들이 제작한 형태) 반대는 스탠다드
자기들이 설계한 시스템
저런것은 무슨 인텔이 만든다 아이비엠이 만든다 자기들만 쓸수있다.
반해서
여기 중간에 있는 아이오 버스느 백플레인 버스는 표준화되어있다. 규격에 맞춰서 제조사가 장치가 여러가지 시스템만들도록 되어있고
프로세스 메모리 버스는 굉장히 빠른 버스다.
익으젬플에서는 단일 버스를 모든 장치들이 공유하는 형태로 예를 보였지만 일반적으로는 빠른 장치 중간정도 속도장치 
아주 느린 장치 뭐이런것들이 서로 구분이되서 동작하도록 설계되있음

굉장히 빠른장치의 프로세스 메모리 버스를 두고 그다음에 일반적으로 아이오 버스
우리가 유에스비 라든지 아까 디스크 전달하는 스캇시 카드 라든지 또는 애플에서 만든 유에스비 에 대응 하는 빠이어 아이오 라든지
이런거는 장치를 컨트롤하는것이고 이것들은 버스의 길이가 길고 상대적으로 동작하는 속도는 느리다.
그대신에 표준화 되어있어서 다양한 장치들을 수용할수있는 장치들이 붙을수있는 그런 형태가 된다.
이 버스가 프로세스 버스라든지 백트레인 버스하고 서로 연결이 되어야 하기때문에 연결되는 포인트에 그 브릿지 역할을 하는
칩셋이 존재한다.
백 플레인이라는건 우리마로 하면 척추이다 등뼈
그러니까 우리가 컴퓨터 내부보면 프로세스 메모리있고 그옆에 굉장 아이들, 프로세스 메모리 버스고 그것을 제외하고
여러 흘러가고 있는 버스가 등뼈 척추에 해당하는 백트레인 버스
아이오 장치쪽으로 슬랏이 있고 만들어진 버스가 아이오 버스다.
이게 백트레인 버스가 그 중간에 역할을 하는 핵심 버스에 해당하고 우리 뭐 
pc에서는 이렇게 아타 셋타미 세타 버스다 이런거 쓰죠 이게 보통 시리얼 바타 페러럴 
세타 페타 
이게 이제 최근에 백트레인 에서 가장 많이 쓰는 주로 그다음 기가 빗 이더넷 이라든지 피시아이 
컴퓨터 시스템에 중앙 핵심부 처리하는 그런 용도로 쓰인다.

## 
버스는 크게 두가지 타입이있다.
하나는 싱크러너스 버스
에이싱크로너스 버스
우리가 
싱크, 어싱크
싱크 : 서로 클락에 따라서 같이 움직이는 버스
그게 싱크로너스 버스
어싱크로너스 버스 : 클락에 따라서 움직이는게 아니라 서로의 의사를 확인하고 움직이는 버스
예를들면 프로세스 메모리 버스, 싱크로너스 버스
이거는 대표적 싱크로너스 버스고 거기에 클락이 있어서 클락이 딱딱 움직이면 클락떳지 5클락 뒤에 반드시 데이터가 올것이다.
그다음에 2클락뒤에 응답하먄딘다 시간에 따라서 규약이 만들어진다.

시간에 맞춰서 
시간에 맞춰 동작하기때문에 부가적인 신호가 최소화 된다.
단점은 뭐냐 이 클락이라는건 굉장히 빠르게 동작, 이게 문제는 내가 여기있고 저쪽에 끝에있는 사람이 내가 동작하는것을 클락 시그널로 인지한다고 했을때 나는 굉장히 천천히 움직이는거라고 하지만 무지하게 빠르게 움직인다고 가정
보는 시점이 절대 시간에 볼때 내가 보는시점과 저 끝에 있는 보는시점이 다르다 이게 굉장히 짧은 거리에서는 문제가 안되지만 원거리에서는 빛의속도가 저쪽으로 걸리는데 시간의 차이가 있다면 저 몇킬로 보는사람의 절대 시점이 절대적으로 시간이 그 시점에 서 타이밍이 다르다 동시에 딱 이렇게 움직이지 못한다 클락 스큐라고 한다.
결국 클락 프리퀀시가 굉장히 높은 하이 프리퀀시 시스템에서는 클락 시큐 때문에 버스 길이 제한 이 된다. 클락 스큐때문에 복잡한 일을 못함
그거를 해결하는 방법이 어싱크로너스 버스
뭔가 신호선을 준다
read ack data 
요청한다 알았다, 준비됬다 가져가라 해가지고 클락이라는 개념이없고 신호선을 띄어주고 저쪽에서 준비가 안되서 더디면 ack가 늦게올뿐임
싱크로너스 딱딱해서 5클락안에 응답이 없으면 페일이야
여기서는 데이터가 왔을거라고 생각하고 그데이터를 가져가니까 
데이터를 주고 받는 핸드쉐이킹 프로토콜 이라고 되어있음 서로 주고 받는 그런 프로토콜이 존재한다 어싱크로너스시스템이 여유가 있다.
이거보면 
## 
지금 아이오 장치가 일단 마스터 역할을 하고
아이오 장치가 메모리 에게 뭔가 데이터를 요청한다
메모리 어디에있는걸 나한테 달라
아이오 장치가 리퀘스트를 요청이야
리퀘스트 뭐를 리드 리퀘스트 하는 신호를 저기에 
이렇게 0에서 1로 내려가지고 상대방에게 리드 요청한다 지금
뭘또 요청해야되 어떤 어드레스를 리드를 요청하는건지 어드레스 라인을 데이터를 실어야 된다.
이렇게 데이터 라인에 어드레스 싣고 리드 리퀘스트를 한다.
그러면 메모리 쪽에서 본다.
저것을 보고 나서 그래 니가 이 어드레스 리드 요청한거 알겠어 에크를 올려줘 에크를 올려줬단 얘기는 니 요청을 알아챘다,=.
조금있다가 메모리에서 준비된 데이터를 어디다 실어야겠죠? 이 데이터라인에다 싣는거야 이 데이터라인은 어드레스를 싣는 용도로도 쓰이고
데이터를 싣는용도로도 쓴다.
그래서 
데이터라인에다가 데이터를 싣고
그전에 그러면은 저쪽에서 이제 ack 했으니까 알았다고 했으니까 여기다가 끝, 리퀘스트 주장할 필요없지 내려도 되지 상대방이 알았으니까
상대방이 내 ack를 받았으니까 나도 ack를 내려야지 그래서 ackㄹ르 내린다 그리고 나서 어떻게 하냐면 메모리에서 데이터를 읽어서 데이터에다가
싣는다. 실으면서 메모리에서 니가 아까 요청한 데이터가 지금 준비됬어 그러고 나서
레디 신호를 올려요 그러면 어떻게 되 이 레드를 상대방 아이오 장치가 보면 어 그래 고마워 니가 올린거 나 보고 있는중이야 
그리고 나서 ack를 올려 그러면 얘가 이제ack 올린거 보고 얘가 이제 내가 올린 데이터를 보는구나 
그러면서 조금 있다가 어떻게 내가 레디 했던것을 내리고 
그다음에 여기에있는 데이터 도 항상 여기끝까지 데이터를 쓸수없잔아 그렇지
여기있는 데이터 도 버스에서 내리고 그러면 상대방이 이 데이터를 내려간것을 알고 ack를 내리고 이런방식으로 
서로 계속해서 요청하고 응답하고 또 반응하고 거기다 응답하고 이런방식으로 동작하는게 이게 무슨 에이싱크로너스 버스
## 

여러분들에게 22페이지 23 ~25 까지 4장의 슬라이드는 봤으면 좋겠ㄷ ㅏ개인적으로
풀링과 인터럽트에 대해서 얘기했다.
그다음에 요 아이오 인스트럭션 , 메모리 맵트 사용하는경우는 이 설명이 부족하면 구글링을 해봐
그래서 이차이를 보고 요 뒤에 그림을 보고 시간이 
화요일 시험 10시