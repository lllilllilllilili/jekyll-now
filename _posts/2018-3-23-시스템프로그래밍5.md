---
post : layout
title : 시스템프로그래밍5
---
## Task states of Linux
.#defince TASK_RUNNING 0//scheduling Queue에 하나가 Running 상태고 나머지가 Ready() 상탠데, running과 ready를 다 포함한다.
.#define __TASK_STOPPED 4 //디버그에서 돌아가는 프로그램을 중지시켜서 확인해보고 싶을때, 브레이크 포인트 라던지..
.#define EXIT_ZOMBIE 16 //프로세스가 더이상 안돌아가면 흔적이 남는데 이거를 시체를 남아있다. 라고 표현한다.

## Blocked state
예제, I/O 요청이 올때 완료될때까지 block 상태이고
IPC 메시지를 기다리고, printer에 경우에는 다른 프로세스가 사용중이면 리소스를 기다려야 한다.
block 상태에서는 CPU를 내놓는데, 쉽게 말하면 CPU가 다른 프로세스로 점핑 한다는 의미이다.(이동하는거니까)
block된 상태에서 I/O가 끝나면 ready 상태로 된다. scheduled 되면 Running 상태고.
프로세스 blocking은 CPU/IO overlap을 가능하게 해준다.

## Process & Kernel Address Space
메모리를 살펴보면, 커널은 하나있고 프로세스 공간이 4가지가 있다.
(어드레스 공간) 리눅스는 프로세스를 여기저기 분배하지만 이론상 붙어있는걸로 생각한다. 
Text : 실질적인 명령어 코드구간이다.(read only) 
Data : global variables
Heap : 동적 메모리 공간을 할당한다.
Stack : local variables, function - call recursive 하게 돌면서 계속 Stack에 쌓인다.
커널도 프로세스와 마찬가지인(프로그램이기 때문에) 공간이 존재하고, 커널 스택은 시스템콜을 직접적으로 접근하는게 아니라 프로세스가 시스템콜하면 커널안에서 커널 스택을 쓰게된다. 커널이 직접 쓰는게 아니다.
## Process Management(1/3)
Process Control Block(PCB) : 프로세스가 생기면 커널이 기록해 놓는것이다. 커널의 입장에서 데이터가 메타데이터다.
(프로세스에 대한 정보를 가지고 있다.)
1. 프로세스의 번호, PROCESS ID
2. 프로세스를 만들때 유저 아이디
3. 프로그램의 정보, Binary program file info
4. 스케쥴링 priority, 커널에 의해서 계속 변한다. CPU를 받는데 있어서 우선순위가 있다. 우선순위를 주는 방식이 스케쥴링이고 
5. 프로세스의 상태(running, blocked, ready, etc)
6. block된 이유, 뭐때문에 block이 됬는지 
7. open file table, pcb안에 process id, user id가 있고 요안에 open file table이 있다. 0,1,2 는 각각 키보드(파일로간주), 콘솔, 같은콘솔이나 오류를 찾아주기 때문에 다른 파일 디스크립터를 쓴다. 3번부터 파일을 open하게 되고, 우리가 일일히 close를 하지 않아도 os가 알아서 해준다.
8. 할당된 자원은 죽으면 회수 목적이 있다.
9. 현재 디렉토리가 어디에 있는지, 리눅스에서는 . 으로 표현한다.
10. 메모리 관리 정보 아까 표현한 4개의 메모리공간 빼고 줘야 하니까 이러한 관리 정보
11. 머신 컨텍스, register를 저장할 공간인데 PC, SP, PSW, general purpose registers 들이 있다.
12. pending signals
커널은 프로세스 관리하기 위해서 메타데이터 로서 pcb를 만들고 관리한다.

## Process Context
프로세스는 돌고 멈추고를 반복한다. 왜냐하면 I/O request가 오거나 time-slice bursts(프로세스마다 클락 타임을 주는거지)
running 상태에서는 time-slice bursts가 걸리면 ready 상태로 가고 I/O 요청되면 block 된다.
Process Context는 메모리에서 프로세스의 저장은 자동으로 되기 때문에 걱정하지 않아도 되지만 레지스터는 cpu가 프로세스를 떠날때 반드시 저장해야 한다. 그래야 재 시작할때 복원되기 때문이다.

## Process Context
user - level context(auto - saved in memory)
text, data, heap, stack

but, 
system-level context(must be saved)
General purpose registers => 산술 연산하는데 사용된다.
pc(점프가능), sp, psw(cpu의 상태를 알려주고), 이 영역은 반드시 세이브 해야한다.

## Context Switch
time slice burst가 되면 cpu를 다른 프로세스에게 넘겨줄텐데, 이때 레지스터의 값은 저장해두고 이전의 진행했던 프로세스로 넘어가겠지 근데 그때 이동한 프로세스에서 중단됬던 레지스터의 값을 load 하고 store해야 이동이 가능하기 때문에 이 과정을 거치고 이동하면 기존에 저장된 값이 있고 Load와 store한 상태는 이전의 context 이므로 마치 context 내용이 바꼈다해서 이거를 context switch 라고 하며 A 프로세스에서 다른 프로세스로 이동할 수 있도록 하는 역할을 한다.

## Context Switch(2)
프로세스는 running 상태에서 time slice가 다되거나 (ready) i/o 작업이 들어오면 block 이 될텐데 이때 cpu는 내놓은 상태가 되니까 이 레지스터에서 작업중이던 값은 저장을 해야되!
이전에 작업했던 프로세스에 값은 restore 하고 이전의 저장한 context 값을 저장한다. 반대로 올때는 내 값은 저장하고 이전의 레지스터의 값을 restore해서 옮겨온다.
레지스터 값이 바뀌는 일이고, context가 서로 변경된다.
그래서 레지스터 pc는 값이 바뀌면 점프로 설명된다.

Context Switch는 커널 속에 있는거고, 실행이 되면 프로세스가 커널 속으로 들어와서 커널 모드로 실행되는것이다. 중단되는지점도 커널 속에서, 살아날 때도 커널에서 살아난다.

## Context Switching(3)
프로세스가 이전에 작업으로 돌아갈때, 현재있는 레지스터 값은 저장을 하고 jump를 해서 이전에 작업했던 내용을 re-running 하고 restore cpu register로 올리고 돌아올땐 이전에 작업했던 내용으로 돌아오게 된다. 커널이 한 프로세스에서 다른 프로세스로 컨트롤을 넘기는 행위다. cpu의 입장에서는 바뀐다. 
(이순신 -> 홍길동)
(홍길동 -> 이순신)

## Context Switch(4)
컨텍스트 스위치는 항상 커널에서 발생합니다 (syscalls에서) !!
중지된 상태의 프로세스는 시작도 중지된 시점에서 살아난다.
따라서 프로세스는 항상 커널에서 중지되고 커널에서 재개됩니다!

## Scheduling queue
프로세스가 ready 상태에 모여 있는게 scheduling queue 인데 여기서는 프로세스라기 보단, pcb로 linked list로 묶인것이다.
current는 현재 돌고있는 프로세스를 가리키는 포인터가 되고, 아래부터 윗번까지 priority가 나눠져 있다. 리눅스에서는 cpu마다 큐를 갖는다. 이건 이제 running 상태에서 time slice 다 되서 ready 상태로 보여지는거라면,(Scheduling queue에는 running 상태와 ready상태가 있다.) block 상태에서는 cpu가 내놓아 지므로 이 queue에 있으면 안된다.

## Sleep queue
block이 되면 인터럽트 올때까지(block이 끝날때까지) 기다리는데 이걸 이벤트별로 처리를 해준다. 예를 들어서 디스크 I/O, 키보드 I/O 이런식으로 이벤트별로 Sleep queue가 따로 위치한다.

## Entry to Kernel
커널안으로 들어갈 때는 다음의 3가지 경우가 있다.

1. System call
프로세스가 시스템 콜을 불렀을 때, trap(유저모드->커널모드로 바뀌는것이고)

2. H/W interrupts(interrupt handler)
인터럽트가 발생했을 때, 프로세스 running은 일시적으로 중단되며 그리고 control은 인터럽트 핸들러(디바이스 드라이버)로 이동하게 된다. 인터럽트 핸들러가 커널안에 있으므로 커널 진입이 되는것이고
인터럽트를 다하면 return from interrupt를 하면서 유저모드로 변경된다.
보통 인터럽트가 발생한것은 현재 실행중인 프로세스에서 발생한것이 아니다. => I/O를 생각해보면 디바이스에서 I/O처리시 인터럽트를 발생할때 그 과정에서는 CPU를 사용하지 않는 block다.(중단된상태) 따라서, 이러한 인터럽트는 현재 돌고 있는 프로세스와 맞지 않다. 이러한 인터럽트가 발생했을 때 현재 돌고 있는 프로세스가 억울하게 짤릴 수 있다.

3. Fault or exception(fault handler)
위에서 현재 돌고 있는 프로세스는 인터럽트가 들어오면 현재 돌고 있는 프로세스가 발생시킨 인터럽트가 아니지만, Fault 는 스스로 발생시킨 인터럽트다. 예를들어서, 0으로 나눈다던가, segment fault(포인터로 주소에 다른 프로세스에 뭔가 침범, 잘못된 접근을 했을시)->fault handler가 처맇나다.
핸들링 기술적 원리는 인터럽트 핸들링과 같다.
fault handler에서 프로세스를 죽이지 않고, 자살명령을 내린다.

## Page/Buffer cache(S/W cache)
CPU의 속도는 빠르고, I/O 디바이스 는 속도가  느리고(디스크도 디바이스니까..) 커널은 현재의 경우 디스크 I/O를 줄이기 위해 굉장히 노력한다.

OS는 디스크 I/O 소트트웨어적인 캐싱이고, 메모리에 캐시를 둬서 하드웨어 캐싱

블럭은 physical 블럭이라고 한다.
디스크에서 1Kbyte씩 읽어오는 프로그램이 있다면 굉장히 못짠거다. 4Kbyte를 한번에 읽고, 요청할때마다 1Kbyte를 주면된다.
(dma I/O-disk에서 4Kbyte를 한번에 읽어오는것)

워드 프로그램이 있다면 이것을 종료했을때 메모리 버퍼에서 사라지는게 아니라, 최신 업데이트로 저장이되고 (메모리에 용량이 허용되는한)기록된다. 이렇게 업데이트된 블락을 delayed write or dirty 라고 한다.(이블락은 디스크로 쓰여지지않고, 디스크 I/O를 줄이기 위해서 OS에 관장해서 규칙으로 어느 정도가 차면 디스크로 쓴다.)

메모리에 page(4Kbyte) cache 라고하고, 프로그램이 실행될때 디스크에서 먼저 찾아보는게아니라 page cache를 첫번째로 찾아보고 있으면 쓰게 된다. 프로세스가 없어져도 메모리에 허용하는한 남겨준다. 자주사용하는거, 앞으로 사용될거, 메모리에 올라와 버리지 않음 올라와 있다.

이러한 방법이 위험한 까닭은 메모리는 정전될시 날라갈 수 있다. 따라서 sync를 통해서 디스크에 write를 할 수 있다.
ex)usb도 장치꺼내기를 통해서 usb까지 간게 아니라 페이지 캐시에 기록이 저장할 수 있게끔 도와 준다고 볼 수 있다.

## System calls, Interrupt, Context Switch
이제 할것은 수도코드로 위에서 언급했던 다양한 개념들이 구현되고 있는 실행동작을 파악한다.
하나의 유저 프로세서가 있다고 하고, 캐릭터 버퍼를 정의하고, open을 할껀데 번호에따라서 0 read 1 write 2 둘다되고 여기서는 2번 모드, read/write 모드이다.

파일 디스크립트 0(키보드),1(콘솔),2(콘솔, 오류채크) 이미 있으니까 3번 리턴되서 파일이 3번 되는거고,

유저모드 러닝, read시 시스템콜(진짜는 라이브러리)인데 사실은
라이브러리가서 진짜 시스템콜 하는거니까로 생각하면 된다.

open 3번 파일, 버퍼에다, 100바이트를 읽어줘라고 커널한테 시키고 시스템콜작동시 커널안으로 들어가서 trap되면서 커널모드가 적용된다. 돌아갈땐 I/O 끝나있음

read 자체가 블락, 실제로 블락되는건 커널 속이다.

## System calls, Interrupt, Context Switch(2)
시스템 콜에 해당하는것은 커널속으로 들어가서 해당되는 read를 읽어오는것.(커널용), 이 페이지에는 fd, buf, count 했지만 사실은 argument - 레지스터로 받는다.

버퍼에다 100byte를 읽어주는 작업이 있다. 이건 커널모드 일것이고 파일을 open 하게 되면 stream으로 되어있다고 볼 수  있으나 실제로 4Kbyte 단위로 쪼개서 흩어져 있다. 속도 면에서 붙어있는게 access가 전자가 더 빠르다.

view를 하면 logical value를 1byte open하면 read/write offset을 0으로 준다. 0이 의미하는것은 파일의 제일 앞이고, 100byte를 read하는것은 read/write offset의 100번째 이다.

만약에 같은 파일을 2번 open하면 각각 3번, 4번으로 offset이 따로 access가 될 것이다. read/write offset이 따로 생겼다.

##### logical disk block addr

읽고자하는 파일의 block의 실제주소는 파일의 이름, 파일 read/write offset 번지가 주소가 된다. 이것을 logical disk block address이다.

결과적으로 이것은 파일의 번호와 read/write offset을 말한다.
몇번째 읽을것인지????

##### physical disk
흩어져 있다.  OS가 disk에서 가져 오고, disk 는 이block이 몇번째 트렉/섹터로 번역해야한다. 즉, 가상 주소 -> 실제 주소로  ex) hufs.ac.kr(심볼릭 네임)->ip 주소 처럼

파일의 이름과 시작점 에서 어디까지 read해서 와있는가 하는 read/write offset으로 커널이 이거를 디스크에서 읽어올려하면 트랙/섹터 넘버 알아야함, Track이 밖에서 안으로 들어가면서 일련번호를 붙이면 physical block number 몇번째블락, 이거를 번역해서 디스크에서 읽어올 수 가 있다.

디스크가 읽어올 수 있는 것은 physical 블락, 섹터 이용해서
ex) 트랙이100번인데 한 트랙에 50섹터 10번째 섹터다. 50*100+50

block범위 캐치하면 pysical block addr 가지고 캐시를 한후에 페이지 캐시에서 찾고 찾는것은 헤싱을 활용 한다.

페이지 캐시 찾고(소프트캐시으로) 페이지 캐시 발견하면, 페이지 캐시데이터를 커널 속에서 실행되며 유저가 버퍼(유저 버퍼를 말하는거겟고) 에 달라고했으니까 카피한다. 이것을 ++copy_to_user() 라고 한다.++
커널 스페이스에서 유저스페이스로 카피한다.

만약에, physical disk block이 100바이트 중간에 걸치게되면 자른다음 나눠서 처리해서하지만, 개념적으론 하나안에 있다 로 처리한다.

디스크 I/O 안하고 완수하게 즉 block이 없게 커널 모드 -> 유저모드 돌아오고,
커널모드로 (밑으로) 내려오면 페이지 캐시에서 이 블락을 못찾았단 말이 되고 디스크 I/O 시작 굉장히 불행함.

## System calls, Interrupt, Context Switch(3)
disk I/O를 하는데 그 위치가 어느 트랙 어느 섹터 정보도 하고있어야하고 DMA I/O를 시작할것이고 그것이 메모리 몇번지인지 4Kbyte 읽어오라고 명령할것이고
### 불행히, 
disk가 다른 I/O로 바쁘다. 따라서 Queue에 위치하고 다른 I/O 를 완성못했을 수 있으니까 이것을 ++a disk I/O request block ++만들어서 저장한다. 대기해서 다음것을 해달라는 정보 만드는것이다.

a disk I/O request block에는 디스크를 어디서 읽을거고, 페이지 캐시에서는 DMA 읽어야 하니까 페이지 캐시 어느 자리로 읽을건지 , 메모리주소, 디스크 주소, 크기가 4Kbyte, 8Kbyte인지 
디스크에다 읽는건지 쓰는것인지 알려준다.
==PCB 들어가는 이유는== 디스크I/O를하는데 PCB 속 정보, 프로세스가 이 디스크 I/O 시킨것에 대해서 끝나면 그 프로세스 깨워줘야 하기때문에 넣는다. (블락에서) 이런걸 묶어서 a disk I/O request block라고 만든다. 
이걸 (디스크 I/O에도 디스크) I/O queue에다 붙임(cpu의 스케쥴링표처럼).

case 1. 디스크 I/O queue를 보여주고, a disk I/O request block 붙이고 First entry라면 첫번째를 의미하고 이것은 디스크가 한가하다를 말하는것이다. 즉, ++디스크 가 하는일없음++을 보여주고 디스크 컨트롤러에게 어느 트랙 섹터 읽어서 메모리 어디로 읽어드리라는 명령을 디스크 컨트롤러에게 하면서 일을 시작한다.(디바이스 드라이버가 명령을 내리는것이겠다.)

##### (핵심)큐를 했는데, 큐에 first entry면, 놀고있었다(disk i/o가), 디스크 컨트롤러에게 i/o 커멘드 보내서 실행시킨다.


case2. 이거는 시작할 수 없다. 다른 i/o를 디스크가 처리하고 있다. 큐에 맨뒤에 붙여야 한다. (디스크 컨트롤에게 i/o 명령을 하라고 사전에 실행중인 상태인거같다.)

**(중요)커널입장에서는 똑같음, 시작했거나 안했거나, 시간이 오래걸린다. 디스크i/o 시작했더라도 cpu가 굉장히 빠르기 때문에 디스크 i/o 작업은 시간이 많이 걸려린다. 결론적으로 위 케이스 두개다 i/o기 때문에 마찬가지다.
그래서, 시작을 했건 case2의 queue에 들어가선 못했건간에 시간이 오래걸리기 때문에 이제는 cpu를 내놓고 블락상태로 간다.**

##### 주석을 해석해보자!
//기다릴시간이다.
//디스크i/o 끝날떄까지 기다려야한다.
//시작됫거나 시작되지 못했거나 (큐에 끝에가서)
//두 케이스다 블락되야 한다.

디스크i/o 끝날때까지 커널속 프로세스는 블락되기시작, 그거를 줄여서 리눅스 sleep 이라한다 wait이라한다.

wait 기다리면서 블락되겟다. 

## System calls, Interrupt, Context Switch(4)
wait(event=disk I/O completion) //이벤트는 디스크 i/o가 끝나는것을 기다린다, 
my PCB.state=blocked//커널속에 my 시스템콜안으로(current) 내 pcb속에 이 프로세스 상태가 cpu를 내놓은 block상태라고 표기만한 실제로는 아닌 그런표기이다.
//cpu를 내놓았으니까 넘겨줄 프로세스를 골라야하는데 스케쥴링큐에있기 때문에 넘겨줄때는 스케쥴링큐에서 pcb를 제거하고(cpu를 줬으니까) 내 pcb를 sleep 큐에넣는다.
that PCB.state=running//스케쥴링 큐에서는 프로세스 하나 뽑은것을 그중에서 그나마 priority가 높은것을 뽑아야하고 내 pcb에 해당하는 프로세스에게 cpu를 넘겨준다. ++그 pcb 상태를 ready에서 running으로 변경++
###### that PCB = 저장한 에전 프로세스값, my PCB = 현재저장한 프로세스값, (thatpcb는 새로운 생긴 프로세스가 옛날에 중단될적에 레지스터 세이브해놓은것)
do context_switch(myPCB, thatPCB)//CPU를 내놓은 상태에서내가 block 아직안되고 아직도 돌고있는 중이다. 실제로 내가 stop되고 다른프로세스로 넘어간다는건(I/O나 이런게 와서..) context switch해야한다. argument가 my pcb, thatpcb 로오고  현재 레지스터 내용을 my pcb에다 저장하고 그것을 교환을 한뒤에 ++교환에는 프로그램 카운터 포함++해서 이 context_switch call하면 그 레지스터 교환후에(my pcb와 that pcb를 교환인듯?) 다른 프로세스 중단됬적 자리에서 점프해서 커널속 context_switch가 등장하는 자리 즉, 다른 프로세스로 넘어가게된다.
다른 프로세스로 점프가 일어나면 나중에 다시 돌기시작하는 시점이 디스크 i/o가 모두 끝났을때 다시 돌기시작할것이고 살아나는 포인트지점은 context_switch다.(커널안) 

context_switch는 마치, function을 수행한후에 돌아오는 것처럼 보이기는 function call처럼 보일 수 있으나 점프해서 다른 프로세스 돌고 그러다가 디스크 i/o 끝나서 context_switch로 다시 오면서 이전에 프로세스가 다시 실행이된다.
원리적으로, 뭐에 의해서 다시 오게 되냐면, 갈때도 contxt_switch 올때도 context_switch로 context_switch한테 that pcb상태에서 context_switch에 의해서 간것은 다시 돌아올때도 context_switch에의해서 돌아와야만 하고 그 시점에서 살아난다.(살아나는건 myPCB 인거같다.)

context_switch는 다른 프로세스로 갔다면 이미 내 프로세스는 cpu를 내놓고 블락상태가 된다. 프로세스는 stop되고 커널속에서 블락되었다가(i/o가 끝날때까지) 살아나는곳도 이커널안에서 살아난다(커널모드).
살아났을땐 프로세스의 상태가 ++running++이다, ready는 돌아가지않는 중단된상태다. 하지만 이미 돌아가는중이고, 이 의미는 block 상태에서 ready를 거쳐서 running되어 돌아온것이다.
##### 누가 그런짓을 도와주지???
디스크 인터럽트를 한다.(디스크 인터럽트 핸들러를 실행) 언젠가는 디스크 i/o 끝나고, 다른 프로세스의 context_switch로 인해서 이전에 중단되었던 프로세스로 살아나게된다. 페이지 캐시에, 내가 원하는 데이터 있으면 페이지 캐시의 메모리에 데이터를 유저 버퍼로 카피하고 이때 커널에서 유저모드로 돌아가면서 시스템콜이 종료된다.

###### 궁금해! queue에다 붙이는 i/o시작하고 block되서 다른프로세스로 갔는데(cpu가) i/oo끝나고 context_switch거쳐서 중단된 프로세스가 깨어났을땐 ready거쳐서  running상태가 되었어! 그럼 이 과정은 어떻게 이루어질까?

디스크 인터럽트 핸들러가 해결사 역할, 시스템콜은 전반부와 뒤에서 숨에서 일을 하는 인터럽트핸들러가 시스템콜과 협력적으로 일하고있으면서 수행하는 방식이다.

## Disk Interrupt Handling
I/O 끝나면 디스크 인터럽트가 발생하고 디스크 인터럽트 핸들러의 2가지 주요작업은 다음과 같다.
우선 인터럽트가 들어오면 실행하고 있던 프로세스가 짤리고, 디스크인터럽트핸들러로 들어간다. 인터럽트 핸들러 들어갔으면 이게 의미가 I/O 끝났다.
그림을 보면 맨 앞에 I/O가 끝났다 이고, 이거를 짤라내서 이 디스크 I/O를 요구했던 PCB주소가 있는데, 디스크I/O를 요구했던 어떤 프로세스가 Block되었는지, Sleep queue에 있는지 알 수 있는데, 이것을 Ready상태로 만들어서, block상태에서 ready상태로 만들어서 스케쥴링 큐로 복귀시킨다.(cpu를 기다리고 있는 ready상태져..) 이것을 block될땐 wait 이거는 스케쥴링 큐로 복귀시킬땐 wake up이라고한다. 
###### 디스크 I/O정보를 담는게 PCB라고 생각하면 이 PCB에 프로세스상태가 변경된것도 알 수 있다. 이게 block인지, 스케쥴링큐에있는지, 슬립 큐에있는지 등등..

wake up은 block된것을 돌린다가 아니라, block되있는것을 ready로 만들어서 스케쥴링 queue에 의해서 돌아갈것이다. 
block의 반대말이다.

그래서 block된상태를 ready로 만드는데 이 I/O를 요구한것은 wake up시켜서 sleep queue에서 빼서 스케쥴링 큐에 집어넣는데, 스켈쥴링 큐에 집어넣을려면 priority queue 존재, 새로운 priority를 할당한다. 스케쥴링큐로 복귀, 이거 하나가 없어졌으니까, 다음껄 수행하는데 다음 I/O에 대한 정보를 리퀘스트 큐에서 부터 가져다가 디스크 controller에게 명령을 내린다. 
그뒤에 인터럽트오고, block이 될꺼고, sleep queue에서 scheduling queue로 갈꺼고(pcb 하나 제거되고 하나 추가되고)  ready상태로 가서 scheduling queue에 박힌다, 언젠간 스케쥴러가 돌아가서 context_switch 받으면 원래 이전에 중단됬던곳으로 깨어난다. ++디스크 controller의 책임은 ready 까지 해주고,++ ready에서 running되기까지는 priority 고려해서 스케쥴러가 꺠워주는거다.

이 디스크 I/O 인터럽팅 수행 하는것은 시스템콜이고, 디스크인터럽트 핸들러는 꼭 있어야 하는관계다. 시스템콜이 프런트엔드, 인터럽트핸들러는 백엔드 숨어서하니까, 디스크 인터럽트 핸들러를 자세하게 하면 

## Disk Interrupt Handler
인터럽트 디스에이블 모드(인터럽트핸들링중에 다른 인터럽트가 드렁올 수 없음)
Interrupt mask set, 인터럽트가 들어올 당시에는 프로세스 B가 돌고 있다면 저장하고 partially interrupt enable 하면, 인터럽트에서 piority가 더 높은걸 허용한다.
Deque도 첫번째 I/O 블럭에서 디큐한다, 거기에 해당하는 프로세스를 웨이크업(block에서 reday로), sleep queue에서 제거하고(pcb를제거하고) 레디상태로만드는것은(the PCB.state=ready;) 그걸 스케쥴링큐에(pcb를 넣고) 복귀시킨다. 
다음 I/O block이(프로세스 상태가 아닌거같아..) 존재하면 디스크컨트롤러에게 명령을 하고 디스크 돌게끔하고, 인터럽트 다 처리했으니까 다시 프로세스 B로 돌아가거나 스케쥴러로 돌아간다. 
스케쥴러에서 다시 프로세서 B로 돌아갈 수 있고 더 높은 priorty가 있으면 그 위치로 갈 수가 있다.

## Sector
컴퓨터 디스크 기억 장치에서 섹터(sector)는 자기 디스크나 광 디스크의 트랙의 일부이다. 각 섹터는 고정된 양의, 사용자 접근이 가능한 데이터를 저장하고 있으며, 전통적으로 하드 디스크 드라이브(HDD)의 경우 512 바이트, CD-ROM과 DVD-ROM의 경우 2048 바이트이다. 신형 HDD는 4096 바이트 섹터를 사용하며, 이는 어드밴스트 포맷(AF)이라고 한다.

섹터는 하드 드라이브의 최소 기억 단위이다. 대부분의 디스크 파티셔닝 계획은 파일의 실제 크기에 관계 없이 파일이 여러 섹터를 차지할 수 있도록 설계되어 있다. 온전한 하나의 섹터를 모두 채우지 못하는 파일들은 0으로 채워진 나머지 섹터 부분을 보유하고 있다. 실질적으로, 운영 체제는 보통 데이터 블록 상에서 동작하며, 이 블록은 여러 개의 섹터를 선회한다[1]

## Track
track ; 트랙. 트랙은 디스크 상에 데이터가 기록될 수 있는 고리 모양의 영역이다. [2]

## Reference
[1] : https://ko.wikipedia.org/wiki/%EB%94%94%EC%8A%A4%ED%81%AC_%EC%84%B9%ED%84%B0
[2] : http://www.terms.co.kr/track.htm





