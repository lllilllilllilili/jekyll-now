---
post : layout
title : 시스템프로그래밍5
---
## Task states of Linux
.#defince TASK_RUNNING 0//scheduling Queue에 하나가 Running 상태고 나머지가 Ready() 상탠데, running과 ready를 다 포함한다.
.#define __TASK_STOPPED 4 //디버그에서 돌아가는 프로그램을 중지시켜서 확인해보고 싶을때, 브레이크 포인트 라던지..
.#define EXIT_ZOMBIE 16 //프로세스가 더이상 안돌아가면 흔적이 남는데 이거를 시체를 남아있다. 라고 표현한다.

## Blocked state
예제, I/O 요청이 올때 완료될때까지 block 상태이고
IPC 메시지를 기다리고, printer에 경우에는 다른 프로세스가 사용중이면 리소스를 기다려야 한다.
block 상태에서는 CPU를 내놓는데, 쉽게 말하면 CPU가 다른 프로세스로 점핑 한다는 의미이다.(이동하는거니까)
block된 상태에서 I/O가 끝나면 ready 상태로 된다. scheduled 되면 Running 상태고.
프로세스 blocking은 CPU/IO overlap을 가능하게 해준다.

## Process & Kernel Address Space
메모리를 살펴보면, 커널은 하나있고 프로세스 공간이 4가지가 있다.
(어드레스 공간) 리눅스는 프로세스를 여기저기 분배하지만 이론상 붙어있는걸로 생각한다. 
Text : 실질적인 명령어 코드구간이다.(read only) 
Data : global variables
Heap : 동적 메모리 공간을 할당한다.
Stack : local variables, function - call recursive 하게 돌면서 계속 Stack에 쌓인다.
커널도 프로세스와 마찬가지인(프로그램이기 때문에) 공간이 존재하고, 커널 스택은 시스템콜을 직접적으로 접근하는게 아니라 프로세스가 시스템콜하면 커널안에서 커널 스택을 쓰게된다. 커널이 직접 쓰는게 아니다.
## Process Management(1/3)
Process Control Block(PCB) : 프로세스가 생기면 커널이 기록해 놓는것이다. 커널의 입장에서 데이터가 메타데이터다.
(프로세스에 대한 정보를 가지고 있다.)
1. 프로세스의 번호, PROCESS ID
2. 프로세스를 만들때 유저 아이디
3. 프로그램의 정보, Binary program file info
4. 스케쥴링 priority, 커널에 의해서 계속 변한다. CPU를 받는데 있어서 우선순위가 있다. 우선순위를 주는 방식이 스케쥴링이고 
5. 프로세스의 상태(running, blocked, ready, etc)
6. block된 이유, 뭐때문에 block이 됬는지 
7. open file table, pcb안에 process id, user id가 있고 요안에 open file table이 있다. 0,1,2 는 각각 키보드(파일로간주), 콘솔, 같은콘솔이나 오류를 찾아주기 때문에 다른 파일 디스크립터를 쓴다. 3번부터 파일을 open하게 되고, 우리가 일일히 close를 하지 않아도 os가 알아서 해준다.
8. 할당된 자원은 죽으면 회수 목적이 있다.
9. 현재 디렉토리가 어디에 있는지, 리눅스에서는 . 으로 표현한다.
10. 메모리 관리 정보 아까 표현한 4개의 메모리공간 빼고 줘야 하니까 이러한 관리 정보
11. 머신 컨텍스, register를 저장할 공간인데 PC, SP, PSW, general purpose registers 들이 있다.
12. pending signals
커널은 프로세스 관리하기 위해서 메타데이터 로서 pcb를 만들고 관리한다.

## Process Context
프로세스는 돌고 멈추고를 반복한다. 왜냐하면 I/O request가 오거나 time-slice bursts(프로세스마다 클락 타임을 주는거지)
running 상태에서는 time-slice bursts가 걸리면 ready 상태로 가고 I/O 요청되면 block 된다.
Process Context는 메모리에서 프로세스의 저장은 자동으로 되기 때문에 걱정하지 않아도 되지만 레지스터는 cpu가 프로세스를 떠날때 반드시 저장해야 한다. 그래야 재 시작할때 복원되기 때문이다.

## Process Context
user - level context(auto - saved in memory)
text, data, heap, stack

but, 
system-level context(must be saved)
General purpose registers => 산술 연산하는데 사용된다.
pc(점프가능), sp, psw(cpu의 상태를 알려주고), 이 영역은 반드시 세이브 해야한다.

## Context Switch
time slice burst가 되면 cpu를 다른 프로세스에게 넘겨줄텐데, 이때 레지스터의 값은 저장해두고 이전의 진행했던 프로세스로 넘어가겠지 근데 그때 이동한 프로세스에서 중단됬던 레지스터의 값을 load 하고 store해야 이동이 가능하기 때문에 이 과정을 거치고 이동하면 기존에 저장된 값이 있고 Load와 store한 상태는 이전의 context 이므로 마치 context 내용이 바꼈다해서 이거를 context switch 라고 하며 A 프로세스에서 다른 프로세스로 이동할 수 있도록 하는 역할을 한다.

## Context Switch(2)
프로세스는 running 상태에서 time slice가 다되거나 (ready) i/o 작업이 들어오면 block 이 될텐데 이때 cpu는 내놓은 상태가 되니까 이 레지스터에서 작업중이던 값은 저장을 해야되!
이전에 작업했던 프로세스에 값은 restore 하고 이전의 저장한 context 값을 저장한다. 반대로 올때는 내 값은 저장하고 이전의 레지스터의 값을 restore해서 옮겨온다.
레지스터 값이 바뀌는 일이고, context가 서로 변경된다.
그래서 레지스터 pc는 값이 바뀌면 점프로 설명된다.

Context Switch는 커널 속에 있는거고, 실행이 되면 프로세스가 커널 속으로 들어와서 커널 모드로 실행되는것이다. 중단되는지점도 커널 속에서, 살아날 때도 커널에서 살아난다.

## Context Switching(3)
프로세스가 이전에 작업으로 돌아갈때, 현재있는 레지스터 값은 저장을 하고 jump를 해서 이전에 작업했던 내용을 re-running 하고 restore cpu register로 올리고 돌아올땐 이전에 작업했던 내용으로 돌아오게 된다. 커널이 한 프로세스에서 다른 프로세스로 컨트롤을 넘기는 행위다. cpu의 입장에서는 바뀐다. 
(이순신 -> 홍길동)
(홍길동 -> 이순신)

## Context Switch(4)
컨텍스트 스위치는 항상 커널에서 발생합니다 (syscalls에서) !!
중지된 상태의 프로세스는 시작도 중지된 시점에서 살아난다.
따라서 프로세스는 항상 커널에서 중지되고 커널에서 재개됩니다!

## Scheduling queue
프로세스가 ready 상태에 모여 있는게 scheduling queue 인데 여기서는 프로세스라기 보단, pcb로 linked list로 묶인것이다.
current는 현재 돌고있는 프로세스를 가리키는 포인터가 되고, 아래부터 윗번까지 priority가 나눠져 있다. 리눅스에서는 cpu마다 큐를 갖는다. 이건 이제 running 상태에서 time slice 다 되서 ready 상태로 보여지는거라면,(Scheduling queue에는 running 상태와 ready상태가 있다.) block 상태에서는 cpu가 내놓아 지므로 이 queue에 있으면 안된다.

## Sleep queue
block이 되면 인터럽트 올때까지(block이 끝날때까지) 기다리는데 이걸 이벤트별로 처리를 해준다. 예를 들어서 디스크 I/O, 키보드 I/O 이런식으로 이벤트별로 Sleep queue가 따로 위치한다.
