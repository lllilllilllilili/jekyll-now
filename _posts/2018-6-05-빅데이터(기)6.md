---
post: layout
title : 빅데이터(기)6
---
## Is the cloud good for everything? 
클라우드 컴퓨팅 얘기를 잠깐 했는데 다좋으냐?
만병통치약 같은데 세상에 그런게 어딧냐
클라우드 컴퓨팅이 모든 앱플리케이션에 맞지는 않다.
그런것은 아님 예를들어서 어떤 그 
그떄 말씀드렸다싶이 odc  경우
센세티브한 개인정보 담고 있는 그 병원이라든지 법원이라든지 그런 쪽 기구 같은 경우는 메디컬도 마찬가지고
국가의 감사가 나온다. 그런거 관련해서 이제 그런 쪽 앱플리케이션 은 귀찮은 면이 있다. 그리고 어쨋거나 클라우드 컴퓨팅의 좋은점 나쁜 점 살펴보면
프론트엔트비용이 적게 들어간다. 그래서 여러분들이 회사를 차려가지고 뭔가 웹호스팅도 하고 뭔가 하고 뭔가 하다보면 처음부터 그 비싼 서버 다 살필요없습니다. 그러다보니까 프론트엔드 비용이 줄다보니까 쓴만큼 만 내니까 당연히 그렇다.
그리고 관리를 내가 잘못해도 상관없다. 관리 잘못하면 너네 책임이야 그리고 
그렇기 떄문에 실제 클라우드 컴퓨팅 모델은 걔네들이 관리를 잘한다 통상적으로 
물론 그럼에도 불구하고 다운타임이 일어나곤한다. 
manageability 한다 당연히 그리고 어 strategic edge라고 써있는데 이게 뭐냐면 자 내가 만약에 일어나는 비즈니스 할때 지금 여러분들이 만약에 뭔가를 차린다. 여러분들이 엔지니어 니까 잘알겠지만 이런 뭐 컴퓨터에 컴자도 모르는 사람들도 클라우드 컴퓨팅 같은경우는 여러사람들한테 얘기해서 본인들은 그 비즈니스 자체 에 충실하면된다. 그런 기술이나 밑단에서 어떻게 돌아가고 테크닉이 뭐고 그런 엔지니어링 적인 요소를 알필요가 없다.
그렇죠 그 런걸 말하는것이다.
그런것을 신경쓸필요가없다.

단점 
다운타임이 나오는데, 기계기 떄문에 실제로 다운 되기 한다. 그랬을때 생기는 문제들 내가 잘못한게 아닌데 내 서비스가 침해를 받는다. 그로인해 efficiency 는 그만큼 속된말로 돈을 잃고 돈을 못버는것이다. 그게 내잘못이 아니다 그럼에도 불구하고 그런일이 벌어진다.
자 다운타임이고 security도 마찬가지다. 어쩃거나 얘네들이 아무리 관리한다 하더라도 같은 그런 머신을 가져다 share하는 모델이다.
뒤에 그래서 버츄얼제이션 얘기가 나온다. 그때 제가 좀더 다루겠다. 아무리 이거를 가져다 vm으로 나눠서 아이써레이션 시킨다고 하더라도 같은 피지컬 머신 상에 있기때문에 그런 스케일러티 문제는 반드시 생긴다.
그리고 vendor lock - in은 락 드 인은 내가 얘네 제품을 쓰면 금방 쓸수가없다. 여러분들이 똑같은 서비스를 가져다 하나를 내가 회사를 차려가지고 외부호스팅을 받는데 절반은 아마존 에서 쓰고 절반은 마이크로 소프트 쓰고 그럴수가 없다. 하나에 제품을 쓰면 좋든 싫든 거기다가 메인은 묶여 버린다. 그게 lock-in이다. 
리미티드컨트롤 당연하다. 클라우드 컴퓨팅 개념자체 자체가 그냥 주는대로 닥치고 써 라는거 개념이기 떄문에 기본적으로 컨트롤이 제한될 수밖에 없다. 내가 내 머신을 가지고 마음대로 세팅하고 내 마음대로 그런 정도의 제어도는 없다. 왜냐하면 자기네들이 관리를 하니까 물론 그렇기 때문에 반대로 생각해서 장점이 있을 수있는 반면에 그게 단점이 될수도 있다.

질문) 서버는 그게 사실은 타임 미스 관점에서 바라보면은 되는데 클라우드 개념에서는 훨씬더 크다 
데이터 센터 바라보면 된다 

그래서 혹자는 얘기한다.
cloud is for everyone 이지만 not for everything 이라고 보통한다. 
## What is virtualization?
자 그래서
이거 거듭말하지만 메모리 매니지 먼트는 그 레벨까지 테크니컬하게 안들어간다 
여러분들이 os에 배워야 할 것들이다.
그렇기 떄문에 클라우드 레벨에서는 그냥 대강 테크닉만 훑는다.
소위 얘기하는 가상화이다.
클라우드 컴퓨터하면 제일 먼저 나오는게 가상화 기술이다.
왜냐하면 이 버츄얼라이제이션 기능은 테크닉 써가지고 클라우드 컴퓨터라는것을 구현하고 서비스를 제공하면 되는것이다.
클라우드 컴퓨터하면 제일 먼저 나오는얘기가 virtualization이다 가상화 얘기다.
예를 들어서 엘리스라는 사람이 자기가 피지컬한 머신이 이렇게 있어 서버 가 떡하니 있다. 서버가 됫든 데이터 센터가 됫든 이렇게
이런 리소스를 가지고 있다. 그런데 bob 이나 charlie 나 daniel 이 이렇게 나는 cpu 하나랑 예를들어서 3기가 해야되 어 그런 리소스 가 필요해 자이렇게 요구하고 있어 찰리는 아 나는 cpu 2개에다가 메모리를 껴야되 
사람마다 요구하는게 다르다, 메뉴얼이 달라진다
자 사실은 컴퓨팅 모델은 그런것이다. 저거를 요구, 컴퓨팅을 가져다 요구한다. 리소스를 가져다 
그랬을떄 프로바이더(제공자) 는 그거를 맞춰줘야 한다. 그렇다고 만약에 가정할것같으면 엘리스 입장에서는 이사람들을 만족시키기위해서 그런 서비스를 제공하기 위해서 어떻게 해야 하냐면 
자 vm을 제공할 뿐이다. 실제 저사람들한테 피지컬한 머신을 당연히 줄수없다. 통상적으로 대부분다 클라우드 서비스 업체나 그 데이터 센터가 remote 하게 있으니까 그러면 그럼 에도 불구하고 그사람들이 정말 내가 그런 리소스를 갖고있는 그런 서버와 컴퓨터를 갖고있는 것처럼 그런 느낌을 주기위해서 그 사람들이 제공하는건다 vm이다. 
virtual machine 을 그냥 줄뿐인것이다.
그래서 실제 보기엔 이제 가상머신을 주고 그런 사람들이 request 하는 그런 리소스를 만족시키는 그런 가상머신 을 줄 뿐이다.
그리고 이 엘리스라는 사람은 벌츄얼 머신 모니터를 통해서 이 각각의 버츄얼 머신을 가져다 manage만 하면된다.

그래서 어 이게 이렇게 하다보면 실질적으로 피지컬 하게 이렇게 되면은 이게 하나의 데이터 센터 던 컴퓨터던 뭐든지 간에 이 하나의 리소스를 가져다 이 사람들 입장에서는 어차피 피지컬 하게 이사람들에게 진행하는건 아니다 
그러다 보니까 각각 본인 스스로가 나눠가지고 아 나는 요구하는 그런 스펙을 갖고 있는 머신을 따로 갖고 있는 느낌을 갖게 된다. 그게 바로 아이솔렝션 이라고 한다.
그런식으로 아이솔레이션을 시켜가지고 본인이 원하는 그런 리소스를 갖고 있는 그런 컴퓨팅 , 서비스를 가져다 제공을 한다. 
자 이게 VIRTUALIZATION 기능인데 
이 실제 요런 기능들을 테크닉을 이용해서 클라우드 업체 경우에는 그런 리소스를 가져다가 얘네들한테 제공을 한다. 물론 이 제공을 할때 여러분들 아시겠지만 os 시간에 배웠겠지만 
가상화 기술이라는게 어느 하나가 존재하는게 아니다.
cpu 도 cpu 가상화가 있고 
네트워크도 네트워크 가상화가 있고 
스토리지도 스토리지 가상화가 있고 
각각 가져다 그런 리소스 해당하는 가상화 기술들이 다 있다. 그런 버츄얼 제이션 기능들을 이용해서 그런 필요한 리소스를 가져다 각각 따로 이런 제공을 해준다. 
그래서 이게 어떻게 작동하느냐 물론 
간단하게, 자 이게 실질적으로 버츄얼 머신이라는것은 버츄얼 매니지먼트 또는 모니터 라고 하는데 
이 VM은요
이 VM 하는일은 굉장히 간단하다. 메모리 맵핑을 한다. 
그냥 가상 메모리를 가져다 실제 자기자신의 로컬에 있는 그런 피지컬 메모리 어드레스 로 맵핑하는 기능만 해준다. 
사실은 그것만 하는게 아니다.
리소스 매니지먼트 다같이 합니다만은 통상적으로 가장 중요한 그 메인 일 자체는 메모리뱅킹이다. 그래서 가상 메모리를 가져다 각각 여기서 보면 이 피지컬 머신내에 밑에 
뭐 여러분들 오라클 VM 같이 뭐 하이퍼 바이저를 깔고 그렇조 
얘네들 VM을 가져다 하이퍼 바이저 라고 많이 한다. 
하이퍼 바이저다 하이퍼 바이저 위에다가 각각 이런

## How does it work?
그런 뭐 vm 을 띄우고 
그리고 각각 vm 마다 자기자신의 os와 애플리케이션 이라든지 각각 자기네들이 마음대로 깐다. 여기보면 각각 리소스를 가져다 가상화 기술을 통해서 얘네들 한테 그 윗단에 각각 버츄얼 머신에다가 그런 리소스 를 제공해주는 역할을 얘가 합니다. 그런데 그 메인 로컬 자체가 어차피 보시면 알겠지만 버츄얼 메모리 이 테이블에 있는게 버츄얼 메모리 그 어드레스를 가져다 실제 자기자신의 로컬에 있는 그 피지컬 메모리에다가 맵핑을 시켜주는것이다.
그걸 가져다 time-sharing을 한다. 
곧 나오게 되겠지만 
결과적으로 이런 일만합니다. 
그래서 이예제를 보게되면 

이게 버츄얼 머신(vm1)1이다.
1에서 어떤 메모리 323 이라는 버츄얼 메모리 , 메모리를 엑세스 한다. 그러면 테이블을 보시면 메모리 맵핑 테이블이 있어서 걔 입장에서는 피지컬한 그 메모리 어드레스 range가 여기 들어간다. 
실질적으로 하이퍼바이저가 이 어드레스를 가져다 이 피지컬 메모리 자기자신에 예를들어서 가령 1,2,3 이다. 
123 번지다. 그러면 그쪽에다가 맵핑을 시킬 뿐이다.
그리고 그 일들이 끝나면 그것을 가져다 다시 밑에서부터 시키고 각각의 가져다가 time-sharing 해가면서 그런 리소스를 가져다 실제  피지컬 메모리에다가 맵핑 시켜주는 역할을 하는게 얘네들 하이퍼바이저의 주된 역할이다.

## Migration
여러분들 실질적으로 그 여러분들 vm 깔고서 그 이미지 같은거 다른데 옮기는게 굉장히 편하다.
그런데 여러분들 생각해보면 실제 여러분들이 피지컬한 머신을 한대 가지고 있다 그러면 그 머신을 가져다 이 문제가 생겨가지고 그러면 단데로 가져다가 내가 migration을 가져다 복잡하다.
복잡한게 아니라 불가능하다. 수많은 작업들을 가져다 처음부터 뭐든 것을 다해야 한다. 아니면 여러분들이 하드디스크에 db 떠가지고 하드디스크 bit by bit 로 모든것을 가져다 그냥 아예 그냥 꽂던지 ddl 해서 아시겟지만 요즘 ddl을 해보면 무지무지 하게 오래걸린다. 그렇게 떠봣자 하드디스크만 그 환경 그대로 떴을 뿐이것이다. 처음에 메모리번지 0번지 에서부터 
0번지 부터 가지고 있는 모든 데이터를 가져다 비트 바이 비트로 다 뜬다. 
그렇기 떄문에 ddl 을 쓰게 되면은 migration을 쉽게 할 수있다 치더라도 굉장히많은 노력과 시간이 걸린다. 그리고 똑같은 머신이 아니면 피지컬 머신에서 그 똑같이 얘기하는 그 dd 떠가지고 하드디스크 한테 못미더워서 시들어서 작동 제대로 안한다. 왜? 메모리 번지가 다르기 떄문에 
그렇기 떄문에 제대로 작동을 않한다. 똑같은 머신 똑같이 카페스티 두고서 걍 db 떠가지고 넘기면 자 그런짓을 할 수있긴 하겠지만 굉장히 어렵다. 어렵다긴 보단 시간이 오래걸린다.
그러면 이 버츄얼 머신 여러분들 깔아봤잔아. 버츄얼 머신 깔아봣잔아 깔아보면 그 바이브레이션 시키는건 굉장히 쉽다. 
버츄어 머신에서 버츄얼 머신으로 이동하는거는 
왜냐하면 기존에 있던 그런 피지컬 머신에다가 vm 깔고 그냥 이미지를 넘기면 된다. 
그게 바이브레이션이다. 
그래서 실질적으로 이게뭐 이 서버가 그냥 폭발을 하든 말든 뭐 어떤 문제가 생겼다 아니면 뭐 이게 뭐 예를 들어서 서비스를 좀 해야되, 업그레이드 를 좀 해야되 
그러면 다른 머신에다가 살짝 쿵 그 이미지를 가져다 이쪽으로 넘겨놓고 그 넘겨놓으면 여기에 있는 그 하드와이저 가 그냥 똑같이 작동을 해서 얘네들 한테 서비스를 그대로 해준다.
다음 타임이 실질적으로 그 유저 입장에서는 다운타임이 느껴지지 않는것이다. 
이게 바이브레이션이다. 
버츄얼라이제이션에서 얘기하는 그 하이퍼바이저를 이용한 바이브레이션이다. 
자 타임 쉐얼링 나온다.

## 타임 쉐얼링
os에 다 배웠을것이다. 타임 쉐얼링은 여러분들이 알고있는 리소스에 타임 쉐얼링 같다. 
에를 들어서 기존에 우리가 진짜 얘네가 갖고있는 그런 리소스가 만약에 100이다. 산술적으로 쉽게
근데 커스터머들이 늘어서 100까지면 괜찬은데 내가 피지컬하게 갖고 있는 리소스가 100인데 오 사람들ㅇ ㅣ늘어나면서 120을 요구해 토탈 합쳐봤더니 120을 요구해 
에밀리라는 사람이 새로 조금전에 해서 cpu 2개에다가 메모리 4기가를 줘 그랬더니 기존에 이미 하나 둘 셋 넷 cpu를 다 쓰고 있는것이다. 이 3명이 밥이랑 찰리랑 다니엘이 
이미 다 쓰고있다. 그런데 이사람들 다 조인해가지고 리소스를 닥치고 더 내놔 이렇게 된단 말이다 그러면 이런 경우에 이런 하이퍼바이저 같은 경우는 자 타임 쉐얼링은 리소스를 타임 쉐얼링 하기 시작한다. 왜냐하면은 이 모든 리소스를 가져다 모든 사람들이 같은 시간에 동시에 쫙 다 써재낏는경우는 거의 없다.
그렇기 떄문에 남는 그런 리소스를 가져다 타임 쉐얼링 해서 잽싸게 넘겨서 얶떻게 든지 에밀리 사람 입장에서는 어 마치 내가 그걸 가져다 전혀 문제 없이 쓰고 있는 것처럼 그대로 느껴질 뿐더러 나머지 사람들도 통상적으로는 별로 영향없이 자기가 쓰던 느낌 그대로 그 vm을 그대로 사용할수가있다. 여러분들이 아는 그런 웬만 한 서버들 웬만한 컴퓨터들, 그 활용 리소르를 유지비가 30% 채 안된다. 그렇기 떄문에 이게 4개라는 그리고 이런 전체 토탈 이거는 정말 동시에 max 일떄 wortst case일떄 그런 require ment  일 뿐인것이다. 그렇기 떄문에 타임 쉐얼링을 하게 되면은 이런 모든 문제를 별 문제없이 해결 할 수있다. 그리고 이 엘리스 사람 입장에서는 지는 cpu 4게짜리 가지고 있으면서 서비스는 6개, 8개, 9개, 10개 씩 이런 그정도의 요구를 하는 그런 토탈 그런 서비스를 할수있는것이다. 그래서 서비스 제공 자 입장에서도 그 만큼의 비용을 들이지 않고 그 많은 더 많은 돈을 벌 수있는것이고 유저입장에서도 사실은  어 어떻게 보면 타임 쉐얼링은 프로바이더 입장에서도 유리한것이다. 이 사용자 입장에서도 크게 피해를 보지 않으면서 그런 자기가 요구하는 리소스를 다 쓸수있는 어 그런 장점이 있다. 그런데 말씀드렸다싶이 만약에 재수없어 가지고 이사람들이 확 몰아가지고 동시에 확쓴다 그러면 그런 서비스에 그런 퀄러티 자체에 문제가 생기기도 한다. 그게 lSOLATION 이다 
## isolation 이다.
이 파트에서 나온다.
아이솔레이션 보이면은 원래 이 아이솔레이션 자체는 시큐러티한 측면에서 많이 다루게 된다. 왜냐하면 말씀드렸다 싶이 이 하나의 피지컬 머신을 엑세스 하지만 저거 버츄얼라이제이션 시켜가지고 쭉쭉 쭉 나눠놓지 않으면 그냥 만약 저사람들이 동시에 똑같이 접속한다 그러면 똑같은 리소스를 똑같이 접속해서 사실은 굉장히 시큐어러티 문제가 생긴다. 너 데이터를 내가 보고 내 데이터를 너가보고 
그런 꼴이된다. 그런데 이렇게 vm이 메모리 맵핑을 시켜가지고 따로 관리를 해놓고 나면 지네들끼리 그런 시큐어러티 문제가 전혀 안생긴다. 이게 사실은 원래 아이솔레이션 개념인데

이거 뿐만아니라 여기서 아이솔레이션 시켰을 때 단점이 나온다. 아까 말씀드렸던 그 후이다.
이게 아이솔레이션을 시켜놓은뒤 제한된 리소스를 가져다 타임 쉐얼링을 통해서 자기의 시큐어러티를 보장하면서 보장받으면서 이많은 사람들이 사실은 더많은사람들이 그런 그 컴퓨터 리소스를 쓸 수있게끔 해놨다는 부분인데 
재수없어서 예를들어서 에밀리라는사람이 밥이라는 실제적으로 피지컬 머신을 같은 피지컬 머신에서 쓴다. 예를들어서 재수없다 표현은 뭐하지만 
이 밥이 이 에밀리라는사람이 새로 도입했는데 이사람이 밥이 쓰고있는 그 피지컬 머신을 나눠서쓰는 괜히 그렇게 어사인 되어있다 라고 가정했을때 만약에 
어 에밀리 라는 사람이 무지막지 하게 써재낀다. 그러면 이 밥이라는 사람은 그렇죠 자기가 느껴진다. 자기의 리소스를 가져다 저사람들이 과하게 씀으로 인해서 자기가 써야할 그런 리소스를 가져다 제대로 할당받지 못하는 문제점이 생긴다. 이 아이솔레이션을 통해서 
자 

## Recap : Virtualization in the cloud
우리가 자 클라우드 입장에서 버츄얼라이제이션을 우리가 알아봤다. 이거뭐
그냥 복습이다.
제가 얘기했던 그내용들이 그대로 다있다.
클라우드 경우는 클라우드 프로바이더는 저런 가상화 기술을 통해서 그런 어떤 flexibility 를 제공을 한다. 그리고 시큐얼리티나 아이솔레이션 같은 그런 것도 제공을 하고 그리고 유저입장에서는 어 컴피덴트한 측면도 있다. 그렇지만 아까도 말씀드렸다싶이 자 퍼포먼스 가 다운되는 그런 경향이 생길수도있는데 
그래서 단 이유가 아니라, 그거는 그 원래 자체가 사실은 제가 첫 부분에 그런 컴퓨팅은 첫부분에 말씀드렸다싶이 원래 리소스 usuage 나 아니면 그런 거를 가져다 트릭틱트 하는게 굉장히 힘들다 원래 모든게 프레딕션 이라는건 굉장히 힘들다. 그래서 그런 만큼 프레딕션이라는게 가치가 있는데
그래서 그 프레딕션에 가치를 인정받는게 요즘 나오는게 흔히 얘끼하는 딥러닝 이다.
머신러닝도 사실로 얘기하자면 프레딕션이다.
기존에 존재하는 데이터 트레이닝 시켜서 앞으로 새로운 데이터 들어왔을때 어떻게 보여줄것인가 라고 구지얘기하면 프레딕션하는것이다. 
어쩃든 프레딕션의 형태이다
어 그런측면 때문에 어 퍼포먼스가 디그레이션되는 문제점이 흔들리는 겁니다. 지금까지 어쩃거나 굉장히 straightforward 하기 떄문에 여러분 팔로우업 하는데 문제가 없을것이다.

미자믹 부분이다.

## 10 obstacles and oppotunities
요고 10가지
어떤 그런 obstacles 랑 뭐 opportuinties 가 나오는데 말그대로 어떤 뭐 그런 리미테이션을 조금 생각해보자
클라우드 컴퓨팅에 대해서 물론 뭐든지 그럿듯이 어떤 리미테이션이나 단점이 있으면 바꿔 얘기하면 그것을 잘 활용하게 되면 기회가 된다. 그런측면에서 우리가 10가지 정도를 꼽아보고 클라우드 컴퓨팅 설렉션을 마치도록 하겠다.
1. availability다.
라는게 있는데 말씀드렸다. 자, 다운 타임을 얘기하는것이다. 어베일러블 하다. 어벨러 빌리티라고 얘끼하는건 여러분 데이터베이스나 그런시간에 굉장히 많이 배웠다. 어떤 컴퓨터에서 아니면 컴퓨팅 리소스에서 어벨러빌리티 라는건 그게 항상 어벨러블 하냐 라는 측면에서 바라보는 얘기이다. 근데 이 클라우드 컴퓨팅 라는게 그러면 그럼 항상 어벨러블 하냐 그러치는 않다. 
오른쪽에 나오는게 클라우드 실제 일어났던 사건들이다.
어떻게보면 좀 엑시턴트 인데요 s3 서비스 경우에 2008 년도에 8시간 다운이 된다. 8시간이라는게 여러분 입장에서 작아보일 수도있는데 거기에 물으는 비지니스 를 생각하면 어마어마 상상을 초월할것이다. 이런 문제점이 생긴다. 그뿐만아니라 구글앱 엔진이라든지 아니면 걔네들 resting 이게 아마 블락 스토리지 어쩃든 익셉티브
얘네들 다 s3나 ecc나 다 아마존 이다. 아마존 클라우드 서비스이다. 예전에 이런식으로 다운되었던 예가 있었다. 얘네들만 있었냐? 그렇지 않다. 에쵸 역시 가운데 마이크로 소프트인데 얘네들 역시도 다운된 적이있다. 대부분 보면 화곡파인터?? 대부분 많다. 그만 큼 얘네들은 전기를 많이 먹기때문에 아니면은 그 허리케인 같은거 중부지방에 데이터 센터를 두는경우는 허리케인 같은게 와서 다 다운타임이 일어나기도 한다. 뭐 어떻게 하겠냐? 
그럼 Intuit 도 마찬가지다. Intuie은 많이 못들어봤을텐데 이 회사는 텍스, 미국에서 한국도 그런 프로그램이 있을텐데 텍스트 파일링 이 별로없을텐데 텍스를 보고하고 그런 걸 해주는 소프트웨어다. 그런 소프트웨어 터보텍스라는 그런 프로그램이있다. 그런 프로그램을 만드는 회사임 미국사람들은 굉장히 유명하다. 그런 모든 사람, 집집마다 다쓰기떄문에 어쩃거나 얘네들 같은경우도 36시간동안 2010년에 다운타임이 일어났었다.
그런데 그 아마 얘네들이 다행이었던게 날짜를 보면 6월 16이었다 미국은 4월 15일까지가 텍스 보고 하게 되는 4월 15일 다. 매년
그래서 이제 얘네들이 만약에 이게아니라 6월 4월15일 이전에 다운 타임이 만약에 일어났다. 그러면 난리 났을것이다.
뒤짚어 졌을것이다. 그나마 이 사건은 얘네들이 그기간 이후에 일어난 ㅁ다운타임이라 조금은 욕을 덜 먹고 갈 수있었던 케이스다.
2. Data lock - in
말그대로 lock - in 되어있는것이다. 어, 한놈만 쓰다가 우리도 만약에 아마존 aws 쓰다가 내가 맘에 안들어서 마이크로 소프트 애즈홀로 넘어가고 싶더라 그러면 어떻게 넘겨준다라는 느낌인거같음? 이런 문제가 생길 수있다. 당연히 그리고 말씀드렸다싶이

3. Data confidentiality and auditability 
그냥 시큐러리티 관련된 얘기다. 아 그 오딧 꺼내서 어드벨리티도 마찬가지다. 그래서 내 데이터가 새나가지 않는다라는 보장이 어딨어 걔네들은 아니다 라고 얘끼하지만 왜 팔아먹어야 하니까 근데 내가 아마존을 어떻게믿어? 그런 문제다.
그 뒤에 데이터를 가져다 트랜스펄 할때 바틀렉인ㄷ요 요즘은 사실은 많이 해소가 됬다.

4. Data transfer bottlenecks
이게 미국이니까 조금더 두각되는 문제가있다. 클라우드 서비스가 데이터 업체들이 다 미국 회사들이다. 그러다보니까 그런부분이 있는데 왜냐하면 미국은 네트워크 속도가 우리나라 보다 느리다. 땅덩어리가 넓다보니까 그것을 가져다 우리나라 처럼 미친듯이 광케이블을 다 깔고 이럴수가없다. 대도시나 나는 조금 그런 도시 
큼직큼직한 데서나 망서비스가 들어가지 실제로 2000년대 4년도 5년도 유학나왔을때 그떄만 하더라도 전화번호를 쓰는집이 많았다.(전화망인거같아)
??
안믿어졌다. 2004 년 우리나라 인터넷이 얼마나 좋아졌읉텐데 그떄 나왔을때 미국에서는 모뎀을 쓰는곳이 있었다.
그러니까 그정도 차이가 있었다. 사실은 요즘은 미국도 그렇지않다. 그래서 여전히 우리나라 보다 느리다. 그러다 보니 나오는 문제다. 여러분들이 로컬에 있는 데이터를 가져다 만약에 클라우드 서비스를 이용해서 그냥 상식적으로 생각해봐 저장을 하고 싶어 근데 여러분들이 10테라 데이터를 가져다 내가 저장을 하고 싶어 
그런데 여기에 나오는 예제는 어 UCBerkeley 에서 산호세 북부 에 있다. 그 실리콘 밸리에서 버클리에서 10 테라 데이터를 가져다 만약에 시에틀에 있는 오시턴주에있는 자 아마존에다가 내가 10테라의 데이터를 가져다 내가 전송하는거야
그랬을ㄸ ㅐ예를 들어서 200메가 bps 짜리의 인터넷을 쓰게되면은 저거 그냥 전송하는데만 4일이 넘게 걸린다.
근데 그짓거리 할바에는 내가 그냥 eps나 페딕스 써가지고 하드디스크 떼서 보내버리면 하루면되는데 
내가 지금 4.5일 걸려서 10테라 보내는 저짓거리를 해야되 라는 생각이 들수있다.
미국이니까 가능한애끼다. 
그런 부분들이다. 그리고 실질적으로 이부분이 단순히 무시할 수 없냐면 여러분들이 데이터를 가져다 말그레이닝? 한다고 생각해봐라 아니면 여러분들이 데이터를 export만 하는거 아니잔아 여러분들 데이터를 import를 한번만해요
그러면 여러분들 수많개 저장해놓은 그런 그 클라우드 서비스 스토리지 에 저장해놓은 그런 데이터를 내가 다운받을 수있는것이다. 똑같은 얘기인것이다. 그걸 가져다 내가 다운받는게 더 빠르다. 아마존 한테 야 너 한테 하드디스크 서버 몇번지 에 있는 서버 떼가지고 나한테 보내줘 그럴순없다. 그런 문제다. 데이터 트랜스퍼와 관련된 바틀렉이있을수있다.
//뭔가 데이터를 export나 import나 하는것보다 데이터를 다운받는게 더 빠를수가 있으니까 트랜스퍼와 관련된 바틀렉이 생길수있다.

5. Performance unpredictability
가장 근원적인 문제다.
퍼포먼스가 preditable 하지 않는것이다. 왜냐하면은 vm 자체가 공통된 하드웨어를 가져다 share하는기능이다. 그렇기 때문에 퍼포먼스가 예쌍치 못한다. 실제적으로 보면 이것을 까기 위해서 이런 데이터들이 나온다. 실제로 복붙해서 가져온 데이터지만 이 메모리 밴드위쓰
아마존 ec3 인스턴트 사면 인스턴스가 뜬다. 걔네들 퍼포먼스를 측정한것이다. 실질적으로 걔네들 아마존 웹서비스를 가져다 성능측정해봤더니 그런거다. 똑같은 짓거리를 하는데도 보면은 메모리 그 밴드위스 퍼포먼스가 뭐냐면 
이게 평균 1.3 기가인데 보면은 std dev가 3% 가 나오고
이 디스크 밴드위쓰도 경우도 통상한 55mb 가 정도 이떄당시에 그렇게 나왔던 std dev 16% 정도 된다. 
그 이 16% 라는게 여러분들 이 생각하는게 16% 일수도있지 라고 생각하겠지만 컴퓨테이션 래티드 같은 그런 센스 에프젝션 그런데 같은경우는 16%는 굉장히 큰 수치이다. 그리고 억울하다. 그리고 내가 공짜로 쓰는것도 아닌데내가 그걸 가져다 보장받지 못하고 그 만큼 돈을 내는데도 불구하고 16퍼센트보다 적은 리소스를 할당받고 성능이 떨어진다라는 것은 있을수없다. 왜냐하면 걔들은 서비스 제공자들이다. 우리가 서비스 이용자고 그 관점에서 바라보셔야 한다.
자 storage가 scalbe 하냐

## Scalable storage
근데 사실은 요부분도 있다. 그 아마존 ebs 경우에 스토리지 서비스 제공한다. 근데 이게 클라우드 모델 경우는 내가 예를들어서 콜드 데이터 를 가져다 여러분들 저장을 해둔다. 여러분들이 잘보이지 않은 엄청난 양에 뭐 사진 동영상 그런거를 가져다 굉장히 많은 양의 데이터를 가져다 이거 너프? 해서 백업 받아 서 둔다. 라고 생각을 했을때는 그 모델이 그닥 잘 맞지 않는것이다. 왜냐하면 쓰지 않는거 두번 나는 차지 하고 있다는 용량만으로도 나는 계속 돈을 내고 있는것이다. 쉽게 얘기하면 
이게 그러다 보니까 이게 클라우드 모델 자체가 셜턴 으로 그냥 짧게 통상적으로 그리고 내가 쓴 만큼만 내는 그런 모델인데 그런데다가 프레스탄스 스토리지 모델이 잘 맞지 않다. 
실질적으로 그래서 사실은 그 백업자체도 얘네들도 지녜들도 데이터센터를 다 가지고 있고 하지만 약간 좀 뻘소리 하면
이 데이터 저장 그 용량에 대한 그런 갈망이라고 해야하나 빅데이터 라고 하는데 엄청난 양의 데이터가 쏟아진다. 페이스북이랑 얘기할 경우가 많이있었는데 페이스북에 갔더니 이사람들 저한테 말하는게 너네 메모리좀 싸게 팔수없냐 라는거임 
걔네들이 뭘 고민하냐면 페북만 해도 사진올리잔아 전세계 사람들이 미친듯이 올려대는 그 사진들이 동영상들이 많은 데이터가요 20 : 80이라는 법칙이있다. 그 2:8 법칙 이 뭐냐면 굉장히 핫한 데이터에 20% 정도 밖에 안된다. 80는 아니다. 걔네들이 그 20% 안되는 그 데이터 핫한 데이터가 실제 리소스에 80% 이상을 다 잡아먹는다는 거임 실제 그런 법칙 있다.
 그러다 보니까 얘네 페이스북 입장에서 보면 그 많은 데이터를 가져다 어쩃든 간에 저장을 해야되고 여러분들이 내사진 저장해줘 라고 올렸는데 페이스북 에서 하이고 용량이 없어서 못하겠네 라고 할 수없는 노릇이다. 그러면 어쩃든지 간에 저장을 해야되는데 여러분들 잘생각해봐 페이스북 여러분 사진 저장해놓고 처음부터 끝까지 다 훑어 보고 처음부터 끝까지 다훑어 보는사람이 물론 있을 수있지만 하지만 넣어놓고 나면 그만이지 실질적으로 그렇다. 그러면 내가 실질적으로 7일이나 한달 바운더리 내에 있는데이터가 핫데이터다 이게 실제 조사서, 여러분들한테 신고도 안될것이다.
아무리 이때 파일이 그 법칙이 존재한다 서 치더라도 그 엔지니어 정책 이나 통틀어서 얘기하는거지 여러분들 핫데이터는 5%도 안된다.
그거를 위해서 페북은요 엄청난 스토리지 준비해야한다. 그래서 개네들이 걔네들 생각하기에 정말 콜드 한 데이터 어디에 저장할것 같냐? 여러분들 access 안하는데이터 어디에 저장할거같아?
하드디스크? ㄴㄴ 
하드디스크 가 사실 제일 싼 장비는 맞다 사람들 태잎이요 이런 말은 하지 말자 도서관이나 정말 정말 정말 한번 아카이빙 받아놓으면 정말 쓸일이없는 그냥 서고에다 그냥 그냥 골동품처럼 보관해놓는 용도로 쓰는 게 태잎이다. 
사실은 그 태잎이라는게 저도 본적이 없음. 여러분들이 본적이 있겠냐 정말 많은 용량의 데이터를 굉장히 싼값에 오랫동안 저장할 용도로는 태이프를 쓰면됨 지금도 많이 쓴다. 
여러분들 볼기회가 없어서 그런거지 
그런데 이 페북입장에서는 그런데 넣어두면요 여러분들이 정말 가끔식 너무 심심해서 술한잔 마시고나서 10년전 사진 볼까 하고 가면 그게 뜰꺼같냐? 안뜬다. 몇년의 태잎은요 작동하는 방식만 봐도 태잎은 그냥 이따만한 50 cm 이만한 태잎이 있다. 정말 태잎이다 돌아가는태잎임 이게 기계적으로 작동함 arm이 있어서 찰각 옮겨가지고 찰칵 꽂고 이렇게 작동시키고 안쓰게 되면 다시 뺴서 넣고 이렇게 작동한다. 
근데 이게 성능이 하드디스크보다 수십배 느리다. 그런데 여러분들 10년전에 동영상 하나 보겠다고 그 짓거리 한다고 여러분들 1분만 기다리면 로딩해주겠따 하면 여러분들이 페북을 쓰겠내고? 
그래서 얘네들이 실질적으로 그 콜드 데이터를 , 페북은 콜드 스토리지 라고하는데 콜드 스토리지 쓰는 형식은 블루베리를 쓴다? 먹는거아니야?
굉장히 의외다. 블루베리
이건 걔네들 가서 얘기해보면서 아는건데 실질적으로 블루베리를 쓴다. 
왜냐하면 블루베리만 ㄴㄴ 블루레이임 
10기가 저장할수있다. 그리고 요즘엔 듀얼레이라고 해서 용량이 더 많이 증가했다. 그정도 덴스하게 가면 용량이 더 늘고 
걔네들이 하디디스크 보다 더싸다. 걔네들은 싼게 중요하다. 싸면서도 성능이 어느정도 나오는것 
블루레이 를 쓴다. 블루레이 쓰다보니 정말 심심하면 초딩때 제일 먼저 페북 볼려고 클릭해보면 살짝 딜레이가 있다. 실제 그렇다. 왜냐하면 그데이터가올라와 있지 않다. 프론트에 올라와있지 않다. 백단 에 있는 데이터를 가져다 걔네들이 잽싸게 끌어와야하는데 딜레이가 생기면 여러분들이 다떠나기때문에 돈을 못벌어 그러면 
그 퍼포먼스와 그 시간 그리고 돈 사이에 함수관계다
그래서 요즘엔 블루레이 를 쓰다가 최근에는 걔네들이랑 얘기를해보니까 최근에는 여러분들 ssd 인데 
여러분들 노트북 들어있는 ssd 는 고급 ssd 이다.
그게 아니라 굉장히 저질의 ssd 쓴다. 왜냐히면 이 ssd 걔네들이 콜드 storage 거의 access 안되는 용도로 쓸거기떄문에 여러분들 노트북 에서 성능이 좋을 필요가 없다. 그냥 
하드디스크 보다 빠르고 그냥 그 정도면된다. 몇번 쓰고 죽어도 괜찬다 여러분들 ssd 수명있는거 아시죠
나중에 삼성 반도체, 하이닉스 로 취업 가실분이면 그런 nand 프레시의 속성을 공부해야한다. 물어볼것이다.

요즘에는 걔네들이 쓰고있는것은 인텔이나 삼성이나 가가지고 굉장히 싼 저질의 그치만 하드디스크보다는 살짝쿵 빠른 그런 nand를 쓴다고 한다. 일종에 ssd 종류임 

처음에 내가 여러분 예를 들어보면 학생이 회사를 만들었어 그떄 들어가는 초기비용을 말한다. 원래 할려고 하는 서버를 사야된다.
근데 살필요가 없다. 그게 업프론트 비용 코스트다.

자 그리고 버블이나 

7. Bugs in large distributed systems
이게 아무리 어 얘네들이 잘한다고 해도 큰 데이터 자체에 버그나 에러가 있으면, 좋든 싫든 여러분들한테 영향을 미칠 수 밖에 없다. 그리고 그 서버나 그 데이터 센터에 문제가 있는 데 맞물려있는 모든 놈들은 그냥 다 피해를 보게 되어있다 그런 문제다.

8. Scaling quickly
카운팅 관련된 문제다. 이게 어 자 
컴퓨터를 boot 하면 
그시간은 내가 아무것도 하는시간이 아니다.
여러분들이 만약에 뭔가 열심히 일을 해요 
쓰는 만큼 돈을 낸다.
idle 마찬가지다. idle 할떄도 그떄부터 내가 돈을 내야되?
난 쓰고 있지도 않는데 boot  하고있어 니네들이 boot up하는거니 내가 boot 하는거니? 난 쓰고 있지도 않은데 돈을 내야되?
자 사람들이요 별의별 사람들이 다있따.
그러다 보니까 어카운팅 돈얘기는 그 기준이라고 생각하면된다.
돈을 매길떄 어떻게 매겨야 되는거야? 그런 문제에 봉착하게 된다. 그런 서비스의 경우
그래서 아 그러면 시간단위로 내라 아니면 분단위로 내놔 아니면 하루 단위로 내놔
1일 단위로 내놔 거기에따라 여러분들의 돈이 달라진다. 
굉장히 파인드랜드 하게 되면 좋을거같지만 지네들 입장에서는 관리하기 힘들어
뒤늦게 롱텀하게 바라보면 지네들 편하지만 여러분들은 억울한것이다.
그러면 그 첫반쨰 무시하라는거다??

9. Reputation fate sharing
이게 레퓨테이션 페이트 세어링이라고 나와있는데 
이게 뭔얘기냐 ! 자 말씀드렸다 이게 어떤 리미트된 그런 피지컬 리소스를 두고 vm이 리소스 쉐어링을 해서 타임 쉐어링을 해서 그냥 공유하는 시스템이다. 예를 들어서 막말로 a라는 서버에 쟤가 a라는 서버에서 어사인되서 쓰고 있어 거기 a라는 서버에 알고보니 b라는 놈이 어사인 되어있는데 이놈은 굉장히 골때리는 놈이다
이 굉장 히 나쁜짓하고 돌아다니고 굉장히 나쁜짓을 해 그래서 재수없어서 fbi 가 ip체크하고 뭐해서 재수없으면 나도 걸리는것이다. 왜냐하면 같은 곳을 쓰고 있으니까 걔들이 어떻게 알아 버츄얼 ip를 
어차피 , 버츄얼도 피지컬 ip 그 맵핑 테이블이 있긴 합니다만 어쨋거나 같은 머신을 쓰고있어서 다른 한놈이 또라이짓을 하면 나도 피해볼 수있따. 이게 reputation fate sharing이다.

10. sofrware licensing
사실 이거 굉장히 센서티브한 문제다. 라이센스 가 있는데 생각해봐라 여러분들 서버에 그 피지컬 한 데이터센터에 여러분들 vm 을 깔아가지고 각각 여러분들 한테 버츄얼 머신을 주는거거든요 
그러면 마이크로소프트 입장에서 생각해봐라 자, 저놈한테 내가 윈도를 가져다 몇개를 팔맞았다고 내가? 돈을 요구를 해야될까? 고민을 하게된다. 
왜냐하면 리소스를 sharing 하고 있으니까
그렇죠 그런 문제가 생긴다 라이센스를 가져다 몇개로 쉐어링 하느냐 문제가 생기는데 실제 이 문제가지고 옛날에 오라클 데이터베이스가 어 싸운적이 있다.
이 오라클 데이터베이스 역시도 예를들어서 아마존 웹서비스 쓰면 우리는 db 는 오라클 db 깔아주세요 하면 db 깔아줘야되 
좋습니다 있다 그런데 
오라클 걸고 넘어진다. 라이센스 
머신당 라이센스가 말이되?
이렇게 따진다. 할말이 없다 왜냐하면 머신당 하나 팔았는데 지녜들은 이; 머신당 여러놈한테 팔아가지고 돈받아먹잔아 각각 다 오라클 db를 쓰면서 다 쓰는것처럼
그러면 오라클은 억울하다. 그러면 걔네들이 따져서 걔네들이 이겼다. 걔네들이 이겨서 그 수를 해가지고 이겼는데
결과적으로 어떻ㄱ ㅔ바꼈냐? 스페스픽하게 오라클인 경우다 
오라클의 경우는 싸워가지고 어떻게 됬냐면 코어당 
cpu 코어당 라이센스를 받는다. 왜그럴꺼같냐? 
cpu 코어당라이센스를 받는 이유는 통상적으로 vm 을 가져다 여러개로 깔아서 띄어봐라 
피지컬 코어당 vm 이 하나씩 할당되는게 대부분이다.
실제로 맵퍼도 실제 피지컬 코어 보단 어사인 쉽게, 인스턴스가 그 만 떠요 
왜나하면, 논리적인 하이퍼 쓰레딩 같은 경우있짠아 그런 페이커 말고 
그 페이커는 말그대로 페이커다. 그렇게 할당하는게아니라 피지컬당 개네들이 그런짓을 하는걸 가져다 지녜들이 아마존이 그런짓을 하는것을 알고서 걔네들이 소송을 걸어가지고 지녜뜰이 이겨서 라이센스를 가져다 코어당 받게 만들어놨더니 지녜들은 좋아 근데 문제는 쓰는놈들이 억울한거다 결과적으로 돈을 더내야된다.
그래서 사실은 어쨋거나 오라클은 착한 회사가 아니다.
실제 그렇다. 라이센스 ?????
그렇다. 
이게 어쩃든 클라우드 관련된 소프트 라이센싱 이슈이다.

## ?
여러분들 쉬는시간을 갖자 클라우드 컴퓨팅 여기까지 마치고 다음에 쉬었다가 다음에는 이 그 nosql 데이터 베이스로 넘어간다
클라우딩 컴퓨팅이 다했다.
클라우딩 컴퓨팅 다룰내용들은 다했고
그리고 또 지금 말씀드렸다싶이 우리가 많이 안남았다.

## Nosql
굉장히 코드레벨을 하둡할때처럼 코드레벨 
어쩃든지 간에 킾인 마인드 노시퀄 갈것이다. 스파크 가 될것이다.
다음 토픽은
노 시퀄
데이터 베이스 수업 다 들었겠쬬
노시퀄 이라는 얘기를 들었나요?
그렇죠
고개를 끄덕이는데 노시퀄 이미 들었을꺼기 때문에 그정도 레벨에 맞게 좀더 추려서 강의를 할려고한다. 
자 어쩃거나 노시퀄이다
이미 많이 알고 있을거라고 가정을 하고 나간다.
데이터 베이스 시간 다 들었을거라믿고
자, 본격적으로 노시퀄 들어가기전에 rdms 
여러분들 흔히 얘기하는 컴싸 디비 몇학년때 들었는지 모르겠지만 흔히 알고있는 오라클 디비라든지 
그런 걔네들 
여러분들 많이 들어봤을 릴레이션 데이터베이스 라고 한다.
관계형 데이터 베이스 라고한다. 
자 지난 수십년동안 얘네들이 왕이었다.
2000 년 초반정도까지는 오라클이 돈을 쓸어 담았다. 
왜냐하면 실제여러분들이 금융기관이나 대부분 정말 그런 굉장히 트랜잭션이나 컨시스턴시나 그런 데이터를 다뤄야하는 그런 데이터 서치는 선택여지가 없었따. 그래서 비싸더라도 정말 오라클 제품을 쓸수밖에 없었다.
오라클 데이터 베이스는 굉장하다. 오랜세월 거쳐서 업데이트해왔고 지금까지도 저도 들어보면은 지금까지도 계속 사용량은 계속 발전해가고 있다. 그런 관계형 데이터베이스가 짱이었음 다 잡아먹었음
왕이었음
왜냐하면은 실제 얘네들이 보면은 하드 디스크 컨시스턴스 데이터를 가져다 스토리지 에다가 컨시스턴스한 데이터를 가져다 저장하는데 얘네들 만한 솔루션이 없었다. 그리고 얘네들이 아시겠지만 그 데이터 모델이나 그런 특히나 랭기지를 제공을 한다. 여러분들 이 아시는 sql 경우 배우셧죠 그 sql 랭기지를 제공한다 특히 sql 같은 경우는 좋아던 적이 뭐냐면 표준이다. 여러분들이 마음대로바꿀수있는게 아니다. 여러분들이 어떤 관계형 데이터 베이스를 쓰더라도 이 sql 여러분들 한번 배워놓으면 그대로 다 먹는다
그만큼 굉장히 버츄얼한 충분히 뭐라그래야하나, 충분히 그런 기술이 축적되서 상속해 있는 기술이다. 수십년에 걸쳐서 발전해 왔기떄문이다. db 시간에 acid 그렇죠 
아시죠 이런 것을 가져다 더 보장을 한다 그렇기 떄문에 얘네들이 굉장한 신뢰를 먹고있었다. 그런 부분 뿐만아니라 트랜잭션 개념으로 단위를 가져다 데이터를 다루잔아 그렇기떄문에 그런 컨커런트 컴팬이 굉장히 잘된다. 그런데 세상에 그런데 
영원한 강자가 어딨음에 세월은 따라 흐름에 얘들도 밥이 된다.
뭐냐, 실질적으로 얘네들은 음 클라우드나 클러스터를 염두해두고 만든것이 아니다.(중요)
왜냐하면 , 옛날에 초기에 60~70년대 그때 어 정확히 시작은 60년대부터 그때 나왔던 개념이기 떄문에 클러스터란 개념자체가 있지않았따. 보통은 그렇다 보니까 기본적으로 얘네들은 하나의 머신에다가 rdms 깔고 쓰기 되고 그리고 아 성능이 부족해 그러면 cpu 도 , 하드디스크 부족해 그러면 하드디스크 더 집어넣어 이런식으로 흔히 얘기하는 스케일 업에 맞는 그런 스텝들 전략을 써온다. 그래서 정말 뭐 성능이 필요하다 비싼 그런 하나의 그런 머신에다가 깔아가지고 쓰는경우는 대부분이다.
이게 30초간 잡설, 에드갓 캇 이란 사람이 릴레이션 데이터베이스의 아버지다 이사람이 영국사람임 
산호세 
거기에서 이사람이 그 관계형 데이터베이스라는 그런 아이디어를 생각해내서 아이비엠에 건의한다 데이터를 가져다 데이터 양이 커질테니 데이터를 효율적으로 저장하는 방법
그리고 효율적으로 처리하는 방법을 우리 자 데이터베이스 릴레이션 데이터베이스 개념을 가지고 그 데이터를 저장한는게 어떤지 주장을 한다. 주장했을때 ibm에서 닥쳐라고함 그래서 받아들이지 않다. 이미 그런게 db2라는게 이미 가지고 있었다. 그렇기 떄문에 이런 훌륭하신 분의 아이디어를 받아들이지 않다.근데 이사람이 그러고나서 논문에 발표를함 굉장히 센세이션해진다.
그거를 보고 다른사람이 레디라는 사람이 그사람이 누구냐면 오라클 창시자다 그사람이 이사람이 써놓은 페이퍼를 보고 영감을 얻는다 아하라는 생각 을 하고 오라클에서 만든게 실제 오라클 데이터베이스다. 이얘기를 왜하느냐 왜 
실제 이사람은 Edgar codd 라는사람은 굉장한 사람임에도 불구하고 실질적으로 굉장히 명성을 얻지 못했다.
이 아이디어를 훔쳤다 하면 미안하지만 그걸 그대로 가져간 레디 에디슨이라는 사람은 떼돈을 벌게된다. 그래서 
여러분 세상이 그런것이다. 
진리를 알려주기 위해서 진리 

어쩃거나 이사람은 유명하고 그 이후에 ibm에서 늦었지만 받아들이게 된다.
db2에다가 관계형 데이터베이스 받아들이게 되는데 이미 그때 되서는 게임이 끝난상태다. 왜냐하면 오라클은 이미 충분히 자리를 다 잡고 있엇기때문이다.
그러니까 ibm이 db에 서 그 똑똑한 사람들 다 데리고서 db 지네들이 시작했음에도 불구하고 오라클에게 질수밖에 없었던 케이스니까 그렇다.
ibm 얘기를 좀더 하면 
어쩃거나 릴레이션 데이터 베이스가 생기게 되는데 이렇게 해서 수십년동안 관계형 데이터 베이스는 왕의 자리에서 군림하게 된다. 대안이 없다 이거 외에는 시간이 지나면 문제가 생긴다. 
불만을 가져다 토론을 시작한다. 그게 뭐냐면
여러분 그 아이디밴스 같은 경우는 데이터 베이스에 프로젝트 해보면 알겟지만 테이블을 만들잔아 스키마를 만들면 
테이블을 만들면 이런식으로 각각 테이블을 갖다가 이렇게 만들게 되는데 여러분들 지네들끼리 릴레이션 이잔아 
그래서 릴레이셔널 데이터베이스잔아 
아시죠, 이런식으로 테이블 을 가져다 만들게 되는데 
저거는 잘 생각해보면 철저하게 db 지네들 중심적인 얘기다
지네들이 데이터를 가져다 어떻게 저장할것인가 
그리고 그것을 가져다 어떻게 데이터를 뽑아올것인가 
막말로 지네들 중심적으로만 디자인 되어있는거지 애플리케이션 디벨로퍼 따위는 고려 되어 있지 않다. 예를 들어가지고 여러분이 뭐 커스터머 가 있고 어떤 커스터머가 어떤 아이템을 가져다 아마존이라고 생각하자 아마존에 여러분에 
아마존에서 여러분들이 주문을 한다 
그러면 커스터머가 
a라는 커스터머가 b라는 물건을 가져다 주문을 한다 그런데 실제 여러분들이 코딩을 하게 되면 지네들 관심있는건 어떤 사람이 어떤 물건을 얼마에 어떻게 삿다라는 자 이하나의 덩어리 에 관심이 있을것이다. 여러분이 에플리케이션 디벨로퍼 입장에서라면 그런데 그걸 가져다 db를 설계하는 입장에서는 그딴거 닥치고 자 그러든 말든 요런식으로 저장을 해 요런식으로 저장을 할 수가있다. 따로따로 떨어져있다. 그리고나서 그 데이터를 가져다 필요한 데이터는 너네들이 알아서 그냥 join 같은거 그쵸, join 프로젝션이나 그런거 해가지고 너네들이 알아서 쓰는거고 우리가 그래서 sql 주는거잔아 그건 너희들이 알아서 쓰고 우리는 데이터 는 무조건 이렇게 되니까 알아서 닥치고 일단 써 이런식으로 나온다 그러니까 디벨로퍼 입장에서는 지네들이 생각하는 그런 생각 코딩을 하기 위해서 지네들이 생각하는 그런 것과 실제 데이터 가 저장되고 다뤄지는 그 사이에는 efficient missmatch가 생긴다. 
이런 데서 점점점 반발이 생긴다 이게 시작점이다.
## Attack of the Clusters
자이게 뭐냐면 시대가 바뀐다.
예전에는 컴퓨터 한대만 해도 충분하지만 이제는 그런게 아니다 클라우드 시대에 접어들고 여러대 데이터 센터나 여러대 컴퓨터가 클러스터 단위로 움직이는 이제는 시대가 그렇게 바뀌게 된다. 근데 아까 말씀드렸죠 기본적으로 rdms 같은 경우는 걔네들은요 이 클라우드에 클러스터에 그닥 잘 맞지가 않다.
잘생각해보면 테이블을 만들었어, 그다음에 테이블을 가져다 수천 수만개 만들어서 생각해봐 그러면 어떤 테이블은 어디다 두고 또 어떤 테이블은 어따가 저장할꺼야 
클러스터 가 여러분들에게 100대가 있따고 주어지면 가정하면 여러분을 테이블을 10만개 만들었어 그러면 어떤 테이블을 어디 클러스터에 어떻게 넣을거야 무슨 기준으로? 어디다 넣을거야 
자 명확한 해결책이 없다. 그런 한계점이 생긴다. 실제적으로 rdms는 클러스터와 잘맞지 않는다.
할려면 할 수 있지만 효율성이 떨어진다.
자그러다 보니까 지금 시대에 와서는 자그런식으로 클러스터가 여러개 싼, 서버들이 묶어서 클러스터 시대가 접어들게되는데 
그닥 잘맞지 않다.
그리고 그러다 보니까 기존에 있던 사람들이 이제 똑똑한 사람들은 세상은 항 상 넘친다. 그사람들이 아이디어를 만들게 된다.

Gooqle Big Table 논문은 굉장히 유명한 논문이다. key-value store다 기존에 릴레이션 데이터 베이스를 가져다 뒤짚어 버린 굉장히 독특한 방식의 데이터 저장 모델을 가져다 구글이 제시를 한다. 그게 빅테이블이다. 그리고 아마존도 자 지네들이 맞는 데이터베이스를 만든다. 그게 아마존 Dynamo 인데 
그런데 아마존 입장에서도 지네들 기존 에 갖고 있는 rdms 를 쓰니까 굉장히 불편하다. 지네들이 그 많은 모든 커머셜 그런 트랜잭션을 다루기에 잘 맞지가 않다. 그래서 지네들이 그래서 고민을 하다가 그럼 닥치고 엔지니어 열심히 쪼아가지고 새로운 하나 만들자 그래서 만든게  
Amazon Dynamo 이다.
실질적으로 아마존에 뒷단에 있는 데이터 베이슨느요 오라클 안쓴다. 걔네들은 지네 자체 에있는 데이터베이스는 Dynamo를 쓴다. 
실제 지금도 쓰고 있다.
자 어쨋든 이런식으로 메이저에있는 실리콘 밸리에 있는 메이저 밴더들이 하나씩 하나씩 새로운 아이디어를 만들어내기 시작한다.
그래서 나온게 nosql이다.

## Nosql
자 여러분 들었던 얘기죠 그쵸 쓸대없이 길게 얘기했다.
어쨋거나 nosql 이라는거다
nosql은 nosql이 아니고, 사람에 따라서 nosql이라고 말하는사람도있음 통상적으로 nosql은 처음에 사람들이 기존에 있던 sql, 릴레이션 데이터베이스에 반대하는 사람들 이 많았기 때문에 좀 강하게 가서 찾는사람들이 nosql 정말 not anymore sql 우리는 sql 따위 안쓴다 관점에서 시작된건 맞는데 차츰 만들다 보니 sql 의 struct를 안쓸수가 없다.아시겟죠 
그러다보니 실제 nosql 이라고 해놨지만 그런 프레임워크나 아키텍쳐를 보면은 그 케이스바이 케이스가 다른것이다. 4가지를 훑어준다 대부분다 보면요 어느정도 까지는 그 struct 된 그런 sql 에 그런 struct 를 가져다 데이터 모델링을 쓴다. 
그러다 보니 걔네들도 살짱쿵 머쓱해져서 사실은 뭐라고 얘기햐냐면 not only sql 이라고 통상적으로 더많이 옴
왜 실질적으로 안타깝게도 nosql 이라는것을 가져다 얘네들이 특별히 offical 하게 standard 시켜서 새로운 정의는 아직 없다.그러다보니 사람들 사이에 저런 왈가왈부가 있는것이다.
근데 요즘은 거의 대세로 nosql 이란 얘기가 not only sql 이란 얘기 도 거의 굳어져 가고 있다.
자 그리고 이게 왜 나오게 됐냐면 아까 말씀드렸다 싶이 빅데이터 시대에 접어들면서 얘네들이 득세를 하기 시작한다.
요즘은 사실 오라클 db는 정말 써야되는대만 쓰지 대부분은 그렇게 잘쓰진 않는다.
실제 구글이나 그런데는 지네들이 만든 db 지네들이 쓴다.
아마존도 그렇다 왜냐하면 nosql db도 굉장히 다양한것들이 많이 나왔다.
그런것들을 가져다 쓴다. 그러다 보니까 뭐 
빅데이터를 저장하는데 좀더 적합한 그런 데이터베이스 모델이 nosql 이다. 
얘네들 보면은 그 main feature를 살짝 살펴보면 

자 sql 을 쓰지 않는다. 그래서 이제 nosql 이라고 하고 릴레이션 모델을 쓰지 않는다. 그래서 얘네들은 더이상 관계형 데이터 베이스가 아니다 대부분 오픈소스이다.
공짜 
대부분 오픈소스, 공ㅉ짜
그래서 굉장히 빠르게 전파가 된다. 아마존
오라클 이 더많은돈을 받기 시작하면서 사실은 더 반감이 생겼을수도있다. 어쨋거나 무료라는건 굉장히 큰 이점 이기 때문에 굉장히 빠르게 회사에 침투를 하게 되고 그럼 얘네들이 클러스터에 굉장히 잘맞는다.
잘맞는 모델임 그러다 보니까 분산 환경에 잘맞는다.
스키마가 없다. 스키마리스 그래서 뭐 책에 따라서 스키마 프리 책에따라서 db시간에 스키마 프리라고 배웠을지도 모르겟다 어쨋거나 얘들은 스키마 리스 형태이다.
그리고 굉장히 간단한 api를 제공한다. 실제 보면 sql 보면 복잡하다. sql은 시험에 나오면 sql 쓰라고 하면 머리 복잡하다 
몇개 꽈 가지고 테이블 몇개 그륩 바이 몇개 묶고 그러면 
정말 머리 쥐난다. 
복잡하다 그런거랑 달리 얘네들은 굉장히 간단한 api를 제공한다. 간단한 api를 제공한다는걸 여러분들 이 코딩 하신분들 알겠지만 굉장히 큰 이점이다 api가 심플하단얘기는 결과적으로 스케일빌리티가 좋아진다는 얘기다 
api 가 심플하다는 얘기는 성능ㅇ ㅣ굉장히 좋아진다 결과적으로 그렇게 비교가 된다. 실질적으로 얘네들 성능 이 훨씬좋다
그 mysql 혹시라도 심심하면 웹 뒤져서 찹터 비교해보면 성능을 비교해보면 비교도 안된다 마리아 디비랑 
얘네들 nosql 랑은 몽고디비 카산드라 디비는 성능이 말도안되게 좋다.
자 뭐 조금 sql nosql 이라면 아침에 자료를 만들다 보니 
있어 보여서 카피앤 패스트 넣었는데 이게 
설명 잘되어있다.
간단해서 명확하고 그렇다
sql의 장점을 보면 아직도 쓰인다. sql은 장점이 뭐냐면 관계형 데이터가 뭐가 좋냐면 그 struct 데이터에 굉장히 잘맞는다 지금까지 예전에 데이터 저장 된것은 대부분은 struct 데이터 였고 그 럴수밖에 없다. 옛날에는 데이터가 대부분 텍스트 데이터 였음 
텍스트 나 숫자형 데이터는 구조가 명확하게 데이터 타임이 명확하다. 그런데 여러분들이 페북에 열심히 올리는 그런 사진들이 무슨 struct 데이터 인가, 아니잔아 그러면 struct가 없다. 근데 빅데이터 시대에 들어오면서 텍스트 데이터는요 20%도 안된다. 
10% 도 될까말까 10~20% 통상적으로 말한다 나머지그 엄청난 데이터 80~90% 데이터는 unstruct 데이터다 구조화되어있지 않은 데이터 에다가 저장을 해야하는데 구조화되어있지않은 데이터를 가져다 구조화 되어있는 데이터 베이스 인 그 sql 그런 릴레이션 데이터 베이스에 넣으면 작동이 제대로 될리가 없거나 성능이 굉장히 느리든지 그래서 성능이 굉장히 느린것이다.
그치만 그렇든 말든 어쨋거나 굉장히 struct 가 되어있는 걔네 그런 데이터 경우는 굉장히 잘맞고 성능이 좋다. 실제 그런 형태 형태에서 굉장히 좋은 성능을 보여준다.

그럼이제 트랜잭션 하죠, 당연히 트랜잭션 베이스니까 그리고 퍼포먼스가 실제 struct data 경우는 퍼포먼스가 굉장히 좋을수밖에 없는게 오랜시간에 걸쳐서 퍼포먼스 옵티마이제이션을 계속 해왔기 떄문에 그렇다. 그런데서 굉장히 좋은 성능을 보여준다.

그럼이건 어느정도 프루브된 테그널러지 이다. 오랜세월 거쳐서 이제 그런 반면에 nosql은 not 릴레이셔널 데이터 에 굉장히 잘맞고 언 스트럭쳐 데이터 자 여러분들이 struct 되어있지 않은 그런 데이터에 굉장히 잘 맞는 모델이다.
그리고 말씀드렸다 싶이 스키마가 없다.
어떻게 보면 일맥 상통하는 부분이다. 
스키마 리스이기 때문에 그런 스키마 리스 아키텍쳐이기떄문에 얘네들이 그런 그 언스트럭쳐 데이터에 굉장히 잘맞는다 그리고 굉장히 그 변화 업데이트 라든지 여러분들이 쓴다 라든지 읽는다라든지 그런경우에 잘 맞는 케이스고 얘네들이 굉장히 스케일빌리티가 좋다. 말씀드렸죠 이게 애시당초 디벨롭 될떄 그 시대자체가 클러스터로 계속 만든거였기 때문에 어 스케일빌리티가 굉장히 좋습니다. 근데 항상 그렇듯 장점만 있나? 자, sql 기존에 있던 그 릴레이션 데이터 베이스 경우는 스케일빌리티가 힘들다. 
스케일 하기 힘들다 
애시당초 염두해 두고 만들어진 그 데이터 아키텍쳐가 스케일빌리티를 염두해두고 만들어진게 아니다 그래서 그런 명확한 한계점이있고 그 스키마 같은 경우는 이 데이터 베이스 코딩 해봐서 알죠, 스키마 이미 초기에 이미 fix 시키고 시작한다. 스키마 디자인 을 하고 나서 여러분들 이 코딩하잔아 
그러다 보니 스키마가 fix 가 되다 보니까 flexible 하지 않다.
어느게 내가 더 필요해서 뭔가를 더 추가할때 그 테이블 을 추가할수있긴 하지만 테이블을 가져다 추가해야 하는 그런 문제점이 생긴다.
사실은요 그러는 반면에 얘네들 같은 경우는 nosql 같은경우는 어떤 장점이 있냐면 아직까지 ing 하는 한마디로 ing다. 
그래서 수십년동안 40~40년동안 그렇게 이렇게 계속 업데이트 되어와서 굉장히 이제 증명된 아니면 그런 증명된 기술방식은 아니다.
아직은 버그가 있다. 써보시면 압니다. 
자 멀쩡하지 않다.
라는 문제점이 있고 그리고 이제 response time이 어 당연히 어 관계형 데이터 베이스보다 느릴수밖에 없는게 얘들은 애시당초 그런 인트럭션 데이터로 만들어진게 아니다. 
그래서 얘들은 리스판스 타임이 살짝쿵 느리다.
자그리고 sql 같은 경우 아까 다 말씀드렸죠 mysql
mysql 경우 굉장히 많이 쓰였다.
오라클 데이터베이스가 제일 많이 쓰였지만 워낙 비싸기 떄문에 
기업에서나 쓰는거고 우리같은 사람들 릴레이션 데이터베이스를 가지고 뭔가 작업할때는 거의 대부분 사람들이 썻던게 next choice가 뭐였냐면 mysql 이다. mysql에서 썻다. 
mysql이 누가 먹었냐면은 바로 그 오라클이 먹는다. 치사하게 라이센스비를 받는다.
그러면서 사람들이 

그래서 마리아 db가 나오게된다.

어쩃거나 이런 example이 굉장히 많다. 얘네들이 유명한 그런 그 데이터베이스이다. 
마리아 db가 마이sql에 자식이다.
아시겟죠 걔네 엔지니어들이 만든 db는 사실 굉장히 잘만들었다. 그런 틀임
nosql 경우 여러분들이 쓰실 일은 없는 db 다이나믹db
여러분들이 한번 정도 들어볼 만한 몽고db, 카산드라 유명하다. 
프레임워크다. 
굉장히 많은게 나온다.
## NoSQL Data Models
자 그럼 nosql 데이터베이스가 그럼 데이터를 가져다 어떻게 모델링을 하느냐 지네들이 실컷 기존에 있던 rdbms를 깟으니 자 그러면 걔네들은 어떻게 하니 라고 한번 우리가 살펴볼 필요가있다. 얘네들ㅇ ㅣ데이터 모델링 하는 방식은 기존에 있던 릴레이션 데이터 베이스에 모델링 하고는 살짝 다르다. 
자그러면 데이터 모델이라는 얘기를 제가 했는데 데이터 모델이라는 얘기는 어떤 정보나 어떤 인포메이션이 있을때 그걸 가져다 어떻게 표현할 것인지를 얘기이다. 기존에 있던 릴레이션 디비 같은 경우느 과연 릴레이션 데이터베이스 경우는 걔는 데이터를 어떻게 모델링했냐면 여러분 아는것처럼 테이블 이나 칼럼 그걸로 row 라는 개념을 써서 걔네들이 데이터를 가져다 리프레젠트 하게 된다.
그렇죠 근데 얘네들은 조금은 다르다. 
그게 이제 데이터 모델이고 그거랑 달리 스토리지 모델이라는것도 있다. 데이터 모델이라는것은 조금은 로직 컬한 개념이다. 유저입장에서 조금 로직컬한 데이터
데이터가 눈에 보이지도 않는데 그게 어떻게?
그 데이터 모델은 그렇게 되고 로직컬하게 그런 데이터를 가져다 어떻게 모델링 하느냐 에 관점에서 바라본것이고 스토리지는 실제 그러면 여러분들이 데이터를 모았다가 로직컬하게 설계를 했을지언정 실제 데이터 하드디스크나 엑세스 중에 그런 저장되는 데이터 모델은 다르다.
그거는 매체에따라 디팬던시가 생기기 때문에 달라진다. 그게 스토리지 모델이다.
그리고 대부분 일반적 나오지만 데이터 모델은 통상적으로 그런 스토리지 모델과는 별 상관이 없다. 왜냐하면 그거는 어 디벨로퍼나 아니면 우리 일반유저들이 생각하는 로직에 맞춰서 만들어지는게 데이터 모델이다. 그래서 피지컬하게 어, 관점에서 바라보면 그 스토리지 모델 과는 살짝 거리가 있다. 자 그럼 데이터 모델에 대해서 실컷 얘기를 했는데 자 그러면 nosql에 대해서 얘네들이 어떤 데이터 모델 을 하느냐 
크게 나누면은 두가지이다. 
aggregate model 이 있고 나머지 하나는 graph-base-model 이다.
자 그리고 aggregate model 같은 경우는 다시 3가지로 나뉜다. 
보시면 키-벨리유 스토어 / 다큐멘터리 데이터베이스 / 칼럼패밀리 데이터 베이스 
이 3가지이다. aggregate model은요 
에그리 게잇이 뭐냐라고 물어보면 다음 페이지에서 해주겠다.
일단은 요런게 있따. 크게 2가지로 나뉘고 그래프 베이스 모델은 여러분들ㅇ ㅣ아는 소셜 네트워크 같은 그런 식으로 데이터를 가져다 그래프 형태로 아시죠, 그래프 와 트리의 차이는 다 아시죠 데이터 스트럭츠 배우셨으니까 자 그래프 형태로 데이터를 갖다가 모델링 해서 표현을 하는게 그래프 베이스 모델링 이다.
앞으로 제가 요기서 통해서 각각 하나씩 키-밸리유 / 다큐멘터리 데이터 베이스 / 칼럼 -패밀리 그래프에 대해서 4개에 대해서 하나씩 하나씩 훑어 나가겠따.

## aggregate-oriented data model
aggregate 정의부터 하고 가자.
말만 했는데 자 aggregate oriented data model 이라는게 나오는데요 이게 뭐냐 
자 이거보시면 이 aggregate 라는 말이 나오게된거는 굉장히 최신이다. 아 실제로 nosql 데이터 베이스가 나오기 시작하면서 나오기 시작한건데 이게 어디서 나왔냐면 domain-driven design 이라는 자 이런 관점, 개념이 나오면서 도메인 드리븐 디자인 이라는 그 관점 그 도메인 내에서 나온 단어가 이 에그리게잇이다. 물론 여러분들이 유행?을 배우시면서 aggregate 이니 composition 이니 다 배우셨을거라고 생각하는데 그 aggregate 이랑 어떻게 보면 굉장히 비슷한 aggregate 이다. 
자 이 도메인 드리븐 디자인이 뭔지부터 살짝쿵 살펴보면 지금까지는 여러분들이 릴레이셔널 데이터베이스 에서는 자, 애플리케이션 디벨로퍼가 뭔 생각을 하던 그 여러분들이 애플리케이션 의 도메인이 뭔지든 얘네들은 전혀 생각하지 않아 
아시겟죠 걔네들은 그닥 관심없어 개네들은 스키마를 만들고 그 각각 테이블 을 갖다가 저장 하고 그거를 갖다가 조인을 하던 프로젝션을 하든 뭔가를 하든 지네들에 그 데이터를 가져다 저장하고 프로세싱하는 거기에만 걔네들이 그 관점이 맞춰져 있는것이다.
아시겟죠, 그런데 거기에 그것떄문에 문제가 생겨가지고 나오기 시작한게 그 nosql 이었다 그러다보니까 사람들이 이제 어떻게 생각하게 되냐면 그게 아니라 여러분들이 디벨롶 하고 있는 여러분들이 관심이 있는 그 도메인 , 에플리케이션 도메인 관점내에서 모델링을 하자 라는것임 왜 그런식으로 실질적으로 디벨로퍼는 그관점에서 디벨로핑을 하는거냐 애플리케이션, 소프트웨어을 만드는데 왜 니들 멋대로 니네들은 그딴식으로 밖에 안하느냐! 거기에 불만이다. 이 도메인 드리븐 디자인이 그것이다.
그런데 도메인 관점에서 데이터 를 모델링하고 그렇게 하자라는 얘기임 그 관점에서 나온게 단어가 aggregate 라는게 거기서 나온다.

이떄 이 aggregate란 얘기는요 자 
A collection of related data that we treat as a unit 이렇게 나온다. 그 얘기이다. 여러분들이 그 어떤 코딩을 하거나 아니면 디벨로핑을 하거나 뭔가를 할때 자, 어느 한 데이터 덩어리를 다루고 싶을거다. 아까처럼 여러분들 어 아마존 온라인 서비스를 만약에 만든다. 가정해봤을떄 보여줘ㅉ죠 스키마 경우는 rdbms 경우는 테이블을 잔뜩 만들어놓는다 그리고 저장한다 끝 물론 뭐 그걸하기 위해서 sql 줍니다. 끝
알아서 써
근데 그게 아니라 아까 제가 보여드렸다 싶이 저게 어디 나오나요
이런것처럼 실제 자 rdbms는 지네들 이런거 하면 끝이지만 실제 여러분들이 소프트웨어를 짜거나 디벨로핑을 하게 될거같으면 유저나 아니면 디벨로퍼, 이관점에서 바라보게 된다. 
이관점에서 코딩을 하고 이관점에서 데이터를 다루게된다.
이렇게 서로 연관이 있는 데이터하나에 그런 유저들 
그게 뭔지는 철저하게 여러분들 애플리케이션이나 소프트웨어에 따라서 달라진다. 도메인 따라서 달라진다. 그래서 도메인 드리븐 디자인 인것이다.

아시겟죠, 철저하게 그것은 도메인 따라서 달라지는것이기 하지만 그렇게 바라보는 이 덩어리 요 유닛을 가져다 우리는 어.. 
여기서 말하는 aggregate 라고 말한다. 
A collection of related data that we treat as a unit 이
요게 어 요것만 자체보면 헷갈릴 수있는데 이뜻이 제가 방금 말씀드린그것이다. 그게 aggregate 다 
그리고 이게 고 단위당 얘네들은 기본적으로 nosql 데이터 베이스는요 acid 에 그닥 뭐 관심이 있지 않다. 얘네들은 
목적은 그게 아니다, 애시당초 태생이나 그 거기에 있는게 아니다.
그러다 보니까 acid 따위는 깔끔하게 무시를 해주는데 그렇다고 이걸 가져다 완전하게 무시할 수없기 떄문에 얘들도 어느정도로 레벨까지는 acid를 제공해줘야하는데 그 단위, 바운더리가 되는게 aggregate 이다. aggregate 단위로 얘네들이 acid 의 프로퍼티를 가져다 만족시킬려고 노력한다.

자 그리고 마찬가지로 컨시스턴시, 트랜잭션 베이스 가 되는 그런 컨시스턴시나 그런것도 이제 데이터를 모니터지를 하거나 그런 manage 하는 그런 단윙 역시도 이 aggregate이 단위가 된다.

근데 자 대충 자세히 모르겠지만 얼추 aggregate이 뭔지는 알겟어 그러면은 얘네들이 요런식으로 하면 뭐가 좋으냐 라고 써놨는데 이미제가 말씀드렸다. 
애플리케이션 프로그래머가 굉장히 편하다.
그렇죠 데이터모델링 자체가 그런식으로 그런관점에서 바로 지네들 관점에서 바라보고 모델링을 해놨기떄문에 코딩하는 사람 입장에서 굉장히 편하다.
그리고 이제 어 클러스터 어 관점에서도 이게 클러스터에 굉장히 잘맞는 모델이 된다. 왜냐하면 그 하나 자체가 굉장히 독립된 단위로 움직이기 떄문에 그거를 가져다 어떠한 ??? 해도 상관없다. 왜냐하면 지네들 관련된 걔네들끼리는 같은 클러스터에 같이 들어간다 아까 말씀드렸다싶이 그냥 테이블 단위로 스키마 단위로 그걸가져다 그냥 미친듯이 짝 저장해놓으면 어떤놈이 어따 넣어야 하는지 굉장히 큰문제가 생긴다. 지네들끼리 어떤 연관성이 없잔아요 그 연관성은 여러분들이 sql을 이용해서 여러분들이 만들어야 한다. 그러다 보니까 그 확장성 이 굉장히 떨어지고 클러스터에 잘 맞지가 않는 모델이지만 얘네들 경우는 서로 연관이 있는 그런 하나의 덩어리를 가져다 어 aggregate이라는단위로 바라보고 그 단위로 데이터를 처리하기 떄문에 클러스터 관점에서 굉장히 잘 맞는 모델이고 
그리고 스케일빌리티 어, 굉장히 유리한 그런 모습을 보여준다.
실질적으로 그 밑을 보면 Retrieve 라고 나오는데 실제 클러스터에 따라 그 단위를 갖다가 데이터를 다루게 되면은 여러분들이 데이터를 retreieve 해가지고 패치 해서 가지고 와도 마찬가지다.
여기 저기 서 패치해가지고 프로젝션 하고 온 섹션널을 할 필요가 없다. 원래는 데이터들이 모여있는 그 애???? 걔내들 놈끼리 ??? 데이터를 패치해오면 되는거이다.

그래서 어 성능도 훨씬더 좋아질 수 밖에 없다.
자 그래서 어 구체적인 예를 보여준다. 예를 보면 조금더 이해가 갈것이다.
이게 지금까지 아까까지 봤던 그런 온라인 상에서 여러분 아마존 하나 만든다고 가정을 해보자.
예를들어서 그런 온라인 프로그램을 하나 ?? 사거래 프로그램을 하나 만든다. 라고 가정했을때 그거를 가져다 이제 모델링을 할려고 하는것이다. 어. 이런식으로 uml 다이어그램을 이용해가지고 자 이런식으로 만들 수 있다고 가정해보자 그리고 보면 커스터머가 있고 당연히 그 커스터머가 주문 한 오더가 있고 그렇죠 커스터머를 갖다가 당연히 빌링 어드레스가 있고 어  십핑 어드레스가 ㅇ있고 
빌링 어드레스, 십핑 어드레스 다이제 커스터머 단이고 
오더 입장에서 바라보면 자 페이먼트, 라든지 그리고 아이템이 뭔지아이템을 뭘 삿는지 그리고 크레딧 카드로 삿는지 현금으로 삿는지 그거에 대한 페이먼트가 있고 
어떤 아이템을 삿는가 
에대한 요런 데이터 형태가 있다고 가정을 해봅시다 
이거를 가져다 우리가 모델링을 한다고 가정하면 기존에 있던 rdbms로 구현한다. 그러면 여기도 그냥 쉽게 이해가 올것이다. 그렇죠 
이렇게 테이블 만들고 그전에 스키마를 먼저 만든다. 여러분들이 생각을 해야한다. 스키마 를 여러분들이 만들고 그리고 그 데이터 를 갖다가 스키마 에 맞게끔 데이터 테이블 을 가져다 만들고 거기다까 데이터 를 이런식으로 넣을것이다.
커스터머를 
각각 프로덕트 라던지 빌링 어드레스 각각 
각각 존재하는 각각 오브젝트에 대해서 여러분들이 스키마를 만드실꺼다 스키마를 만들고 테이블을 만들것이다. 릴레이션 데이터베이스 경우는 
굉장히 직관적이다.
요렇게 할것이다. 우리게 aggregate 이라는 그런 관점에서 nosql 데이터 베이스 관점에서 바라보고 우리가 그것을 구현을 하게 될것같으면 자 일단은 자 요렇게 될것이다.
한가지 예다. 요렇게 해야된다는것은 없습니다. 자 일단 한가지 posibble한 aggregation 달아보면 customer 관점에서 한번 여러분들이 바라보게 됩니다. 그래서 어떤것들 끼리 연관되어 있는 데이터 인지 데이터 청크들인지 그런 ??? 끼리 이렇게 바라보게 된다. 그리고 또한가지더 order 주문 , order 관점에서 바라보게 되면 또 하나의 관련되어있는 오브젝트들 이 나올것이다 요두 개의 관점에서 이 두개의 관점을 잘라가지고 자 각각을 갖다가 aggregate이라고 바라보고 그 단위로 모델링을 하는것이다.
자 근데 어느정도 make sense 한게 뭐냐면 이 커스터머 라는게 여러분들이 코딩을 하면서 생각을 해보자 커스터머 갖다가 여러분들이 데이터를 가져다 끌어오게되면 당연히 이 빌링 어드레스는 쉽핑어드레스 라든지 그런것을 당연히 가지고 올수밖에 없다.
당연히 쓸수밖에 없다. 그런것을 쓴 맵이 이걸 갖다가 모델링을 해놓은건데 기존에 있던 이거같은 경우는 커스터머 때는 지네들끼리 따로 놀앗잔아 
프로젝션 해서 니네들 알아서 쓰세요 이거잔아 
그런데 얘같은 경우는 요런식으로 덩어리 묶어버리면 데이터가 연관이된 데이터끼리 하나씩 묶여 져 있게된다. 이게 aggregate 이다 이렇게 해서 데이터를 갖다가 다시 표현을 하게된다.
기존에 UML을 바꿔가지고 
그래서 커스터머는 자 어 .. 블랙 다이아 모드는 음.. 컴포지션인데 화이트 다이아몬드가 aggregate 겠다. 어쩃거나 뭐 여러분 뭐라그러지 마라 복붙했다.
자어쨋든지 간에 이 커스터머 입장에서 바라봤을때 하나의 그런 aggregate 모델의 유행의 모델이 나오게 되고 
order 입장에서 바라봤을때 저 하나의 요런 덩어리가 다시 나눠지게 됩니다. 요 지금 두개의 aggregate에서 바라봤을떄 UML 모델은 이렇게 각각 달라진다. 그거를 가져다 구현을 한다 라고 가정하면 물론 요거는 다큐멘터리 db 일경우만 그렇다. 오해하지 마라
이걸 가져다 
다큐먼트 그 4가지 nosql 형태중에 다큐먼트 db로 저것을 표현했을떄 이런식으로 표현이된다. 물론 이유는 어 익숙한 사람도 있겠쬬 재이슨 ??? 재이슨을 갖다가 했을때 이런식으로 표현이 가능하다. 실제적으로 제이슨이나 비사를 많이 쓰죠???
아니면 xml도 많이쓴다. 어쩃거나 요런식으로 구현이 될것이다. 커스터머 관점에서 하나의 aggre gate이 나오고 order 관점에서 하나의 그런 또다른 aggregate이 나올것이고 
관점을 요렇게 바라보고 합니다.


그러면 그게

## Aggregate impplementation
정답이냐? 정답은없음
aggregate를 말씀드렸죠?
여러분들 상황에서 그리고 아니면 도메인 따라서 애플리케이션에 따라 달라진다.
요거는 조금 다른 관점에서 바라본다.
이제는 커스터머 관점에서 바라본다.
아까전에는 구지 말하면 order 관점에서 바라봤다.
이제는 커스터머 관점에서 하나 바라보고 전체 하나묶어가지고 왜냐하면 이 order라는것은 결과적으로 어쩃거나 커스터머와 연관이 되어있다. 이 커스터머가 이 order 랑 내에 있느거아니야 	
그렇게 바라보면 이 덩어리 하나 전체를 그냥 하나의 	 aggregate로 볼수도있는것이다. ( 뒷페이지인듯)
할 수있다 그렇다 그렇게 해가지고 이제는 그런식으로 커스터머 밑에다가 이런식으로 uml 이런식으로 새로운 모델링을 하고 이를 갖다가 구현을 할떄 재이슨을 쓰든 xml을 쓰시든 써가지고 구현을 할떄 커스터머 관점에서 커스터머에 aggregate를 만들어주고 그 속에다가 다 집어넣을 수 도 있는것이다.
자 
tgif = thanks god it's friday. 
