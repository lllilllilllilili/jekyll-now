## Ex: File Sharing~
fd1, fd2에 한 file씩 복사한다.
1 byte씩 읽어서 fd2에 써넣는다.
중간에 fork()는 child, parent도 아래 같은 code를 돌린다.
fork()가 하나더 들어가면 프로세스가 total ==4개==가 생긴다.

fork() 실행시, open file도 물려받지만, r/w offset도 공유한다.
parent 1byte 읽으면 r/w 하나 가지면, child는 뒤에서부터 읽는다.(shared)
parent와 child는 r/w 같은 것을 읽지 않는다. // read, write 같이 공유한다.

fork()시, child 생겨서, child도 while lop을 돌면서 write을 한다. 
while(read...)
write()  1)
read 할때 rock하고 write할때 release함. mutual exclusion(상호간에 배제한다.)
parent와 child 사이에 mutual exclusion만 필요하지 다른 관계는 필요없다.

## Inter~~
IPC = 프로세스끼리 통신, 리눅스는 많은 툴을 제공한다.
pipe: circular queue 제공(In Linux), queue 공유해서 문제가 생긴다. 이런문제가 없게 pipe 방법
- named pipe : 가상적인 파일을 만들어서 관련없는 프로세스끼리 도는것
- unnamed pipe : 프로그램이 끝나면 자동적으로 없어짐, 부모 - 자식 원형 큐 제공

하나는 프론트로 쓰고 리어로 쓸것이다. r/w offset 2개

동기화 : block됬다가 깨워주면 동기화됨
파이프가 비어있음, 읽을려면 block 되서 기다린다. 큐에서 무언가 날라올때까지 block되어있다.

꽉차면 집어넣는 process가 block되고 또 비면 깨어나서 데이터 전달
pipe는 block된것을 깨주는 역할을 한다.

파이프는 통신도 하지만 block을 깨워주기도한다.
파이프는 가상파일이라고 생각, fifo 파일이 2개가 있어서 하나는 읽을때쓰고(프론트),쓸때쓰는것이다.(리어) 파일을 두번 오픈한다.
mutual protocol을 자동으로해준다.
파이프가 비어있는데 읽을려 하면 block된다.
파이프에 뭐가 하나 들어오면 깨어나서 그것을 가져오고, 파이프를 close해도 깨어나게된다.(receiver 입장이다.)

writer는 pipe는 꽉차게 되면 블락되고, receiver 쪽에서 받아서 빈칸이 생기면 writer는 깨어나서 쓰게된다.

```
child - 쓰는 역할
parent - 읽는 역할
pipe는 r/w offset이 두개 필요, fd[0] - 읽기 전용, fd[1] - 쓰기 전용으로 쓸것이다.
if(fork()==0){} //child도 open file을 물려받는다. parent에서 2번 child 2번해서 파일을 4번open 했으므로 close도 4번해야한다.
파이프에다 쓰기만 할꺼니까 read는 버린다. close(fd[0])
input으로 write하고 close(fd[1])한다.

parent 도 pipe도 2개를 물려받음 쓰는게 필요없으니 닫아주고 output 파일을 하나 만들어주고
pipe에서 읽어주고 있다. pipe에서 10바이트씩 읽어받고 output 파일에 copy 한다.
다읽었으니까 wait()해서 child가 죽기를 기다린다.
프로그램이 끝나면 pipe가 끝나면서 unnamed file 이라 불린다.
```

## Shell~
a.out돌리면 화면으로 나옴, 양이 많고 빨리 지나가면 more는 1page씩 보여주고 yes/no 로 물어보고 넘어간다.
a.out은 standard OUT으로 나가지만, more는 키보드 에서 입력을 받으니까 standard Input |는 pipe다.
a.out 나가는 아웃풋을 pipe에다 써라! more라는 프로그램은 키보드 에서 받아야 하는데 이제는 pipe에서 받는다.

## 쓰레드
variable 같은걸 쓰면 문제가 생긴다.
mutual exclusion으로 해결한다.

pthread_create(routine1) 3개 쓰레드 생긴다.


