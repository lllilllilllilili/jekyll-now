---
post : layout
title : 컴퓨터구조(기)10
---
## 복습
메모리 계층 구조를 배우고있는데 정리하면
메모리시스템이 여러개의 계층으로 구성되어있고 각 계층의특징을 보면 아래계층일수록 용량은 크고 엑세스타임 속도는 느리고 위의 계층일수록 용량은 작고 대신 속도는 빠른 여러계층의 매체들로 전체 메모리 시스템이 구성되어있다. 그래서 그들간에 서로 갖고있는 장점을 효과적으로 활용하기 위해서 우리가 채택하는 방법이 뭐에요, 캐싱이라는거임 캐싱이라는건 아래계층에 있는 어떤 데이터를 위의계층에 복사해놓는것을 다 캐싱이라고 한다. 어떤 계층이던지 그래서 어 캐싱을하는데 우리가 어떤 정보를 위에 있는 계층에서 그 정보를 찾는과정 을 우리가 뭐 데이터 룩업 이라고 데이터를 탐색한다 그렇게하는 거기서 우리가 데이터를 찾으면 히트됬다고 한다.
만약에 거기서 이제 못찾으면 미스 됬다 라고 하고 그럼 어떻게 되? 거 바로 아래 계층에서 그 데이터가 있는지 살펴본다.
그렇죠 
어 그리고 또 중요한건 그러면 그 계층과 계층사이에 데이터가 전달되는데 그 전달되는 단위 전송의 단위는 어떠냐, 우리가 보통 여러개의 워드로 구성된 블락 단위로 데이터가 전송된다. 그렇게 얘기를 했죠 그렇져
블락단위다. 프로세스에서 큰 불행??은 예를들면 우리가 load word 어 이거 필기된거 ppt에 있음.
lw t0, ?, 4(r1)
R1이 갖고있는 주소 + 4 번지에 있는 한 워드를 읽어오란 얘기다. 원래는 프로세스에서는 한워드만 읽어오라고 명령을 내리지만 메모리시스템에서는 그 워드 가 포함되어있는 블락을 올려보낸다. 물론 그 블락이 한 워드일수도있다. 설계에따라서
그런데 보통은 어떻게, 두개 이상의 두개이상의 복수개의 워드들로 구성되어있다.그떄그 워드의 개수는 2의 지수승개다. 두개나 네개나 여덟개나 이렇게 
그래서 점점 그 블락의 크기가 점점 증가하는 추세에있다. 현재 컴퓨터시스템에서는 그블락의 크기가 

## 이거내가 주말에 한번 그 따라가면서 연습을 해보라했는데 
## Cache Example
캐시블락이 8개가 존재하고 각각의 어 블락마다 한워드, 예제로 연습용으로 그리고 다이렉트-맵드로 동작하는 메모리시스템이 있다고할때 처음에는 이건 지난번에 내가하다가 머.. 하다가 이렇게 잠깐 쓴건데 처음에는 다 데이터가 없으니까 캐시가 비어있겠죠 그렇죠 그때는 모든 valid data가 No 로 in-valid 상태이라는것을 알릴것이고 다 비어있을것이다. 
그다음에 지금 한 로드에 한 블락이니까 워드 가 한 블락이다. 근데 워드 어드레스가 지금 22번이다. 22번이면은 바이너리 어드레스로 따지면 이거는 데시말이라고 써줘요 10진수
어..
그러면 10110이 22를 나타내는 어 2진수이고 저거 자체가 뭐야, 저거 자체가 블락 어드레스임
이거 자체가 블락 어드레스임 그러면 지금 저 블락이 어디로 올라갈까 다이렉트-맵트에서는 블락 어드레스를 캐쉬 블락의 개수로 나눈 나머지 캐시블락의개수가 지금 8개니까 8로 나눈 나머지인데 지금뭐 8로 나눌 필요가 없다. 저기서 몇비트 
오른쪽에 몇 비트를 보면되? 3비트를 보면된다.
그러면 저때 저 오른쪽 3비트를 우리가 저 블락이 위치할 캐쉬 인덱스 라고 한다. 
캐쉬인덱스 0,1,2 이렇게 있잔아 캐쉬 첨자 
110에 들어간다. 근데 처음에 지금 지금이제 우리가 어떤 상황이냐면 프로세서에서 저 워드를 지금 참조할려고 하는거다 저 워드가 저워드를 메모리에서 가져오려는건지 쓸려는건지 모르겠지만 어쩃든 하여간 저 워드를 데이터를 가져온다고 가정했을떄 로드한다고 가정했을때 어떻게
저 어드레스가 딱 뜨면 오른쪽에 저 110 인덱스를 보고 110 단에 찾아가서 뭘봐? valid bit를 보겠지 그 아까 valid bit가 뭐였지? No 였지 그치? valid bit가 No 면 캐시 hit 야 miss 야? miss다.
그러면 어디로 갔겠어 저거 하나 아래 층 에 있는 메모리로 갔겠다. request가 그래서 메모리에서 해당되는 그런 110에 해당되는 22번 워드를 읽어달라고해서 읽어와서 그걸 일단 어디에 여기에다가 그거를 기록해야한다. 캐시에다가 
그래서 10110에 해당되는 한 워드죠, 한워드
한워드를 여기다가 쓰고 그다음에 여기에 기록해야할 값이 뭐여? tag, tag가 뭐지?
저 주소지에 블락 주소중에서 오른쪽에 인덱스를 제외한 나머지 상위 비트들 그게 tag 라고했다. tag는 tag 캐시에서 tag가 뭐냐 어떤 역할을 하냐 물어보면 뭐라고 해야되? 
캐시 정보중에서 태그는 어떤 역할을 하냐? 어떤 블락에 고유값을 나타낸다. 그런역할을 한다. 구체적으로 말하면 지금 이 캐시인덱스로 올수있는 메모리 블락이 여러개있을 수있다. 그렇지 
어 왜냐하면 오른표 주소중에 블락 주소중에서 오른쪽 3비트를 제외한 오른쪽 3비트가 110 이라고 되어있는 블락들은 다 어디로와? 다 여기로 온다. 이 자리로 
그러니까 이 인덱스 캐시 인덱스에 저장될수있는 수많은 메모리블락중에서 어떤 블락이 여기로 올라와있는지를 밝혀주는 그걸 표시하는 정보다. 이게 
그래서 여기 캐시1 태그는 10으로 되고 
지금 이게 순서상으로 보면 여기서 요거는 이 빨간것은 캐시 미스가 처리된후에 가져와서 여기를 업데이트 한 결과를 보여주고 있는것이고 일단상황은 저 어 캐시 인덱스에 처음에 미스가 났고 그다음에 해당되는 블락을 가져와서 여기를 채워넣고 그다음에 밸리드를 y로 밸러드 상태를 놓고 태그를 10으로 놓고
이게 miss를 처리하는것이다. 
miss는 한번 낫고 
그다음에 26번 워드 역시 워드 어드레스이다. 워드 어드레스이니까 지금 오른쪽 2비트를 떼버린것이다. 바이트 어드레스에서 그렇지 바이트어드레서 오른쪽 2비트를 뗴버린것이다.
역시 뭐에요 바이너리로 보면 11010 이고 010이 인덱스인데 010 여기 지금 처리되는 후보를 지금 보여주는건데 바로 직전상태를 갖는 이게 No였다. No였고 비어있었다. 캐시 미스이다. 그리고 어떻게 가져오지 가져와서 11010워드를 여기다 쓰죠 그렇죠 
그다음에 여기다가 태그는 뭐야 11이지 왼쪽에 
그다음에 두개 22번 , 22번 10110 22번 일단
다시 cpu에서 22번 데이터에 대한 접근이 일어났다. 그러면 뭘 봐야대? 110을 봐야되 캐시 미스 110을 봤더니 뭐에요? valid 해 그렇지? 어! 데이터가 있구나 여기서 그냥 바로 데이터 가져갈수있어? 뭐 해야되? 이 데이터가 내가 찾는 데이터 인지 확인해야되 뭘로? 태그를 봐야해 얘의 태그 정보하고 내가 지금 엑세스 하려는 곳에 태그 정보하고 일치해야지 내가 원하는 데이터다. 
여기 10 그다음엠 여기 10 일치한다. 캐시 힛 이다. 아까 방금전에 읽어다 놓은것이다.
그다음에 26번 , 우리는 뭐 이미 이거를 example을 앞에서부터 봐왔기 때문에 26번 바로 그 앞에서 나온것을 알지만 프로세스는 알길이 없다. 프로세스는 매번 기계적인 동작을 해가지고 그거를 찾는것이다. 26번
11010 , 010 인덱스에가서 거기가 어, yes야 데이터가 있다 이얘기다 역시 마찬가지로  멀 비교해야되? 태그 비교해야해 태그 11 11 서로 같다 히트다. 여기 들어있는 데이터가 자기가 원하는 데이터이다.
## Cache Example(5/6)
그다음에 16,워드 16
10000 인데 인덱스는 뭐지? 000이지 000에 갔을때 뭘 쓸까? 어 No 라고 되어있을테니까 미스다. 미스.
그러면 일단 메모리에서 가져와야 하고 여기다가 데이터를 채워넣고 태그 가 10을 태그에다가 기록해 
3은 뭐야 00 011 이지 011 뭐였어? 011 역시 No 였지 그렇지 미스야 그렇지 여기에 데이터를 가따놓고 yes로 바꿔놓고 ??? 보는거야

16 방금전에 읽었따. hit

## Cache Example(6/6)
18
10010, 10010 아까 
010 , 010 갔는데 yes네 그렇죠
그런데 어 멀 확인해야되? 태그를 확인해야되
여기에 들어있는 태그는 11이다. 자기가 지금 찾을려고하는 태그는 얼마야 여기서 
자기가 지금 access 할려는 블락의 태그는 10이다. 기록되어있는것은 11이고 내가 지금 찾을려고하는건 10이니까 미스 매치가일어났고 캐시 미스야 여기 뭐가있지만 자기가 원하는데이터가 아니야 
미스야.
그래서 데이터를 가져와서 여기다 어떻게 이전데이터를, 이전데이터가 뭐가있었어? 이자리에 - 어, 11010이 있었어 (26) 11010이 있던자리를 이렇게 지우고 들어가서 어 110으로 쓰고 지금 여기서 캐시가 캐시데이터 엑세스 했을때 캐시데이터에 캐시 미스 에 크게 3가지 어 캐시미스타 입이 있는데

## 캐시 미스 타입
1. compulsory
이거는 불가피한 미스임, 어떤게?
캐시가 비어있는데 맨 처음에 데이터를 엑세스할때는 어때 
오는거지 그런 다 메모리에서 가져온다 주로 초기미스 
최초에 해당 블락을 엑세스할떄 발생하는 미스 
그러니까 처음에는 뭐, 캐시가 비어있고 어떤 데이터는 처음에는 다 메모리에서 가져와야한다. 그것을 우리가 compulsory 미스라고 한다.
2. conflict miss
충돌, 캐시 충돌에 의한 미스임
예를들면, 자 여기서 이 예제는 여기서 끝났지만 이 바로 뒤에 만약에 이 바로 뒤에 22번 엑세스가 나온다면 이거 히트야 미스야? 22번 만약에, 18다음에 22가 나오면 미스지
왜냐하면, 여기에 가봤더니 자기가 찾는 데이터가 아니잔아 
원래 tag가 10이라고 기록된데 22번의 tag는 11이잔아 그렇지 그래서로 맞지 않으니까 미스야
그런데 이거는 아까 한번 올라왔었다 22번은 캐시에 그렇지 그러니까 만약에 얘가 18번이 얘를 밀어내지 않았으면 있었을 것이다. 그러니까 캐시에 이미 올라와있었는데 다른 캐시 블락에 의해서 쫓겨나서 해당 블락이 미스가 발생하는경우는 conflict miss라고한다.

첫번째 conpulsory miss는 데이터를 최초에 메모리에서 가져와야 하기떄문에 발생하는 불가피한 미스=>
그러니까 우리가 어떤 프로그램을 돌리면 처음에는 compulsory miss가 대부분이겠다. 대부분 메모리에서 가져와서 캐시를 채워넣어야 하니까 그다음 부터는 어떤 미스가 대부분이야? conflict miss가 대부분임
이미 올라와있는데 그냥 가만이 좀 놔두면 되는데 누군가가 같은 자리에 일치되면서 이전에 올라와있는 놈을 쫓아내서 걔가 나중에 다시 위 access 될때 다시 접근할떄 미스가 발생한다. 그게 conflict miss다.
3. capacity miss
용량이다. 용량 미스, 우리가 뒤에 이제 보겠지만
우리가 이렇게 주소뜨면 걔가 들어가야될 캐시인덱스가 바로바로 정해지는 방법을 다이렉트-맵트-캐시라고 한다그랬쬬 그쵸 
그래서 이 다이렉트-맵트-캐시는 여러분들이 지금 한 예를 봐서 알겠지만 프로그램이 엑세스하는 데이터 패턴에 따라서 아주 운이 나쁜경우에는 계속해서 같은 자리에 데이터가 위치함으로써 이전 데이터를 쫓아내는 그런 상황이 발생하는게 다이렉트-맵트-캐시에 단점이다.
그래서 보면 다른데도 있구만 다른데도 빈자리가 있는데도 불구하고 꼭 그자리에 가도록 맵핑을 해가지고 충돌로 만들어 내는 그런 상황 그런 상황을 우리가 조금 개선하기 위해서 우리가 빈자리가 있으면 어디든 들어갈 수있게끔 맵핑을 조금 개선한 방법을 뒤에서 살펴본다 그것을 우리가 set associative cache 라고 한다.
set associative cache 라는건 빈자리가 있는 경우 그 빈자리를 충분히 활용하도록 맵핑하는 방법에 하나다. 그러다 보면, 어디든지 들어갈 수있다고 했으니까 빈자리가 있으면 다 꽊꽊 채울 수있겠지 그렇지? 그런 캐시에서는 
그런데 캐시 미스가 발생했다. 그러면 그거는 이거는 충돌도 아니고 모에 부족때문에 용량의 부족 때문에 캐시 미스가 발생하는거지
그렇지 그런 경우 그거를 우리가 capacity miss 용량의 부족떄문에 주로 어떤 맵핑에서 set associative mapping 에서 발생한다. 

그래서 참고로 1번과 2번은 잘 이해해 주도록

## Address Subdivision
자 한번 봐라
여기에 지금 까지 했던것을 다시 한번더 종합적으로 표현하는건데 
어.. 항상 주소가 어떤 방의 주소로 여기에 표기 되는지 주의 해야되고 지금 이거는 바이트 주소가 오는것이다. 
바이트 주소가 왔고 그다음에 어... 
캐시 용량은 캐시의 용량은 1k word 바이트 로는 4k byte 그렇지 캐시의 용량은 이때 캐시의 용량 파트를 어떤 부분을 캐시에 용량이라고 하냐 ?  여러분들 봐요 여기에 
데이터가 들어가는 부분도 있고 앞에 태그도 있고 밸러드도 있고 그렇지만 근데 실제 캐시의 용량은 여기 데이터가 차지하는 부분 이부분 만 캐시의 용량으로 어우리가 그 ... 
일단 그 캐시의 용량을 명세할떄 몇 킬로바이트 캐시다 이렇게 용량은 명시할떄 이 부분을 제외한 값을 캐시의 용량으로 명세한다. 어 
하지만 실제로 그 캐시를 구성하는데 실제로 소요되는 메모리는 그것보다 더 많게되 왜냐하면 이것들도 메모리거든 이것들도 다 비트거든 그러니까 실제 소요한 메모리는 데이터 용량 + 태그 + 비트가 실제 소요한 소요된 메모리의 용량이 된다. 소요된 메모리다 하지만 우리가 캐시의 용량을 나타낼떄 몇 메가, 몇 키로 바이트 캐시다 이렇게 얘기할때는 데이터 분에 할당되는 수 ??? 표현한것이다. 그래서 지금 캐시의 용량이 1k word 이다. 그리고 한 블락은 역시 한 워드가 한블락이다. 한 워드
그러면 우리가 그림 안주고 이렇게 지금 파라미터만 주면 여러분이 이 그림을 생각할 수있어야된다.(그말은 중요하다) 일단 
용량이 1k word인데 한 블락이 한 워드니까 이 캐시는 몇개의 블락으로 구성되? 당연히 1k 개 1024개 블락으로 구성됟 
그다음에 그러고 보니까 인덱스가 0부터 1023 까지 쭉 나열이 될것이고 그러면 인덱스가 0부터 1023 까지 나열된다.
그러면 인덱스를 구성하는 비트는 몇비트냐? 인덱스를 구성하는 비트는 0부터 1023까지 표현 할려면 몇비트가 필요해?
어?10비트이다. 2의 10승이 1024 10비트가 필요하다 자 그러면 주소가 있어요 프로세스에서 주소가 나와요 자 일단 블락 어드레스 알아야 한다. 블락이 지금 한 워드가 한 블락이라고 했으니까 오른쪽에 몇비트를 뗴버리면되여? 오른쪽에 2비트를 떼버리면 워드잔아 
그러면 이 값이 메모리에 블락 주소다. 이값전체가 
(ppt 같이보셈)
자 그러면 그 블락에 해당되는 한 워드가 메모리에서 오겠찌 그렇지 오면 걔를 이중에서 어디에 위치시킬 것인가 캐시 인덱스, 인덱스를 어떻게 찾아? 
1024로 블락어드레스를 나눈 나머지인데 볼것도 없이 오른쪽에 10비트를 딱보면 그 나머지이다. 거기에 해당되는 인덱스 로 가는것이다. 지금 이제 미스가 나서 가져오는 경우라고 생각하고 가져오면 거기다가 해당되는 워드들을 써버리고 그리고 밸러드 비트를 뭐야 밸러드 비트를 yes라고 또는 vlid라고 표시하고 그다음에 여기 tag는 어떤 부분을 쓰면되? tag는 
나머지 , 이블락 주소에서 블락 인덱스 를 제외한 나머지 상위 비트주소값 이게 tag임 tag를 여기다가 기록해 두면됨 그럼 아 이제 여기에 보면 tag값 보면 여기 들어와있는 주소를 알수가 있다. 거꾸로 tag 는 tag에 넣고 index는 index에 넣고 그다음에 여기에 우리가 바이트 주소를 다룰떄에는 오른쪽에 뭐야 00 부터 11 까지 붙이면 그러면 전체 4바이트가 우리가 확인이 되지 
그래서 이제 만야에 이렇게하는거야 캐시 엑세스 할때 만약에 씽큐?? 에서 먼저 캐시를 보겠다. 캐시 데이터가 있는지 그럼 주소가 나오면 인덱스에가서 여기에서 만약에 밸러드 비트가 어떻게 되있는지 1인지 0인지 밸러드가 1이면 있다는것이고 0이면 없다는것이고 
그다음에 여기에서 나온 태그하고 여기서 지금 cpu 가 볼려는 주소에 태그하고 이게 comparison 비교하는것이다. 
그래서 비교해서 이 일치하면 1이라는 값이 나오고 그래서 뭐야 밸러드 하고 그리고 태그가 일치하면 and 캐시 히트임 !!! (중요하다)
그러면, 캐시 히트면 볼것도 없이 어디서 데이터를 읽어가?
캐시에서 데이터를 가져가면 될것이고 이게 미스면 밑에있는 메모리에 데이터요청을 해야할것이다. 

## Example: Larger Block Size
만약에 캐시에 블락이 64개 블락이 있고, 블락당 16바이트면 워드로는 4워드임 굉장히 큰 블락이다. 
그러면 만약에 아 밑에 이 어드레스 1200이 바이트 어드레스 1200 이라고 한다면 이게 1200이 바이트 어드레스
항상 확인해야한다. 그러면 이 1200 속해있는 주소 1200에 속해있는 어떤 블락이 있겠지 
그블락주소는 어떻게 결정되느냐 그 주소, 자기의 바이트 주소를 어떻게 16으로 나눈 나머지값 75다.
75번 메모리 블락이란 말이다. 이 1200이라는 바이트 가 
이게 몫이다.
75 
16*75 = 1200 이겠지?
그다음에 그러면 이 1200이 75번 블락에 뭐야 맨 첫바이트야 맨 끝바이트야? 1200이 75번 메모리 가 쭉있잔아 (이거 헷갈림)
해서 여기가 0번 바이트 지금 바이트다. 이렇게 
해서 여기 15
이게 메모리블락 뭐야 블락 0 
그다음에 16번 부터 몇번까지 31번까지 블락 1 
이런식으로 매겨졌을때 지금 1200번지 75번 블락에 들어간단 말이다. 
75번 블락에 첫바이트지. 거기에 75번 블락에 소속되어있는 바이트 들을 쭉 나열하라 그러면 얼마야? 1200 1201 ~ 1215 까지 그 16바이트가 같은 덩어리, 같은 그륩으로 왔다갔다 한다.
그러면 걔가 이제 75번 블락이 캐시로 올라와서는 어디에 들어갈까? 블락 넘버를 지금 이게 캐시가 갖고있는 블락의 개수라고 했으니까 64로 어떻게? 모듈 취해 
모듈을 취하는건 무슨 맵핑? 다이렉트 맵핑 캐시이다. 모듈 취하면 11이야 그러면 11 번 캐시 블락에 들어간다. (이때는 나머지를 취함) 그래서 주소가 지금 32비트 일때 어... 한 블락이 16바이트라고 햇으니까 오른쪽에 블락 바이트 주소 해서 4비트를 빼버려야지 무슨 주소가 되 이게? 블락 주소가 된다. 그다음에 캐시가 64개 라고 그랬으니까 오른쪽에 6비트가 이게 64로 나눈 나머지잔아 그치? 이게 캐시 인덱스 다. 그리고 나머지가 다 태그다 이때 offset은 어떤 의미냐 offset이라는건 뭐라그랬어? 상대적인 위치다. 어디에서의 상대적인 위치야? 이거는
한 블락에서의 상대적인 위치다. 
예를들면 16, 이 블락에서의 상대적인 위치는 얼마야? 0 다 . 이 블락의 시작위치다. 
32 블락 2에서 상대적인 위치는 0다. 그렇다. (0부터 시작하니까?)

그다음에 우리 잠깐만 자료를 바꿔서 

## Temporal and Spatial Localities
이 그림은 뭘 보여주려고 하느냐면 이런 그래프가 나오면 제일 봐야 하는게 뭐냐 
가로축 세로축이 뭘 표현하고 있는가
가로축은 어쩃든 타임에 우리가 프로세스 버츄얼 타임이라고 하면 이 프로세스가 실제 실행될떄 여러분들 시스템프로그래밍에서 버츄얼 타임이 뭐야? 어떤 프로세스가 유저모드 에 있거나 또는 프로세스가 커널모드에 있을때 그떄에 실행됬던 시간의 합 그게 버츄얼 타임이다. 메이킹 타이얼 뺴고??? (메이킹 타이얼이 머지)
해서 여기 시간이 지나면서 그떄그떄 오른쪽으로 , 세로축은 뭐냐면 메모리 location이다. 다른말로 얘기하면 세로축은 주소다. 
그래서 그 시간에 어느 주소를 참조했는지 점을 찍은것이다. 이게 뭘 보여주려고 하는거야? 어떤 단위시간당 어떤 순간에 그근처에서 참조하는 주소들이 상당한 일정한 영역안에 있다. 만약에 그렇지 않고 정말로 미친듯이 아무대나 access하면 이그래프가 어떻게 나타났을까 모래뿌려놓은것처럼 이렇게 흩어져서 나타났을것이다. 요떄엔든 요 주소 . 요떄에는 요주소이렇게 이렇게 시간이 지나면서 엑세스하는 주소들이 일정한 영역들이 있따. 그리고 그게 한동안 그 패턴이 시간에 한동안 이어진다.
그렇지 수초동안 같은 range에 계속 access 하게 그렇지 
그래서 이걸 메모리 로케이션을 보여준다. 
이거는 뭐 우리가 어떤 프로그램을 실행하고 나서 실행하면서 그때그때 걔가 엑세스하는 데이터 어드레스를 로그를 받아가지고 로그 를 받아서 그거를 그래프로 이렇게 뿌려놓은것?? 이다.

그다음에 요고 지나가는데 여러분들 그 좀 이전 강의자료와 어떤 부분이 다른지 좀 살펴봐야함 
음.. 이게 자 

## Direct Mapped Cache
이걸 뭘 의미하는지 한번 다시 다이렉트 맵트 캐시 
용량
지난번에 블락의 크기 
이그림을 한번 보도록 

## Caching: A Simple First Example
지금 여기 한 칸이 몇 비트야? 한 칸이 한워드이다.
한칸이 한워드이고 그다음에 어
오른쪽에 있는 주소는 뭘의미해? 여기에 들어가있는 요4개의 워드가 1000 까진 앞에 일치하고 그다음에 뒤에가 2비트가 다른 4바이트가 들어가있다.
00 01 그다음에 10 11 이렇게
이런 4바이트가 들어가있다.
그러면 어떤 주소가 프로세스에서 나왔을때 이게 캐시에 있는지 어떻게 확인해? 일단 중요한건 캐시는 블락 어드레스를 본다. 그래서 오른쪽에 블락에 해당한느 오프셋을 떼버리고 블락 어드레스를 보고 블락어드레스중에서 이 캐시가 지금 몇개의 블락을 제공하냐면 4개의 블락을 제공하니까 오른쪽에 몇비트를 봐야대? 2비트가 캐시인덱스에 해당한다. 그 2비트를 보고 해당되는 자리에 가서 valid 와 tag 두개가 다 매칭되야 거기에 데이터가 있는것이고 그렇지않으면 해당되는 워드를 가져온다. 

## Caching : A Simple First Example
요것도 조금 다른 형태로 되어있지만 여러분들 다시 보고 연습하고

## Taking Advantage of Spatial Locality
요거 한번 보자 요거는 어...
같은 캐시인데 
같은 캐시를 조금 재구성해서 한 블락을 키웠다. 한 블락을 워드 두개로 근데 지금 우리가 데이터 가 들어가는 부분만 표시한다고 했을때 데이터가 들어가는 부분만 표시한다고 했을때 이게 지금 앞에서는 이거 한 워드를 한 캐시블락으로 썻다. 그래서 캐시블락이 4개인그런 그 시스템으로 디자인을 했었는데 지금 여기에서는 한 블락을 두워드가 한 블락이 되게끔 두 워드 니까 바이트 수로는 8바이트 이다. 8바이트가 한 워드가 되게, 한 블락이 되게끔 
그렇게 디자인을 바꿨다. 그렇게 하다보니까 캐시 블락은 두블락이 나오는셈이다. 
메모리 블락도 역시 한 블락이 두 워드씩 구성이 된다. 
자 우리가 이때 이 주소를 워드 주소라고 가정하자. 워드 주소
오른쪽에 두비트가 떨어진 주소다. 바이트 주소에서 워드주소를 체크. 
워드 주소라고 가정하면 지금 앞에하고 어떻게 달라지느냐 자! 어 0워드 엑세스 했을때 0워드가 있는지를 볼려면 어디를 봐야되요? 이렇게 하면은 여기 인덱스0를 봐야되겠지 당연히 그치
미스다. 그러면 0워드를 읽어와야하는데 미스 때문에 메모리에서 읽어와야하는데 지금 한 블락이 두 워드니까 
0도 읽어오면서 뭘 같이 읽어오겠냐? 
워드 0 와 워드1을 같이 읽는다. 그래서 여기다가 2개를 워드0 워드1 같이 
이떄에 0 엑세스 했을때는 미스죠 당연히 
그다음에 1번 엑세스 할떄는 뭐야, 1번 주소에 
1번주소에 블락넘버를 2로 나누면 그 나머지가 0이고 그 가가지고 봤더니 태그가 같고 그리고 안에 자기가 찾을려는 메모리 1번 워드가 이렇게 들어와있다. 왜들어와있나? 여기에서 두워드 한꺼번에 읽어왔기때문에 여기서 
요고하거 어떤차이가 있는지 알아보자 
## 다이렉트
여기서 지금 한 블락이 한워드로 구성되어있다. 이때는 0번 미스일때 뭐만 읽어와요? 0번 워드만 읽어서 가져다 놓는다.
그렇죠 그다음에 1번 역시 여기에 없어요. 그렇죠 미스임
이게 뭘 지금 보여주고 있는거냐? 한 블락의 크기를 두워드로 이렇게 블락 개수를 늘렸을때 함께 따라오는 데이터가 효과를 보여준다. 그러면 우리가 뭐라그러냐? "spatial locality" 라고한다.
그렇죠 공간적 지역성 이라고한다.
그래서 요고는 여려분들이 해보면 8번 중에서 미스가 6번 난다. 
근데 이거는 미스가 4번 한 2분쯤 남았는데
여러분들이 한번 이거를 주소를 따라가면서 해당되는 위치를 찾아서 내가 이게 블락 0 이게 블락 1 이다. 
그리고 요 앞에 값은 지금 valid bit 는 표시가 안되어있고 이 앞의 값은 tag 비트다. 
이거 확인해봐라 지금
주소를 바이너리로 표현해가지고 그중에서 인덱스값을 찾고 나머지를 tag에 집어넣고 그렇게 연습을 해야되(이게 가장 핵심인듯 중요) 

## 쉬는시간후
## 
조금 잘못되어있다. 여러분들이 이그림을 다시한번 그려보자.
잘못되어있나? 이게 해봤어요? 
이게 지금 워드주소라고 했죠 , 워드 주소라는건 오른쪽에 바이트 오프셋이 빠져버린 주소다. 만약에 묻기를 어 이렇게 해놓고 그러면 여기에 속해있는 바이트 들은 몇번지 부터 몇번지 냐 그러면 어떻게 하냐 그러면 오른쪽 두비트를 붙여서 00 01 10 11 바이트 주소로 환원해야한다. 그렇지
지금 여기서는 그냥 숫자를 좀 간결하게 하기위해서 오른쪽 2비트는 뗴버리고 워드 단위의 주소로만 지금 여기에 표현하고 있는것이다. 이렇게 10진수를 썻어도 주소를 우리가 생각할때는 이진수로 생각해줘야한다. 뭐 0000 0001 0010 0011 이렇게 주소가
어... 지금 두 워드가 한 블락이라고 했으니까 워드가 주소가 나오면 워드가 주소가 나오면 
블락 주소를 알기위해서는 그걸 2로 나눠줘야 한다. 그러니까 여기에서 역시 워드주소에서도 하나를 떼버려줘야한다. 여기지금 
주소가 000이면 이게 0000일꺼 아냐 0000중에서 얘의 워드주소니까 지금 두워드가 한블락이라고했으니까 얘를 바꿔?? 그러면 워드 주소가 있고 두워드가 한 블락이라고 했으니까 워드를 2로 나눠서 2로 나눈 몫이 이게 워드주소이다. 000 이다.
만약에 이게 만약에 바이트 어드레스야 0110 0010 이 바이트 주소야 근데 한 블락이 두워드로 되어있대 그러면 이 주소를 보고 얘가 속해있는 블락넘버를 알려면 어떻게해야되? 얼마로 나눠줘야되? 이 주소를 이 주소를 2로 나눠줘야해? 얘는 바이트 단위의 주소라니까 바이트 개수로 나눠줘야한다. 두워드가 몇ㅂ ㅏ이트야 8바이트지 8로 나눠줘야한다. 오른쪽 3비트를 제거한다. 얘는 지금 워드주소지 단위가 (0000을 말하는듯) 그런데 두워드가 한 블락이래 그러면 얘가 이미 이미 워드잔아 그렇지 어 그러니까 2로 이거를 두워드를 나눠줄려면 오른쪽 하나만 떼버리면 된다.
얘를 만약에 주소가 저게 바이트주소로 환산되면 어떻게 되? 
0000 이 워드주소고 오른쪽에 뭐가 붙어 2비트가 붙는다. 00이 붙었다고 해보자 그럼 이렇게 하면 이건 무슨 주소야? 바이트 주소다. 그렇지, 자 역시 똑같이 마찬가지로 블락당 2워드래 역시 오른쪽에 몇비트를 떼버려? 3비트를 뗴버려야 한다. 그렇지 
3비트를 떼버리니까 결과적으로 비트 정보 2개 떼졌고 워드어드레스 에서 오른쪽 한비트가 뗴졌고 그렇죠 그러니까 이게 어 블락으로 어드레스가 나오면 그러니까 어드레스가 바이트로 표현되면 블락으로 우리가 환산 해줄떄 바이트 개수로 나눠주면 되는것이고 이게 워드주소로 환산되면 블락의 수를 워드의 개수로 환산한다음에 워드의수로 나눠주면 된다. 똑같아 
그건 그렇고 0000 이 워드 주소인데 여기서 두워드가 한블락이라고 했기때문에 블락 주소를 볼려면 오른쪽에 한비트만 뗴버리면 000이 블락주소다. 그렇죠 그런데 그러면 이 000블락은 몇번 워드와 몇번워드로 구성되어있냐 하면 어떻게 되? 
블락넘버가 이렇게 있지 000 이라고 그리고 여기에 한자리에 해당되는게 0이 들어갈수도있고 1이 들어갈수도있는거아냐  그치 
이렇게 두개가 한 블락으로 묶여 다닌데 
0000 0001 얘들이 한블락이다. 두워드가 
그러면 000에 해당되는 블락은 알았고 000을 블락, 000을 구성하는 워드들이 0과 1이라는것을 알았고 그다음에 뭐를 우리가 생각해야되 캐시 어디로 위치시킬것인가 그건 어떻게 되? 이 블락주소를 캐시에 블락의 개수로 나눈 뭐야, 나머지다. 그러니까 000을 캐시블락이 2개로 되어있으니까 두블락이다.(ptt보면 0번블락 1번블락을 의미하는거고) 2로나눈 몫이다.(나머지아닌가..?) 0이다 그렇지 0번 블락에 위치한다. 자 그리고 태그는 뭐야? 태그는 00이지.
태그는 나머지 2비트잔아. 태그는 00이 들어가고
메모리0 1 단위가 뭐야 워드야 워드0 워드1이 들어간단 얘기야 그다음에 워드1 당연히 히트고 이게 2번 0010 이지 2번 워드 주소로 워드주소로 얘는 0010 이야 워드주소로 얘의 블락은 몇번 블락이야? 블락은 여기를 떼버리고 001 블락넘버다. 얘가 속해있는 001에 들어가는 워드는 몇번이냐 0010, 0011 이다. 그렇죠 그러니까 2번 3번 워드가 같은 블락을 구성
그다음에 이게 블락넘버야 그러면 2번,3번 워드가 몇번 블락에 들어갈까? 그걸 어떻게 요 블락주소를 2로 나눈 나머지다 그러면 오른쪽에 한비트가 2로나눈 나머지다. 블락 1번 
블락 1번 이게 블락 0 (ppt에 써있고 캐시인덱스를 말하는듯맞나?)
2번 워드, 3번 워드가 들어가고 
그다음에 태그는 뭐야 역시 00이다. 태그는 00

3번 바로 뒤에 히트 4번 워드주소야 
4 = 0100 블락 넘버가 010 이니까 0100, 0101 이다. 
얘가 속해있는 블락 010, 블락으로는 010 블락
거기에 들어가는 워드도 0100 0101 그래서 4번과 5번 두워드가 같은 블락을 이룬다. 그다음에 블락넘버에서 오른쪽 한비트가 캐시인덱스라고했다. 이블락이 들어갈 그러면 여기는 
여기에 지금 있는 블락의 태그는 00이고 내가 찾을려고하는 원하는 블락의 태그는 01이고 미스매치다. 그래서 여기에있는거는 내가 지금 원하는 데이터가아니니까 미스고 메모리에서 읽어와서 여기다 다시 오버라이트해야한다. 4번 5번 워드넣고 태그를 01이라고 
그래서 블락어드레스에서 블락어드레스는 뭐와 뭘로 구성되? 오른쪽에 캐시인덱스 그리고 나머지 왼쪽은 다 태그 그렇지.
15번 한번 더 해보자
1111 이거고 워드 주소고 이게 블락 으로 보면 111이니까 
1110, 1111 일수도있다.
+ 주소가 값이 어떤 단위로 주어졌느냐 그걸 확인하는게 제일 중요하다.!!!! (깡조하심)
어 그게 좀 이상하네 
이게좀 자 워드 15는 어떻게 되죠 1111 이다. 그렇죠 이게 블락 넘버는 지금 오른쪽의 한비트를 뺀게 블락넘버다 
왜냐하면 두워드가 한블락이라고 했으니까 그러면 블락넘버는 111, 7이다. 7번블락에 들어가는 워드는 뭐와 뭐야? 1 그리고 0 
1이나 0이다.
그러니까 7번 블락은 14번 15번 두워드로 구성된다. 
얘가 들어갈 자리는 요 블락넘버에서 한 자리 1번 블락에 들어가야 하고 1번 블락에 봤더니 태그 가 00이다. 내가원하는 데이터가 아니고 단놈이 들어와있다. 미스다. 그래서 14 15를 가져와서 거기다 넣고 태그도 내가 지금 멕세스 하는 태그 11로 여기를 바꿔줘야한다. (왜냐면 111 이 7이라고했으니까)

## Multiword Block Direct Mapped Cache
요고는 한 블락이 멀티모드일때 
방금처럼 두워드나 네워드나 멀티워드일때 다이렉트 맵트 캐시가 조금 구성이 달라지는것을 보여주고 있다. 아까 봤던것은 한블락, 한워드 일때 모습이었고 이거는 좀 달라졌는데 요떄 요 주어진 주소는 무슨 주소냐 바이트 주소다. 지금 여기서 블락 당 몇 워드래요? 블락당 4워드다. 바이트로는 몇바이트 에요? 저렇게 되면 16바이트다. 그래서 바이트 주소가 딱 뜨면 한 블락이 16바이트이기 떄문에 오른쪽 몇 비트를 딱 때버리면 블락주소에요 
4비트를 떼버리면 블락주소다. 왜나하면 2의 4승이 16이니까 
그렇지 그런데 이거를 이렇게 생각할수도있다. 
당연한거지만, 바이트 주소가 뜨면 오른쪽 2비트가 뗴버리면 워드주소가 된다. 자 한 블락이 4워드라고 했으니까 워드 주소에서 몇 비트를 떼버리면 블락주소가 되냐 워드로 주소가 나왔을때는 그 워드를 4로 나누면 블락주소가 되는거아냐 그렇지
4로 나눈다는것은 오른쪽에 몇비트를 뗀다 얘기야 
두비트를 뗸다 얘기임 그러니까 워드 주소 로 나왔을떄 그것을 블락이 몇개의 워드로 구성되어있느냐 그래서 그것을 워드의 개수로 나눈다. 그 결국은 뭐하고 똑같아 한 블락이 몇개의 바이트로 구성되어있느냐 그것을 바이트주소에서 떼버린다. 그거하고 똑같다. 
워드주소는 워드의 개수를 뗴버리고 그다음에 바이트 주소는 바이트의개수에 해당하는 만큼 뗴버리면 똑같은 블락주소가 나오게 되어있다. 뭐, 같은 값을 표현을 좀 다르게 한것이니까
그다음에 어 그러면 여기에서 오른쪽이 떼면 오른쪽 비트 정보를 뗴면 이게 블락주소가 되는것이고 블락주소가 나오면 자 해당되는 블락이 캐쉬에 어디로 위치할것인가를 결정해야하는데 그 블락주소에 아랫부분이 캐시의 인덱스라고했음 그런데 얼마만큼 봐야 되느냐? 얼마만큼 봐야되요 캐시가 제공하는 뭐에수? 캐시 블락의 개수 만큼 봐야된다. 지금 여기에서는 0번부터 255번까지 
256개의 블락을 제공하고있다. 256으로 걔를 블락주소를 나눈셈아니야 그러면 오른쪽에 몇 비트? 8비트값이 걔가 들어갈 위치다. 그블락이 그러면 나머지 왼쪽에는 몇비트가 남냐?
20비트가 남는다. 저 20비트는 그블락의 태그이다. 그래서 여기에 태그에 기록되고 
그다음에 그러면 우리가 그냥 예를 한번 들어봅시다. 
어 주소가 헥사 32 비트니까 ox12345678 이런 바이트에 접근할려고 한다. 32비트죠 이 바이트가 속한 블락은 어디로 위치할까 캐시 인덱스 몇번에 위치할까? 저 바이트가 속해있는
저 바이트는 이 중에 어디 한바이트라고 한바이트인데 저 바이트 하나땜에 지금 몇개가 읽혀져 오는거야? 16개의 바이트들이 우르르하고 캐시에 들어와서 들어오는것이다. 그렇지 그러면 일단 저 바이트는 캐시 몇번 캐시 에 들어올까 계산해봐라
바이트 주소라고했어.이진수로 변환해야함 
1,2,3,4,5,6,7,8 바이트야 주소에요? 주소?
거기에 있는 데이터는 뭔지 모르지만 걔를 읽어와서 넣어야 하는데 주소야 이거는 
자, 다 이진수로 바꿀 필요는 없다. 지금 오른쪽 세자리 정도만 바꾸면된다. 6,7,8 정도만 바꾸면됨
여기서 블락주소를 알려면 그 블락을 구성하는바이트개수만큼 나눈 몫이다. 오른쪽 몇비트떼버려야하냐? 4비트 왜? 한블락이 4워드 16바이트라고했으니까 얘를 떼버려 
이부분을 뭐라고해? 이부분을 블락 오프셋이라고 한다. 다시말하면 뭘까? 애가 속해있는 블락, 그 블락에 이 바이트가 상대적인 위치를 나타낸다. 몇번이야? 1000 이면 이게 8이잔아 그렇지 8번쨰란 얘기다. 사실 9번쨰다. 왜 시작이 0부터 시작하니까 0 1 2 3 4 5 6 7 8 9 번쨰 그블락이 어떻게 될지 모른다. 이렇게 그런데 하여간 거기 블락안에서 이 바이트는 9번쨰 해당되는 블락이다. 그럼 당연한 얘기지만 얘가 속해있는 블락에 첫번째 바이트는 몇번 바이트야? 어떻게 해야되 오프셋이 0000 인놈이 있겠지 0000인놈이 그블락의 첫번째 바이트다 그러면 헥사로 123456670 얘가 속해있는 블락은 주소가 몇번지 서부터 몇번지 까지냐? 12345670부터 1234567F 까지 0~F까지 16바이트가 한블락으로 왓다갓다 한다. 
그럼 내가 그림을 여기지금 어 ... 9번째 여기가 0 1 2 3 4 5 6 7 8 여기네 사실은 
(9번째라는게 위치고 8은 숫자상의 표현인것같다)
자, 그런데 중요한거는 어 블락이 왔을떄 캐시 인덱스 어떻게? 캐시인덱스 블락주솔르 가지고 캐시가 지금 256개니까 256으로 나머지 연산 나머지이다.
나눌필요없이 오른쪽 몇비트를 봐? 블락주소에 8비트를 본다. 0110 0111 10진수로 얼마야 이게 얼마 103 이다. 
십진수로는 103 여기 103번에 인덱스에가 서 우리도 사실 지금엑세스를 하는거면, CPU에서 엑세스를 하는거면 뭐 봐야되 , 밸러드 비트봐야되고 그다음에 태그를 봐야한다. 태그는 나머지다 여기
나머지 어... 인덱스 정보를 제외한 나머지 헥사로 012345 그거하고 여기있는 태그하고 같아야된다. 그렇지 
만약에 다르다면 미스고 그러면 저 16바이트 차례로 여기다가 가져다 쓰고 여기다가 헥사 12345 라고 태그를 써주고 그렇지
자그러면, 자그러면 여기에서 이 cache를 구성하기 위해서 필요한 토탈 메모리 은 얼마일까?

비트로 따진다면

##### 토탈메모리 
일단 요 데이터블락은 한 블락이 4워드이고 그다음에 이런게 256개니까 256*4워드 = 1kword 이다. 요 데이터 블락은 1k word 
1k word는 비트로 따지면 얼마야 한 워드가 32 비트니까 32 bit kilo bie 다 그래서 그 데이터 블락 만큼은 32 kilo bit 
또 뭐가 필요할까 태그가 필요하다. 태그는 한 태그가 몇비트냐? 20 비트다. 20비트가 지금 256개 있지 그러면 20* 256 = 5120 bits 여기는 5120 bit 그다음에 또 뭐가 필요해 밸러드 비트도 1 , 0(원제로로) 표현해야하니까 한 비트씩 필요하다. 쭉 256 bits 밸러드 비트 
이 토탈이 이 캐시를 구성하는데 필요한 전체 메모리이다. 이건 용량이든 얘들은 표현이 안되고있지만 용량에는 표현이 안되고 있지만 이 용량의 캐쉬 중에서 필요한 토탈 메모리를 구해라 그러면 이 태그와 밸러드 비트를 표현해줘야한다. 


## 
요것은 나중에 좀 하기로 하고
42로 가자

## 42, Set - Associative Caches
지금 다이렉트 맵트 캐시를 살펴봤는데 다이렉트 맵트캐시는 구현이 간단한것은 있는데 지금 봤듯이 그 메모리 블락에 들어가야할 자리 가 한곳으로 고정되어있기때문에 프로그램이 어떻게 어드레스를 막 이렇게  재생하다보면 공교롭게도 같은 자리에 뭔가가 맵핑되어가지고 충돌이 발생되게 된다. 
그런 현상들이 나타날 수있꼬 또하나의 문제는 뭐냐면 우리가 지금 블락들을 키워나간다. 블락을 4워드 8워드 심지어는 더크게 키워가는데 블락을 키우면 충돌은 어떻게 될까? 충돌은 더 커질까 작아질까? 같은 자리에 대한 충돌
블락을 키우면, 이런걸 생각해보자 우리가 이만한 통이있고 그 통안에 테니스공을 가득 담았어 그런경우에 어떤 테니스 공을 교체할때 그 테니스 공하나때문에 쫓겨나는 면적 그건 뭐야
그 테니스 공 크기만한 면적에 공이 쫓겨나는것이다. 근데 거기에 농구공을 담았어, 그러면 농구공 하나를 교체할때 그 농구공 부피에 해당하는 부분이 다 교체되는것이다. 그렇지
그러니까 어떤 문제가 있냐면 우리가 spatial locality를 키우기 위해서는 블락의 길이를 키웠는데 그러다보니까같은 공간에 대한 쟁탈전이더 높아졌다. 그러다 보니까 다이렉트 맵트 캐쉬는 블락의 크기가 커지면서 효과가 급격하게 떨어진 그런 문제가 발생
그러면 이 자유도를 주자, 들어갈 수있는 위치를 한곳으로 꼭 고정하지말고 좀 여유가 있으면 다른데로 옮겨갈수있게끔 여유를 주자 해서 제한된 방벙이 Set Associative Caches이다.

## Set-Associative Caches
여기서 제일 중요한건 set이다.
그래서 추측하면 뭐야 우리는 다이렉트 맵트 캐시는 걔가 들어갈 위치가 한곳이었따. 
얘는 걔가 들어갈 위치를 set로 정의해주자 그래서 set가 예를들어서 한 세트가 뭐 두블락이면 , 두 캐시블락이면 걔가 여기들어가든 아니면 저기 들어가든 둘중에 하나 선택해서 들어갈 수있게끔 이렇게 set으로 제공하자 그러면으로 볼떄 다이렉트 맵트 캐시는 세트에 집합에 들어간 원소가 몇개인 캐시야
한개인 1개인 캐시고
어 그거를 그 세트의 크기를 좀 늘려가자
첫번째 과제? 지금캐시인덱스

다이렉트 맵트 캐시는 인덱스 하나당 뭐지 어 한 엔트리가 맵핑 됬던것에 반해서 지금 set-associative 캐시는 인덱스 하나당 여러개의 엔트리를 구비해주자 인덱스 하나당

그래서 우리가 인덱스 하나당 구비된 그 캐시 엔트리 또는 캐시블락에 개수에 따라서 그 엔트리 수가 n이면 n개이면 그것을 n-way set-associative cache 라고한다. 
이 엔트리 수가 만약에 n이라면 그떄 그 캐시를 n-way set -associative cache 라고한다. 
엔트리 수가 2개면 2-way 4개면 4-way 
자 n은 각 세트에 들어와있는 캐시블락의 수를 n이라고 하고 자 그럴려다 보면 그 세트에서 뭔가를 찾아낼려다 보면 그 세트에 들어와 있는 놈들에게 사실은 우리가 뭘 봐야되 우리가 지금 앞에서 다이렉트 맵트 캐시도 인덱스를 찾아가죠 그다음에 이게 밸러드 인지 봤죠 그다음에 뭐 봣죠? 태그가 내가 찾는 태그하고 일치하는지 봤죠
근데 지금 그런 엔트리가 한 세트에 두개있다고 해보자 
두개 그전에는 오면 딱 한 태그만 갖고있는데 지금은 이사람 태그도 봐야되고 혹시모르니까 저사람 태그도봐야되고 이렇게 차례차례 봐야된다. 근데 이렇게 차례차례 보는게 시간이 많이 걸리잔아 그러니까 이것을 하드웨어 적으로 동시에 걔들이 가지고있는 태그를 한꺼번에 꺼내가지고 한꺼번에 태그매칭을 할수있도록 회로를 구성한다. 그것을 우리가 parallel 하게 동시에 병렬로 n개가 갖고있는 태그값을 동시에 comparison한다
동시에 비교할수있도록 하드웨어가 제공한다.
그러다 보니까 뭐야, 하드웨어 를 구성하는 비용측면에서는 다이렉트 맵트 캐시보다 비싸겠지 좀 
비싸.
그다음에 또하나 생각해야할게 2-way associative 라고 했으면 한 세트에 지금 들어갈 수 자리가 두자리인데 두 자리인데 처음에는 비어있겠지만 어떻게 쓰다보면은 그 두자리 다 들어와있겟지 누군가가 그런데 내가 새로운 블락을 가져오고 나서 늘려다 보니까 이 세트에 넣어야되면 어떻게 되 지금 두블락 중에서 적당한 한 블락은 쫓아내야 된다. 그것을 우리가 뭐라하냐면 replace 라고 한다. replace .
그래서 만약에 내가 지금 새로가지고오는 블락이 어느 블락과 충돌이 일어난다면 그러면 해당 되는 블락을 replace 해야하는데 
다이렉트 맵트 캐시는 고민이 없었다. 왜냐하면 그자리에 있는놈을 그자리에 있는놈을 그냥 쫓아내면 되었었다. 
그런데 지금 세트는 세트안에 2개이면 둘중 에 누구를 쫓아내느냐 에 따라서 성능이 달라진다. 
그렇죠 그래서 굉장히 리플레이스할때 전략, 리플레이스 알고리즘이 중요한 요소를 차지한다. 자 그런데 만약에 우리가 이 n을 두개, 네개 이렇게 늘려가다가
이렇게 r 캐시엔트리가 256개 야 그러면 256개 중에 비어있는 아무대나 들어가게끔 그냥 캐시를 만들겠다.
그럼뭐야 한세트가 256개가 된다. 그러면 우리가 256 웨이라고 안하고 뭐라그러냐면 fully associative caches 라고 한다.
어디든 들어갈수있는 곳임
그 캐시 엔트리수가 뭐 n개면 n개 어디에든 들어갈수있는 캐시 그렇게 설계한 캐시를 fully associative cache 라고 한다. 
자 얘는 이 associativity 만큼 뭐가 필요해? 그 패러럴 하게 비교하는 회로들이 다 구비되어야 한다. 그렇치 왜냐하면 그안에 있는 태그들을 다 매칭해야 되는데 그 태그들을 sqential 하게 매칭하다 보면 이게 시간이 너무 많이걸리니까 각 엔트리를 각 매칭할 수있는 하드웨어 회로들을 다 설치하다 보니까 fully associative는 무지무지 하게 비싼 캐시임 
비싼 캐시고 access time도 조금 길다 왜냐하면 다른건 그냥 메모리 딱 들어가면 값이 나오면되는데 얘는 항상 비교연산을 한다음에 값을 꺼내니까 access time 도 다이렉트 맵트 캐시보다는 길다. 그럼에도 불구하고 fully associative cache를 쓰는 이유는 뭐야 conflict가 현저하게 낮아지니까 
그래서 fully associative cache는 아무데나 쓰지 않고 아주 빈번하게 access 하는 데이터를 위해서 소용량 만큼 제공을 한다. fully associative cache는 
그래서 우리뭐 gpu architecture 안에도 주로 여기 랜더링 하고 그래픽 오퍼레이션 할때 그래픽 데이터에 의해서 캐싱을 한다던지 그런 의미로 
그런면에서 볼때 다이렉트 맵트 캐시는 뭐라고 볼수있느냐 
one -way set associative cache 라고 볼수있다.
왜냐하면 갈길이 한곳으로 딱 고정된 그런 캐시라고 볼수있다.

그래서 우리가 캐시를 디자인 하는게 중요한데 같은 메모리 용량이 있어요 아까도 봤듯이 메모리 용량을 같이 주고 너보고 캐시한번 디자인해봐라 이랬을때 어떤 사람은 한 블록을 한 워드로 구성해서 쪼로록 그냥 256 엔트리 만드는 사람도 있고 어떤 사람은 한 블락을 나는 4개로 워드로 한블락을 구상할꺼야 그래가지고 어 128개의 블락들로 가진 그런 캐시를 구성하는 사람도 있고 
어떤 사람은 아 다이렉트 맵트 캐시보다는 나는 set - associative cache 를 구성하겠다. 그래서 set을 늘리는 사람도 있고 그래서 같은 반도체를 가지고 캐시를 만드는데 다양한 설계 방법이 가능하다. 그것을 누가 어떻게 그 응용에 맞게 잘 파라미터 를 설계하는가가 엔지니어에 능력이다.
엔지니어의 능력인데

캐시 용량이 주어질때, 고정되어있을때 자 
associativity 를 늘리면 일반적으로 캐시 hit rate 가 올라가는 경향을 보인다. 뭐가 줄가 때문에 그렇지 conflict 가 줄기떄문에 
(중요)

그래서 뭐 당연히 아까도 얘기했지만 하드웨어 코스트가 상당히 증가한다. 결국 비용을 들이지 않고 성능이 올라갈순없다. 
다시한번 말하지만 뭐 이거는 비용을 절감되면서 성능도 현격하게 올라갔다. 사실은 잘들여다 봐야한다 그런 제품들 
뻥을 가능성이 높다.

## Cache Organiztion Spectrum
자 이거는 이 그림한번 봐라 위에는 블락넘버다.
블락넘버
밑에 워드인지 바이트인지 그런 정보는 뺴버리고 블락넘버만 나와있다. 
다이렉트 맵트 캐시는 이게 한 캐시 엔트리가 한 블락으로 구성되어있다. 
set - associative cache 이거는 여기 지금 보여주는 건 two-way다 set 하나에 블락이 2개가 들어간다. 
2way 
만약에 4way면 어떻게 되 , set하나에 블락이 4개가 한 set로 
이때 여기에 이 number 들은 우리가 캐시 인덱스 넘버라고 했다. 다이렉트 맵트 캐시에서는 여기에서는 이거는 우리가 세트 넘버라고 해 
이거는 index 넘버라고 안하고 set 넘버라고 한다.
set 0, 1 , 2, 3
이거는 뭐야 이거는 index 넘버가 없다. 그냥 아무곳에나 비어있는곳에 위치할 수있다.
fully associative cache 이다.
자 그러면 우리가 찾을때 얘는 인덱스 가 정해져있기때문에 그 인덱스에 들어가서 태그를 매칭하면 되지만 얘는 세트를 알아도 그 세트에 두블락이 있을수있기때문에 두 블락이 각각 갖고 있는 태그를 비교해봐야 하기때문에 두개가 패러럴 하게 매칭되는 그런 비교 연산이 필요하다. 
얘는 어디에 있을지 모르거든(풀리를 말하는듯) 전체가 한셋트이다. 여기 각각에 들어있는 태그를 비교하기 위해서 이 연산이 필요하다. 이게 상당히 높은 코스트를 가지고 있다.

## Implementation of Set Associative Cache
그래서 이거는 어 set가 몇세트가 있는가가 중요한데 지금 이게 보면은 요게 한줄이 한 세트이다.
한줄이 한세트이다. 
한 세트는 몇블락으로 구성되어있어? 몇개의 블락으로 구성되어있지 지금?
4개의 블락으로 구성되어있다.
그러면 이거는 4way set associative cache 라는것이다.
이런 세ㅡ트가 몇개있어요? 세트가 256개 있다. 그러면 우리가 다이렉트 맵트 캐시에서는 요게 한 줄이 한 블락이었다. 그리고 요게 블락의 개수였다. 블락의 개수로 블락 넘버를 나눈 나머지가 그 캐시가 들어갈 인덱스였는데 이거는 뭘로 나눠져야 되?
어 세트의 개수로 나눠줘야 한다. 
세트가 지금 256개니까 
블락이 크면 그 세트의 개수로 나눈 나머지 그것을 특별히 여기서 뭐라고 그러냐면 앞에 다이렉트 맵트 캐시에서는 캐시인덱스라고 불렀는데 여기에서는 셋트 인덱스라고 부른다.
세트 인덱스, 세트 넘버. 셋
여기에서 요기가 지칭하는 그 값에 해당되는 세트로 간다.
그런데 이 블락이 들어갈수있는 자리가 가서 봤더니 몇자리나 되? 4자리가 된다. 4자리
다 비어있으면 첫번째 자리에다가 넣으면 되는것이고 
만약에 다 차있으면 누군가를 쫓아내고 그자리에 갈아끼워넣는다
그것을 우리가 아까 리플레이스라고 한다 그랬다.
자 그렇게 하고 만약에 요자리에 위치해다고 쳐 
그러면 요 자리에다가 뭐를 요기다가 넣어야대? 여기서 나머지 요 부분이 태그 정보잔아요 그렇죠 
태그를 여기다가 기록을한다. 그래서 나중에 혹시 이데이터가 엑세스 되면 요 세트가 지정될것이고 그 세트에 들어있는 태그들이 다 동시에 동시에 나오고 그 태그들과 내가 찾는 태그가 동시에 비교연산이 일어나가지고 그중에 어느 하나가 매칭이 일어나면 있는것이고 하나도 매칭이 안일어나면 어, 미스다. 여기에 들어와있는것중에는 내가 원하는데이터가 없는것이다.

여러분들 그, 요 자료에 48쪽 부터 한 52쪽 까지 5장 슬라이드 보도록 지금 set - associative 캐시를 설명하고 있는 문제 니까 
요기까지 하고 질문한다..

## 질문
0 1 2 3 4 3 4 15 이렇게 찾아가는거야
프로그램에서
이건 바꾸면 안된다.
그러니까 0 엑세스할때 캐시 메모리에 이런 변화가 일어나고 
1 엑세스 할때 이런 변화가 일어나고 2 엑세스 할때 이런 변화가 일어난다 그거를 보여주는건데
이거는 바꾸면안된다. 3을 엑세스 했을때 3이 메모리에 있었기 떄문에 hit가 된다. 
4를 엑세스 했을때 어, 4가 없었따. 그래서 미스다. 4하고 같은 블락에 속해있는 5를 가지고 와서 이자리에 넣었다. 

이거를 8개의 바이트가 한 워드가 아니고 한 블락을 구상하게 된다면 블락주소가 만약에 이렇다면 블락 주소가 그럼 사실은 여기서 여기까지가 블락 주소지. 그리고 8바이트라고 했으니까 요 뒤에 3자리가 000 ~ 111 까지 8개의 바이트 주소를 표현할수있잔아 
이렇게 요 8개가 한 블락을 구성한다. 그렇게 이해하면된다. 

no-operation 이라는건 명령이다. no-op 라는 실제 명령이있다.
그래서 필요할때 no-operation을 하면은 아무일도 안하면서 한클락 사이클을 지나가는 그런 명령어를 실제로 마이크로 프로세스에서 돌린다. 그런데 no-operation을 집어넣으란 얘기는 얘하고 얘사이가 이렇게 디펜던시가 있잔아 
그러니까 이게 지금 해저드 디텍션이 되거나 포워딩이 되면 하드웨어에서 값을 그 디텍트해서 전달을 하고 할텐데 그게 없으니까 이거를 누가 해줘야 하냐면 컴파일러가 프로그래밍 컴파일 과정중에 이것을 처리해줘야한다. 그래서 
얘문장하고 얘문장 봤더니 둘의 종속관계가 있으니까 여기하고 요 and 사이에다가 no-op 를 이렇게 두개를 넣어준다. 명령을
그러면 자연적으로 얘하고 얘사이가 벌어진다. 
그래서 얘를 읽을때 이 값이 write 가 되고난 뒤에 일혀지도록 명시적으로 두 문장을 넣는것이다
그래서 구지 파이프 로 따진다면 
이게 load 가 insturction fetch instruction decode 이렇게 가잔아 
그러면 뒤에 no - operation이 instruction fetch , 이건 no-operation 이다.
이건 load고 
instruction fetch -> instruction decode가 no-operation 에 해당되는 부분이 또 쭉 진행이 되는것이고 그다음에 no-operaiton 도 여기서 instruction fetch instruction decode 정상적인 명령어 인것처럼 진행이 되고 and가 그다음에 여기서 instrquction fetch decodew 이렇게 간다 그러다 보니까 여기에 write back 인데 writev back에 전반부에 데이터가 쓰여지고 후반부에서 요 x를 읽기떄문에 ??
요기서 쓴데이터를 여기서 읽어가는 효과가 난다.
그래서 이게 no-operation 은 정상적인 명령어를 넣는것이다
컴파일러가 





