
## Line I/O Example(1)
버퍼 사이즈를 100으로 잡고 line buffering 하기위해서 100글자씩 잡아놓고
argument가 3개가 들어오지 않으면 error가 난다. 첫번째 파일이름을 받고 read mode로 오픈을 했고
fout에는 두번째 파일 이름을 받고, append mode 한다.

논리를 배우고 소프트웨어란 도구로 표현할줄 아는 사람이 되야 한다.
setvbuf는 버퍼를 라인단위로 버퍼를 줘서 라인단위로 읽겠다. 이거 안해도 버퍼링은 되니까 구지 않해도 된다.
line 단위로 버퍼 
fgets는 파일에서 string 단위로 가져와라. fpin이 들어올때까지 읽고 파일에서 읽어서 line에다 null이 아닐때까지 null이면 eof에 걸린다. 그걸 파일에다 써라.
이건 커널을 말하는게 아니라 standard I/O library 를 말하는것이다. 

## File I/O
읽을때는 fread, fwrite를 쓴다.
읽을때는 void *ptr, 읽어들어야 하니까 메모리 어드레스 준다. size_t size는 전달할 element를 의미하고 그런것이 몇개있느냐
size랑 개수를 곱해져서 그것만큼 메모리에서 읽어들인다. size가 100byte이고 개수가 10이면 1000byte을 읽어온다.
open file *를 FILE * stream에 주는것이다.

write는 거꾸로다. os는 read와 write를 하지만 여기서는 fread와 fwrite를 한다.

## Array I/O
file에 array 몽땅 쓰고 싶다. array size가 10개 
integer면 4byte고 40byte(total)이다.
40 byte를 file steam으로 하나 만들고 파일을 argv[1] 해서 write mode open했다. 
write mode open해서 stream에 쓸려고 한다.

sample array라고 array 주소를 주고 sizeof(int) 하나의 element는 size는 4byte int 라고 한까닭은
기계에따라 8byte , 4byte도 있으니까 이래야 프로그램에 portable 해진다.

array_size 는 integer 4byte면 4byte 10개를 써라 open한 파일에다가 쓰다가 실패하면 array size가 에러가 난경우
stream에다 쓰는데 ARRAY_SIZE가 안쓰이면 != ARRAY_SIZE와 다른 값이 되므로 에러가 될것이다.

## Struct I/O
파일에 struct가 있는데 struct 가져다 쓸려고 하는데
똑같이 write를 하는데 object의 주소를 주고 sizeof(object) 주고 1개를 쏴라 파일에다가 struct를 쓴다.
이런 struct가 있으면 short,char,long(int),float(4byte) length가 얼만진 몰라도 있는데
하나의 struct가 길이가 몇바이트냐? shor 2byte, char 1byte long 4 byte 합쳐서 7 byte.
float numeric[LENGTH] // 40byte
total 47 byte냐? struct도 cpu마다 크기가 달라진다(중요) 왜 달라지냐, long 4byte인데 메모리는 바이트 연속으로 되어있음 어떤 cpu는 4byte는 짝수부터 시작해야 한다는 룰이있다. 어떤것은 배수로부터 시작해야한다.
char 하나였다가 long을 집어넣으면 4의배수에서 시작해야 하는데 주소가 4의배수가 안될수도 있다. 컴파일러가 heading을 집어넣는다(빈칸을넣는다) 메모리의 alignment를 맞추기 위해서.
어떤 cpu는 long은 주소가 4의 배수가 시작해야하는데 cpu마다 다르기 때문에 struct의 사이즈는 일정하지가 않다.
프로그램에서는 똑같은데 cpu마다 다르다.
size(object)을 해야한다.(중요)
ex) 네트워크 struct를 가져다 한쪽 기기에서 struct를 packet속에 담아서 다른 컴퓨터로 보내는데 각 컴퓨터 마다 cpu가 다르면 보내는것을 padding에 들어가느냐, 안들어가느냐에 따라서 이해를 못할 수 도있다. network에서는 패팅을 없애는 작업이 있다. 

이런 struct를 잡으면 중간마다 padding이 생길수도있다.(홀수 짝수를 맞추기 위해서)

반드시 sizeof(object)을 한다.

## File Copy with Full Buffering
full buffering으로 파일을 카피하는것이다.
버퍼 사이즈는 1kbyte 잡고 아규먼트도 역시 인풋파일과 아웃파일 두개가 들어온다.
첫번쨰 아규먼트는 파일을 readmode로 오픈하고 두번째 아규먼트는 파일이름으로 write모드로 오픈하고
프로그램을 짜는데 에러체크를 안하면 제대로 된것이 아니다.(반드시 찍어줘야 한다.)

line buffer를 set하고 위해서 setvbuf를 해서 buffer를 full size로 full buffering을 한다.
양쪽다 세팅을 하고 이 라인은 해도 그만 안해도 그만이다.
버퍼링을 하면 시스템콜 횟수가 줄어든다.

while(n=fread ...) 이게 메인 loop
한 캐릭터만큼 읽어서 한 캐릭터 단위로 버퍼 사이즈 1kbyte를 읽으란 말이다. fpin에서 읽어서 fwrite로 카피를 해서(fpout으로 쓰겠지)

## File Access Methods
standard I/O library는 c배우면서 공부해야 한다. 시간이 없다. 
파일을 가져다 접근하는 방법에는 어떤 것이 있냐 
default는 sequential access 다, 카세트 테입으로 노래를 들으면 차례대로 들어야한다 중간에 건너뛸 수 없다.
파일을 오픈하면 맨 앞에 r/w offset이 생겨서 쓰고 읽는것 만큼 가면서 sequential access하게 읽는다.
제일 빠르다.
random accesm, 두번째 access cd들을때는 6번트랙갔다가 1번트랙갔다가 왔다갔다 가능
파일에서도 건너뛰어서 읽고 싶다. random access라고 한다. random access할때 사용하는 I/O function이 os에 ㄹfseek이고 standard I/O library에서는 lseek()이다. (반대로씀)
lseek을 다시 call하게 된다. record 단위의 프로세싱할때 주로 사용한다.
ex) 호텔에서 접수 받는 사람이다 방이 10개 가 있다. 방에 들어가는 손님의 레코드가 존재 그 레코드를 디스크 파일에 저장한다고 하면 방이 0~9번까지 있다고 가정하면 0번방에는 사람a가 들어갔고 성별은 어떻게 되고 나이, 주민 데이터가 들어가 있다. 방은 사용중이고 언제 체크아웃하고 정보가 있을텐데 이 레코더가 파일에 10개 있어야 되는데 길이가 똑같다. 새손님이 왔다 5번방 달라고 하면 파일 오픈한 뒤에 5번째 방의 레코드로 건너 뛰어야 한다. 길이가 한 레코드가 만일에 50바이트라고 하면 5번째 레코드는 250번째 바이트에 있다. 그렇게 건너뛸 수 있는게 random access이다. 왔다갔다 할 수 있다. 파일의 위치를 알아서 위치를 location해서 거기서 I/O를 할 수 있는것으로 정의한다.
이것까지는 LIBRARY나 Operating system에서 지원된다.

keyed access다.
keyed 는 key를 가지고 record를 찾는다. 손님중에 사람b라는 사람이 호텔에서 묶고 있다. 몇번째 방인지 모르므로 찾아야 한다. 그때 사람b가 key가 된다. key를 가지고 찾아가야 한다. 데이터베이스가 이러한 원리다. key를 가지고 디스크파일을 찾아가는 것이지만, 파일 자체는 sequential 하게 되있는데 찾아간다.
랜덤 엑세스 까지는 os가 제공하지만, db를 할려면 db package가 요구되므로 mysql 도구를 가지고 배운다.
사람 a이 몇 호실에 있는지 레코드를 보여달라 요청하면 어떻게 찾는지, 5호실에 있다하면 250을 찾아야 하는데 (레코드가) 전화번호부를 찾듯이 , 몇호실에 있다 라는 기록된 전화번호부 같은것이 있어야 한다.
거기서 찾아서 이 사람은 어디가면 있구나를 알아야 한다. 그런것을 index tree로 만든다해서 이렇게 붙였따.
ㄱ 시작하는 사람은 1로가고.. db에서 찾을때 index tree로 보는데 이걸 뭘로 만드냐면, data sturct에 b plus tree 같은것으로 만든다.
그래서 index file이 필요하다. data base는 key가 이름이 key다. 사람 a 치면 기본키인데 이름은 모르고 주민등록번호는 안다. 주민등록번호를 가지고도 index tree를 만들어야 한다. db는 재주가 없고, db옆에는 전화번호부 파일이 있어야 한다.
2번까지는 os가 제공하니까 배운다.

## R/W offset Functions
sequential access는 많이 나왔다. 읽으면 차례대로 가는거니까
좋아하는 노래, 빨간맛이 있다. 빨간 맛 불르라 하면 노래를 처음부터 하면 잘부르는데 중간에서 부터 부르면 생각이 안난다.(사람은 sequential 한것에 강하다. random은 강하지 못하다.)

random access 할때 fseek을 사용한다. fseek을 파일을 오픈하면 r/w offset 혹은 r/w pointer 생긴다.(다음에 access 할 위치다.) 읽거나 쓰거나 하면 계속해서 카센트 테이프 하는것처럼 앞으로 가는데 그 위치를 맘대로 바꾸는게 fseek라는 라이브러리 function이다. fseek는 open file의 stream이고 long offset이 100이면 파일의 100번째로 가라는 의미다. 점프하라 말이다. int ptrname 가는데에 seek option이다. 
SEEK_SET : offset을 100을 주면 100번지 가는게 파일의 처음에서부터 시작해서 100번지로 가라. 
seek_cur : 현재 위치에서 100byte만큼 앞으로 가라 
seek_end : 파일의 맨 끝에서 더가라는 의미다. 제일 많이 쓰는건 set이다.
5호실데이터를 찾아줘 하면 한 방의 데이터가 50byte니까 5*50 = 250 이 된다.
seek_set을 쓰고 offset을 250을 주면 글로 간다.

rewind는 카센트 뒤로 감는거처럼 똑같다. read/write offset을 0으로 돌려놔라 맨앞으로 돌려놔라!

long ftell(FILE *stream) 은 현재 read/write offset이 어디에 가있느냐 물어본다. 

## fseek, rewind, ftell example(1)
rspn 현재 position을 나타낸다. 첫번째 아규먼트에 파일 이름을 주면 그것을 read mode로 open 한다.
fseek 해서 이 파일에서 fssek해서 L(long 이다.) 8은 8번쨰 바이트로 옮겨라(파일의 첫번째 처음을 기준으로해서)
여기서보면 test.dat 파일이 있는데 이안에 들어가는게 this is a test data라는 캐릭터가 들어가있는 파일이다. 이것을 open해서 8번째로 옮기고 ftell을 해서 몇번지에 있냐 pos에는 8이 return 된다. 
fgets(buf,256,fp), fgets 256(최대) 캐릭터를 버퍼에다가 파일에서 읽어다 줘~ 8번째 byte에서부터 string을 읽어들인다. maximum은 256이다. printf position, position은 8을 찍는다. buffer에 있는것은 읽어들인것을 찍는다.

rewind하면 r/w offset이 0이되고, 위치가 물어보는 pos에는 0이 return 되고
데이터를 0번째부터 읽어들여서 스트링을 여기서는 printf("%d", pos); 추가하고 fclose(fp)한다.

이런 random access 어떻게 하느냐 파일에 대한 구조는 강의시간에 한다.

## I/O Types

I/O 할때는 formatted I/O가 있고 Unformatted I/O 가 있다.
formatted I/O는 printf할때 %d 주면 decimal로 찍어달라 요구 %4d하면 10진수로 찍는데 4자리 수로 찍어달라 뜻
그런것을 내가 원하는 형태로 칸을 맞춰서 찍게끔 I/O를 했던거 그리고 내보는것도 전부다 아스키 코드(데시말로)내보낸다. 이런거 formatted I/O고 
unformatted I/O는 integer는 4byte 있으면 integer가 1234가 들어가 있다 하더라도 이것은 32bit의 binary signed two's compliment number로 1,0로 들어있는데 이것을 고대로 file에다 쓰면 binary I/O다.
winodw/linux에다 binay file찍어보면 이상한 글자가 나온다. 그것을 사람이 볼 수 있는 포맷이 아니라 메모리에 있는 그대로 바이너리가 들어간것이다.
float는 sign 하고 exp 하고 mantissa로 구성된다. (exp는 몇승) 정수는 2의 보수로 1.0을 있는 그대로 집어넣는것을(디스플레이어에) 바이너리 I/O라고 한다.
데이터를 저장하는 목적일때는, formatted I/O는 사람이 보기에는 편하지만 길이가 들쭉날쭉하다.
binary I/O를 하게 되면 Integer, 다른 형들이 4바이트씩 들어가고 double은 8바이트씩 들어갈 테니까 contact하다. 파일이 
데이터 저장하거나 리트리거(나중에 읽어들일 목적으로 하는게) binary I/O하는게 유리하지만, 디스플레이 할땐 이상한글자가 나온다. Binary representation한걸 아스키 코드로 읽으려하니까 이상한글자로 나온다.

I/O Binary format 메모리에 있는 그대로 가져다 쓴다. integer는 4byte고 float는 4byte double은 8byte(sign+ memtisa + exp 구조로 가는것이고) 이것을 읽을려면 디스플레이에서 안보이니까 바이너리 읽는 프로그램을 통해서 string , char 바꾸는 뷰어 프로그램을 설치해야 할것이다. 

Formatted I/O는 integer나 float나 double을 메모리에 있는 표현대로 쓰는게 아니라 아스키 스트링으로 컨버젼을 한다. %d하면 아스키 컨버젼하대 그것을 decimal 10진법으로 사용해서 아스키 컨버전하라는 말이고 input은 키보드로 abc 치면 아스키 코드가 들어올텐데 그걸 integer 받았을때는 integer나 float나 double로 번역해서 메모리에 집어넣어야 하니까 그것을 해주는 function이 scanf다. scan 컨버전 뜻. 키보드 읽는것을 아스키 코드로 쭉들어오는것을 읽어서 인테져, 플로팅 포인터 넘버로 컨버전한다해서 scanf function으로 만든것이다. 사람이 보기는 쉽지만 파일 사이즈가 들쭉 날쭉 하고 파일 사이즈가 커지게 된다. 

## Formatted Output
리눅스는 파일의 내용 가져다 char로 파일의 이름을 주면 디스플레이가 가능한데, 바이너리 파일은 안된다.
formatted Output할때는 이미 썼던거 printf 많이 쓰고 %d, %s 어쨌고 아규먼트를 주는데 printf(... argument 개수가 하나일수도있고 두개일수도 있고) 콘솔에다 나가는것이고
int fpintf(File * stream, const char *format. /* args */...) 콘솔로 내보내지 말고 file로 내보내는것이다. 앞에 f가 붙는다. f가 붙으면 디스크의 오픈된 파일로 나간다. open 된 파일의 스트림을 주고 있다. sfintf 는 formatted한것을 printf("%d",..)이런것을 string에다 깔아달라말이다. string으로 컨버전해달라
거꾸로 읽는것을 scanf를 썻는데 파일에서 읽을땐 fscanf하면된다. 거꾸로 string에서 output했으니까 string으로 읽을땐 sscanf쓰면 된다. 

## scanf, fscanf, printf, fprintf examples(1)
file *가있고, 버퍼에 캐릭터가 256 있고, 스트링도 있고 
string으로 scnaf하는것은 반드시 끝이 NULL로 끝난다. test.dat를 write mode로 open했다.  fprintf, number와 string 있을것을 가져다가 콘솔에다 쓰는게아니라 오픈한 파일에다 쓴다. enter까지 내보낸다. 
repoen하면 open한것을 reopen한 이유는 read mode하기 위해서 그리고 r/w offset을 0으로 댐 (wrtie모드가 read모드로 바뀐다.) 0이된다는건 제일 앞으로온다.
파일에서 쓴것을 파일로 읽는다.

## Error Confirm
파일 I/O하면 에러가 생기면 gobal variable에 error 넘버가 있어서 에러가 났던 숫자가 저장된다. 에러 넘버가 3이면 메뉴얼을 찾아봐야 한다. 3이라는 에러가 들어가있으면 에러가 안났을때는 아무것도 없는데 제일 최후 에러가 난 번호가 들어가 있다. 제일 최후로 난 에러가 뭐냐를 물어본다. 
에러가 없으면 0이 리턴된다.(ferror)
파일에 끝에 도착했는지 물어본다(feof)
clearerr- ferror를 clear 한다. (error가 더이상 필요없다. 의미)

## ferror, clearerr Functions
putc('?',fp); ?를 fp에 써라
에러가 발생할것이다. read모드로 open했는데 write했으니까 error 발생
ferror를 물어보면 전에 생겼던 error가 나온다. 메뉴얼을 찾아보면 error가 뭔지 나온다.
error 지울땐 clearerror
clear error 한뒤에 ferror을 찍어보면 error가 없다. 0을 return할것이다.
그리고 ferror() returned 1 은 read mode 인데 write mode로 했다 해서 1이 에러 로 나올것이다.

## feof Function
read mode로 오픈된것을 EOF 걸릴때까지 스트링 파일을 읽어들이겠다.  
string 읽은것을 print 한다 
eof에 다다르면 while(!stat) 가 false를 return 할것이다. 
false return 되는 이유는 파일이 잘못될수도있고 eof 될수도 있으니까  

파일에 끝에 도달할 경우 0이 아닌값 반환
stat - feof(fp), eof면 0이 아닌값으 반환하므로 while를 통과한다. 




