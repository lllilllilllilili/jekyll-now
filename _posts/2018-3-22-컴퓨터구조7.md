---
post : layout
title : 컴퓨터구조7
---
## More about Loads and Stroes
Load/Store을 통해서 메모리 오퍼런트 주소를 지정해야한다.
Alignment restriction - 워드주소를 읽을땐 4의배수로, Halfword를 읽을땐 2의배수로 익는다.(앞에주소..)
부분적으로 메모리에서 읽혀올때는 Sign-extend와 Zero-extend가 있다.
Sign은 부호확장(1로..) unsigned는 부호확장이 아닌 데이터 0으로 채운다 보통
lh(load half word), sh(store half word), lhu(load half word unsigned) zero extension은 u를 붙인다.

## Mips Immediate Instructions(1)
빨리 접근할 수 있는법?
1. 메모리에다 전형적인 constants형으로 로드하기 (x)
2. $zero와 같은 hard-wired registers을 만든다 (x)
3. immediate instructions를 갖는다. (o)
immediate는 i를 붙인다. 작은상수를 쓴다. load/store시에는 address offset이 쓰이지만, immediate시에는 상수값(constant)이 쓰인다.
장점은 명령어 포맷안에 있기때문에 빠르게 읽어올 수 있다.
signed로 값을 표현시 16비트 범위내에서 2의 15승-1부터 마이너스 2의 15승까지다.

## MIPS Immediate Instructions(2)
명령어안에 32bit의 어떤 값을 즉시 만들어 내기 어렵다. 
표현 자체가 어려우므로, 메모리에서 저장한후에 32bit를 읽어오면 offset(Base register)을 통해서 읽어오겠다. 
두 명령어를 통해서 레지스터 안에 특정 상수값이나 주소를 레지스터에 반영할 수 있는데 그 명령어는 lui와 ori이다.
lui $t0, 1010101010101010  과(lui-i format이고, $t0의 upper part에 넣는다.)
ori $t0, $t0, 1010101010101010 인데(ori는 논리or이다.) 결과적으로 두 명령어를 통해서 32bit를 만들 수 있다.
1010101010101010 1010101010101010.

## Review: Unsigned Binary Repersentation
Hex : 0x00000000 ~ 0xFFFFFFFF
Binary : 0..0,32개 ~ 1..1,32개
Decimal : 0~2의 32승 -1
프로그램의 해석상 Unsigned냐 signed에 따라 부호가 없을때 2의32승 -1 이고 부호가 있으면 -1 이다.

## Review: Signed Binary Representation
unsigned 없는 경우에 뺄셈 연산 같은 경우가 쉽지 않으므로, 보수란 개념을 도입해서 1의 보수를 취해서 계산했다. 하지만 4비트의 경우에 2의4승만큼의 숫자중에 1111, 0000이 0으로 표시되는 아깝게 쓰이고 있어서 2의보수를 도입했다.
2의 보수는 제일 큰 양수의 값에서 1을 더하면 제일 작은 값이 된다. ex) 0111 + 1 -> 1000 
앞이 1이고 나머지가 0인 부분이 n비트로 표현한 제일 작은 수가 되고,1씩 계속 더해서 1111이 0에 제일 가까운 값이 된다. 
1000만 2의 보수를 취해줘도 자기 자신의 값이고, 나머지는 대응되는 숫자들이 있다. 따라서, 음수에서 하나더 값이 많다.

## MIPS Shift Operations
8-bit characters를 32-bit word에 쌓는것을 pack
32 - bit word에서 1bit character을 빼오는것을 unpack 이라고 한다.
logical 이란, 맨 오른쪽에 빈자리가 생기면 0으로 채우는것을 logical 이라고 한다.
sll $t2, $s0, 8 // $t2 = $s0 << 8 bits
srl $t2, $s0, 8 // $t2 = $s0 >> 8 bits
shift를 32bit 안하는 이유는 전부가 0이 되어 버리기 때문에 0으로 처리한다.
shift 가 갖는 산술적인 의미는 왼족으로 쉬프트 했을 때 2배가 되고 오른쪽으로 쉬프트 했을 때 나누기 2의 효과를 얻는다. 정수처리시에 빠르다.
오른쪽으로 쉬프트 할때 1111 에서 01111 로 쉬프트 했다하면, 부호가 유지되어야 하기 때문에 기존의 srl 경우 0111이 되지만 sra을 쓰면 1111 부호를 유지시켜준다.

## MIPS Logical Operations
다음은 Instruction Format(R format) 이다.
and $t0, $t1, $t2 # $t0=$t1 & $t2
or $t0, $t1, $t2  # $t0=$t1 | $t2
nor $t0, $t1, $t2 # $t0=not($t1 | $t2)
다음은 Instruction Format(I format) 이다.
andi $t0, $t1, 0xFF00 #$t0 = $t1 & ff00
ori $t0, $t1, 0xFF00 #$t0 = $t1 | ff00

## NOT operation in MIPS
NOT은 비트를 다 뒤짚는 것이다. 하지만, MIPS에는 NOT이 없다.
(a NOR b) == NOT (a OR b)
nor $t0, $t1, $zero
zero와 or하고 비트값을 역전하면 not값을 구할 수 있다.

## MIPS Control Flow Instruction
이제부터 살펴볼것은 conditional branch에 대한 명령어를 살펴본다. 
bne $s0, $s1, Lbl # s0와 s1가 맞지 않으면 Lbl로 가라
beq $s0, $s1, Lbl # s0와 s1이 같으면 Lbl로 가라
++zero의 경우에 대해서, 다르면 bnz를 쓰고 같으면 bez를 쓴다. ++
명령어 이름을 바꿔 쓰기도 한다. 같은 명령어다.

bne $s0, $s1, LblA #같으면 이 라벨을 무시하고 다음 명령어를 수행하지만, 다르면 LblA가 주소처럼 작용해서 그 쪽으로 명령어를 실행하게 된다.

Instruction Format을 살펴보면, 
명령어는 한 워드로 구성되고 
bne는 opcode가 0x05이고, rs에는 $s0를 그대로 넣고, rt에는 $s1을 그대로 넣는다. offset이 중요한데 (LblA-(PC+4))/4
PC는 처음에 이 명령어를 수행하면 다음 명령어를 수행하도록 설계되어 있다. 
LblA를 표현하는데 offset인거 같고,
LblA가 PC를 가리키고 있는곳으로부터 얼마만큼 떨어져 있는가(offset을 찾는것이 중요하다.) 
예를들어 bne의 메모리위치가 100이면 pc는 104번지를 가리키고 있는것이다.
offset에 들어가는 형식적인 모습이 (LblA-(PC+4))/4인 까닭은 명령어의 위치가 4의 배수만큼 숫자로 표현될것이다.(오른쪽에 00은 낭비된채로) 그대로쓰면 낭비가 되기 때문에 Byte offset을 쓰는것이 아니라 ++Word offset을 쓴다.++(4로 나눈값)
++몇 바이트 보다는 명령어 몇개 떨어져 있는지 확인하는것이 중요++