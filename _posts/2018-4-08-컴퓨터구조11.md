---
post : layout
title : 컴퓨터구조11
---
## 컴퓨터구조11
컴퓨터구조11
## step
first step
명령어든 데이터든 메인 메모리에 있고, 메인 메모리에 있는 명령어들 중에 다음에 실행할 명령 주소가 pc이다. pc가 지시하는 한 워드를 가져와야 하는데 가져오는 단계를 instruction feche step 이라고 한다.
메모리에는 read signal 보내고 해당되는 워드가 읽히고 pc 자동적으로 4만큼 증가하고 다음 명령어를 가리키도록 

seconde step
가져온것을 해독한다. 제일 중요한건 opcode 32bit 중에 상위 6bit(opcode bit) rs, rt, rd 이런 레지스터 넘버에 해당되는 레지스터를 32개 레지스터에서 읽어내는것 register prefetch라고 한다.

이 두스텝은 어떤 명령어든 동일하게 거치는 스텝이다. (instruction fetch, regster prefetch)
다음 스텝부터 명령어에 따라 하는 행동이 달라진다.

산술/논리 연산
업로드/저장 연산
점프 연산 
에 따라서 해야할 일이 달라진다.

third step
opcode 0이면 산술/논리 연산자라는것을 안다. operation 바로 실행시킨다. R-format으로 구성, R-format에 모든 operand가 register에 있다. 레지스터 에 있는 값이 2nd step에서 읽어냈다. 그것을 실행을 시킨다. ALU를 활용한다. ALU는 안에 산술/논리 기능이 회로가 구비되어 있고 값이 들어가면 그 값에 대해서 모든 기능이 동작한다.

ALU 나온 결과중에서 실제로 필요한 값을 선택해서 내보낸다.(기능, (조합회로)muxtiplexter 내부에 구현되어있음, multiplexer에 선택선이 필요하다. 선택선이 alu control이 mux의 선택선 역할을 하게 된다.)

Memory-reference instructions = 로드/스토어 인스트럭션
effective address(유효 주소) 실제로는 로드/스토어 명령어 보면 메모리 oprand 주소가 명령어상에 base와 offset으로 구성되어있다. 메모리에 전달할때는 base offset 전달 못한다. 프로세스 안에서 주소값을 계싼해야한다. 베이스 값에다가 offset을 더해야 했다. 베이스 안에 값에 다가 offset을 더한값을 유효주소 라고 한다.(왜 effective냐, 메모리에 이해하기 위해서 계산된 주소를 본다)

만약 브랜치면, rs, rt, Label rs와 rt 비교해서 조건이 맞으면 Label로 가라 여기서는 rs와 rt를 비교한다. 연산을 통해서 비교할 수 있다. (하나에서 다른하나를뺌 0이면 같은것이고 0이아닌값은 다른값이다.) = load/store instruction

Final step
메모리 레퍼런스 인스트럭션 = 유효주소를 계산했는데 그 주소를 메모리 에서 d램으로 주소를 보내고 로드일 경우에는 로드는 메모리에서 읽어내는것이다. 스토어는 메모리에다 쓰는것이다. 메모링 엑세스한다는것은 아까 계산한 effeictive 위치에 접근한다. 산술, 논리 연산자는 ALU 계산결과가 나오면 다시 목적지 register에다 넣는다. 브랜치 인스트럭션은 비교결과에 따라서 PC 바꿔줘야댐(PC 다음에 실행할 명령어 주소를 가리킴) 비교를 했는데 같든지 , 다르던지 브랜지 지정한 조건을 만족하면 라벨의 위치로 바꿔주고 만족하지 않으면 프로그램 카운터를 바꾸지 않는다. 바꾸지 않으면 브랜치의 다음 위치다.
비교해서 분기조건이 만족되면 PC를 바꾼다.
PC 는 첫번째에서 명령어를 가지고 올때 바뀌고 3,4 단계에서 Branch가 아닌경우 안바뀐다.(첫번쨰에서 pc 위치 고수) Branch는 분기하는 주소로 바뀐다.

## clocking
컴퓨터 시스템은 clock에 기반했다.
clock에 edge에서 값이 변경이 일어난다. 모든 storage elements는 레지스터, 메인 메모리 가 해당한다. 동일한 클락 엣지에서 동작한다. edge-triggered clocking이라한다. (falling edge를 채택하고 있다.)
클락을 얼만한 길이로 해야하는가? 디자인할때 얼마나 하느냐에따라 컴퓨터 시스템의 속도가 결정된다. 어떤 플립플랍(레지스터를 구성하는 기본적인 bit다.) 한 bit가 플립플랍으로 구성된다.
32bit 레지스터가 플립플랍이 32개 나열되었다. 
(시작)플립플랍에서 (도착)플립플랍까지 도달하는데 한 주기안에 표현되어야만한다.(중요)
클락을 무리하게 돌려서 짧게해서 클락이 도착까지 못하고 짤리면 falling edge(값이 변경되는 시점)
 이 더 짧게 나타날것이고 combinational logic block까지 충분히 가지 못한채로 falling edge가 발생할것이다. 한 클락 사이클은 시작부터 도착할때까지 시간을 충분히 포함해야 한다.

propogation delay는 플립플랍에서 나오는데 까지 걸리는 시간, 중간에 있는 combinational 통과하는 시간을 의미, 도착 플립플랍에 값이 들어가면서 바로 값이 바뀌지 않고 어떤 값이 반영이 되기까지 미리 예비시간(setup)이 필요하다. setuptime이라고 한다.
이것을 다 더하면 사이클 타임이다. 길면 문제가 되지 않는데 짧으면 동작하지 못한다. 하염없이 길면 성능이 안좋아짐.
