---
post : layout
title : 데이터통신(기)10
---
## 데이터통신 10 
저부분을 생각해보라고

알아보라고 공부해보라고
여기 
여기에 가령 여기가 뭐 i번째고 j번째인데 여기에 에러가 발생했고 여기도 에러가 발생했으면 이게 에러의 사이즈다. 이게 에러 사이즈다 L이다.
j-i, j-i 와 L과의 차이는 이게 +1이 L이죠 가령 에러 사이즈 여기서부터 여기까지는 약 쪽 포함이니까 이와같은 관계가 있다. 
L은 이런 의미를 갖는거고 이거 폭이라는 거죠 에러가 발생하는 폭 
r은 디바이저다 디바이저 G(x) = x의 r승 + 모 + ... + 1 모양의 r은 디바이저 crc에서 사용하는 디바이저에 최고차항이 r이다. 
자 이 L과 r과의 관계를 갖고 지금 어 표를 제시를 했쬬
그래서 뭐 어떤 둘간의 관계 이걸 지금 받아쓰는사람들은 뭐야 
숙제를 안했단 말이야
L이 뭔지 r이 뭔지 지금 받아써야되? 저 
고민을 해봤으면 L과 r을 알고있어야죠 
굉장히 수상한 사람들이다.

3가지가 있어요 
crc, 자 여기에 지금 소용되는것이 G고 G는 x의 r승 더하기 + 1 분에 여기는 뭐죠 여기는 지금 x의 j승을 빼면은 x의 j-i승 + 해서 +1 자이게 나누어 지느냐 이거를 보는것이다. 근데 우리 이미 봤듯이 얘는 이 x의 제로항 
그러니까 플러 스 1이라는놈이 있고 그거와 더불어서 한항이라도 더있으면 얘는 나눠지지 않는다 라고했다 (하나의 싱글에러 있는지 확인할때)
따라서 이미 G(x)에는 그런조건이 있기때문에 얘는 안나눠진다는게 확실하다 얘는 우리 무시한다. 이거임 요식이지 결국 (x의 j승)
이식이 과연 나누어 지느냐 를 지금 확률적으로 표현한것이다.
어떤 경우에 나누어지는데 나누어지는 확률이 어느정도 되는지

자얘는 분모는 주어진거고 분자는 통신중에 발생해서 만들어진 에러의 패턴이다. 
j-i 차수의 폴리노미얼이 나온것이다. 자 저상태에서 여러분들 숙제 해왔으니까 해온사람 시간이 많이 걸릴거같아서

저게 L이 r보다 작거나 같다 이 
가령 이 차수가 얘보다 작으면 그렇죠 맨위에 있는것은 이 차수가 얘보다 작으면 가령 x의 5승 더하기 +1 인데 x의 4승 더하기 + 1 이다 이런거는 나누어질수가 없다. 분자가 차수가 더 작으면 즉 그 케이스를 얘기하는것이다. 다시말해서 j-i 가 r이면 이런 거죠 
j-i가 r이면 r 보다 작으면 그럼 안나눠진다. 그거에 따라서 에러가 검출이 될 수있다 이거임 
나머지가 생기니까 근데 얘가 L-1이라고 그랬죠
여기 보면 요 관계식에 의해서 j-i는 L-1 이다.
L-1 L이 요거를 표현한 L이 r+1과 같죠 이거를 표현하면은 L이 r과 r보다 작거나 같은것이다. 
그렇죠 다 정수이기때문에 L이 r+1 보다 작다라는 얘기는 L은 최대로 가질수 있는값이 r이다 그렇죠 r+1보다 작으니까 
그래서 이와같이 표현할수있단 얘기고 이 표현이 저 맨위에 조건으로 나온것이다 그래서 저조건의 의미는 분자의 차수가 분모의 차수보다 작은경우 
이거는 너무도 뻔한 상황이다 안나눠 진다. 
분자가 분모보다 더 작으니까 몫이 나올수가없고 나눠지지도 않는다.
저게 바로 그 가장쉬운 그 어 해석이고 두번째 와 세번째는 사실 두번째는 알지만 세번째도 어 유도를 할수있다. 두번째가 어떤 어 과정을 통해서 나온식이냐를 이제 살펴봐야죠 
고민해본사람 

지금 뭐 다른케이스는 뭐겠어 이게 차수가 얘보다더 낮은 케이스를 제일 먼저 봤으면은 그다음에는 혹시 이거와 이것이 같은 차수인경우는 한번 살펴보고 그다음에는 얘가 얘보다 더 큰 차수인경우 그거야 지금 저게 
그렇죠 두번째는 j-i 와 r이 같은 차수 일경우 
j-i = r인경우죠 이게바로 이게 바로 L-1 이라고 했죠 얘가 
그러다 보니까 또 얘를 사용안하고 L과 r과의 관계를 쓰다보니까 r+1 이지 
두번째는 L이 r+1인 상태 1인 경우를 얘기하는것이다 다시말해서 이 차수와 이차수가 같다 이거임 여러분들 과연
분모와 분자가 차수가 같다. 
그러면 나누어질 수도있고 안나눠질수도있죠
어떤 경우 에 나눠질수있을까 가령 내가 x의 4승 더하기 x더하기 1이면 여기도 x의 4승이 있다. 이거죠 분자에도
얘가 얘랑 나누어질려면 이 주위에 뭐가 따라오면될까?
+x+1  같아야 되는거지 
차수가 같다면 분모와 분자가 완전히 일치가 되야 나누어지죠 그렇죠 
다르면 안나눠진다.
그래요 
같죠 차수가 같으면은 완전히 같아야되 모든 항이 얘는 x에 3승에 계수가 0이었고 x의 제곱에 계수도 0이었고 x의 계수는 1이고 x의 0승도 1이다 이거임
계수가 몇개있냐면은 4개 
얘를 제외한 최고차항에 있는것 제외한 나머지 계수는 4개가 있죠
4개 
얘도 똑같이 x 의 3승 계수는 0이어야 되고 제곱 0이어야되고 1승은 1이어야되고 제로승은 1이어야됨
그렇죠 계수들이 완전하게 같아야되!
그러면 계수가 갖을수있는건 1/2 이다 확률적으로
0또는 1밖에 없어요
얘가 0이면 얘도 0이고 
얘가 1이면 얘도 1이어댜 된다 그게 몇개있죠 
그게 이게 분자가 x의 r승이면 나머지 지금 계수가 몇개 가 있냐면 r개가 있다 왜냐하면 x의 0승부터 r-1 승까지 있잔아 얘를제외한 나머지가 0부터 r-1 까지니깐 계수가 r개가 있다.
r개의 계수가 얘도 같아야되고 얘도 같아야된다. 얘와 얘가 같아야된다.
서로 같은 차수인데 계수가 같아야되요
그러면 같은 차수에 있는계수가 얘가 1이면 얘도 1이어 되는거죠 
가령 얘가 1일때 얘가 1일 확률은 1/2 이지 
1/2 이죠 0과 1중에 둘중에 하나죠
또 얘가 0일때 얘가 0일 확률은 또 1/2 
헤서 이게 r승이 되어야한다. 
r개가 
계수가 r개가 다 똑같을 확률은 1/2 에 r승이 된다.
그런데 여기보면 r-1 이죠 이게 왜 이럴까 이걸르 사실 고민을 해야한다.
왜 r-1 고민할거리는 아닌데 맨 마지막 +1 은 양쪽에 보나마나 있다 라는거임
얘들은 보나마나 있다 왜냐하면 우리가 이 G에 이 디바이저에 조건이 x에 0승에 해당하는것 은 반드시 있어야 되는게 이 디바이저에 조건이라 이거죠 
얘는 반드시 있는거고 그럼 얘는 반드시 있느냐? 얘도 반드시 있단 말이죠 
이게 이게 그 에러 패턴을 x에 여기 x에 i승이고 여기 x의 j승인데 x 의 j승 을 
아니 x의 i승을 빼보자
i승 빼면 x의 j-i부터 쭉해서 여기에 해당하는 놈 +1 이 나온다. 이거죠 
우리가 이 에러패턴을 폴리노미얼로 표현할떄 가장 아랫자리에 해당하는 차수가 뭔가 있으니까 거기서부터 시작했을거 아니야 
그렇죠 그 차수에 해당하는것을 앞으로 뺏잔아 x의 i승을 빼고 x의 j-1 부터 쭉했는데 요 마이너스 플러스 1 요자리에 바로 x의 i승이 있었던 자리 분명히 있어야 되는거죠 그래야 지금 이런 이런 폴리노미얼이 나올수있다 이거죠
따라서 확률적으로 표현한게 아니라 이거 디터미스트 하다 이거에요 여기도 있고 당연히 여기도 있어요 
그래서 r-1 승 
얘 맨 처음과 맨 높은차수와 맨 아래차수를 뺴고 나머지 계수들 r-1 개가 있는데 애들이 위아래가 완전히 같아야 되는거지 그럴 확률은 서로 1/2 확률로 같은데 그게 r-1 번을 반복해야 하니까 r-1승이 되는거에요 그게 바로 나누어지는 케이스죠 나누어지는 케이스 
나누어진다 얘기는 에러패턴이 엉뚱하게도 이 디바이저로 나눠어 지니까 에러가 발생했는데도 불구하고 에러가 없다라고 함묵? 하는거야 따라서 에러를 검출하는 확률은 1-(1/2)^(r-1)
써있듯이 에러를 검출할 확률은 디텍션할 확률은 1-(1/2)^(r-1)승 이라는거임 

자 그러면 얘가 됬으면 이제 그다음 애는 뭐냐면 이 위의 차수가 더 클때야 이제얘가 얘가 얘보다 더 클 떄 가령 여기에 x에 x의 6승 더하기 뭐 있고 여기에 x의 4승 더하기 뭐있다. 이경우에 과연 분자가 분모로 나누어질까를 계산을 해보면 나누어 봐야곘다 나누어 가다가 언제 이제 드디어 이제 오냐하면은 
당연히 나누어지든 몫이 분명히 있을테고 이렇게 나눠가다 보면은 차츰차츰 나누어 가다보면은 x의 제곱 뭐하다도 위에 커바야 x의 4승이 나온다 이거죠
무슨 말이냐? 나누어보면은 뭐 어떻게 되나요 
x의 6승더하기 +1 , x에 가령 4승 더하기 일이다 
그럼 여기 x의 제곱 쓰잔아요 이렇게 
그러면 x의 6승더하기 x의 제곱 뭐이렇게 해서 여기 1더하기 x의 제곱 더하기 1 이런식으로 쓰죠 
자이렇게 나누기 생기는 이놈이 가질수있는 제일 큰놈이 이거일수가, 같은차수가 있을수있는거다. 한번 해볼까 
여기 x의 3승을 하면나온다.
x의 3승을 해보면 
봐여 그러면 x의 3승 이게 계속 몫이 있는지 없는지를 알기위해서 나누어가는데 이렇게 되면 몫이 x의 3승이되죠
그러면 x의 6승더하기 x의 3승 그러면 x의 3승 더하기 +1 자 요게 드디어 나왔죠 여기서 이제 아거는 나누다보면 애는 몫이고 나머지 혹은 하튼 나누다 보면 결국은 이 두 케이스 중에 하나가 된다 얘기에요 
이 두케이스중에 하나 
이렇게 같은 차수가 나오거나 아니면 여기에 더 작은 차수가 나온다 그러면 그렇게 나오면 그다음엔 여기랑 똑같은 이 두케이스는 똑같은 애기를 할수가있는데 할수가있는데 이때는 약간 좀 상황이 다르게 이거 완전하게 나누어 지네 그냥 x의 3승 더하기 1 하면 끝나네 
(x의 제곱승으로 나누면 더 작은 케이스도 있는거 같은데 지금 그런 목적은 아니니까)
이거 모듈러 2연산이라고 했지
뺄셈이나 덧셈이나 마찬가지임

여러분들 이거 뭐죠
이 crc연산하는거 연습을 해봐야되(시험)
자 이렇게 나누다 보면 결국 여기 나오는놈이 자기와 같은 차수이거나 낮은놈이 나오게 된다. 그렇죠 그때부터 다시 이제 이제부터는 나누어질까 과연 (궁금하다)
알수있다 이거임 왜냐하면 이미 차수가 높으면 나눠봐야되 
일단 나눠본다음에 그다음에 같은 차수 또는 작은 차수가 나오면 그때 시작해보면된다. 
이 요 조건이 뭐냐면 분자가 분모보다 차수가 높은 경우 
해서 이렇게 가다가 정확히 지금 여기 정확히 나왔네 
x의 3승 더하기 1 이와같이 나왔네 
정확하게 나왔네 이런 확률이 얼마가 되겠냐 이거죠 이럴 확률이 
이렇게 될 확률

이럴확률 이 지금 정확히 같을려면은 아까 봤죠 이 계수가 이게 계수가 총 r+1개있어야 0승부터 r승까지 있으니까 r+1 개있죠
그럼 완전히 이 함수가 이렇게 나누다 보니까 나온 이 함수가 완전히 얘와 똑같을 확률은 (1/2)에 r+1 승이야 그렇죠 r+1개가 있으니까 계수가 
이렇게 

근데 저기 왜 r승이죠 하나가 필요없단 얘기죠
나누어질 확률은 기본이 조건이 이거는 기본조건이다 라는거임 x의 3승에 1이라는 계수가 양쪽에 있다 x의 r승에 해당하는 계수가 양쪽에 똑같이 있을때를 가정을 하는거야 
가령 똑같은 계수가 없으면은 저 맨위에 항에 해당하는거고 맨위에 그럼 안나눠지는것이다. 이렇게 가다가 x의 좌승밖에 없더라 그러면 안나눠지는것이다.
나누어 지는 케이스가 언제냐 이렇게 똑같은 항이 나왔을때 이렇게 똑같은 항이 나왔을때 나머지들이 같은 케이스가 되버리는것이죠 
계수가 r+1 개인데 맨첫번째 항은 1로 
==1이 되어야 똑같은 제일 큰항이 다 살아남죠 나머지들이 r개가 더있는데 걔들이 같다면 완전히 일치가 되는거지 얘와 얘가 그러면 나누어지는 바람에 에럴르 검출 못하는것이다. 이경우에는 반드시 맨 마지막 +1이 있다는 전제가 여기는 성립이 안되지 나누다 보면 맨 끝에 항이 +1있다는 그게 전제가 안된다 이거지 여러분 이런저런 케이스 한번 나눠봐야되요 
여기는 이걸 얘기할떄는 항상 +1 여기 있다라는걸 가정을 했지 근데 이렇게 나누다보면은 얘가 어떻게 없어질수도있잔아 
얘가 이게 없을수도 있다(뭐가 없어지는거지) 이거임 따라서 여기도 같아야될 조건까지 들어가서 
이번에는 전체 맨 최고차항 빼고 나머지 r개의 계수가 모두 같아야 될 확률은  1/2 에 r승 이라는거죠== 
여기 지금 암튼 다시 고민을 해봐요
그래서 에러를 검출할 확률은 1-(1/2)^r승이 된다.
폴리노미얼을 갖고 설명을 할수있는거지 양쪽이 나누어지는 케이스들을 이 계쑤들이 같냐 계수들이 같은 경우만 나눠진다. 그런 확률값을 쭈욱 구한게 바로 저 표현이다. 내용이다. 

그래서 예를들어서 지난시간에 도 봤지만 이와같이 G(x)를 33승이라는?? 이 무려 33비트짜리 어 바이너리 표현하면은 33비트 다 이거죠 이게 여기까지 x의 0승깍지 포함해서 표현하면 
사용하면
저런 그 G(x)를 사용하면 뭐 어느정도의 확률로 에러를 검출하는지 
나와있다라는거임 지난시간에 우리 봤듯이 뭐 burst length가 33 
여기서 여기까지 길이가 33개 그 length 사이에 얘와 얘가 에러가 발생해 그러면 가운데 에러가 있든 없든 하튼 이만한 사이즈에 발생하는 에러를 검출해낼수있는 능력 그 에러를 검출하지 못할 능력 은 100억분에 5다. 이런 
확률 로 

이걸로 이식에 집어넣보면 
r은 32
음 ... 
그리고 마지막으로 이제 그 정리했던 거가
요거 
그래서 G(x)가 가져야될 조건
어 반드시 최소한 두개의 텀 이상이  있어야한다. 
+1 얘가 반드시 있어야 되고 하나더 있어야 되는 최소한 두개가 바로 이  
1번 2번에 해당하는것이다.
자 이부분들은 어,...
x에 t승 +1 뭐야 이건 
요거요 중요한 얘기였다.
x+1 이라는 이 이놈이 분자가 x+1이라고 하는 이 텀을 요소를 갖고있으면 홀수개의 에러를 무조건 검출해낼 수있다. 
이부분은 지금 아마 이런 조건들을 쭉 종합해서 한마디로 표현했는데 x의 t승 + 1을 어 나누어서는 안된다. 이거다. x의 t승 +1 
t값은 뭐 2에다 n+1이다. 
지금 이 내용들을 한마디로 묶어서 아마 저렇게 했죠
???

## 표준다항식 
실제쓰는 그 폴리노미얼 
랜에서 쓰는 그런 디바이저가 이런 
crc 통신기라고하죠 저것을 
우리가 hdlc 곧 오늘 들여다 보게될텐데 hdlc라고 프로토콜에서는 아 crc 16을 쓴다. 16
이건 표준이에요 
이게 x의 16승 부터 시작하는데 16승 시작부터 아무거나 쓰는게 아니라 각 반드시 x 16 더하기 x 12승 더하기 x의 5승 더하기 1 이라고 하는 요 규격화된 요 폴리노미얼을 쓴다 라는 거임 디바이저로 
자 이게 해서 이 지난시간 에 쭉 이거까지 했다. 
exclusive or까지 활용을 해서 뭐 어 이것도 봣죠 이 

여려개 쭉 흩어져서 발생하는 에러를 검출해낼 수있는 방법이죠 지금 그러니까 저거는 이와같이 아 청크 인털리빙이라고 해서
가령 큰데이터를 n개로 쪼개서 덩어리 를 n개로 만들어서 보낼때 얘들을 몽땅 exclusive oring 한놈을 같이 보내는것이다. r을 그래서 그중에 어느 한놈이 에러가 발생하면 이와같은 수식을 적용하면은 바로 이 원래의 값을 내가 찾을 수있다 아주 간단한 논리지만 굉장히 어 좋은 아이디어라 이거죠 
exclusive oring이라는 오퍼레이션을 취하면 바로 저런걸 얻어낼수있다는거죠 이거는 이 n개중에 하나만에 덩어리가 이 에러가 발생했을때 우리가 사용하는거죠 두개 이상 발생하면은 저런 방식으로 exclusive oring 방식으로는 할수가없다. 그래서 이 아이디어는 그런것이다. 뭉쳐서 5개가 발생할 수 있는 에러를 각 그 덩어리 5개중에 어느 하나씩으로만 발생하게 분산시키는 방법이 바로 이와같이 만든다음에세로로 보내면 각각 하나씩 묶어서 보내고 또 두번째 열에서 보내고 세번째 열에서 묶어서 보내면 어느 한덩어리가 한부분에 많은 에러가 발생해도 결국은 얘들은 각 행의 하나씩에서만 나온것이기 때문에 각 행마다 아까 와 같은 exclusive oring 방식으로 복구를 하면은 각 행마다 다 복구할수있다 라는거임 
그래서 interleaving 방식이다 라는거임 
보여주고 있다.

숙제가 있다. 
숙제를 한번 하면서 4번에 crc 해볼수가 있겠네요 4번에 
그리고 3번은 오늘 아까 배웠던 한글 복습 해보고 자 해서 4문제를 다음시간에 숙제 해보자 

## Chapter 11 Data Link Control
12장 까지 한다.
자료를 다 올렸고 
12 장이 mac이다. 멀티플 엑세스 
컨트롤 미디어 엑세스 컨트롤 그부분이 데이터링크 레이어에서 제일 중요한 
부분인데 
오늘 11장
시험은 21일 목요일 10시 15분 충분히 시간을 갖고 10시 15분 
큰방이지

출판사에서 제공하는 슬라이드 없던 챕터다.
이전버전에서는 없던 챕터를 이제 버전 5에 와서 
introduction부분을 집어넣은것이다. 결국은 뒤에가서 깊이 들어가는데 
11장
11장 다루는 부분은 4가지이다.
어 dhc
지난시간에 
데이터링크 레이어를 우리가 두번째 레이어로 부르고 있다.
두번째
5개 레이어 중에 두번째 레이어인데 요고를 서브레이어로 나눈다고했죠 이렇게 
데이터링크 레이어를 서브 레이어로 나눠서 여기가 dlc 레이어고 여기가 맥 레이어다 이렇게 된다. 
서브 레이어로 얘기를 한다 이거죠 
요게 이게 데이터링크레이어 에요 
데이터링크 레이어
두개의 서브레이어로 나누는데
11장이 요 윗부분을 얘기하는거고 12장이 mac 이 다음 12장에 있다.
11장은 어 뭐 좀 사실 중요한 부분이 mac 레이어 쪽이다.
중요하다.
이 재미난 얘기도 많고
그래서 서브 레이어 이쪽을 지금 보여주고 있다. 이쪽은 네트워크 레이어 에 대한 서비스를 제공하는 측면이고 그런 측면을 우리가 어 그 염두에두고 봐야되고 mac레이어는 아래 물리게층과의 접촉부분이라고 생각하면됨 
이렇게 서브레이어로 나눈것은 위 상위계층과 관계는 dlc가 하는거고 아래계층 물리레이어 는 mac 계층 맥서브 레이어가 주로 한다. 이런 개념으로 두층을 나눠서 생각을 한다. 

이와같이 4가지 섹션이 있는데 어 11.4절은 생략하고
hdlc 라고 하는 프로토콜이 이 데이터링크레이어 만들어지는 어떤 프레이밍에 한 기본적인 옌데 이런 ppp 같은 프로토콜은 바로 이 hdlc에서 제시한 프레이밍을 그대로 사용하는거 특별한 케이스일 뿐이라 이거죠 
그래서 기본적인 프레임에 방법을 이 hdlc에서 우리가 배우고 그다음에 mac 레이어로 넘어간다. ppp는 그거에 특별한 케이스일 뿐이고

넘어간다 ppp

이 출판사 제공한 슬라이드는 말이 많다.
어 일단 dlc 서브 레이어로 지금 계속 부르고 있다. 아까 얘기한데로 서브 레이어야 이렇게 서브레이어
dlc 서브레이어 가 제공하는 서비스 
서비스를 이 첫번째 1.1 섹션에서는 다룬다. 
그 서비스라는게 무엇이냐면 프레임 이다. 이 레이어 가 서비스를 한단얘기는 그 서비스를 받는사람은 요 네트워크 레이어다. 네트워크 레이어에서 내려보낸 데이터를 애가 포장을 하는거지 이 밑으로 내려보낼 준비를 하기위해서 여기 편지 알맹이를 받으면 여기서 편지 봉투에 집어넣는 일을 하는거야 dlc가 그래서 프레이밍이라고 한다 이거임
편지봉투에 집어넣는것이다.
집어넣을때 편지봉투에 이것저것 쓰게되겠죠 이 dlc 서브레이어 에서 사용하는 헤더에 무슨정보를 넣느냐 이제 이런것들로 우리가 그거를 살펴볼수가있다.
프레이밍 이라고하는 프레임이라고하는 서비스를 먼저살펴보고 그래서 두가지 타입이 있다. 프레이밍이 그리고 이 dlc 서브레이어 에서 수행하는 기능중에 flow control , error control 부분이 있다. 이 플로우 컨트롤 에러 컨트롤은 이 링크 다음에 또 전달받을 다 음 링크와 사이에 플로우 컨트롤은 서로 처리할수있는 능력에 맞게끔 데이터를 속도 조절을 한단 얘기고 에러 컨트롤은 여기서 받았을때 에러가 발생했으면 다시 보내게 요청한다든지 이 링크 와 한 홉을 갈때마다 에러 컨트롤 한다는거임 그 에러디텍션은 뭘로 하느냐? 우리 10장에서 배운 crc갖고 하는거다. 그래서 여기에 프레이밍할때 애가 프레이밍을 할때 헤더를 붙인다고했죠 편지봉투에 정보를 집어, 이것저것 정보를 쓰는데 쓰는정보중에 바로 crc 정보도 들어간다 이거임 
그정보가 들어가야 crc정보가 뭐야 우리가 지금 사용한 디바이저로 나누었을때의 나머지를 거기다 써서 보내는거죠 그런 받은 쪽에서 또 나눗셈을 했을떄 이 나누어지는지 안나눠지는지 보는식으로 에러디텍션을 한다 그랬죠

바로 crc 필드가 여기 dlc에서 어 들어간다 이말임
에러 컨트롤이 된단 얘기는 에러 필드가 정의되어있다 라는 얘기임
어 그리고 뭐 
이런 dlc이 여기서 보관 
커렉션 디바인드 도 커렉션 디바인이 아닐수도 있고 
뭐 다 가능하다 이거임

추상적인
두번쨰 섹션, 여기 섹션별 소갠대 두번째 섹션은 
어 뭘 보여주고 있죠 이 어 플로우 컨트롤에 대한 상세한
세번째 섹션이 아까 
기본적인 프레이밍 하는 프로토콜 중에 어느 특정한 hdlc 라고 하는 기본적인 프레이밍 하나의 방법
자 이거를 보고
네번쨰는 어 그거는 생략을 한다. 

프레이밍이 뭐지??

여기 어 데이터링크 레이어가 하는일 여기에 써있죠 
여기 이 데이터를 받은 입장에서는 여기 피지컬레이어 에서 올라오는 한 비트 한 비트 한비트 의 그 정보를 이제 편지에 틀에 담아내는 작업도 프레이밍이라고 할수있고 위에서 내려오는놈을 편지 봉투에 넣어서 아래로 내려보내기위해서 여기 양쪽에 그 헤더를 씌우는 작업도 프레이밍이라고 한다. 
뭐 그렇게 양쪽방향으로 다 우리가 프레이밍이라는 표현을 쓰고있어요 
그래서 어 인?? 시스템에서 이 프레이밍은 마치 인턴 시스템 과 유사하다 이런얘기를 하고있고 
말을 넘어가죠

프레임 이 위에서 이제 네트워크 레이어에서 이 어떤 아이피가 만든 패킷이 그대로 왔다 그러면 이 데이터링크 레이어에서 dlc에서 헤더를 붙이죠 때에 따라서는 트레일러 도 붙인다 이거임 앞뒤로 이 편지봉투에 데이터를 써놓듯이 앞뒤로 이렇게 전보를 써놓고 그리고 중요한건 양쪽에 플래그를 붙이는데 이 프레임 에 시작 과 끝을 나타내기 위해서 플래그 붙인 거죠 
근데 두가지 타입이 있는데 이 플래그 를 만든 두가지 타입이 있는데 첫번째 타입은 character - oriented 하나인 여기 쓰이는 모든 정보들이 바이트 단위에 8비트단위로 쭉 하나의 유닛이 8비트 짜리 정보로 채워지는 그런 것들 캐릭터 오리엔티드 프로토콜이라고 하고 
그렇지 않은거 한 비트단위가 되는것은 비트오리엔티드 프로토콜이 되는거죠 뭐 모양은 비슷해요 이프레임 모양은 비슷한데 어 이 들어가는 데이터가 바이트 단위로 어떤 정의된 데이터들이냐 일종에 우리가 이 키보드로 치는 텍스트 위주로 (텍스트들은 다 아스키로바꾸면 8비트로 바뀐다. 그래서 텍스트 정보들은 거의다 이 8비트 짜리 단위로 쭉 이루어지는 데이터들이다 이런 경우에 바이트 오리엔티드라고 할수있고 비트 오리엔티드 는 그러한 개념이 별로 없는거 이미지 데이터 같은거 그닥 어 임의 로 만들어지는 이미 지 데이터 한 비트 자체들의 연속으로 이루어지는 그런 정보들은 비트오리엔티드 프로토콜 속에 수용이 되어야겠다.)
그런경우에 차이가 있다라고하면 이 플래그의 모양이 차이가 있어서 이렇게 보이는 놈들이 어 구별을 먼저 하고 있다. 

아까 얘기 
가령 crc 값이 어디로 들어가느냐 뭐 이 트레일러 어딘가에 crc 정보가 들어갈 자리가 있는거죠 그 데이터 링크 레이어에서 이렇게 내려오면은 내려온 정보를 갖고 이런 crc 를 돌려서 이 필드에 나머지 값을 채워넣는거임
그래서 보내면 받은쪽에서 그걸 crc로 돌려서 나머지를 
그런 부분이 이속에 있고 그 헤더 부분에 뭐가 들어있느냐? 
조금잇다가 

자 플래그는 이 프레임이 시작과 끝을 알려준다고 했죠 그 플레그는 어떤 특정한 패턴 일정한 패턴을 가져야 하는거에요 그 패턴이 쭉 기다리다가 그 패턴이 나타나면 아 이 프레임이 시작이구나 그거와 똑같은 패턴이 나타나면 끝이구나 이렇게 판단을 한다는 거임 
그래서 문제는 그경우에 문제는 이 플래그와 같은 패턴이 이 패킷속에 나타나면 어떻할꺼냐 그래서 그래서 여기 바이트 스타핑 이런 
바이트 오리엔티드 된 이런 프레이밍에서는 그거를 카바하기 위한 방법이 바이트 스터핑이라고 하는데 한 바이트를 추가한게 그 한바이트가 뭐냐면 플래그앞에 반드시 esc라고 하는 이 문자를 특수문자를 집어넣는것이다.
키보드에 esc 문자 버튼을 누르면 나오면 8비트 고 놈들을 여기다가 반드시 똑같은 패턴이 프레임 내부에 나타나면 그런 놈들한테 esc를 쓴다. 
그래서 받은쪽에서는 플래그에서 esc 이 플래그에서 뭔가를 봤는데 쭉 가다가 어 플래그 또 나타나면 끝인가 아닌가 혼동 안할 수있는 방법이 esc가 있는지 없는지 보는것이다. 바로앞에 esc가 있으면은 아 얘는 마지막 플래그가 아니라 내용속에 있는 같은 패턴의 정보다 라고 얘를 버리고 이 플래그 취하는 식으로 하는것이다. 그래서 플래그 가 오인되지 않게끔 받은쪽에서는 esc를 다 버리는것이다. 
그럼 이 내부에 있는 정보속에 또 esc 라는 정보가 있으면 어떻게 할꺼냐 (이스케잎) 그러면 얘도 역시 esc를 또 붙인다. 그러면 받은 쪽에서 esc이 두개가 나오면 아 하나는 바이트 스터핑을 한거고 버리고 나머지 하나만 정보로 취한다 이거임 뭐 이건 안전장치도 아니다.

비트 오리엔티드는 뭐 다 이 프레이밍 내부에 대한 얘기는 다 같은데 바이트 단위로 만들어지느냐 비트단위냐 이런차이가 있는데 
이 콜레드에 모양이 우리 비트 오리엔티드에서는 이와같이 8비트 짜리 이런 어 복?? 패턴을 취한다 이거임
그러면 여기 이제 이속에 바이트 단위로 데이터 가 나눠진게 아니라 비트단위 이기때문에 이게 어디선가 막 나타날 수있는거죠 막 
어디서 부턴가
역시 플래그 가 중복되서 나타난것을 대비해서 비트 스터핑이라는것을 한다.
여기에 어 당연히 그 같은 패턴이 나타나면 안되기 떄문에 
비트 스터핑은 우리가 플래그에 어떤 패턴을 썻냐면은 0 그다음에 1이 6개 쭉이어지고 그다음 0 이게 처음과 끝을 나타내는 플래그로 쓴다. 비트 스터핑에서는 그래서 이 메시지 속에 그런  비슷한 유사한 버퍼가 많이 나올수있기때문에 그것을 플래그 오인하지 않게끔 방지하는 방법이 이 일단 5개 가 쭉 이어져 나오면 무조건 0을 취하면 된다. 무조건 0을 취한다. 
그러면 여기는 플래그와 동일 한 패턴이 나올수가없다 이거죠 
플래그에는 1이 6개가 쭉 이어지는 패턴이 있어야하는데 여기는 무조건 1 5개 만 나오면 0을 추가한다이거임
그 받은쪽에서 1이 5개 다음에 0이나오면 무조건 지워버려야되 
그건 무조건
무조건 지워버려야대
그래서 보낸 데이터를 추출해낼수있다. 이거임 
이게 5개가 이게 0
이게 비트 스터프
아까와 다르다 
바이트 스터핑은 esc 이라고 하는 바이트를 추가시켰고 플래그와 구별짓기 위해서 비트 스터핑은 1이 연속되는 5개 중에 0이라는 한 비트만 추가하므로써 이 플래그와의 혼동되는 사레를 방지를 한다.(이게 결과고 중요하다. )
