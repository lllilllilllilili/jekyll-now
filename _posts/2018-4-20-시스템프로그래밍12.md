---
post : layout
title : 시스템프로그래밍12
---
## 시스템프로그래밍12
시스템프로그래밍12

## Linux File Types
리눅스 파일 종류는 다음과 같이 6개 종류로 나눠진다.

special file - 디스크에 있는 파일이 아니라, I/O device 키보드 라든가 마우스 라든가 하드디스크 네트워크라든가 디바이스를 파일로 맵핑하는데 ++왜 맵핑하냐면 파일 open/close/read/write를 할려고++ 그것을 special file이라고 한다. special file은 전부다 루트밑에 디바이스란 디렉토리에 있는 파일들이 전부다 디바이스를 파일로 맵핑한 파일이고 디렉토리 파일이라는것은 폴더라고 하는것(폴더 혹은 디렉토리) 디렉토리는 어떤 파일을 가지고 있는것이다. 어떤 가지고 있는 파티션을 말하는게 아니라 디렉토리는 그 자체도 파일이다. 디렉토리는 파일의 이름들을 가지고 있는 전화번호부다. 
character special file - 버퍼링을 거치지 않고 디바이스에 접근하는 파일
block special file - 버퍼링을 거치고 디바이스에 접근한다.

FIFO file - first in first out 파일로 Named pipe fifo 준 하나다. Named pipe - 전혀 관계 없는 프로세스끼리 파이프로 통신할려 하면 이름이 있어야 한다. 그런 경우 쓰는것이다. fifo는 포인터가 두개 있어야 한다. 큐니까 그런파일이고

Link file - 심볼릭 링크 파일 원본파일의 위치정보만 갖는다. 바로가기 그것을 말하는것이다.

## struct stat(1)
stat 구조체 대한 것이다. stat 함수라는것에 대해 argument를 보면 path name과 stat 구조체의 버퍼링이 있다. 
이 함수를 path에 있는 파일의 정보를 stat 구조체 함수로 복사해서 옮기는 형태다.
성공하면 0 실패하면 -1
이름을 줬고


## struct stat(2)
lstat은 링크 스텟이라 하고 똑같이 패스네임과 버퍼를 주고 path name에 심볼릭 링크 파일이 들어가면 링크를 타곡 가는게 아니라 링크 파일의 정보를 버퍼에 옮긴다.
return은 같다.
바로가기 자체가 파일이고, 원래 원본 파일도 있는데 원본파일까지 가는게 아니라 바로 바로가기 파일 자체를 알려준다. 
중요한건

fstat은 파일 디스크립터 stat 함수인데, 패스 네임 대신에 파일 디스크립터가 들어가고 stat 버퍼가 들어간다. 
해당 파일 디스크립터에 있는 파일 정보를 버퍼에 담는 성질이다. 실행중인 파일의 정보를 알고싶을때 쓴다.
open한 파일이다.

++공통적으로 struct stat에 돌려준다고 되어있는데 뭘 돌려주냐면 파일의 여러가지 상태를 돌려주는데 다음에 나온다 파일 크기라든가 누가 만들었는지 파일 건드린 시간 등 정보들이 struct stat으로 리턴된다, 돌려주게 된다.++

## struct stat(3)
다양한 정보를 가지고 있는데 버퍼에 정보를 담는다. 
디바이스는 하드디스크에서 온건지 어디에서 온건지
inode 넘버라는게 있는데 프로세스가 있으면 프로세스 관리하기 위해서 pcb 있다라고 했는데(프로세스 제어블락) 파일이 있으면 파일 본체가 있는것이고 커널이 파일을 관리하려고 하면 파일에 정보를 담고 있는게 있어야 한다. 그 파일의 정보를 담고 있는것을 리눅스에서는 inode라고 한다.
파일이 천개가 있으면 inode는 1000개가 있다 이말이다. 
accessmode는 read/write/execute 할수있는것
owner는 할수있는게 뭐고 .. 그런거에서부터 이것을 만든사람의 유저 id라든가 맨 마지막으로 access한시간 언젠지 맨마지막으로 수정한 시간은 언젠지 여러가지 정보가 나오는데 많이 쓰는건 파일의 크기를 볼때 st_size 라는걸 사용하게된다. 파일의 크기를 알때

## Macros for struct stat
매크로는 조건문에서 쓰이는데 일반 파일이다 하면 이 매크로 상수가 쓰인 조건에 따라서 기능을 수행한다. 
stat.h에서 제공하는 매크로이다. 전페이지에 가져왔는데 직접써도 좋지만, 맴버들을 다 외우지 못하니까 그래서 매크로를 쓰면 편리하게 상태를 받아왔으면 regular 파일인지 물어보는것이다. regular 파일이면 true가 리턴된다.

일반파일이 아니라 디렉토리 파일이냐 물어보는것이다. 이게 파이프냐 아니냐 물어보는식이다.

외울필욘없다.

## Example(1)
fstate를 하면 파일을 먼저 오픈한다음에 디스크립터를 가지고 알아보라 파일에 대해서 마지막 argument는 파일의 이름이 된다. lstate는 파일이름을 주면 링크를 쫓아가지않고 일반파일은 일반파일대로 가는거고 바로가기 파일이 있으면 바로가기 파일을 지우기도 하는데 바로가기 파일 까지만 보겠다.
밑에 3개 조건이 나오는데
첫번째는 일반파일이면 레귤러 파일을 출력하고
디렉토리파일, 링크파일 출력
매크로다. 지금 stat에서 읽어온 파일이 regular file인지 true면 regular file이다. 

shell에서 쓰이는것을 확인해보면 mydir 라는 것을 보면 ls -ld 하면 mydir라는 디렉토리에 이는 파일을 다 찍어달라 요구 자세히
맨앞에 d가 있는것은 디렉토리 표시이다.
mydir은 current dir인데 맨앞에 d는 directory의미이다. 두번째는 myfile이라는 일반파일 이있는데 owner은 read write할 수있고 others 하고 group은 read만 할 수 있는 파일이다.
root root 라는것은 root가 만든파일이다. 두번쨰 root는 그륩 아이디를 말한다. 세번째의 파일은 mylink 라는건데 windows의 바로가기다. mydir에 myfile을 가리키고 있다
mylink는 진짜파일이 아니라 (바로가기파일이다.)
프로그램 돌리면 myfile을 주면 아규먼트로 결과가 나오고 디렉토리를 넣으면 디렉토리를 알려주고 mylink가 있는데  stat의 경우 링크를 타고 원본파일로 가기때문에 링크파일이 가지고 있는 myfile에 
mylink는 바로가기다. 심볼릭링크라고 하는데 mylink의 링크를 쫓아가서 myfile을 본것이다. myfile은 레귤러파일이다. 밑에보면 lstat는 링크를 쫓아가지 마시오 라는의미, mylink를 보면 myfile을 쫓아가는게 아니라 그자체를 알으켜주는거므로 심볼릭링크파일이다 라고 나온것이다.

fstat의 경우는 stat과 마찬가지로 원본을 따라가기 때문에 myfile, regular file임을 알려준다.
(mylink는 mydir의 myfile을 연결해주고있음)

## process's Creator id(1)
user id를 얻는 함수다. 프로세스 유저아이디 반환 
그륩아이디 반환한다.
리눅스서버에 계정을 만들면 vm에 root로 들어가서 쓸텐데 그 서버는 여러 사람의 계정을 만들텐데 만일에 뭔가를 만들면 id를 다 따로 줘야 한다. 그러나 그륩아이디는 똑같이 준다. 번호로 준다. 프로세스가 하나 생기면 그 프로세스를 돌릴 사람이 있고, fork 한사람이 있을것이고 fork 한 사람의 유저 아이디 프로세스를 자신을 만든 유저아이디가 뭐냐 그륩아이디가 뭐냐 클래스 아이디가 나올것이고 개별 아이디가 나올것이다.

아이디가 중요한 이유는 파일 을 건드리면 파일 건드리는것은 프로세스가 건드린다. 파일의 주인(만든) 그 주인하고 aceess 하려면 그프로세스를 만든 주인하고 권한를 비교해봐야한다.
프로세스 아이디도 알 필요가 있다. 프로세스를 만든 유저아이디를 알아보고 싶을때는 getuid를 한다.

## Process's Creator id(2)
effective user id 를 물어보는 함수.
return으로는 effective user id를 반환한다.
전페이지는 프로세스를 만든 user id 라고 했다.
여기에는 effective란 글자가 하나더 붙었다. 나중엔 os 시간에 차이를 배운다. 파일을 뚫고 들어가서 파일을 건드린다거나 지울려고 하면 권한이 있어야 한다. 파일의 owenr는 read write execute 할 수 있다. 라고 했으니까 만일에 길동이 오너라고 하자. 길동이 만들었다. 
근데 이것을 read/write/execute 그다음에 group others는 write를 못하잔아 어떤 프로세스가 생겼다. 프로세스가 open 하는데 write mode로 오픈하면 이게 write할 수 있는 권리가 있어야지 이것을 open할 수 있다. 그러면 write mode로 오픈할 수 있는것은 file을 만든 길동만 가능하다.

그럴때 이 프로세스를 누가 만든 프로세스로 해야 이것이 가능하냐 길동이 만든 프로세스를 해야 이것을 오픈할 수 있다. 근데 이때 사용되는것이 앞에장의 user id가 아니라 좀전에 나온 effective user id를 사용하게 된다. 이게 실질적으로 ++파일의 보안시스템을 뚫고 들어가는 id를 effective user id라고 하는데 ++ 근데 유저 id하고 effective user id와 무엇이 다른지 

유저 id와 effective user id가 똑같은것이라 생각하자.
나중에 달라질 수 있다.

프로세스를 만드는것에 파일의 owner 말고 프로세스를 만들었으면 이 프로세스의 유저이고 길동이 로그인해서 이 프로세스를 만들었으면 길동이 이 프로세스의 유저 id가 되고 이게 effective user id가 된다.

## 파일 접근 검사 과정
x
## 파일 생성시의 권한 설정
x

## Conforming the file's access permission
amode라는 매크로 를 보내서 
접근이 가능하면 0 이고아니면 -1
이것은 내가 파일을 오픈했는데 내가 이 파일을 쓸수있어요 이 파일을 읽을 수 있어요? 이 파일을 execute 할 수 있어요? 를 물어보는 function이다.  access 이다. 
## Conforming the file's access permission(2)
amode에 상수들이 들어가는게 이 값들이다.

## Conforming the file's access permission(3)
F_OK 는 파일의 존재여부가 파일 이 존재하냐 존재하면 0 아니면 -1
argument vector 1으로 파일의 이름을 줬을텐데 이 파일이 있습니까 물어보는것이다 없으면 -1이 리턴된다. 0으로 리턴되면 파일이 있다.

파일이 있다고 확인되면 권한을 확인해본다. 
읽기 권한 확인, 쓰기 권한 확인, 실행 권한 확인
프로그램 돌아가면 프로세스가 된다. 이 프로세스를 만든사람이 길동일텐데 (아까 애기했던 effective user id가) 그럼 길동이 이 파일을 읽을 수 있나요 이 파일을 오픈해서 쓸수 있나요 물어보는 시스템콜이 access 함수이다.

이것도 어떤 사람이 이 프로그램을 돌리느냐에 따라서 대답이 같은 파일이라도 달라질 수 있다. 길동이 물어봤으면 write ok가 나올것이고 철수가 물어봤으면 안된다 라고 한다.

## 파일 권한 설정
x

## cmask 인수에서 가능한 값
x

## Changing File's Access Permission
access permission을 바꾸는 함수이다.

X라는것이 파일의 이름, 파일의 OWNER는 길동이다. 그륩은 조선사대부들 이라고 하면 조선사대부들이 공유하는 파일이 있다그러면 길동은 rwx 할수있고 조선사대부들에 속하지만 이황은 r-x 밖에못한다. 전혀 아닌사람은 r-x밖에 못한다. 이거를 가져다 access permission 이라고 할때 바꾸고 싶을때가 있을것 이다. 여기다가 write를 추가해주고 싶다. 바꿀때 shell command가 change mode다.
change mode하고 x하고 여기다 argumnet를 주면 바꿀수있는데 
change mode 라는것은 파일의 access 권한을 바꾸는것이다. 누구만 할수있나? owner 만 할 수 있다. 파일을 만든 길동만이 그파일의 access 권한을 가져다 바꿀수가 있다. shell에서 change mode를 할 수 도 있고 여기서는 system call로 하고 있다.
시스템콜로 함수를 콜해서 파일의 access 권한을 바꿀 수 있다. 
인자로 파일이름과 모드 상수를 주고 바뀌면 0 에러가 나면 -1을 준다.

앞에 f자가 붙으면 open한 파일 디스크립터를 이용하여 변경한다. 

## 파일 접근 권한(mode) 상수
나머지를 보면 여러개 선택하고 싶으면 or 한다. 

## Example
stat 구조체에 statbuf를 사용하고 
lstat는 이게 regular file인지 아닌지를 확인하고 regular 파일이면 들어가서 

파일의 선택을 물어봤으면, statbuf에 대해서 mode에 대해서 물어보는 매크로가 있었다. 이 파일이 일반 regular file이니까  링크파일이나 디렉토리 파일이면 안하겠다. 라는 말이다. 일반파일 일 경우만하겠다.
S_IXGRP 그륩의 수행권한을 말하는데 그륩의 수행권한을 빼겠다. 실패는 -1을 리턴 -1이 뜨면 에러가 떳다고 알려준다. 
statmode에는 여러가지 파일이 들어가 있겠지만 그중에는 rwx r-x r-x 들어가 있다.
비패턴으로 111101101이렇게 들어가있다. S_IXGRP는 그륩의 실행퍼미션이다. ~은 NOT이다. NOT한것을 원래 mode와 and를 했으니까 결국은 group의 x가 날라간다. 
Group의 execution permission이 0으로 바뀐다. 
결국은 not 하고 and를 했단 말은 group의 execution permission을 제거해 달란말이다.

and가 아니고 or로하면 or로 하면 추가해달라라는것이 된다.

regular 파일이 아니면 regular 파일이 아니라고 출력해달라는 간단한 예제다.

shell에서 myfile과 mydir에 자세한 정보를 출력한다.
myfile을 넣으면은 group의 수행권한을 박탈시킨다. 

x가 없어진다. mydir은 dir 파일이니까 이건 안한다.
regular 파일이 아니니까
수행을 하고 나서 자기 정보를 봤을때 수행권한이 없어졌다.

## Changing the owner/group-owner(1)
group owner을 바꾸라는 함수다.
처음에는 파일이름, owner id, group id를 넣고 성공0 실패-1 
아까 x라는 파일이 있었는데 owner은 길동, 그륩owner는 조선사대부들 바꾸고 싶다. 주인을 
그때쓰는게 shell에서도 change owner가 있다. 시스템콜을 할때는 ppt에 있는것처럼 한다.
파일의 주인은 주인만 바꿀 수 있다. 주인하고 superuser(root는 모든지할수있다.) change mode랑 change owner를 할 수 있다.

한번바꾸면 권한이 사라지기 때문에 
lchown는 아까 나왔던 lstat 와 같이 link file을 argument로 넣으면 링크를 따라가지 않고 링크 파일 자체에 대해서 owner 아이디와 그륩 owner id를 바꾸는 함수다.

파일 디스크립터 change owner는 파일디스크립터와 똑같이 argument를 주고 실행중인 파일의 owner와 group의 owner 를 바꾸는 함수다.
++
윈도우에서 바탕화면에 있는 바로가기 파일을 지우면 바로가기 파일이 지워진다. 원본파일이 지워지지 않는다. 그것을 심볼릭 링크라고 합니다. 그때 지울때는 원본파일을 쫓아 가지 않았다. 안쫓아 간것은 앞에 l자가 붙는다. 그러나 바로가기 쫓아가서 원본을 지우고 싶으면 l자가 안붙는다.++

link를 쫓아가느냐 안쫓아가느냐의 차이를 l자가 붙느냐 안붙느냐 로 판단을 한다.

심볼릭 링크파일은 바탕화면 자주쓰는건데 찾아갈려하면 root밑에 뭐밑에 한참 내려가야 하니까 귀찮다. 그래서 가짜 이름을 하나 만든다. 

## Example
아이디 설정하고
argument가 5개인지 확인
파일명, 명령어(l로 할껀지 그냥할껀지결정), 파일이름(owner을 바꿀려고 하니까), 변경할 새로운 owner id, 변경할 새로운 group id 로 들어가서 총 5개

문자로 인식하기 때문에 숫자로 바꿔서 코딩을 해준다. atoi
명령어가 chown 이면 chown 해서 성공적으로 바뀌면 넘어가고 실패하면 error 가 발생했다고 알려준다.
다시 바꼈는지 확인하기 위해서 출력을 하는 코드이다. 

파일 디스크립터 changeowner 면 파일을 먼저 open하고 똑같이 진행을 한다.

링크 change owner면 수행

shell에서 쓰는 명령어로 본것이다.
my 자가 들어가는 파일들을 자세히 출력하라는 의미다. 3가지가 나왔다. 
cisc 
네이버, 게임사이트 로그인할때 자신의 로그인 네임이 잇듯이 로그인 네임이 cisc 인데 컴퓨터 속에는 숫자로 저장되어있다. 그걸 물어본것이다. u cisc cisc 유저 아이디는 무엇이냐? 1703 이다.
cisc의 group id는 무엇이냐 511이다 라고 숫자를 알려주고 숫자를 사용해야 한다. 루트면 0이뜨고 

주인이 oskernel 이었는데 cisc로 주인이 바꼈다. (유저 아이디, 그륩 아이디)

## Link Files
링크파일은 바로가기 파일이다.
총 2가지가 있다. 심볼릭 링크, 하드링크가있다.
심볼릭 링크 : 위치에 대한 정보만, 바로가기 파일 만드는것
하드링크 : 파일은 하나인데 이름을 여러개 줄 수있다.
(파일은 한개, 이름이 여러개, 같은 링크에 하드링크를 만들어놓으면 파일이 두개로 나온다. 하나를 지운다고 해도 나머지하나는 남아있어서 파일이 지워지지 않는다.)
그런것을 하드링크라고 한다.

심볼릭 링크 원본 파일을 삭제하면 링크를 사용할 수 없다.

## Hard Link
하드 링크를 만드는 함수다.
존재하는 오리지널 파일의 네임을 쓰고 새로운 이름을 넣어서 하드링크를 생성한다 성공 0 실패 -1
링크를 하게 되면 이름이 2개 생겨서 파일은 하나지만 파일이 2개인것처럼 된다. 
나머지 하나는 남기때문에 파일이 안전하게 보관이 된다.

## Hard Link Example(1)
간단한 예제.
argument는 파일명 파일이름 파일의 새로운 이름
총3개 인지 물어보고 아니면 error 리턴
첫번째인자, 두번째 인자를 넣어서 하드 링크를 만드는데 실패하면 실패를 알려준다.

## Hard Link Example(3)
shell에서 이용하는 코드를 살펴보면, my가 들어가는 파일들을 자세하게 출력하고 myfile myhardlink 새로운 이름을 넣어서 실행을 하게 되면 myhardlink라는 새로운 함수가 나온다.

myfile과 myhardlink는 같은 파일이다. 파일 보관하고 싶을때 백업하듯이 백업은 아닌데 백업을 하면 파일이 2개 생기는건데 이건 파일은 하난데 이름이 2개다. 그대신에 하나를 지워도 하나는 남아있다. 

파일 하나에 두개가 연결되서 2로 바꼈다.

## Symbolic Link
오리지널 파일 이름과 링크 이름을 줍니다. 성공 0 실패 -1

## Symbolic Link Example(1)
하드 링크와 마찬가지로 두개의 argument를 받고있고 인자가 3개인지 확인하고 
++argv[1]은 루트밑에 뭐밑에 뭐밑에 한참 내려가는 원본파일일것이고 argv[2]는 간단한 이름일것이다. 연결이 바로가기가 된다.++

## Symbolic Link Example(2)
shell에서 사용하는지 보면,
my자가 들어가는 파일을 자세하게 출력하고 
새로운이름을 넣어서 실행하면
my 보면.
mylink는 소프트링크 심볼릭링크 라고 하는데 진짜파일이 아니라 바로가기다. 앞에 l이 붙어있다. l은 링크파일, 바로가기다. 같은 디렉토리에 이렇게 만들지 않는다.
일반적으로 하나는 어디 복잡한 위치에 있는 파일이고 하나는 내가 자주쓰는 디렉토리에 만들어놓은 파일일것이다.
바탕화면 같은곳에 만들어둔다.

## 링크처리에 따른 함수 구분
link change owner, link stat 같은경우는 링크를 따라 가지 않은 함수들이 있고 링크를 따라가는 함수들이 있기때문에 조심해서 함수를 본다.

unlink는 파일에서 link를 지우라는 말이다. 파일을 실제로 지우라는 말이다. 파일을 지울때 unlink를 쓰고
remove를 사용해도 되고, remove는 바로가기만 없앤다.

이런것은 link를 쫓아가지 않는다.
open 하면 링크를 쫓아가서 원본파일을 오픈한다.

## Following a Link
readlink 
링크가 가리키는 파일이 무엇인지 읽어내는 파일이다. argument로는 link name, buf addr, buf size 입력하고 성공하면 읽은 
버퍼에다가 
실제로 이름의 길이가 들어간다.
path 라고 준것은 심볼릭 링크(바로가기 이름), 쫓아가면 무슨 디렉토리 밑에 한참길게 나올것이다 파일이름 기니까 버퍼를 두고 maximum사이즈를 둔것이다. maximum 사이즈를 100을 줬다하면 100자리 까지 간다.
실제파일의 길이의 이름이 80자였으면 80이 리턴된다.

## Following a Link Example(1)
버퍼사이즈 변수
버퍼 배열, read 사이즈

링크이름이 들어가서 argument확인
buffer size가 read size다 에러가 뜨면 에러가 떳다고 알려주고 읽어내는데 null문자가 안들어가니까 추가로 넣고 출력하는 코드다.
++
캐릭터 스트링으로 파일 이름을 읽어왔는데 거기에 끝에 널이 안붙어있다. 끝에다가 null을 붙여주고 출력을 해야한다. 그래야 파일이름이 나온다. 오리지널 파일이름을찍는다.++

코드에 mylink를 넣어보면 그 가리키는 파일에 myfile이라고 알려주는 형식이다. 이것은 original file이다.
이렇게 안나온다. 더 길게 복잡하게 나온다. root/.../...나온다. 돌려봐야 나온다.