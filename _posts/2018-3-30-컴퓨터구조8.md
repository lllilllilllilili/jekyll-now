---
post : layout
title : QtSPIM 사용하기
---
## 들어가기 앞서
QtSPIM 이란건 어셈블리어로 작성하고 테스트해보기 위한 GUI 프로그램이다.

## QtSPIM Program Example

샾 : 주석을 달때 쓴다.
.text / .globl 같은것은 어셈블러 키워드, 지시자 이다.(directive)
.text - 여기에서부터 프로그램 코드가 정의되어 있다.
.globl main - main이 LABEL이 되며, main을 호출한다.

main : la $t0, value 
main 뒤에 :(콜론)은 주소를 의미하고 시작주소가 main부터 시작한다.
la(load address)는 수도 명령어로(실제로는 Real 명령어로 구성된다.)어셈블러가 사용자에게 편리를 제공한다. value가 15000 번지라면 $t0에 15000 번지를 저장한다.

lw $t1, 0($t0)
load word는 $t0가 가지고있는 주소값을 보고 그 안의 값을 읽어내는것이다. 15000번지의 값을 읽어내서 10을 $t1에 저장한다.

lw $t2, 4($t0)
위와 마찬가지로 15004번지의 값을 읽어서 20을 $s2에 저장한다.

add $t3, $t1, $t2
$t1과 $t2의 값을 더해서 $t3에 저장한다.

sw $t3, 8($t0)
$t0 주소값에 해당되는 값을 번지(여기서는 15008)에 값을 읽어서 $t3에 30의 값을 저장한다.

.data - 어셈블러 디렉티브라는 의미고 data가 정의되어 있다 라는것을 말한다.
value : 주소를 의미하고 (메모리 적재시에 실행된다.)

value : .word 10, 20, 0
.word는 word의 크기만큼 뒤에 나오는 값을 word 크기 만큼 저장한다.
value는 word의 첫번째로 나오는 10의 주소에 가리키게 된다.(그림참고)

## MIPS Memory Usage in qtSPIM
text segment - 프로그램 코드가 적재된다. 0x00400000부터 적재한다.
data segment - 데이터를 적재한다. 0x10010000번지 부터 할당한다. word는 안에 할당한다.

## MIPS 어셈블러 지시어(directive)
### Data Definitions
.word w1, ..., wn
word 단위로 저장한다.

.half h1, ..., hn
word의 half 단위로 저장한다.

.byte b1, ..., bn
byte 단위로 저장한다.

.asciiz str
ex) .asciiz "Hello", 6바이트를 메모리에 저장시키는 아스키 지시어이다. null???

## MIPS 어셈블러 지시어(directive)(3)
.space n
단위가 byte인 n만큼의 공간을 확보한다.
단순하게 .space 128 이렇게 쓰면안되고, 메모리 주소에 해당하는 라벨이 있어야 프로그램의 지점을 access 할 수 있다.
buffer: .space 128 이런식으로 써야한다.

## pseudo instructions
mov $t0, $t1
$t1의 값을 $t0에 복사한다. Real instruction에서 없는것으로 보아 만들어진것이다.
add $t0, $t1, $zero 의 명령어다. 한자리라도 줄일 수 있으면 편리하기 때문에.

li $s0, immed (load immediate 줄인말이다.)
$s0에 immed 상수값을 넣는다. 
실제 명령어는 addi $s0, $zero, immediate

la $s0, addr 
주소값을 넣는다. 주소안의 값이 아니라.
두개의 Real instruction으로 구성된다. 
lui $s0, upper_16bits(addr) 상위16bits 와
ori $s0, $s0, low_16bits(addr) 하위 16bits 를 결합해서 32bit 레지스터에 들어간다.

참고로 주소는 어셈블러가 알 수 있는데, 
data segment - 데이터를 적재한다. 0x10010000번지 부터 할당한다. word는 안에 할당한다. 이 위치에서 주소를 보면 
주소 해당값을 레지스터에 넣어야 하는데 주소는 32bit고 이것을 레지스터에 곧바로 넣을 수 없다. 따라서 두개의 명령어를 이용한다.

결합해서 $s0에 원래 넣을 주소값이 명령어 2개를 거쳐서 들어가게 된다. 하지만 이건 어셈블러가 담당하고 프로그래머는 Label로 표현하면 자동으로 처리된다.

## Start SPIM
왼쪽은 레지스터 정보고 오른쪽은 Data와 Text로 나눠진다.
Data에는 정의한 데이터(즉, value 정보가 있고)
Text에는 프로그램 명령어를 보여준다.
순서대로, 해당지점주소 32bit값이 기계어로 표현되있고 메모리엔 안들어가있지만 사용자를 위해서 어셈블러가 어셈블리 명령어를 보여주고 있다.

어셈블리 코드 확장자는 .s

#3 Load Program
Text.s (어셈블리 소스코드)
Reinitialize and Load File 하게되면 시뮬레이터 상태 초기화 그리고 지정한 어셈블리 파일을 로드해라!

## Execute Program
시작은 00400000 이고 하지만 우리가 짠 코드가 400000에서 바로 시작하지 않는다. 초기화에 사용되는 코드들이 존재한다.

여기서는 jar 0x00400024[main] 라고 해서 함수호출점프(main의 위치를 함수로 호출해라) 이다. 이전에 봤던 jump는 한번 가버리면 끝나지만 이것은 호출하는것이다.
0x00400024를 찾아서 실행하게 되고, 주석을 달게되면 옆에 나오지만 한글은 지원하지 않는다.

## Program data

어셈블리에 익숙하지 않다면 명령어가 실행되고 어떤 상태로 레지스터값이 변하는지 한줄씩 확인 할 수 있다.
data 영역을 보면, 4word로 32byte에 해당하는 내용을 볼 수 있다. 그리고 오른쪽은 아스키 캐릭터로 해석해서 보여진것으로 hello를 치면 hello를 볼 수 있을 것이다.

## Set a break point
프로그램을 실행하다가 너무 크면 동작원리를 보고 어느지점에서 멈췄으면 하는 위치에 break를 걸어주면 돌다가 그 지점에서 멈추게 된다. F10이고 마우스로도 설정가능하고
디버깅하는데 좋다.

## Syscall Codes
MIPS는 OS를 지원하지 않는다. 다만, 명령어중에 실행시키고 Print를 하던가 Input 값을 입력받는 다던지 이러한경우를 지원하기 위해서 System call을 하게 된다.

print 하고 싶을 경우에는 Print_int 에 해당하는 값을 code $v0에 저장한다. 
$v0에 내가 시킬 서비스코드(너버), 시스템콜코드를 적재하고
출력할 값을 $a0에 넣어야한다.(출력 integer값이겠지)
그리고 systemcall을 하면 화면에 나오게 된다.

화면에 Help->window에서 console창을 열게되면 출력용 window에 뜨게 될 것이다. 그리고 integer가 저장된 값이 출력용 콘솔화면에 나타나게 된다.

Helloworld 같은 경우는 v0=4를 넣고 Helloworld의 주소를 a0에 넣고 실행하면 Hellowworld가 뜰것이다.

값을 받고 싶으면, v0=5 값을 받는것이니까 system call하고 v0에 키보드 정수값이 담겨서 돌아온다.

출력은 code 와 Arg에 구비하고 systemcall하고 
입력은 v0에다 코드값을 적고 systemcall 적으면 Result를 확인해서 밖에서 누른 키보드 값이 이 레지스터로 들어와 있을 것이고 내부적으로 활용해서 쓰면된다.







