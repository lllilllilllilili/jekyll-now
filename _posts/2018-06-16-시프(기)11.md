---
post : layout
title : 시프(기)11
---
## Other socket APIs
겟 호스트 바이 네임, 겟 호스트 바이 어드레스 
아이넷 아톤, 어드레스 이런게있는데 뭐 이런것들
32 비트 주소가 아이피 주소가있고 그다음에 뭐 점 뭐 점 뭐 점 하는 닷 노테이션이 있고 그다음에 www.뭐점뭐점 하는것을 url 이라고 하잔아요 이 3개를 서로 컨버전하는 그런 목적이 되겠습니다
그래서 겟 호스트 바이 네임 은 도메인 네임 자기 호스트에 있는 네임 을 어 32 bit 어드레스 선으로 어 바꿔주는 것이다. 그래서 여기에보면 자기에 이제 도메인 네임 url 이 들어가면 이거를 가지고 struct host 앤트? 라는 이 스트럭쳐를 가져가 리턴해주는데 이 안에 스트럭트 셋트라는거에는 호스트 이름 하고 호스트의 만일에 별명이 있으면 별명에 대한 캐릭터 스트링 리스트가 들어가고 호스트 어드레스 타입 이 인터넷이 뭔지 알려주고
호스트 어드레스의 길이를 알려주고 여기에 보면 캐릭터 포인터 포인터 에 리스트가 있잔아요 그러니까 이거는 인제 스트링 이 여러개가 있는거를 얘기하는것이다 포인터에 포인터니까 그래서 여기에 보면 호스트 어드레스의 리스트가 나오는데 
일반적으로 여러분들의 pc하나만 아이피 어드레스가 하나만 주어지는데 서버 같은 경우는 아이피 주소가 여러개를 줄수도있기때문에 그아이피의 주소가 여러개일 경우에 이 리스트를 쭉나온다 라는 얘기가 되겠다.

## Example:using hostent
별거아니다 그래서 여기보면 스트럭츠 호스트 앤드 에 마이 호스트 앤트리 하나 잡아놓고 이거를 갖다가 룹을 돌면서 어 
겟 호스트 바이 네임에 여기에 url 이름을 주면 url 이름 을 아규먼트로 주면 마이 호스트 앤트리에 이제 자기 호스트에 아이피주소가 쭉 나오게 될거아니겠습니까 스트링으로 그걸이제 룹을 돌면서 전부다 찍어보는것이 되겠다 그래서 룹을 돌면 아까 호스트 어드레스 리스트가 이게 널이 아닐때까지 호스트에 어드레스 리스트를 인테저로 바꿔서 어드레스로 집어넣고 마이 어드레스의 에스 어드레스에 어드레스의 내용을 가져다 집어넣고
그것을 가져다 마이넷 네트워크 아스키, 네트워크 어드레스를 뭘로 아스키 어드레스로 찍어보면 이제 뭐점뭐점뭐점 이 나온다 얘기고 
또 스트럭쳐에 요건 플러스플러스 하면 넥스트 아이피 어드레스가 되가지고 룹을 돌면서 자기의 호스트가 아이피 주소를 여러개를 갖을 때 다 무엇인지 찍어보는 그런것이 되겠다.
별거아니다

## Ohter Socket APIs
그다음에 겟호스트바이어드레스는 거꾸로 32 비트 아이피 주소를 가지고 나에 도메인 네임이 뭔지를 알아보는것이 되겠다 그래서 여기에 보면 어드레스하고 길이가 들어간다. 
길이가 들어가고 타입이 들어가는 데 타입이라는거는 뭐 af 인터넷인지 af 유닉스 이런게 들어가는거겟죠 네트워크에 종류가 들어가면 역시 호스트엔트리로 리턴이 되서 거기에 url 이름들이 들어간다 라는 얘기가 되겠다.
그다음에 닷 노테이션하고 뭐점뭐점뭐점 하는거하고 원래 ap 주소는 네트워크에서 주고받을때는 32bit 인테저로 주고받잔아요 그래서 그것을 컨버전하는 루틴들이다.
그래서 아이넷아스키 투 네트워크라고 하면 닷 노테이션 뭐 204.200뭐점뭐를 32비트 아이피주소의 스트럭쳐로 리턴을 해주는것이고
그다음에 아이넷 어드레스라는건 닷 노테이션을 바이너리 아이피주소로 바꿔주는것이고
그다음에 아이넷 네트워크 투 아스키 라는것은 32 비트 아이피 주소를 뭐점뭐점뭐점으로 바꿔주는 그런 상호간에 다 볼수있는 그런 루틴들이 있으니까 그런것을 알아서 메뉴얼보고 필요할때 사용하면되겠다. 
이게 별거는 아니다.
이건 뭐 넘어간다.

그다음에 이제 
## Servent structure
서비스 엔트리 스트럭쳐 라는게 있는데 
이 서비스 라는거는 뭐냐면 
우리가 만일에 피씨 같은거나 서버같은것을 돌리면 뭐 그 피씨가 파일 트랜스퍼 서버같은것을 돌릴수가있죠 그렇죠 그다음에 뭐 여러분들 윈도우즈에서 보면 파일 공유하는 기능이있잔아요 그런것을 리눅스에서 쌈바서버라고해서 돌리고 그러는데 
그런 이메일 서비스 라든가 여러가지 서버스가 있는데 그런 이메일 서비스 파일 트랜스퍼 서비스 같은것들은 포트가 지정되어있다. 다 모든 pc에 그래서 그 포트에 이미 알려진 서비스가 뭐뭐가 있는지를 물어보는 그런 시스템 콜이 겟 서비스 바이 포트 
포트를 집어넣어주면 이 포트에서 지금 어떤 서비스가 이미 수행중인거를 알려주는데 그 수행중인 서비스에 대한것을 여기선 스트럭쳐로 돌려준다. 이런 얘기다 그래서 여기보면 뭐 그 서비스 만일에 ftp 서비스라고 하면 그 ftp 라고 나올것이고 ftp에 
얼라이언스라는건 별명이 있는거고 요거는 포트번호 , 사용하는 포트번호 
요거는 뭐냐면 사용하는 프로토콜 뭐 이런것들을 알려주는 현재 피씨에서 돌아가고 있는 서비스가 뭔지를 알려주는 그런 시스템콜이 겟 서비스 바이 포트 가 되겠다. 뭐 필요할떄 쓰면되는거고 

## UDP Programming
그래서 원래 나눠줬던 슬라이드에 udp 프로그램에 관련된 예제가 없기때문에 몇가지 udp를 사용하는 예와 udp 를 사용하는 서비스에 대해서 통신방식에 대해서 추가 슬라이드 올렸다.
만일에 udp를 가지고 원투원 서비스를 한다. 원투원이라는거는 이제 무슨말이냐면 포인트투포인트가 되겠다. 포인트투포인터가 아닌거는 뭐에요? 1:1로 대응한다는얘기다
아니면, 브로드 캐스트 (한꺼번에 몽땅 다보내는거고) 멀티캐스트(지정한 몇군데에다가 패킷을 보내는것을 멀티캐스트 방식이라고한다) 그 3가지에 대해서 얘기를 할려고 하는거다 그래서 포인트투 포인트 , 원투원이라는 얘긴데 거기에서 서버하고 클라이언트를 한번 보겠다.

## server
서버는 뭐냐면 항상 클라이언트 에서 들어오는 메시지를 기다려야한다.
그렇죠 근데 tcp 와 udp가 다른점은 뭐라그랬지? tcp는 먼저 전화를 걸어서 커넥션이 이루어진다음에 대화를 하는것이고 udp는 누차말하지만 그냥 받든지 안받든지 전보 방식으로 보내는 그런것이라고했다 그래서 여기보면 서버 , 서버쪽은 메시지를 받아야 되니까 메시지 크기 이제 1k 를 안넘는다고 가정을하고 그다음에 
자기 자신에 소켓을 하나만들고 소켓읆 만들떄 어떻게 만들었냐면 데이터그램, udp 방식을 사용한다고 해서 데이터그램 방식으로 만드는게 tcp랑 다르고 
tcp에서는 이게 뭐였었어요? sock_스트림 이었다 스트림 일경우는 tcp고 소켓 데이터그램은 udp 를 쓰는것이다. 
그다음에 서버 어드레스 를 하나만들어요 자기 어드레스 를 하나 만들어놔서 이제 바인드를 해야되겠죠 소켓에다가 
서버 어드레스를 0으로 클리언한다음에 어드레스 패밀리는 인터넷이고
그다음에 서버포트는 뭐 아무거나 잡아도됩니다 뭐 
14000번이 되든 15000번이 되든 24000번이 되든 포트를 하나 잡고 그다음에 서버 의 어드레스 아이피주소는 
인 어드레스 애니(inaddr_any) 는 나왔었죠 이거는 뭐냐면 호스트에 아이피 중에서 아무거나 하나 선택해주쇼 하는것이다. 그래서 자기 자신의 아이피어드레스를 네트워크 퐁?에서 롱워드로 바꿔서 어드레스에다가 집어넣고 이것을 서버의 소켓하고 요 어드레스를 바인드를 해서 자기가 받을 소켓에 대한 바인드가 끝나는것이다. 
그리고 뭐 간단하다
while(1){
recvfrom해서 이거는 뭐 커넥션이 없잔아요 전화없는게 없으니까 그냥 전보오는것을 기다리는게 뭡니까 reecvfrom이잔아요 그래서
recvfrom에서 서버소켓으로 좀전에 바인드한 서버소켓으로 메시지를 1k까지 받는데 여기에 보면 만일에 클라이언트가 메시지를 보내서 이 recvfrom에서 n바이트를 받아가지고 리턴을 했을 경우에는
클라이언트의 어드레스의 상대방의 아이피 주소하고 상대방의 포트번호가 들어와서 그게 누군지를 알수있게 되는것이다.
여기에 대해서 대답을 할때에는 뭘로합니까? sendto 로 하잔아요 그렇죠
sendto로 할때 반드시 여기에 보내는쪽에 클라이언트 어드레스를 방금전에 받은 어드레스로 세팅을 해야지 전꺼를 보내온놈한테 답장을 하는 형식이 되는것이다 
그래서 이거는 이렇게 룹을 도는것이다 그래서 누구라도 요 서버 포트하고 아이피 주소를 지정을 해서 메시지를 보내면 리시브 프롬에서 받아서 거기에대한 대답을 sendto로 하는 방식이 udp 서버의 방식이다.
tcp보다는 훨씬 간단하다. 이거는 커넥션이 없으니까 

## 클라이언트
클라이언트는 뭐냐면 클라이언트는 뭘 알아야되요?
서버의 주소를 알아야지 글로 보낼수가 있잔아요 전보를 보낼려고하면 시골의 무슨 뭐 무슨 면에있는 그런 주소를 알아야된다.
주소가 있어야 되니까 여기보면 일단 클라이언트 소켓을 만듭니다 역시 udp로 만들고 클라이언트 어드레스에는 자기자신이 쓸 클라이언트 포트하고 인터넷 패밀리 그다음에 아무 아이피 주소, 나의 호스트 어드레스 해서 바인드 합니다 클라이언트 소켓 에다가 자기자신의 주소를 바인드하 고 그다음에 메시지를 보낼려고 하면 상대방에 주소도 지정해야한다.
그래서 서버어드레스에는 서버 어드레스를 클리어를 하고 af_인터넷하고 그다음에는 서버쪽에서 사용하는 포트를 가져다 포트에다가 집어넣어주고 그다음에 슬라이드가 짤렷네
여기보면 서버에 주소가 만일에 204.254.10.0 이라고 가정하면 서버 아이피는 알아야된다. 자기가 반드시 그래서 서버 아이피를 주고 아이넷_어드레스는 뭐라그랬냐면 요 아스키 포맷을 뭘로바꾸는거에요? 32비트 아이피주소로 바꿔주는거죠 
이거를 이제 어드레스 구조체에다가 이렇게 집어넣어서 이것을 이제 서버 어드레스 에 저장을 시킨 다음에 
간단하자죠, 뭐하면 됩니까 sendto 하면됩니다

tcp에서는 뭘했었죠? send만 했으면 됬었죠? 여기서는 sendto를 하면서 반드시 자기의 소켓과 뭐에요? 상대방의 받을 서버의 주소를 가져다가 여기에다가 줘야되는게 특징이다. 매번보낼때마다 
왜냐하면 하나하나 마다 이거는 주소가 들어야된다. 전보 스타일이니까 

그래서 이렇게보내고 다시 서버 로부터 받을게있으면 recvfrom을 가져다 사용하면되겠다. 
그래서 udp가 간한해요? tcp가 간단해요 udp가 간단한데 간단한 반면에 udp는 신뢰성이 보장이 안된다. 오다가다가 잊어먹을수가 있어요 그렇기떄문에 100% 신뢰성을 확보하는경우는 udp를 곤란하다.

여러분들 전화기로 단문 메시지 보내잔아요 그런걸 생각해보면 되겠다.
그러니까 tcp 같은 경우는 뭐 파일같은것을 다운받을떄 줄줄히 많이 보내야 되니까 커넥션이 필요한거고 udp는 그냥 저 메시지 하나 보내가지고 대답받는 이런형태의 어플리케이션에서 사용하기가 편리한 , 적합한 것이 이제 udp가 되겠다.
## 멀티캐스트
그다음에 udp 에서 많이 쓰는것은 소위 얘기하는건 멀티캐스트 방식이다. 멀티캐스트 라는건 얘기했지만 뭐냐하면 센드투를 할때 한군데다 보내는게 아니고 등록된 여러개의 에 클라이언트에다가 메세지를 가져다 보내는 방식이 멀티캐스트 방식이다 그러니까 만일에 서버 가 3개의 클라이언트 노드에다가 보낸다고 하면 아까 포인트 투 포인트 방식으로 하면 3번 sendto를 해야되잔아요 
근데 이거는 뭐냐면 sendto 한번에 해서 한번만 해가지고 여러개의 노드한테 메시지를 가져다 보내는 방식을 멀티캐스트 방식이라고 한다.
멀티캐스트는 tcp는 안되고 udp를 기반으로 해야되고 멀티캐스트 그륩을 기반으로 멀티캐스트 패킷을 주고받는다 
하나의 멀티캐스트 패킷은 라우터를 통해서 다수의 호스트에 전송이 된다. 그래서 여기보면 여기서 얘가 이게 뭐 서버가 됫든 클라이언트가 됫든 메세지를 보내면 얘한테도 가고 라우터를 거쳐서 얘한테도 가고 라우터를 거쳐서 얘한테도 간다 이런 얘기다 글면 이 3개가 지금 받고 얘는 안받잔아요 그런데 이 3개가 어디에다가 가입을 해야되냐면 
이 멀티캐스트 그륩이 등록을 하고 그륩에 가입을 해야지 3개한테 보내줄수있잔아요 그래서 이 멀티캐스팅을 할떄는 이 멀티캐스트에 그륩에 가입하는 절차가 있다. 그게 약간 달라지는것이다.

## 그래서 멀티캐스트를 할때는 라우팅과 ttl
라우팅은 경로배정이라고 했죠 우리말로
그래서 중간에 있는 라우터가 패킷을 하나 받았을때 이게 최종 목적지가 뭐 미국에 백악관으로 가는거다 그러면 내가 그거를 어떤 다음 라우터 한테보내야지 이게 전달이 될것인가를 결정하는게 이제 라우팅이라고 했고 아이피 프로토콜에서 해결한다

ttl은 타임 투 라이브 인데 타임 투 라이브는 내가 패킷을 보냈을때 라우터를 여러개를 거쳐서 저쪽에서 갈것인데 라우터를 갔다가 거쳐서 갈수있는 그 홉의 개수의 맥시멈을 지정하는게 ttl이다.
여기보면 얘가 얘한테 클라이언트가 ttl을 가져다 3으로 지정을 해서 이 메시지를 보내게 되면, 라우터 한번 두번 세번 간다 이런얘기에요 
3번까지 갈수가있다. 그래서 여기서 라우터에서 더이상 보낼수있습니까 없습니까 못보낸다 이런말이다 
라우터가 패킷을 중간에 중계할때 받을떄마다 패킷속에 있는 ttl 카운트 를 갖다가 어떻게 하겠습니까? -1로 감소를 시키면서 ttl이 0이 되면 어떻게됩니까 더이상 중개하지를 않는다 이런얘기다. 그래서 내가 멀티캐스팅을 할때
이 ttl을 갖다가 얼마까지 주느냐에 따라서 어떻게 됩니까? 보내는 범위가 결정이 된다 이런말이다.
그래서 이 ttl은 멀리보내고 싶으면 뭐 ttl을 가져다 넉넉하게 주는게 좋겠죠 
다음 예에 나오는데 보통 뭐 64 까지 주기도 하고 그다음에 완전히 내 방에서만 보낼려고 하면 ttl을 뭘로 하면되요? 1로 하면되겠죠 
그럼 완전히 다이렉트로 붙어있는놈한테만 간다 이런얘기다. 


## 멀티캐스터 의 센더와 리시버 
센더는 뭐냐면 임의의 멀티캐스트 그륩에 데이터를 전송하는 호스트를 얘기를하고 리시버는 뭐냐면 이 멀티캐스트 그륩에 일원으로서 호스트에 
센더에서부터 보내는것을 여러놈이 받는거를 우리가 리시버라고 합니다. 그래서 멀티 캐스터에 센더하고 리시버를 구현할때는 이렇게 해야된다.
먼저 udp 소켓을 양쪽 생성해야되는거는 그거하고

보내는쪽에서는 뭐로 설정해야 되겠습니까? 아까 얘기한 ttl 이 맥시멈 몇개인지를 설정해야지 몇 홉을 라우터 몇개를 거쳐서 갈수가있는지 결정하니까 그것을 소켓옵션으로 결정을하고 그러고 나서 이제 멀티캐스터그륩으로 데이터를 전송을 하는데 요 멀티캐스트 그륩은 어 지금 얘기할까요
멀티캐스트 그륩은 여기 나와있는데 이 224.0.0.0 에서부터 239.255.255.255 까지 요 아이피주소에 범위에 있는것이 멀티캐스팅 전용으로
이미 전세계적으로 할당이 된 아이피주소이다.

그러니가 저런 호스트가 진짜로 있는게 아니라 멀티캐스팅을 할때 이것중에서 하나를 골라서 써야됨
그러니까 예를들어서 224.0.0.0 하면 나는 그냥 이 아이피로 보내는데 이  게 멀티캐스팅을 받는 상징적인 멀티캐스팅 그륩에 아이피주소가 된다. 그러면 받는쪽에서는 어떻게 해야되겠습니까? 받는쪽에 호스트는 아이피주소가 다를거아니에요 저거하고 그러니까 
그 아이피주소를 여기에다가 가져다 어떻게 해야됩니까? 가져다 멤버를 가입하므로써 붙여야 된다 이런얘기다 
여러놈이 이 예를들어서 224.0.0.0 을 사용한다고 하면 거기에다가 받는놈이 자기의 아이피 주소를 가져다 등록을 하고 붙이는 절차를 하면 얘가 일로보내면 거기에 붙어있는 놈들은 어떻게 된단 얘기에요?
다 메시지를 받는다 하는 얘기다.
그러니까 요거는 상징적인 아이피주소라고 생각하면 되겠다.
요것도 조금 다르다 224.0.0.0 하면 이거는 이제 로컬, 저기 연구실이라든가 학교내에서만 쓸수있는거고
이쪽으로 갈수록 이 범위가 넓어지는것이다 전세계적으로 그렇게 생각하면되겠다.
상세한것 메뉴얼을 보라 
이게 센더 좌우지간 그래서 멀티 캐스트 그륩으로 데이터를 전송한단 얘기는 요 호스트 아이피 중에서 하나를 골라서 약속한대로 보낸다 하는 얘끼가 되겠다.

리시버는 유디비 소켓을 생성하고 멀티캐스트그륩 을 지정하는데 이거는 무슨얘기냐면 ip_mreq 구조체가 나오는데 이게 뭐냐면 아까 얘기한 이 멀티캐스트 아이피에다가 자기주소를 가져다 붙이는데 사용하는 그런 구조체가 되겠다.
예제를 보면된다.
이거를 가지고 멀티캐스트 그륩을 가입을 하게 된다. 그래서 이거는 예를 간단히 보면 
이해할수있다.

## 센더
센더를 보면 디파인 멀티 캐스트 그륩, 야 우리는 내가 멀스캐스팅을 할때 뭐 224.0.0.0 으로 하자 그러면 받는 놈은 다 여기 모여라 이렇게 되는거에요 쉽게 말해서 이게 멀티캐스트 그륩의 아이피가 되겠다
그다음에 아까 애기했죠, ttl이라는건 라우터를 몇개까지 거칠수 있느냐 64개 까지 거철수있다. 범위가 넓어진것이다
그다음에 보내기 위한 소켓을 
af_인터넷에 소켓 데이터 그램 udp를 사용하는 소켓을 하나 만들고
그다음에 보내야 되는 주소가 있잔아요 보낼 주소를 세팅을 해야하는데 보낼 주소가 멀티 어드레스라고 가정 
이름을 이렇게 만들었다 멀티 어드레스에 패밀리는 af_인터넷이고 
멀티 어드레스에 아이피 어드레스는 뭐냐면 멀티캐스트 그륩 즉 224.0.0.0 으로 셋팅을 하던지 224.0.255.255 으로 하던지 자기 마음이다 아무튼 하나를 지정해야 한다
그리고 이제 포트는 뭐에요 6천번 아무거나 사용을 하면된다.
그러면 이거는 내가 보내는 주소가 되는거고 아까도 얘기하듯이 받는놈은 어떻게 된겁니까? 여기에다가 자기를 등록해야한다.
그래서 이렇게 셋팅을 했다
이게 이제 멀티캐스트 주소가 되는거고 
셋소켓 옵션이라는것을 써서 여기 ttl을 갖다가 64로 셋팅을 해야되기떄문에 요거 한겁니다. 소켓에 옵션을 셋팅을 하는데 무슨 레벨에서 ip , ip가 라우팅 하는 레벨이죠 
우리가 무슨 레벨이 있었어요? 소켓 레벨이 있었고 tcp udp 레벨이 있었고 ip 레벨이 있었잔아요 이 TTL은 라우터를 몇개 거치느냐 하는 옵션을 셋팅한거니까 어 느 레벨에서 프로토콜 아이피 레벨에서 셋팅, 옵션을 셋팅한다 얘기임 
그래서 여기보면 아이피 멀티캐스트 TTL
멀티캐스트할떄 TTL을 셋팅하겠다 이런뜻
그래서 여기보면 TTL에 어드레스 를 
TTL에 64 어드레스 주고 사이즈 오브 TTL을주게되면 
내 아이피가 언제까지 배달을 해요 TTL 64를 하나씩 줄여가지고 라우터를 거칠떄마다 -1을 해서 그게 어디까지? 0이 될떄까지 전달하니까 라우터를 몇개거칠수 있단 얘기에요? 64개까지 거칠수있다.
그렇게 소켓 옵션을 셋팅하고 그다음에 멀티어드레스 에 사이즈를 셋팅을 하고 센드투를 합니다.
센드투는 UDP 이기때문에 역시 마찬가지로 SENDTO 를 하죠
그래서 보내고 싶은 메시지, N바이트를 가져다 이 소켓으로 보내는데 수신자의 어드레스는 좀전에 얘기했듯이 뭐에요 224.0.0.0 에 포트가 6천이다 이런얘기다 글로 보내면된다 이말이다.
보내는쪽은 그렇게 보내면되고 받는쪽 프로그래밍이 조금 머리가 아프다. 받는쪽 프로그램은 

## 받는쪽
자여기보면 리시브 소켓 내가 사용할 소켓을 UDP를 사용해서 하는것을 하나 만들고 
그다음에 그것을 클리어를 일단 해놓고 여기 어드레스 패밀리는 인터넷이고 
내가 받을것이니까 여기 내 주소가 들어가 야겠죠 ? 
INADDR_ANY 내주소가 되는것이고 
아까 멀티캐스트를 어디에다 하기로 했어요? 6천번에다 하기로 했잔아요 그래서 이제 포트가 6천번이 들어가고 그거를 바인드를 합니다 
바인드를 했어요 근데 지금 바인드가 된게 어디에 바인드가 됬냐면 
내 주소에다가 바인딩이 됬죠? 그렇죠 그것을 또 어디갓다가 또 붙여야되요?
아까 얘기했듯이 224.0.0.0 이 멀티캐스트 주소를 사용하기로 했다 그러면 거기에 가져다 붙여야 된단 말이에요
그래서 여기보면 struct ip 멀티캐스트 리퀘스트 라는 구조체가 있어요 
멀티캐스트 리퀘스트라는 구조체가 있는데 요거는 이미 시스템에 디파인이 되어있는것이고 
조인 어드레스 라는걸 하나 만든다.
이 조인 어드레스 라는거는 이제 갖다 붙인것이다 그래서 조인 어드레스 에 imr multiaddress. s.addr에 멀티캐스트 그륩 이게모에요 224.0.0.0을 하까 사용하기로 했잔아요 그거를 사용하고 거기에다가 뭘 붙이는거에요?
imr 인터 페이스로 서 내 어드레스 , 내 호스트 아이피 어드레스를 가져다가 여기에다가 집어넣어주고 
이거를 가지고 셋소켓 옵션을 해서 이거를 이 조인 어드레스를 아까 어디에 갖다 붙이는겁니까? 224.0.0.0 인 멀티캐스트 포트에다가 내 아이피를 등록을 하는것이다 그러면 이 
이렇게 되면 내가 어디에 가입을 한겁니까, 멀티캐스트 그륩에 가입을 하게 된다. 이런얘기다
요것도 역시 옵션이 아이피 레벨이고 옵션은 뭐냐면 에드맴버십을 한다. 요 기에다가 내 아이피 주소를 가져다 붙여서 나도 멀티캐스트 그륩에 뭘하겠다? 참여를 하겠다 이런뜻이 되겠다.
거기에 그리고 이제 어드레스로서, 조인 어드레스하고 사이즈업 조인어드레스 
즉 내어드레스하고 멀티 캐스트 어드레스가 들어가있는것을 여기에다가 옵션으로 셋해서 자기가 멀티캐스트 그륩에다가 가입을 하는거죠
그리고 나서 이제 뭘합니까 기다리는거죠, 리시브 프롬 
아까 브로드캐스팅을 해준다고 그랬으니까 리시브프롬을 하게되면 이 멀티캐스트 리시버는 이거 하나만 있는게아니라 여러개가 있는거죠 그쵸 그러면 멀티캐스팅으로 받게 된다 이런얘기다. 

그래서 이런거죠 집에 아이피 티비 보나요, 케이블 티비 보나요 
아피 티비 보는사람 나는 둘다 보는데 
아이피 티비 도 많이 있죠 그 아이피 티비를 처음에 들면 sk 라고 하면 sk에서 똑같은게 날라오잔아요 
내가 vod 신청하지 않은이상 그거가 바로 멀티캐스팅이다 아이피 티비가입한 사람한테 똑같은것을 찔려주고있는거니까 
그렇게해야지 네트워크 패킷의 양이 줄어들거아니냐
그걸 일일히 포인트 투 포인트로 하면 다 따로 따로 보내야되니까 네트워크 패킷이 엄청나게 늘어날것이다 
이거는 그냥 패킷하나만 돌아다니면서 멀티캐스팅을 한거니까 
그래서 멀티캐스팅은 그런 용도로 사용할수있다.

자그래서 멀티캐스트 보다쎈거는 브로드캐스트다.

## 브로드 캐스트
브로드 캐스트는 뭐냐면 뭐 제한없이 무조건 다 보낸다 아까 같이 여기서는 ttl 옵션이 안나오는데 ttl 옵션을 64로 셋하면 뭐에요?
라우터 64개를 거치는 동안에는 뭐에요? 다 갖다 보내라 하는얘기가 되겠다 그래서 브로드캐스팅을 할때에는 전송방식이 udp를 기반으로하고 전송목적지 udp 패킷 과의차이점은 전송목적지에 아이피 주소 일뿐이다.
동일 네트워크 속하는 모든 호스트에 동시 전송한다 멀티캐스팅과의 차이점이다
인터넷사에서는 지역 네트워크 내에서만 브로드캐스트를 허용한다
네트워크 부하를 고려한다. 
여러분들 이 만일에 학교에서 브로드캐스트 하는 프로그램을 짯다그러면 학교 네트워크 안으로 국한이 된다 이거임
그 이상 다가오면 남들한테 민폐끼치는것이다 물론 받는쪽에서 그런 포트가 할당이 되어있으면 그 패킷을 받아서 그것을 어떻게 해버리겠습니까
없애버리겠지만 좌우지간 네트워크에 트래픽이 굉장히 늘어나잔아요 그래서 브로드 캐스트는 보통 지역 네트워크 내에서만 사용을 한다
그래서 브로드 캐스트을 할땐 아까 멀티 캐스팅을 할때는 뭐가있었냐면 이 아이피 주소를 요 대역 대를 써야 된다고 그랬잔아요 
멀티 캐스트를 할때는 이런식으로 씁니다 어 예를들어서 192.12.321.255 라고 하는거면 여기서 255 라는건 마스크에요
그래서 이건 무슨얘기냐면 192.12.321 에 000에서부터 255 까지 뭐하란 얘기에요 다보내라 하는 얘기다
쉽게 말해서 255.255.255.255 하면 어떻게되요? 이거는 뭐 전세계에 다보내달란 얘기에요 마스크가 전부다 1로 셋되어있으니까 
그런데 이렇게 해도 아까 어디까지 밖에 안간다고? 지역 네트워크 안으로 국한이 된다 이런얘기다.
트래픽을 방지하기 위해서

브로드캐스트의 장점도 있지만 단점은 뭐냐면 패킷이 너무나 많이 들어가는거고 그다음에 받는 놈이 받을건지 안받을건지는 모르지만 무조건 보내보는것이다 멀티캐스트하고 다르다 
브로드캐스트는 조심해서 써야된다. 
그래서 여기보면 예제를보자

## 브로드캐스트 
브로드캐스트 1번
요거 인테저로 잡았는데 캐릭터로 잡아도 되고 인테저로 잡아도 된다.
이건 조금잇다가
소켓을 하나만들었다 
pf 라고 해도 되고 af 라고 해도 된다.
유디피로 만들었다
유디피로 만든다음에 브로드 캐스팅을 할려고 그려면 반드시 옵션을 설정해야된다.
여기에 보면 셋소켓 옵션, 센드 소켓 소켓의 옵션 설정하는데 레벨이 소켓 레벨에서 옵션을 설정한다 아까는 아이피 프로토에 아이피는 아이피 레이어 에서 옵션을 설정하는거고 요거는 소켓레이어에서 옵션을 설정하는데 무슨 옵션을 설정한겁니까 브로드 캐스트를 할꺼냐 말꺼냐 이다.
브로드 캐스트 할꺼나 말꺼냐 라는 옵션을 설정하는데 브로드 캐스트를 할꺼면은 여기1 이 들어가있잔아요 지금 여기에다가 1을 주는거고 안할꺼면 뭘 주면 되요? 0을 주면됩니다. 0을 주면 브로드 캐스트가 꺼지는거다.
그다음에 이제 브로드 캐스트 , 내가 보내야 되니까 보내는쪽에 어드레스를 줘야 될꺼아니에요?
브로드캐스트를 누구한테 할껀지 그래서 브로드 캐스트 어드레스는 인터넷 어드레스고 브로디 캐스팅을 하는 아이피주소는 아까얘기했듯이 255 255 255 255 하면 무슨얘기에요 이건 외대 에 있는 네트워크에 모든 pc에다가 어떻게 하란 얘깁니까? 브로드 캐스팅을 하라는 얘기가 되겠다.
그리고 포트는 아무거나 써도되요 6천번으로 해서 보내면 받는쪽에서는 몇번으로 받아야되는거에요 6천번으로 받아야 된다 당연히

그리고 강의를 하다가 착각 수정사항, 포트하나를 여러개의 프로그램 쓸수가 없다. 네트워크 프로그램에 하나가 들어가면 한 포트를 차지하면 다른 프로그램은 거기다가 바인드할수가 없습니다. 그래서 반드시 그 프로그램이 없어지고 조금 지나야지 그 포트를 가져다 사용할수있다.
좌우간 이제 지역 네트워크에 다 보내내죠 그렇게 이렇게 세팅을 하고 포트는 여러분들 마음대로 보면 되는거고 그래서 센드투를 하면됩니다
센드투에 브로드캐스트 어드레스 이걸 주면 이거는 지역네트워크에 있는 모든 컴퓨터한테 메시지가 전달이 된다.
리시버는 똑같으니까 생략을 하도록 하겠다.

# System Programming Time & Timer Management
마지막인데 시간을 다룰때 에 쓰는 api에 관한 세미나 내용들이다.
그래서 
컴퓨터에서는 시간을 다룰떄 
시간을 다룰떄 2가지 시간이 있다 프로세스 타임이 있고 캘런드 타임이라는게 있는데
프로세스 타임이라는건 우리가 이미 익히배웠지만 클럭 인터럽트 핸들러 있죠
클럭 인터럽트핸들러가 계속 클락이 올때마다 시스템 타임을 업데이트하고 여러분들이 그런 시간을 이용해가지고 숙제도 했잔아요 
인터벌 타이머 를 써가지고 주기적으로 깨어나는 스레드 라든가 이런 숙제를 했을텐데 다시말하지만 그 타이머를 쓰는 숙제는 자기손으로 해봐라
굉장히 나가서 쓸일이 많다.
그것이 컴퓨터에서 클락에 의해서 관리되는시간 얼람이든가 슬맆3초한다든가 이런거는무슨 타임? 프로세스 타임이 된다.
칼렌더 타임이라는건 뭐냐면 몇년 몇월 몇일 몇시 라는거죠 그게 칼렌더 타임 
칼렌더 타임은 뭐냐면 프로세스 타임은 설명할게없고
칼렌더 타임은 뭐냐면 이거 무슨 표준시 가있잔아요 그리니치 천문대 기 준으로 한시간이 있고 한국에 뭐가 있습니까 로컬 타임이 있고 거기다가 미국에 가면 또 뭐가 있어요? 서머 타임이라는게잇어요 
그래서 여름에는 시간이 한시간 앞당겨지잔아여 그런것들에 따라서 결정되는 시간이 칼렌더 타임입니다 그래서 utc 이게 그리니치 타임을 얘기하는것이다 천문대 표준시간이다. 근데 이 칼렌더 타임을 표시할때 
여러분들이 이제 저 윈도우즈 같은데서 폴더를 가져다 자세히 보면 
파일을 갖다가 만든시간이나 최우로 건드린 시간이 나오잔아요 
몇년 몇월 몇일 몇시에 이 파일을 갖다가 수정했다가 나오잔아요 그쵸 
나와요? 나오죠
그 거가 어디에 저장이 됩니까 리눅스에서는?
어디에 저장이 되죠?
아이노드에 들어가잔아요 파일의 메타데이터니까 파일이 언제 만들어졌건 누가 만들었고 뭐 
디스크에 어디있고 이게 아이노드 아니에요 그쵸
아이노드에 그런게 저장이되는데 그러면 파일의 아이노드에 
이 파일을 만든시간이나 최후로 건드린 시간이 나온다고 하는데
그거를 몇년 몇월 몇일 몇시 몇분 몇초를 저장할려고 그러면피곤하다.
그렇죠,
그래서 그런것을 저장할때는 모든 오퍼레이팅 시스템이 공통적으로 쓰는시간이 있는데 
그게 Epoch time 입니다
이거는 1970년 1월 1일 0시 0분 0초를 기준으로 해서 현재 시각 까지의 몇초 가 지났는가를 초단위로 나타낸 인테저, 인테저로 나타낸것을 우리가 에포타임이라고 한다. 에포그 타임이 1이라는건 무슨얘기에요?
1970년 1월 1일 0시 0분 1초라는 얘기죠
그렇게 해야지 이제 인테저로 아이노드에서 저장을 할수있으니까 좌우지간 그것을 사용한다 
그래서 그 에포그 타임의 데이터타입이 타임 t가 되겠다.
그래서 이 에포그 타임을 컴퓨터에서 부터 받아가지고 와가지고 그것을 가져다 유저한테 디스플레이 해줄때는 뭘로 번역을 해줘야되요?
몇년 몇월 몇일 몇시 로 윤년그런거 다 따져서 환산을 해줘야 되잔아요 그 프로그램 짜기 귀찬으니까 그런 시스템콜들이 있다 그런말이다.
그런 시스템콜에 관한 애기가 되겠다.

## 
타임하고 타임은 물어보는것이고 s타임이라는건 타임 시간을 설정하는것이 되겠다 그래서 타임 을 하고 물어보면 리턴 타임이 타임 t가 되는데 이거 그냥 인테저라고 생각하면되겠다 인테저 64 bit	32 bit인지는 모르겠다
아무튼 인테저로 리턴되는건데 어 일로 리턴도 되고 여기에다가 저장도 해준다.
t_location 에다가 그것을 가져다 저장을 해주기도 한다. 
이제 셋타임이라는건 뭐냐면 시간을 가져다 에포 타임으로 줬을때 그걸 시스템 시간을 가져다 바꾸는것을 말한다. 
여러분들 윈도우 에서 보다가 저기 오른쪽 모퉁이에 시간이 나오잔아요 그거 바꿀수있죠 그렇죠 바꿀때 쓰는게 이거다 이런얘기다 리눅스에서
그래서 얘를보면 네임에 타임 t 커런트 타임 하고 모디파이 타임 요거는 이제 원래시간이고 
요건 이제 바꾸겟다 이런얘기다
그래서 여기보면 아규먼트를 3개를 받는다. 그래서 
이게 무슨얘기냐면 프로그램 이름을 치고 그다음에 +, - 하고 초를 친다 이런얘기다 만일에 +10을 줬으면 시간을 10초 더 보내라 -10이면 뒤로 땡겨라 뜻이 되겠다 
그래서 모티파이 타임은 타임에 커런트타임을 해서 받습니다.
그러면 현재 시각이 어디로 들어와요? 커렌트 타임으로 들어온다 이거임
이 커런트 타임 하고 이거는 똑같은것이다 그다음에 
printf 커런트 타임을 찍어봤다 이거 찍으면 어떻게 나오냐면 얘를들어서 현재 시각에 다가 3600을 초를 advance 시키시오 앞으로 
근데 지금 커런트 타임 어떻게 찍혔어요? 993168445 라고 나왔죠 이게 어디서부터 의 시간이에요? 1970년 1월 1일 0시 0분 0초로부터 지금 시간이 이렇게 초로 지났다 라는 얘기다.
여기보면 스트링 컴패어 , 스트링 컴패어 해서 아규먼트 해서 마이너스 를 쳤는지 어떻게 합니까 + 를쳤는지를 따져가지고 -를 쳤으면 두번째 아규먼트 커런트 타임에서 그것을 뺴기해줘 인테저로 바꿔가지고 
그랬으면 인테저 를 바꿔서 플러스를 해서 그걸 가지고 어떻게 하는겁니까 셋타임 을 한다 이거에요 그래서 모디파이 타임을 이걸 아규먼트로 주면 현재 시간이 어떻게 되는겁니까 바뀌는것이다.
그래서 여기보면 모디파이 타임은 뭐에요 여기에? 3600을 더하라고 했으니까 현재시간이 어떻게 됩니까? 3600이 더해져서 나왔죠 현재시각이 바꼈다 라는말이다.

## 
그다음에 컴퓨터 시스템으로 부터 뭘 받고싶을때 아까 얘기했듯이 칼렌더 타임을 받고싶을때 사용하는 구조체 가 이 tm 이 struct 가 되겠습니다. tm sturct에 는 여러가지가 들어가요 그래서 초도 들어가고 리밋도 들어가고 아워도 들어가고 네임도 들어가고 데이라는건 이건 뭐냐면 몇번째 나이가 그달에서의 먼스라는건 뭐냐면 0이면 1월이고 12이면 12월이다 라는뜻이다 
이유는 1900년으로부터 몇년이 지났는가 
year가 50이면 1950년을 의미한다
그다음에 이거는 뭐냐면 일주일에 몇번째 날인가 이게 뭐 일요일부터도 찍느냐 월요일에서부터 찍은건지 나도 모르겠다
그다음에 이 오늘이 1년에서는 몇번쨰 날인가 이런거
그다음에 isdst, 서머 타임 이 적용이 된거냐 안된거냐 를 나타내는것이 되겠다.
그래서 여기보면 요 isdst 에 만일에 0보다 큰값이 나오면 이거는 이시간은 뭐에요 현재 서머 시간이 일광절약된 시간이 적용이 된시간이다 라는 얘기고 
이게 0이면 섬머 타임 이 없다라는 얘기고 
0보다 작을때에는 나도 모르겠다 라는 뜻이 되겠다
우리나라는 썸머 타임이 없다
## 
그런데아까 애기했듯이 1970 년서부터 초로 계산한 시간이 있는거고 그다음에 달력시간이 있는거잔아요 그거사이를 컨버전하는 api가 되겠다
여기보면 로컬타임, 로컬 타임이라는건 인풋이 뭘로 들어가냐면 타임 t로 들어갑니다 그러니까 1970년서부터의 에포크 타임이 들어가는데 그거를 struct tm 조금전에 봣듯이 뭐에요, 연월일 그 포맷으로 바꿔달라 이런 얘기가 되겠다 요거는 어 
gmtime 이라는건 그리니치 천문대에 표준시간으로 알려달라 
로컬타임은 뭐에요, 한국시간으로 알려달라 이런얘기다. 

## 
그래서 여기보면 타임에 커런트 타임 해가지고 
커런트타임을 갖다가 에포크 타임으로 받아왔어요 
그다음에 핸드 워커에 struct tm * 해서 그리니치 세계 표준 시각을 환산을 해서 tm 버퍼에다가 집어넣는다 라는 얘기가 된다.
그래서 그것을 받은것을 가지고 뭐에요 year을 찍고 month를 찍고 year는 1990년 서부터 시작했으니가 1900년도를 더해야되고 
month에서부터 시작하니까 1을 더해줘야 할것이고 
이런식으로 해서 찍어본다
이게 0보다 크면 서머 타임이 적용이다 아니면 섬머 타임이 아니다 라는걸
여기보면 로컬 타임 요거는 이제 세계 표준 시각이 아니라 한국의 시간을 가져다 알으켜 달라 이런 얘기가 된다
똑같이year month day hout 찍으면 된다.
그래서 찍고 나서 써머 타임이냐 아니냐를 갖다가 찍어주는 그런 예가 되겠다
여기보시면 a.out을 하면 이건 뭐에요 
이쪽은 2012년에 7월에 11일에 5시 45분이고 4초다 
서머 타임이 적용디 되지 않았다.
이거는 이제 표준타임(로컬타임)
그리니치 천문대에 시간이고 요거는 한국에 시간이 된다. 

## 메이크 타임
조금전에 했던 어 몇년 몇월 몇일 몇시 이런 거 tm struct가 있었는데 
그거를 가지고 뭐를 만드는거냐면 거꾸로 에포크 타임 
1970년서부터 몇초가 지났는가를 환산해내는 그런 역으로 하는 인제 옵션이 되겠다.
그래서 여기보면 현재 시간을 여기다가 년월일 포맷으로 받아가지고 그거를 가져다 뭘로 만들었어요 ?
에포크 타임으로 만들었어 디스플레이 해본다. 
그러면 현재 가 지금 이런시간이 현재시간이 이런데 1970년서부터 환산을 하면 이거는 ~?? 지났다

## 비슷한거다 
ctime , asctime은 뭐냐면 시간을 갖다가 뭘로 바꾸는 거에요 아스키 스트링으로 바꿔가지고 저 찍기 편하게 만드는것이다.
그래서 ctime이라는건 에포크 타임을 주면 에포크 타임을 갖다가 아스키로 바꿔주는것이고 그다음에 struct tm 년월일 포맷을 갖다가 또 역시 아스키 스트링으로 바꿔주는게 아스키 타임이 되겠다.
별거아니니까 
찍은거를 보면 이런식으로 가능하다 
현재 에포크 타임이 이런데 이거를 갖다가 ctime으로하면 이런 표준 포맷으로 2001 년 저 수요일에 줄라이 11에 몇시 몇분 몇초 다 이런식으로 보기 좋은 포맷으로 바꿔준다. 라는게 되겠다

## 이거는 인제 프린트 f할떄
이거를 포맷을 바꾸고 싶을때가 있잔아요 만일에 외대라고 안부르고 원래 
수요일은 웬스데이 풀네임을 찍느냐 이런거를 갖다가 옵션을 선택하는건데 너무 뻔한 얘기다 넘어가다 메뉴얼 보고 하세요

## 이것도 마찬가지다.

## 그래서 전체적으로 펑션 릴레이션
커널이 사용하는거는 무슨 시간이에요? 에포크 타임이다 라는거임
처음에 인터페이스는 타임 t가 된다. 이거는 에포크 타임 즉 1970년 1월 1일 0시 0분 0초를 기준으로하는 시간이고 이것을 이제 스트링으로 바꿀때에는 뭐 이런것을 쓰고 그다음에 이것을 년월일 포맷으로 바꿀떄에는 이런 펑션들을 갖다가 쓸수가있다 이렇게 정리해놓은것이다. 이것 연월일 포맷을 일로 바꿀때에는 아까 말했듯이 뭐 메이크 타임을 쓴다 라는거임
이것을 멋잇게 찍고싶을때에는 strf를 사용을해서 포맷을 조정할 수있다 이것들이 시간들에 관한 펑션들이다.

## 펑션 릴레이션
그래서 전체적으로 펑션 릴레이션
커널이 사용하는거는 무슨 시간이에요? 에포크 타임이다 라는거임
처음에 인터페이스는 타임 t가 된다. 이거는 에포크 타임 즉 1970년 1월 1일 0시 0분 0초를 기준으로하는 시간이고 이것을 이제 스트링으로 바꿀때에는 뭐 이런것을 쓰고 그다음에 이것을 년월일 포맷으로 바꿀떄에는 이런 펑션들을 갖다가 쓸수가있다 이렇게 정리해놓은것이다. 이것 연월일 포맷을 일로 바꿀때에는 아까 말했듯이 뭐 메이크 타임을 쓴다 라는거임
이것을 멋잇게 찍고싶을때에는 strf를 사용을해서 포맷을 조정할 수있다 이것들이 시간들에 관한 펑션들이다.

