--
post : layout
title : 시스템프로그래밍6
---
## 시작
시작, 시스템프로그래밍..
## Library(1)
standard I/O Library - printf, scanf, getchar 있다.커널속에서 실행되는 시스템콜은 아니다. 
scanf를 하면 library 위치에서 처리를 해주지만 결국은 시스템콜을 하게된다. 시스템콜(커널 콜)을 직접하기 보다는 편리성을 위해서 윗단에 Library를 제공한다.

standard I/O library 에서 scanf 쓸때 잘못쓰면 backspace, delete processing(삭제한다. 생각하자) 하는데, 커널속에서 처리하는데 backspace, delete도 문자라서 backspace 키, delete 키가 (글자들을) 들어오면 유저가 처리하면 불편하기 때문에 standard I/O library 밑에서 buffering을 통해서 해주게된다.(버퍼링은 저장공간인가?, 큐, 임시저장소), 편하게 쓰기위함

c++에서는 stream I/O library이와 유사하다.

Library라는건 A set of compiled object (컴파일해서 이진파일을 묶어놓은것) 이라 하고 sin, cos, tan를 묶어놓으면 mathmetical library가 되는데  sin을 call하면 sin만 가지고 프로그램에 붙여서 들여와서 프로세스를 구성하게 된다. 

리눅스는 루트밑에 \lib나 \usr\lib를 하게 되는데, 이러한 Library function이 많이 존재한다. 

## Library(2)
라이브러리는 2가지 형태로 구성이된다.
Graphic libary는 .so로 끝난다. 이게 shared object이다. methmetical library가 math.so로 되있다면 sin으로 숙제를 받으면 여러사람이 Linux에 접속해서 각각의 사람들이 프로세스마다 sin을 call하게 될것이다. 많은 sin이 메모리에 load 될것이고 낭비로 이어진다. sin이 여러 프로세스에 쓴다하면 메모리에 1 copy만 올려놓고 공유하는것이 좋다.
=>메모리를 절약하는것을 Shared Library라고 한다. 

이때, sin과 내 프로그램을 같이 compile 한것이 아니다. 내 프로그램에서 sin을 call하면 sin의 주소를 알아야 하는데 같이 compile하지 않았으므로 주소를 알 수 없다. (메모리에 이미 정착되어 있기때문에 모른다.) 내 프로그램은 sin의 주소없이 메모리에 올라가서 sin주소를 찾아야만 한다.(쓸려면) =>dynamic linking 이라한다.(call할때 주소를찾는다.), dynamic은 run하는 도중에 sin을 call하면 그때 메모리에 sin addr을 찾는것을 의미

이것을 거쳐야만 shared library가 될 수 있다. 
서버에서 유용하다.(사용자들이 많이쓸수록 메모리에 1 copy만 두기때문에 메모리 절약된다.)
단점은 sin 주소를 메모리에 저장해야한다.(symbol table을 메모리에 keep해야한다.) 
프로그램이 돌아갈때 sin을 직접 call하는게 아니라 symbol table을 찾아서 dynamic linking을 해야하니까 시간이 오래 걸린다. 

Static library가 존재한다. (.a, archieve의 약자, 모아둔다.) 100개의 프로그램이 sin을 call하면 각 프로그램마다 sin을 가지고 들어간다. 임베디드 시스템에서 많이 쓴다. 메모리를 절약필요없다. 한가지 프로그램만 돌아가니까, 속도가 더 중요하다.

.dll(window에서 붙임, 라이브러리 쓸때) dll은 dynamic linking library의 약자다. 이게 shared library을 뜻한다 라고 생각하자.

compile에 따라 뭘 쓸지 결정된다.

## Library(3)
각 프로그램 별로 Function을 가지고 들어간다. (Static library)
Function을 1copy만 가지고 들어간다. 

## Standard I/O Library
Standard I/O Library에서 File을 I/O할때 fopen이나 fclose를 쓰게 된다. open하면 File*를 받아오게된다.(이걸로 fread, fwrite, fflush, fgets등하게됨) 이걸로 file을 쓴다. 커널이 아니라 라이브러리지만, os속에 read를 call하게된다.(fread경우) =>편하게 쓸수있도록 배려한것이다. 
프로세스가 올라오면 3가지 파일은 open이 되어있다.
standard Input/output/error (키보드/모니터,콘솔-단, 에러메시지가 나가는것은 채널이 다르다.)
그다음부터 쓴다. Standard I/O Library는 stdio.h에 정보가 담겨있다. #include 해서 쓴다.

File * 은 file pointer structure 라고 하고 이것으로 파일을 나타낸다. file은 항상 stream이 되고 File은 standard I/O Library에서 쓸수 있다.

커널 API는 open(), read(), write()는 파일 디스크립터로 쓰인다. 파일 포인터로는 쓰이지 않는다. 
커널에서쓸때는 파일 디스크립터 I/O를 써야하고, Standard I/O Library를 쓸때는 File *를 사용하게 된다. 
Standard I/O 로 getchar 할경우 종국에는 커널속에 read라는것을 call하게 된다. 커널이 제공하는 파일 디스트립터 I/O(커널 API) 보단 편리하다.

## File Pointer & Descriptor
몇가지 api를 보면, File open했을시 FILE *stream으로 받아왔다 가정하자.
int fileno(FILE *stream) 
이것은 커널에서 파일 디스크립터 I/O로 OPEN한다고 앞에서 언급하였다. 파일 디스크립터를 알고싶으면 파일의 number를 알려주는 library call이 있다. File 디스크립터 넘버를 알려준다.

File *fdopen은 파일디스크립터로 open한것을 I/O library로 쓰기 위해서 대문자 FILE *로 reopen하는것이다. library call이다. 

## Kernel Buffering
page cache는 커널단에서 disk에서 읽은것을 미리 가져다 놓고 메모리에서 주는것으로 디스크 I/O를 줄이는데 사용했다. ex)아래 한글 경우 save 해도 메모리까지 밖에 못간것이다. 커널이 사용하는 버퍼다. 

커널은 storage에 있는것을 page cache에 미리 가져다가 저장하고 디스크 I/O를 줄인다. Buffer cache는 옛날 말이다.

## Library Buffereing
Standard I/O Library도 Library buffering을 한다.
User process가 Library가 제공하는 buffer를 사용한다.
ex) scanf 할경우 1,2,3 입력시 들어가는게 아니라 enter키를 쳐야 들어간다. getchar도 마찬가지 
왜냐하면 1,2,4를 입력하면 delete processing을 통해 1,2,3으로 바꾸고 다한뒤에 넣어야 할것이기 때문에 
enter키를 치면 모든 것들이 마쳐지고 확정되었단 의미, 그것을 user에게 한꺼번에 준다는 말이된다.
그래서 들어오는것에 대해 (모든것을 전부 수용하는데,)유저에게 전달하지 않고 버퍼링(저장)한다. 잘못치면 수정해야하니까 일일히 하기 번거로우므로 버퍼에 저장한뒤 작업이 완료되면 한꺼번에 유저에게 전달한다.
=>Library가 버퍼를 가져야하는이유

라이브러리는 유저모드에서 일어난다. 유저단에서 일어나는 버퍼링이다. 

디스크에서 loop을 돌면서 10byte씩 20번을 썻다고 상황을 만들어보자, 10byte씩 20번 쓰면 디스크로 바로 안가고 page cache에 쌓인다. 나중에 한꺼번에 디스크에 쓴다. 디스크 I/O는 줄어들었다. (1번밖에 안일어난다)
그럼, 10byte씩 20번쓰는경우랑 100byte 한번에 쓰는경우랑 디스크 I/O는 같다.(page cache를 하니까) 하지만, 이경우도 시스템콜의 차이가 나면 시스템콜도 시간이 걸리기 때문에 가능한한 시스템콜의 횟수도 줄어야한다. 
* 페이지 캐싱을 통해서 디스크 I/O할때 4kbyte으로 처리한다. 

라이브러리에서 버퍼를 하는이유는 모아뒀다 커널에게 주게 되면 시스템콜을 덜하게 된다. 

정리하면 라이브러리에서 버퍼를 하는것은 1. delete 다른걸로 수정해야할경우 반영이 완료된 후에 넘겨주기 위해서 하는것도 있고 2. 시스템콜의 횟수를 줄이기 위해서다.

## Library buffering이 제공하는 형태
###### Full buffering
4Kbyte 단위로 하는것이다. 라이브러리가 유저모드에 하는 버퍼를 의미, 페이지캐시가 아니다. 
디스크에서 write할때는 4Kbyte로 쓰게되면 시스템콜 1번 I/O 1번이지만, 라이브러리 에서 버퍼를 10Mbyte씩모아서 4Kbyte가 되면 한번에 보내주게 된다. 시스템콜의 횟수가 줄어든다. 커널을 들락날락 하는것은 좋지 않다. 

라이브러리에서 full buffering을 하게 되면 디스크의 블락 사이즈 만큼(4kbyte) 하게 되는것이다. (블럭, 블락 블럭..!)
fflush는 standrad I/O Library 하는건데 버퍼에있는것을 커널로 보내라! 디스크까지 간다는 보장이없다. 커널은 페이지 캐싱을 또하게 되니까! 디스크I/O할때에는 Full buffering을 쓸 수 있게 되고, 

키보드 I/O할경우에는 ENTER키가 들어올때까지 라인 단위로 버퍼링을 한다. ENTER를 집어넣어야 전달이 되기 시작한다.

Unbuffering은 라이브러리 단에서 buffering을 하지 않는다. 이경우 delete나 수정사항등을 buffer에 저장할 수 없으므로 안먹게된다. delete나 그런게.. 그래서 자기가 delete를 직접 바로 처리하게 되는 형태가 된다.

3가지 모드를 선택할 수 있다.

## Characteristics of the Linux library buffering
stderr(standrad error) 버퍼는 즉시즉시 나가야 하므로 버퍼링이 불가하다. 
stddin/stdout은 키보드나 화면으로 나가는것이기 때문에 버퍼가 가능하다. 라인단위로 버퍼가능
그밖의 버퍼는 디스크에다 쓰는것이다. 이경우 full buffering 하는것이 기본이다.

그래서 standard I/O Library할때 위의 3가지를 통해서 버퍼를 결정하고 사용해볼 수 있다.

## Set Buffering
buf : not NULL -> 버퍼시 주소를 준다.
NULL이 아니면 버퍼시 주소로 사용해라 NULL이면 버퍼를 사용하지 않겠다 라는 의미이다.
File *stream 은 FIle
char *buf 는 버퍼주소
int type은 Fill/Line/Un buffering 할껀지
size_t size는 버퍼의 사이즈를 4kbyte, 8kbyte 할껀지
그러나 int type을 결정할때는 키보드등 라인으로 받아들이는경우는 Line buffering을 하지만 기본은 Full buffering 하게 된다.

## Flush(1)
버퍼에 있는것을 커널로 보낸다. 
프로그램을 디버깅 할시 디버그 쓸수있을텐데(오류를 찾는것은 디버그, 이러한 과정은 디버깅)
여러개의 프로세스가 돌아가는 concurrent process는 프로세스가 왔다갔다하는것으로 디버그가 달라질 수 있다. 이런경우 디버그로 디버깅이 불가하다. 안돌던게 돌기도한다.

printf하고 프로그램이 죽으면 화면에 나올수도있고 안나올수도있다. 버퍼에있으니까(라이브러리의), 꼭 나오게 할 경우 fflush(stdout)하면 나중에서라도 커널이 찍어주기 때문에확인을 할 수 있다.

printf 한다해서 즉시 화면으로 나가는것이 아니고, 라이브러리의 buffer까지 도착한것이다. 확실히 할려면 fflush를 해야한다. 

fflush를 했다는것은 lib.buffer에서 page cache까지 갔다는것을 의미한다. 디스크까지 간것이 아니다. page cache에 있는것은 언제가는 커널에 의해서 디스크로 가게 되어있다. sync라는 명령어로 갈 수 있다.

file이 close가 되면, flush()가 자동으로 일어나서 나가게 된다.

## Flush(2)
flush는 open한 파일의 stream에 대해서 나가게 되는것이다. 

## File Open
File을 Open할때는 fopen을 하고 인자로 파일의 이름을주고 
type은 access mode이다. access mode는 read / write / read o write / 파일뒤에다 붙이는 건지(append mode) 여는것인지 모드를 지정하는것이고 파일 open 성공하면 FILE *가 리턴된다. 리턴된것을 파일 디스크립터로 사용하게 된다.

FILE *reopen은 열려있는것을 한번더연다라는 의미이다. 
파일을 open하면 연결되어있는 형태고(stream으로), 앞에 read write offset이 0으로 되어있고 읽거나 쓰거나 할때 offset이 뒤로 이동한다. ???

File 을 새로 연다는것은 read/write offset을 새로한다는 의미다. 

## File Access Mode
File Access는 Character type으로 되어있는데
표는 ppt를 참조 
write는 파일이 있다고 하면 안에 있는것을 날리고 앞에서부터 새로 쓰겠다 의미이다. 
a는 파일의 원래 위치에 쓰는것을 뒤로 붙인다. 
r+ read/write 다하겠다.
w+ 파일이없으면 새로만들어달라
a+ read/append mode 다.
외울필요가없다.

## File Close
fclose한다. 그동안 버퍼링 했던것이 이제 page cache 로 나간다. 

## File I/O Functions
디스크에서 읽을때 사용하는 Library function이 있는데 
fread는 읽는것 fwrite는 쓰는것이다. size_t는 integer의미, 몇 byte 읽었다. 리턴해준다. 100byte를 읽을려고하는데 50byte뿐이면 50byte만 return 한다. 

size_t fread/fwrite는 실제로 읽고 쓴것을 의미하고 void *ptr은 여기다가 읽어달라 를 의미. (이주소에다)
size_t size가 100이고 size_t nitems가 10이면 100byte를 10개 읽어달라라는 의미이다.
FILE *Stream은 open한 file의 stream을 의미한다.

fread와 fwrite는 동작순서로 서로 반대다.
읽을경우는 어느 파일을 open해서 얼마만큼 읽고 쓸때는 어느 파일을 open해서 기존에 어디로부터 얼마만큼 쓸껀지를 보여준다.
이 둘의 default buffer는 full buffering이다.
(1byte씩 유저가 쓴다해도 시스템은 4kbyte 한번에 모아서 쓴다는것을 의미한다.)

## Character Input
getc, fgetc
getcharacter는 키보드에서부터 가져온다.
getc는 파일에서 한 캐릭터 가져온다. fgetc도 마찬가지다.
fgets는 파일에서 한 사이즈 만큼의 string으로 가져오라!(NULL로 끝남), String은 키보드로부터 가져온다.

파일에 집어넣을땐 putc나 fputc를 쓴다. 한 캐릭터 집어넣음
모니터 스크린 내보낼땐 getchar 대신 putchar을 쓴다.
fputs는 string을 파일에다 쓰는것이고 
puts는 string을 standard output에다 쓰는것이다.
이거 안쓰고 printf("%s")를 쓰곤함 우리는

## File I/O Example
Argument가 3개가 아니면 에러를 처리하도록 되어있다.
perror(argv[0]) 에러메시지를 찍는다.
argument가 3개라는것은 프로그램 이름이 하나있고, argument가 2개더 들어와야한다. argv[0], argv[1], argv[2] 까지 들어와야 한다.

fopen(argv[1],"r")
argv[1]은 파일의이름
read mode로 open해서, file pointer fpin에다 받아들인다. 
fopen(argv[2],"a")
두번째 argument가 들어온것으로 open을 하는데 append mode 파일에 뒤에다 붙인다. 
setbuf에 NULL을 주면 버퍼링을 하지 않겠다 라는 의미다.
c=getc(fpin) Input에서 open한 파일에서 한 캐릭터를 가지고 온다. End of FIle이 될때까지 한 캐릭터씩 가지고 오면서 output file에 뒤에다 append한다. putc(c,fpout)
c는 한 캐릭터 fpout은 output file 이 뒤에 append 한다고 if(fpout==fopen(argv[2],"a")) 가 main에 있어서..?음..

## 질문

buffer로 library를 저장하는 공간이 있다. 프로그램이 가지고 있는 공간은 아니다.

line buffering은 page cache를 하지 않는다.

시스템콜을 줄이기 위해서 라이브러리 버퍼에 가져다가 4kbyte가 모이면(full buffering) 원하는 만큼 페이지캐시로 가지고 간다. 읽을때는 페이지캐시부터 찾아보고 없으면 버퍼에서부터 가지고 오고 이때 역시도 4Kbyte 가져다 놓음(full buffering)