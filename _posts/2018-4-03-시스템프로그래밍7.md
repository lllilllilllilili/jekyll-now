--
post : layout
title : 시스템프로그래밍7
---
## 시작
시작

## Concurrent Programming
별 5개 이해가 시급.(first 과제)
프론트 엔드에서는 I/O를 하기때문에 block이 되고, 백 엔드는 디스크 인터럽트 핸들러가 프로세스를 다시 깨워주는 역할을 했다.(wake up)

## Clock Interrupt Handler
인터럽트중에서 Clock Interrupt Handler가 중요하다.
펄스가 한번 들어오면 1/1000초다. 이러면, os마다 clock interrupt 간격을 다르게 세팅하지만 Linux에서는 1/1000초를 보통쓴다. 버거우면 1/100초 쓴다.
클락 인터럽트가 들어오는것을 클락 틱 이라고 한다.

## 클락인터럽트가 들어오면 하는일이 많은데..
##### One)
시간을 아는 유일한 방법이다. 클락 틱이 1/1000초티면 시간이 지나가는거니까, 커널이 부팅된 이후에 1/1000초가 몇개나 돌아갔나를 체크 이것을 jiffy로 체크한다. 시간에 관련된것을 알 수 있다. 5초에 한번씩 돌아야 한다던가 시스템타임과 관련된것을 jiffy로 체크한다.
sleep 3초도 클락 인터럽트를 쓴다. 3초있다 깨워줘야함(block->running)
##### Two)
디스크에도 큐가 생겼다. I/O가 바쁘면.. 그러나 여기선 프로세스가 3개가 존재하는데 Sleep(3) Sleep(5) Sleep(7) 이렇게 있으면 클락에 대해서도 줄을 서게 된다. 시간의 차이만큼 줄을 서게 된다. 알람처럼 깨워주는것도 클락에 대해서 깨워달라고 요청할때 알람 클락이 존재한다.
시간과 관련된건 클락 인터럽트와 관련이 있다.
프로세스는 타임 드리븐, 이벤트 드리븐 두가지가 있다.
타임드리븐(slice-time-burst) 이벤트 드리븐(미사일을 쏜다든지)
커널도 주기적으로 해야하는 일이 존재한다. 예를들면 페이지캐시에서 디스크로 주기적으로 옮긴다하면 이 주기도 클락 인터럽트에 의해 통제될 수 밖에 없다. 시간이니까
##### Three)
타임아웃 함수가 존재. 인터럽트가 발생하면 인터럽트핸들러가 처리하는데 커널속에 있고 인터럽트가 3초마다 발생하면 이 인터럽트를 커널속에서 체크해주는게 클락 인터럽트다.
프로세스는 커널속에서 죽고 커널속에서 살아난다. 인터럽트 핸들링은 재빨리 끝내야 된다.
전화는 용건만 간단히, 인터럽트 핸들링이 늦어지면 디스크 I/O는 처리하지못하고 다시 돌아가버린다. 클락인터럽트핸들러도 1/1000초에 한번씩 오는데 인터럽트 핸들링 길어져서 1/1000초 지나면 아무것도 못한다. 그리고 못받으면 시간을 잊어버린다. 누적이되버리면 3초가 3시간이 되고 공장으로 비유하면 공장이 터진다. 증권회사의 경우 많은 돈이 없어질 수 있다.
결론 : 시간을 잊어버리면 안되고, 물리적인 디바이스가 처리해야할것을 끝내줘야 한다. 

긴작업의 경우에는 프로세스로 만들어준다. 프로세스로 만들면 CPU받아서 돌아가는데 프로세스는 인터럽트 핸들링보다는 순위가 밀리는데 인터럽트가 끝나야 돌아간다. 커널이 해야할 일을 커널 프로세스로 만든다. FILE sync(메모리->디스크 써주는것) 경우 너무 느리니까 (인터럽트 핸들링은 빨리끝내야 하므로 처리할수없음) 커널 프로세스에게 할당한다. 인터럽트 핸들링이 끝난 뒤에, ready 상태로 만들어줄테니까 스케쥴링 받아서 돌아가 이런 원리이다. 
swapper는 메모리를 청소하는것이다. sync나 swapper는 커널프로세스로 만들어서 인터럽트 핸들링이 끝난 다음에 돌아가게끔 클락 인터럽트 핸들러가 ready만 시켜놓는다. 원래는 block 상태였다. 커널이 만든 프로세스 이기 때문에 priority 높음
유저 프로세스 유저 코드돌아갈땐 유저모드, 시스템 콜하면 커널모드, 커널프로세스는 항상 커널모드이다. 커널 스레드 라고 한다.

#####Four)
cpu 한번쓰는걸 1/100초 하는데 다 끝나면 context_switch로 다른 프로세스로  옮긴다. 1/100초 카운트, 10번 들어오면 cpu를 뺐는다. 모든 프로세스는 time_slice_left 를 PCB안에 가지고 있다. time_slice_left를 자꾸 빼야한다. 클락 인터럽트가 들어올때마다, 결국에는 0이 된다.  1/100초 지나고 다른 프로세스로 cpu를 넘겨야 한다. 넘길려면 context_switch를 한다. 
인터럽트핸들링 속에서 context_switch는 없다. 왜? 인터럽트핸들링 하다가 도중에 context_switch하면 다른 프로세스로 가버리면 기존의 인터럽트핸들링은 끝난게 아니다. 
context_switch 필요가 생겼는데 언제 해야될까? 인터럽트핸들링이 끝나자 마자 해야한다.
도중에는 할 수가없다. Context_switch한다는것은 스케쥴러를 돌려서 끝난 프로세스에서 cpu를 뺐어가야하는 flag를 set해서 가져가고 Context_switch가 일어나게 된다.

## Clock Interrupt Handler
### Clock Interrupt handler
one)
시스템타임을 업데이트한다. jiffy++
two)
커널 타임아웃 함수를 호출한다.( 모든 n 틱에 대해서 )
three)
sleep() 된 후에 깨워야 한다. block에서 ready로
four)
현재 돌고 있는 프로세스의 클럭 인터럽트가 들어올 때마다 priority를 재계산한다.(시간을 계속 조사해서 데드라인에 가까워지면 priority를 높여주는 OS도 있다.)
five)
현재 돌고있는 프로세스의 PCB time_slice_left 가 줄어들면서 0이되면 다된것이고 재 스케쥴해야하는데 인터럽트 상태에서는 할 수 없으므로 PCB에서 nedd-resched flag를 1로 set 한다.
돌고있는 중에 새로운 급한 프로세스가 오면 need_resched flag가 1로 set될 수 있는데 1이 되면 리스케쥴링해서 재빨리 context_switch를 해야한다는것을 의미한다.
six)
클럭 인터럽트 핸들러에서 다 끝내지 못한 일을 여기서 한다. 
seven)
인터럽트 핸들링이 끝나면 다시 유저모드로 돌아간다. 그것을 return from interrupt라고 하는데 return from syscall하고 똑같다. 커널모드에서 유저모드로 가는것이다.
return from interrupt가 한줄이 아니라 오른쪽 표를 보는바와 같이 
```
do_softirq();
if(~~){
...
} 으로 구성된다.
```
여기서보면 소프트웨어 인터럽트가 등장한다.(지금까지 다룬건 하드웨어 인터럽트이다.)
currentPCB.need_resched가 1로 set되면 Context_Switch를 해야한다. 스케쥴링큐에서 높은 우선순위 가진것을 뽑아서 Context_Switch 해서 돌다가 클락 인터럽트가 들어오면 타임 슬라이스가 다됬으면 나오다가 cpu를 뺏기게 된다. (인터럽트 핸들러를 나오자 마자)
나중에 살아나는 지점도 Do Context_Switch 지점이다. 

## Kernel Places where Context Switches happen
언제 Context Switch가 일어나는 순간과 커널속 어디에서 일어나는지?
System call의 read를 살펴보면, 시스템 콜 안으로 들어와서 I/O 하기 위해서 스스로 CPU를 내놓고 CONTEXT_SWITCH한건데 이것은 시스템콜 도중에 한게 되는데 도중에 한것은 자발적으로 CPU를 내놓은것이다. Voluntary Context Switch라고 한다. 
Context_switch했다가 디스크 I/O가 종료되면 다시 살아날 것이다. 살아나면 커널속에서 돌다가 종국에서는 return from system_call을 하게 된다. 
이전에 currentPCB.need_resched =1 로 되서 리스케쥴링하고 CPU를 뺐어오는경우는 자발적인 경우가 아니다. , Context_Switch 되는것. 
```
ret_from_syscall(return from systemcall):
	if rescheduling is necessary,
    	do Involuntary Context Switch; //비자발적으로 뺏기는 경우
}
```
정리, 시스템콜 중간에 Context_switch는 자발적으로 cpu를 내놓으면서 I/O를 진행하는 자발적인 Context_Switch에 반해 시스템콜 중간에 다른 인터럽트가 들어오면 재스케쥴하고 CPU를 뺏어야 하니까 비자발적인 Context_Switch이다.

인터럽트 핸들러 도중에는 컨텍스트 스위치는 절대 없다. 빨리 끝내야 하니까, 인터럽트 핸들링이 끝날때 Involuntary Context_Switch가 일어난다. 

-시스템콜 도중에-voluntary CS
-시스템콜 끝났을때-involuntary CS
-인터럽트 핸들링 끝났을때-involuntary CS
이 3가지 형태가 커널속에 있다.

premtive(선점하는) 커널 중간에 involuntary CS 있어서 프로세스가 짤려도 돌아가는 방법이 있다.

시스템콜이 길어지는 경우는 전송되는 메시지가 크다고 가정하면 읽는데 시간이 걸리니까 중간에 involuntary CS 집어넣는다. 대부분의 시스템콜이 짧는데, 메모리 카피가 많은경우 혹은 메시지가 길경우 

## Concurrent Programming with Process
모든 프로그램은 Concurrent 프로그램이다. 메인프로그램을 돌리면 메인 프로세스 하나가 돌아가는것이다. 한 프로그램속에 프로세스가 여러개 있는것을 의미한다 = Concurrent Process
프로세스와 쓰레드 비슷한데 쓰레드가 더 가볍다. 프로세스로 우선 배운다.

inter process communicate - 프로세스끼리 통신하는것 의미 
언어별로 Concurrent programming을 제공하는 방법이있는데 자바는 쓰레드가 있고, 에이다, go, 모듈라 2 

c, c++ 는 위와같이 짜는 방법이 없기 때문에 커널이 도와줘야 한다. 커널이 제공하는 시스템콜을 가지고 Concurrent programming 한다. 

네트워크 프로그램, 각 기계안에서 프로세스안에서 통신하는것이 (서버-클라이언트 프로그램 통신) Concurrent process고 비행기 자동 항공 합법 시스템 혹은 미사일, 자동차 속의 소프트웨어는 대부분 센서(gps), 자이로 스코프센서(기울기 알아냄), 그외에도 많은 센서 요구 센서입력받아서 서버모델을 제어해서 날기시작한다. 

센서가 3개가 있다고 가정하자. 하나의 프로그램이 센서 3개로부터입력을 받기는 쉽지 않다.

센서를 기다리면서 block이 되어 있으면, 다른 센서 들어오는 값을 받아올 수 없음. select 문장이 있으면 센서 3개를 돌리면서 하는것도 있지만, 프로세스를 센서 하나당 하나씩 만들어서 block 되더라도 누가 먼저 인풋이 들어와도 상관없게 된다.

Real Time applications는 무기나 비행기 같은것, 장갑차 속 컴퓨터 같은것 (분산 시스템), 소프트웨어적인 전투체계를 가지고 있다. 센서당 프로세스를 하나씩 맡는다.

앱 프로그램을 짜는데 프로세스 2개를 만들어서 하난 cpu 돌고 하나는 I/O 동시에 돌리면 내 프로그램이 빨라질 수 있다.

큰 데이터를 보낼때는 이런식으로 프로세스별로 처리를 해야한다는것이고, 파이프 역할 프로세스 끼리 잘 통신해서 큰 데이터를 처리해야한다.

공학도는 문제해결능력이 중요하다.

--Concurrent Programming 까지

## Concurrent Programming in Linux
Concurrent Programming을 하게 되면 메인 프로그램이 하나의 프로세스가 되고, 
메인 프로그램에서 다른 프로세스를 만들수 있어야한다. 
프로세스를 하나 생성하는 함수가 fork이다. fork 하게되면 fork 순간에 프로세스가 하나더 생기는데 부모의 유전자를 가진 자식 프로세스이다. 프로세스의 공간은 text, heap, data, stack을 똑같이 가지는 자식 프로세스이다. (새로운 프로세스) = 복제와 마찬가지다.
복사한 프로세스로 다른일 을 할 수 있다.
원래있는 프로세스 = 부모 프로세스, 복사된 프로세스 = 자식프로세스

자식이 또 fork하면 또 자식이된다. 부모가 fork를 하게되면 자식의 형제를 가지게 되는것이고 프로세스는 무한대로 만들 수 있다. while에다 fork쓰지마라, 프로세스가 뻗는다.

fork를 call하는 순간 시스템콜 안으로 들어가게 된다. 시스템 커널속에서 부모프로세스와 똑같은 프로세스를 만든다.(자식프로세스) 

parent의 fork는 child의 프로세스 번호를 return 하고, child의 fork는 0을 리턴한다.
parent와 child의 관계지만 따로 경쟁하며 프로세서가 돌게된다. cpu가 어디로 갈지 모른다. 스케쥴러가 판단하기 때문에, 각각 독립된 프로세스다.

## Fork System Call
TEXT는 공간을 공유하지만, DATA HEAP STACK은 독립된 공간으로 부모와 자식은 독립된 프로세스가 되서 따로 수행한다. DATA속에는 Global Variable이 들어간다. Global variable은 따로 쓴다. 이게 들어가는 위치인 data가 독립된, 따로 쓰는 영역이니까

Child process는 프로세스 id도 다르고 PCB도 다르다. but, File open은 같이쓴다. Parent가 open한 파일은 child도 쓸수있다.(open 하지 않아도)

Copy-on-Write-is sued는 다음학기에 설명

## Fork System Call(con't)
리소스를 물려받는다, 유저 아이디 그륩아이디 같음 
부모가 오픈한 파일에 standard I/O file number(0:키보드 1:콘솔 2:에러) 위치를 물려받으니까 부모가 printf를 하나 자식이 printf를 하나 똑같은곳으로 나온다.(공유하기때문에)
파일을 오픈하면 r/w offset이 0으로 set되서 쓰는거나 읽을때마다 뒤로간다. 이것도 공유를 한다.

## Fork System Call(con't)(2)
```
int a =3; //글로벌 변수, 데이터영역에 저장된다.  글로버 변수는 저장했지만 자식이나 부모의 프로세스에는 서로 다른 변수 a의 값이 존재하게 된다. 각 독립된 영역이기 때문에

int main(void){ //메인의 위치에서 불러오면 부모프로세스가 시작되는것이다.
	pid_t pid; //지역변수로 프로세스의 아이디를 저장해놓는것이다.
    if((pid=fork())==0){ //child 프로세스 영역
    	a=5; //부모프로세스의 a와는 다르다. 5값이 저장되어있다.
        cout<<"child a="<<a<<endl; //5값이 출력
        exit(0); //자식 프로세스가 죽음, 프로세스가 없어지고 이것은 부모프로세스의 wait()으로 넘어간다.
    }else{ //부모 프로세스는 child 프로세스의 번호를 return할것이고 이것은 pid_t pid에 저장될것이다.
    a=6; //자식프로세스와 다른 a의 변수다.
    cout<<"parent a ="<<a<<endl;
    wait(); //wait은 child프로세스가 일을 다할때까지 기다린다.(death of child를 기다림)즉, child죽을때까지 block 상태다.
    }
    do something // by parent
}
쓰레드로(데이터를 공유한다.) 만들면 a가 같은 변수다.(부모 - 자식)
프로세스로 만들면 a가 다른 변수다.(부모 - 자식) 이경우 각각 카피해서 완전히 어드레스 스페이스를 따로 갖는다.
그리고 프로세스의 경우는 standard I/O 공유하니까 한군데로 값이 출력될것이다. (printf 경우)
프로세스의 경우 부모와 자식프로세스는 sequence 순서가 다르기 때문에 디버깅이 쉽지 않다. 어디가 먼저 시작될지 모르기 때문에(2개의 프로세스가 되어있고 concurrent 가 어느곳을 비중을 두고 돌아갈지 알 수 없다.)
로직은 부모프로세스가 자식프로세스에게 일을 시켜서 일을 다하면 child는 죽는다. 처음에 fork의 값이 0 이 아니니까 부모 프로세스가 먼저 실행되고 wait이 걸리면 block 상태로 들어가서 child process id값
```
