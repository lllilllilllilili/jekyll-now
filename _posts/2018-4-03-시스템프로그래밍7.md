--
post : layout
title : 시스템프로그래밍7
---
## 시작
시작

## Concurrent Programming
별 5개 이해가 시급.(first 과제)
프론트 엔드에서는 I/O를 하기때문에 block이 되고, 백 엔드는 디스크 인터럽트 핸들러가 프로세스를 다시 깨워주는 역할을 했다.(wake up)

## Clock Interrupt Handler
인터럽트중에서 Clock Interrupt Handler가 중요하다.
펄스가 한번 들어오면 1/1000초다. 이러면, os마다 clock interrupt 간격을 다르게 세팅하지만 Linux에서는 1/1000초를 보통쓴다. 버거우면 1/100초 쓴다.
클락 인터럽트가 들어오는것을 클락 틱 이라고 한다.

## 클락인터럽트가 들어오면 하는일이 많은데..
##### One)
시간을 아는 유일한 방법이다. 클락 틱이 1/1000초티면 시간이 지나가는거니까, 커널이 부팅된 이후에 1/1000초가 몇개나 돌아갔나를 체크 이것을 jiffy로 체크한다. 시간에 관련된것을 알 수 있다. 5초에 한번씩 돌아야 한다던가 시스템타임과 관련된것을 jiffy로 체크한다.
sleep 3초도 클락 인터럽트를 쓴다. 3초있다 깨워줘야함(block->running)
##### Two)
디스크에도 큐가 생겼다. I/O가 바쁘면.. 그러나 여기선 프로세스가 3개가 존재하는데 Sleep(3) Sleep(5) Sleep(7) 이렇게 있으면 클락에 대해서도 줄을 서게 된다. 시간의 차이만큼 줄을 서게 된다. 알람처럼 깨워주는것도 클락에 대해서 깨워달라고 요청할때 알람 클락이 존재한다.
시간과 관련된건 클락 인터럽트와 관련이 있다.
프로세스는 타임 드리븐, 이벤트 드리븐 두가지가 있다.
타임드리븐(slice-time-burst) 이벤트 드리븐(미사일을 쏜다든지)
커널도 주기적으로 해야하는 일이 존재한다. 예를들면 페이지캐시에서 디스크로 주기적으로 옮긴다하면 이 주기도 클락 인터럽트에 의해 통제될 수 밖에 없다. 시간이니까
##### Three)
타임아웃 함수가 존재. 인터럽트가 발생하면 인터럽트핸들러가 처리하는데 커널속에 있고 인터럽트가 3초마다 발생하면 이 인터럽트를 커널속에서 체크해주는게 클락 인터럽트다.
프로세스는 커널속에서 죽고 커널속에서 살아난다. 인터럽트 핸들링은 재빨리 끝내야 된다.
전화는 용건만 간단히, 인터럽트 핸들링이 늦어지면 디스크 I/O는 처리하지못하고 다시 돌아가버린다. 클락인터럽트핸들러도 1/1000초에 한번씩 오는데 인터럽트 핸들링 길어져서 1/1000초 지나면 아무것도 못한다. 그리고 못받으면 시간을 잊어버린다. 누적이되버리면 3초가 3시간이 되고 공장으로 비유하면 공장이 터진다. 증권회사의 경우 많은 돈이 없어질 수 있다.
결론 : 시간을 잊어버리면 안되고, 물리적인 디바이스가 처리해야할것을 끝내줘야 한다. 

긴작업의 경우에는 프로세스로 만들어준다. 프로세스로 만들면 CPU받아서 돌아가는데 프로세스는 인터럽트 핸들링보다는 순위가 밀리는데 인터럽트가 끝나야 돌아간다. 커널이 해야할 일을 커널 프로세스로 만든다. FILE sync(메모리->디스크 써주는것) 경우 너무 느리니까 (인터럽트 핸들링은 빨리끝내야 하므로 처리할수없음) 커널 프로세스에게 할당한다. 인터럽트 핸들링이 끝난 뒤에, ready 상태로 만들어줄테니까 스케쥴링 받아서 돌아가 이런 원리이다. 
swapper는 메모리를 청소하는것이다. sync나 swapper는 커널프로세스로 만들어서 인터럽트 핸들링이 끝난 다음에 돌아가게끔 클락 인터럽트 핸들러가 ready만 시켜놓는다. 원래는 block 상태였다. 커널이 만든 프로세스 이기 때문에 priority 높음
유저 프로세스 유저 코드돌아갈땐 유저모드, 시스템 콜하면 커널모드, 커널프로세스는 항상 커널모드이다. 커널 스레드 라고 한다.

#####Four)
cpu 한번쓰는걸 1/100초 하는데 다 끝나면 context_switch로 다른 프로세스로  옮긴다. 1/100초 카운트, 10번 들어오면 cpu를 뺐는다. 모든 프로세스는 time_slice_left 를 PCB안에 가지고 있다. time_slice_left를 자꾸 빼야한다. 클락 인터럽트가 들어올때마다, 결국에는 0이 된다.  1/100초 지나고 다른 프로세스로 cpu를 넘겨야 한다. 넘길려면 context_switch를 한다. 
인터럽트핸들링 속에서 context_switch는 없다. 왜? 인터럽트핸들링 하다가 도중에 context_switch하면 다른 프로세스로 가버리면 기존의 인터럽트핸들링은 끝난게 아니다. 
context_switch 필요가 생겼는데 언제 해야될까? 인터럽트핸들링이 끝나자 마자 해야한다.
도중에는 할 수가없다. Context_switch한다는것은 스케쥴러를 돌려서 끝난 프로세스에서 cpu를 뺐어가야하는 flag를 set해서 가져가고 Context_switch가 일어나게 된다.

## Clock Interrupt Handler
### Clock Interrupt handler
one)
시스템타임을 업데이트한다. jiffy++
two)
커널 타임아웃 함수를 호출한다.( 모든 n 틱에 대해서 )
three)
sleep() 된 후에 깨워야 한다. block에서 ready로
four)
현재 돌고 있는 프로세스의 클럭 인터럽트가 들어올 때마다 priority를 재계산한다.(시간을 계속 조사해서 데드라인에 가까워지면 priority를 높여주는 OS도 있다.)
five)
현재 돌고있는 프로세스의 PCB time_slice_left 가 줄어들면서 0이되면 다된것이고 재 스케쥴해야하는데 인터럽트 상태에서는 할 수 없으므로 PCB에서 nedd-resched flag를 1로 set 한다.
돌고있는 중에 새로운 급한 프로세스가 오면 need_resched flag가 1로 set될 수 있는데 1이 되면 리스케쥴링해서 재빨리 context_switch를 해야한다는것을 의미한다.
six)
클럭 인터럽트 핸들러에서 다 끝내지 못한 일을 여기서 한다. 
seven)
인터럽트 핸들링이 끝나면 다시 유저모드로 돌아간다. 그것을 return from interrupt라고 하는데 return from syscall하고 똑같다. 커널모드에서 유저모드로 가는것이다.
return from interrupt가 한줄이 아니라 오른쪽 표를 보는바와 같이 
```
do_softirq();
if(~~){
...
} 으로 구성된다.
```
여기서보면 소프트웨어 인터럽트가 등장한다.(지금까지 다룬건 하드웨어 인터럽트이다.)
currentPCB.need_resched가 1로 set되면 Context_Switch를 해야한다. 스케쥴링큐에서 높은 우선순위 가진것을 뽑아서 Context_Switch 해서 돌다가 클락 인터럽트가 들어오면 타임 슬라이스가 다됬으면 나오다가 cpu를 뺏기게 된다. (인터럽트 핸들러를 나오자 마자)
나중에 살아나는 지점도 Do Context_Switch 지점이다. 

## Kernel Places where Context Switches happen
언제 Context Switch가 일어나는 순간과 커널속 어디에서 일어나는지?
System call의 read를 살펴보면, 시스템 콜 안으로 들어와서 I/O 하기 위해서 스스로 CPU를 내놓고 CONTEXT_SWITCH한건데 이것은 시스템콜 도중에 한게 되는데 도중에 한것은 자발적으로 CPU를 내놓은것이다. Voluntary Context Switch라고 한다. 
Context_switch했다가 디스크 I/O가 종료되면 다시 살아날 것이다. 살아나면 커널속에서 돌다가 종국에서는 return from system_call을 하게 된다. 
이전에 currentPCB.need_resched =1 로 되서 리스케쥴링하고 CPU를 뺐어오는경우는 자발적인 경우가 아니다. , Context_Switch 되는것. 
```
ret_from_syscall(return from systemcall):
	if rescheduling is necessary,
    	do Involuntary Context Switch; //비자발적으로 뺏기는 경우
}
```
정리, 시스템콜 중간에 Context_switch는 자발적으로 cpu를 내놓으면서 I/O를 진행하는 자발적인 Context_Switch에 반해 시스템콜 중간에 다른 인터럽트가 들어오면 재스케쥴하고 CPU를 뺏어야 하니까 비자발적인 Context_Switch이다.

인터럽트 핸들러 도중에는 컨텍스트 스위치는 절대 없다. 빨리 끝내야 하니까, 인터럽트 핸들링이 끝날때 Involuntary Context_Switch가 일어난다. 

-시스템콜 도중에-voluntary CS
-시스템콜 끝났을때-involuntary CS
-인터럽트 핸들링 끝났을때-involuntary CS
이 3가지 형태가 커널속에 있다.

premtive(선점하는) 커널 중간에 involuntary CS 있어서 프로세스가 짤려도 돌아가는 방법이 있다.

시스템콜이 길어지는 경우는 전송되는 메시지가 크다고 가정하면 읽는데 시간이 걸리니까 중간에 involuntary CS 집어넣는다. 대부분의 시스템콜이 짧는데, 메모리 카피가 많은경우 혹은 메시지가 길경우 

## Concurrent Programming with Process
모든 프로그램은 Concurrent 프로그램이다. 메인프로그램을 돌리면 메인 프로세스 하나가 돌아가는것이다. 한 프로그램속에 프로세스가 여러개 있는것을 의미한다 = Concurrent Process
프로세스와 쓰레드 비슷한데 쓰레드가 더 가볍다. 프로세스로 우선 배운다.

inter process communicate - 프로세스끼리 통신하는것 의미 
언어별로 Concurrent programming을 제공하는 방법이있는데 자바는 쓰레드가 있고, 에이다, go, 모듈라 2 

c, c++ 는 위와같이 짜는 방법이 없기 때문에 커널이 도와줘야 한다. 커널이 제공하는 시스템콜을 가지고 Concurrent programming 한다. 

네트워크 프로그램, 각 기계안에서 프로세스안에서 통신하는것이 (서버-클라이언트 프로그램 통신) Concurrent process고 비행기 자동 항공 합법 시스템 혹은 미사일, 자동차 속의 소프트웨어는 대부분 센서(gps), 자이로 스코프센서(기울기 알아냄), 그외에도 많은 센서 요구 센서입력받아서 서버모델을 제어해서 날기시작한다. 

센서가 3개가 있다고 가정하자. 하나의 프로그램이 센서 3개로부터입력을 받기는 쉽지 않다.

센서를 기다리면서 block이 되어 있으면, 다른 센서 들어오는 값을 받아올 수 없음. select 문장이 있으면 센서 3개를 돌리면서 하는것도 있지만, 프로세스를 센서 하나당 하나씩 만들어서 block 되더라도 누가 먼저 인풋이 들어와도 상관없게 된다.

Real Time applications는 무기나 비행기 같은것, 장갑차 속 컴퓨터 같은것 (분산 시스템), 소프트웨어적인 전투체계를 가지고 있다. 센서당 프로세스를 하나씩 맡는다.

앱 프로그램을 짜는데 프로세스 2개를 만들어서 하난 cpu 돌고 하나는 I/O 동시에 돌리면 내 프로그램이 빨라질 수 있다.

큰 데이터를 보낼때는 이런식으로 프로세스별로 처리를 해야한다는것이고, 파이프 역할 프로세스 끼리 잘 통신해서 큰 데이터를 처리해야한다.

공학도는 문제해결능력이 중요하다.

--Concurrent Programming 까지

## Concurrent Programming in Linux
Concurrent Programming을 하게 되면 메인 프로그램이 하나의 프로세스가 되고, 
메인 프로그램에서 다른 프로세스를 만들수 있어야한다. 
프로세스를 하나 생성하는 함수가 fork이다. fork 하게되면 fork 순간에 프로세스가 하나더 생기는데 부모의 유전자를 가진 자식 프로세스이다. 프로세스의 공간은 text, heap, data, stack을 똑같이 가지는 자식 프로세스이다. (새로운 프로세스) = 복제와 마찬가지다.
복사한 프로세스로 다른일 을 할 수 있다.
원래있는 프로세스 = 부모 프로세스, 복사된 프로세스 = 자식프로세스

자식이 또 fork하면 또 자식이된다. 부모가 fork를 하게되면 자식의 형제를 가지게 되는것이고 프로세스는 무한대로 만들 수 있다. while에다 fork쓰지마라, 프로세스가 뻗는다.

fork를 call하는 순간 시스템콜 안으로 들어가게 된다. 시스템 커널속에서 부모프로세스와 똑같은 프로세스를 만든다.(자식프로세스) 

parent의 fork는 child의 프로세스 번호를 return 하고, child의 fork는 0을 리턴한다.
parent와 child의 관계지만 따로 경쟁하며 프로세서가 돌게된다. cpu가 어디로 갈지 모른다. 스케쥴러가 판단하기 때문에, 각각 독립된 프로세스다.

## Fork System Call
TEXT는 공간을 공유하지만, DATA HEAP STACK은 독립된 공간으로 부모와 자식은 독립된 프로세스가 되서 따로 수행한다. DATA속에는 Global Variable이 들어간다. Global variable은 따로 쓴다. 이게 들어가는 위치인 data가 독립된, 따로 쓰는 영역이니까

Child process는 프로세스 id도 다르고 PCB도 다르다. but, File open은 같이쓴다. Parent가 open한 파일은 child도 쓸수있다.(open 하지 않아도)

Copy-on-Write-is sued는 다음학기에 설명

## Fork System Call(con't)
리소스를 물려받는다, 유저 아이디 그륩아이디 같음 
부모가 오픈한 파일에 standard I/O file number(0:키보드 1:콘솔 2:에러) 위치를 물려받으니까 부모가 printf를 하나 자식이 printf를 하나 똑같은곳으로 나온다.(공유하기때문에)
파일을 오픈하면 r/w offset이 0으로 set되서 쓰는거나 읽을때마다 뒤로간다. 이것도 공유를 한다.

## Fork System Call(con't)(2)
```
int a =3; //글로벌 변수, 데이터영역에 저장된다.  글로버 변수는 저장했지만 자식이나 부모의 프로세스에는 서로 다른 변수 a의 값이 존재하게 된다. 각 독립된 영역이기 때문에

int main(void){ //메인의 위치에서 불러오면 부모프로세스가 시작되는것이다.
	pid_t pid; //지역변수로 프로세스의 아이디를 저장해놓는것이다.
    if((pid=fork())==0){ //child 프로세스 영역
    	a=5; //부모프로세스의 a와는 다르다. 5값이 저장되어있다.
        cout<<"child a="<<a<<endl; //5값이 출력
        exit(0); //자식 프로세스가 죽음, 프로세스가 없어지고 이것은 부모프로세스의 wait()으로 넘어간다.
    }else{ //부모 프로세스는 child 프로세스의 번호를 return할것이고 이것은 pid_t pid에 저장될것이다.
    a=6; //자식프로세스와 다른 a의 변수다.
    cout<<"parent a ="<<a<<endl;
    wait(); //wait은 child프로세스가 일을 다할때까지 기다린다.(death of child를 기다림)즉, child죽을때까지 block 상태다.
    }
    do something // by parent
}
쓰레드로(데이터를 공유한다.) 만들면 a가 같은 변수다.(부모 - 자식)
프로세스로 만들면 a가 다른 변수다.(부모 - 자식) 이경우 각각 카피해서 완전히 어드레스 스페이스를 따로 갖는다.
그리고 프로세스의 경우는 standard I/O 공유하니까 한군데로 값이 출력될것이다. (printf 경우)
프로세스의 경우 부모와 자식프로세스는 sequence 순서가 다르기 때문에 디버깅이 쉽지 않다. 어디가 먼저 시작될지 모르기 때문에(2개의 프로세스가 되어있고 concurrent 가 어느곳을 비중을 두고 돌아갈지 알 수 없다.)
로직은 부모프로세스가 자식프로세스에게 일을 시켜서 일을 다하면 child는 죽는다. 처음에 fork의 값이 0 이 아니니까 부모 프로세스가 먼저 실행되고 wait이 걸리면 block 상태로 들어가서 child process id값을 ??? 뱉는건가??

child가 먼저 exit 하면 parent가 wait을 안하면 child가 좀비가 되버린다. 
parent가 wait을 해야하고 child를 죽기를 기다리고, wait가 먼저 일어나면 parent가 block되면 child가 exit되면 parent 신호를 보내서 child가 장래를 치른다.

## Wait/Exit System Calls
여러개 child가 죽으도 parent가 깨어날 수 있다.
child 죽는것을 지정할수있다. child에 번호를 부여해서 parent에 번호에 맞으면 장례를 시키고 안맞으면 안한다.

exit은 4공간이 없어지고, 프로세스 관리하기 위해서 프로세스 컨트롤 블락은 남아있다. pcb를 parent에게 전달해줘야 하기때문에 프로세스 컨트롤 블락은 남아있다. 그리고 parent가 wait하면 pcb도 없어진다. pcb는 남아있고 프로세스 없어진 상태는 번외로 좀비상태라고 한다.

status는 임무를 완수 혹은 못할시 정한 숫자를 넘겨준다. 0이라든가 1이라든가
wait시 child 다 살아있으면 block이 되어야 하는데 WNOHANG은 다음에 다시하겠다는 에러를 리턴한다.

## Fork and Wait
fork() == 0 => child 
child fork() => grandchild
exit 하면 child가 기다림

sibling 형제를 만들어 낼 수 있다.

## Typical Example(Factory Control)
센서 A와 센서 B가 있을때 각 센서별로 값을 읽어와서 프로세스가 처리후 빅데이터에 값을 쓴다(IOT) 그리고 또 다른 프로세스는 이것을 읽고 처리해서 이상이 있으면 Actuators 실행해서 값을 수정한다던지 Control 하는 Motors가 있다.
프로세스 여러개가 필요한 예제다.

## Exec System Call Family
exec() syscall family = 변종이 많다.
execv(const char * path// 파일 name, 프로그램 이름, const char *argv[])
child 하나 생겨서 parent 물려받은건데 child 프로세스 몸체 속에 새로운 프로그램을 load 하고싶은것(백혈병 -> 피를 바꾸는 것처럼), 새로운 프로세스를 만드는 것이 아니다. 쉘과 아래 한글
부모와 자식간의 족보도 유지된다. 자식의 몸체 프로그램만 바꾸고 새로운 프로그램 만들고 나머지는 변함이 없고, wait - exit 없고, 프로세스 id도 같고, open file 도 공유하고 프로세스가 생기는게 아니라 프로그램 몸체만 바꾸는거고 프로그램을 메모리로 loading 하는 수단이 된다.(exec()가)

fork+ exec() 합치면 될거 같다. window가 이렇게 한다. 리눅스는 나눠둠, fork 와 exec() 각각의 장점이 있기 때문이다.

exec()은 실제로 new 프로그램을 올리는 수단이지 프로세스가 바뀌는것은 아니다. 
argument vector 주느냐에 따라서 변종이 생긴다. execl, execv 처럼.. 

## Example: Smell Shell Construction
child가 돌아가다가 
execv("a.out", argv) a.out이 디스크에서 새 프로그램으로 4영역이 새로 들어오고 프로세스는 그대로다.
execv system call은 return이 안된다. 새로운 프로그램이 메인으로 가버리는 것이다. file을 못찾을때 error return 한다. 정상적인 경우에 같은 pcb를 쓴다. 프로세스는 그대로 이기 때문에.
```
## User Process Tree after Booting
리눅스 커널이 부팅되면 최고의 선조 프로세스가 init 만들어내는데 process id가 = 0 이다.
init은 getty 프로세스 여러개를 만든다. 로그인을 기다린다. (리눅스는 서버로 구성, 로그인을 기다려야한다.) getty는 키보드에서 입력되기를 기다리고 있다. 4개니까 4명의 유저를 기다리고 있다. init이 fork를 하면 프로그램이 init으로 똑같다. fork한뒤에 exec getty해서 몸체를 바꿔치기 했다. 로그인 할때는 getty가 필요없으므로 exec 해서 프로그램만 바꿔치기 한다. login의 아버지는 init이다. 프로세스가 바뀐적이 없음.
유저네임 비밀번호 통과하면 exec로 shell로 바꿔치기 해서 우리들과 대화하는걸로 바뀐다. shell의 아버지도 init이다. 프로세스 바뀐적이 없으니까.
shell에서 a.out을 돌리면 shell exec하면 shell이 없어진다. shell은 exec 하고 또 돌아가야하니까 없애면 안된다. 이때 fork해서 child shell 이 생길꺼고 child shell은 exec 통해서 a.out으로 바꿔치기 하고 a.out의 아버지는 shell이고 shell은 wait하고있고 main이 끝나면 자동으로 exit 일어나서 shell은 a.out 이 끝나기를 기다리면서 대기하다가 a.out 죽었다하면 다른 프롬프트가 뜬다.

## Process tree
shell애 따라 프롬프트 쓰는게 다르지만 $으로 했다.
$ //shell을 만들어서 뜨게하고
$ ./a.out //shell을 a.out을 fork와 exec으로 만들어서 shell도 돌아가고 a.out도 돌아가는 상태다. shell은 a.out이 끝나기를 기다렸다가 끝나면 프롬프트 사인이 뜬다.(보여진다..)
cat myfile // 모니터에다 파일을 보여준다.
cat은 shell이 아니라 다른 프로그램, shell이 또 포크를 해서 포크된 child shell이 cat이라는걸로 exec(프로그램만 바꿔치기 했다.)
shell 자체가 조그맣다 하더라도, 다 바꿔치기가 되니까 가능하다. 
./a.out & 실행하면 ./a.out을 돌리는데 n시간이 걸린다 하고 다시 shell하고 다른일을 하려면 shell과 대화해야댐. ./a.out &는 백그라운드에서 돌린다 의미. 돌리자마자 shell이 떨어져서 다음 명령어가 떨어지길 기다린다. shell이 a.out이 끝나기를 안기다리고 a.out 돌려놓고 shell은 기다리지 않고 돌아간다. a.out이 죽으면 shell이 wait을 해줘야 하는데, a.out이 죽을때 wait을 해야 장례식이 끝나는데 이걸 해결하는건 뒤에 나온다.

a.out을 돌리면 > output 하면 print 나오는것을 화면으로 보내지말고 파일 output을 파일에 넣고 디스크에다 저장해달라라는 뜻 I/Oredirection 이라고 한다.

~~./a.out < output 하면 키보드에서 들어가는게 아니라, 디스크 파일에서 인풋을 받으란 말.~~

shell은 아주 조그맣게 만들어 볼 수 있다. 
etc password 밑에 자기가 쓰는 shell을 지정하게 되어 있다. 요즘엔 바시셀을 쓰니까 바시셀로 되어있음.
shell을 만든다면 작게, 기능이 제한되는것, ./a.out(포그라운드) 와 ./a.out &(백그라운드 프로세스) 만 한다. 이것만 처리하는 shell을 구성해본다.

logout할때까지 프로그램이 돌아간다 .로그아웃은 shell하면 exit()하면 로그아웃 끝난다.(shell은 무한 loop을 도는데 로그아웃할때까지)
print promot 찍어서 준비가 됬다는것을 알려준다. 유저가 키보드로 커멘드를 친다. 라인 스트림을 가지고 온다. a.out 가지고 오면 중간에 ??? 끊어서 파싱해야 된다. 토큰을 불리한다. 
파싱을 해서 a.out이냐 a.out &만 취급하기로 하자.
fork 를 해서 0면 child shell, child는 a.out을 돌린다. execv(a.out,argv) execv하면 argv를 주게 된다. I/O redirection은 나중에..
child process로 fork가 된 놈이 execv 해서 a.out이 shell하고 동시에 돌아가게 된다.
포그라운드, 였으면 a.out 이라고 친거다. a.out이 끝날때까지 기다려야한다. wait를 한다. 기다리는 동안에 만든 child가 아니면 옛날에 만든 child가 죽을수도있으니까(이상한 프로그램이) child가 죽을때까지 loop을 돌려서 wait을 한다.
포그라운드일경우에는 shell이 아무것도 안하고 기다리고 있다가 a.out이 끝나야지 맨위로 다시 가서 프로픔트를 시작한다.
포그라운드가 아니면 백그라운드, 백그라운드는 안기다린다. 넘어가서 다시 맨위로 올라가서 프롬프트찍고 다시 돌아간다.
나머지 하나의 문제, 백그라운드가 언젠가는 죽을텐데 장례식을 어떻게 치러주는가? 백그라운드는 백그라운드에서 돌고 shell에서 다른 명령어 내리면 포그라운드 돌리면 언젠간 wait 로 들어올텐데 
기다리고 있는데 언젠가는 포그라운드 프로세스 기다리고 wait하고있는데 옛날에 만든 백그라운드가 죽으면 포그라운드에서 리턴되고 청소가 된다. 백그라운드가 내가 원하는 id가 아니니까 또다시 wait , 그러나 거기에 만나서 청소가 된다. 백그라운드가 청소는 다른 포그라운드 돌려야 청소가 된다.