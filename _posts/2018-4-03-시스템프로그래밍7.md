--
post : layout
title : 시스템프로그래밍7
---
## 시작
시작

## Concurrent Programming
별 5개 이해가 시급.(first 과제)
프론트 엔드에서는 I/O를 하기때문에 block이 되고, 백 엔드는 디스크 인터럽트 핸들러가 프로세스를 다시 깨워주는 역할을 했다.(wake up)

## Clock Interrupt Handler
인터럽트중에서 Clock Interrupt Handler가 중요하다.
펄스가 한번 들어오면 1/1000초다. 이러면, os마다 clock interrupt 간격을 다르게 세팅하지만 Linux에서는 1/1000초를 보통쓴다. 버거우면 1/100초 쓴다.
클락 인터럽트가 들어오는것을 클락 틱 이라고 한다.

## 클락인터럽트가 들어오면 하는일이 많은데..
##### One)
시간을 아는 유일한 방법이다. 클락 틱이 1/1000초티면 시간이 지나가는거니까, 커널이 부팅된 이후에 1/1000초가 몇개나 돌아갔나를 체크 이것을 jiffy로 체크한다. 시간에 관련된것을 알 수 있다. 5초에 한번씩 돌아야 한다던가 시스템타임과 관련된것을 jiffy로 체크한다.
sleep 3초도 클락 인터럽트를 쓴다. 3초있다 깨워줘야함(block->running)
##### Two)
디스크에도 큐가 생겼다. I/O가 바쁘면.. 그러나 여기선 프로세스가 3개가 존재하는데 Sleep(3) Sleep(5) Sleep(7) 이렇게 있으면 클락에 대해서도 줄을 서게 된다. 시간의 차이만큼 줄을 서게 된다. 알람처럼 깨워주는것도 클락에 대해서 깨워달라고 요청할때 알람 클락이 존재한다.
시간과 관련된건 클락 인터럽트와 관련이 있다.
프로세스는 타임 드리븐, 이벤트 드리븐 두가지가 있다.
타임드리븐(slice-time-burst) 이벤트 드리븐(미사일을 쏜다든지)
커널도 주기적으로 해야하는 일이 존재한다. 예를들면 페이지캐시에서 디스크로 주기적으로 옮긴다하면 이 주기도 클락 인터럽트에 의해 통제될 수 밖에 없다. 시간이니까
##### Three)
타임아웃 함수가 존재. 인터럽트가 발생하면 인터럽트핸들러가 처리하는데 커널속에 있고 인터럽트가 3초마다 발생하면 이 인터럽트를 커널속에서 체크해주는게 클락 인터럽트다.
프로세스는 커널속에서 죽고 커널속에서 살아난다. 인터럽트 핸들링은 재빨리 끝내야 된다.
전화는 용건만 간단히, 인터럽트 핸들링이 늦어지면 디스크 I/O는 처리하지못하고 다시 돌아가버린다. 클락인터럽트핸들러도 1/1000초에 한번씩 오는데 인터럽트 핸들링 길어져서 1/1000초 지나면 아무것도 못한다. 그리고 못받으면 시간을 잊어버린다. 누적이되버리면 3초가 3시간이 되고 공장으로 비유하면 공장이 터진다. 증권회사의 경우 많은 돈이 없어질 수 있다.
결론 : 시간을 잊어버리면 안되고, 물리적인 디바이스가 처리해야할것을 끝내줘야 한다. 

긴작업의 경우에는 프로세스로 만들어준다. 프로세스로 만들면 CPU받아서 돌아가는데 프로세스는 인터럽트 핸들링보다는 순위가 밀리는데 인터럽트가 끝나야 돌아간다. 커널이 해야할 일을 커널 프로세스로 만든다. FILE sync(메모리->디스크 써주는것) 경우 너무 느리니까 (인터럽트 핸들링은 빨리끝내야 하므로 처리할수없음) 커널 프로세스에게 할당한다. 인터럽트 핸들링이 끝난 뒤에, ready 상태로 만들어줄테니까 스케쥴링 받아서 돌아가 이런 원리이다. 
swapper는 메모리를 청소하는것이다. sync나 swapper는 커널프로세스로 만들어서 인터럽트 핸들링이 끝난 다음에 돌아가게끔 클락 인터럽트 핸들러가 ready만 시켜놓는다. 원래는 block 상태였다. 커널이 만든 프로세스 이기 때문에 priority 높음
유저 프로세스 유저 코드돌아갈땐 유저모드, 시스템 콜하면 커널모드, 커널프로세스는 항상 커널모드이다. 커널 스레드 라고 한다.

#####Four)
cpu 한번쓰는걸 1/100초 하는데 다 끝나면 context_switch로 다른 프로세스로  옮긴다. 1/100초 카운트, 10번 들어오면 cpu를 뺐는다. 모든 프로세스는 time_slice_left 를 PCB안에 가지고 있다. time_slice_left를 자꾸 빼야한다. 클락 인터럽트가 들어올때마다, 결국에는 0이 된다.  1/100초 지나고 다른 프로세스로 cpu를 넘겨야 한다. 넘길려면 context_switch를 한다. 
인터럽트핸들링 속에서 context_switch는 없다. 왜? 인터럽트핸들링 하다가 도중에 context_switch하면 다른 프로세스로 가버리면 기존의 인터럽트핸들링은 끝난게 아니다. 
context_switch 필요가 생겼는데 언제 해야될까? 인터럽트핸들링이 끝나자 마자 해야한다.
도중에는 할 수가없다. Context_switch한다는것은 스케쥴러를 돌려서 끝난 프로세스에서 cpu를 뺐어가야하는 flag를 set해서 가져가고 Context_switch가 일어나게 된다.

## Clock Interrupt Handler
### Clock Interrupt handler
one)
시스템타임을 업데이트한다. jiffy++
two)
커널 타임아웃 함수를 호출한다.( 모든 n 틱에 대해서 )
three)
sleep() 된 후에 깨워야 한다. block에서 ready로
four)
현재 돌고 있는 프로세스의 클럭 인터럽트가 들어올 때마다 priority를 재계산한다.(시간을 계속 조사해서 데드라인에 가까워지면 priority를 높여주는 OS도 있다.)
five)
현재 돌고있는 프로세스의 PCB time_slice_left 가 줄어들면서 0이되면 다된것이고 재 스케쥴해야하는데 인터럽트 상태에서는 할 수 없으므로 PCB에서 nedd-resched flag를 1로 set 한다.
돌고있는 중에 새로운 급한 프로세스가 오면 need_resched flag가 1로 set될 수 있는데 1이 되면 리스케쥴링해서 재빨리 context_switch를 해야한다는것을 의미한다.
six)
클럭 인터럽트 핸들러에서 다 끝내지 못한 일을 여기서 한다. 
seven)
인터럽트 핸들링이 끝나면 다시 유저모드로 돌아간다. 그것을 return from interrupt라고 하는데 return from syscall하고 똑같다. 커널모드에서 유저모드로 가는것이다.
return from interrupt가 한줄이 아니라 오른쪽 표를 보는바와 같이 
```
do_softirq();
if(~~){
...
} 으로 구성된다.
```
여기서보면 소프트웨어 인터럽트가 등장한다.(지금까지 다룬건 하드웨어 인터럽트이다.)
currentPCB.need_resched가 1로 set되면 Context_Switch를 해야한다. 스케쥴링큐에서 높은 우선순위 가진것을 뽑아서 Context_Switch 해서 돌다가 클락 인터럽트가 들어오면 타임 슬라이스가 다됬으면 나오다가 cpu를 뺏기게 된다. (인터럽트 핸들러를 나오자 마자)
나중에 살아나는 지점도 Do Context_Switch 지점이다. 

## Kernel Places where Context Switches happen
언제 Context Switch가 일어나는 순간과 커널속 어디에서 일어나는지?
System call의 read를 살펴보면, 시스템 콜 안으로 들어와서 I/O 하기 위해서 스스로 CPU를 내놓고 CONTEXT_SWITCH한건데 이것은 시스템콜 도중에 한게 되는데 도중에 한것은 자발적으로 CPU를 내놓은것이다. Voluntary Context Switch라고 한다. 
Context_switch했다가 디스크 I/O가 종료되면 다시 살아날 것이다. 살아나면 커널속에서 돌다가 종국에서는 return from system_call을 하게 된다. 
이전에 currentPCB.need_resched =1 로 되서 리스케쥴링하고 CPU를 뺐어오는경우는 자발적인 경우가 아니다. , Context_Switch 되는것. 
```
ret_from_syscall(return from systemcall):
	if rescheduling is necessary,
    	do Involuntary Context Switch; //비자발적으로 뺏기는 경우
}
```
정리, 시스템콜 중간에 Context_switch는 자발적으로 cpu를 내놓으면서 I/O를 진행하는 자발적인 Context_Switch에 반해 시스템콜 중간에 다른 인터럽트가 들어오면 재스케쥴하고 CPU를 뺏어야 하니까 비자발적인 Context_Switch이다.

인터럽트 핸들러 도중에는 컨텍스트 스위치는 절대 없다. 빨리 끝내야 하니까, 인터럽트 핸들링이 끝날때 Involuntary Context_Switch가 일어난다. 

-시스템콜 도중에-voluntary CS
-시스템콜 끝났을때-involuntary CS
-인터럽트 핸들링 끝났을때-involuntary CS
이 3가지 형태가 커널속에 있다.

premtive(선점하는) 커널 중간에 involuntary CS 있어서 프로세스가 짤려도 돌아가는 방법이 있다.

시스템콜이 길어지는 경우는 전송되는 메시지가 크다고 가정하면 읽는데 시간이 걸리니까 중간에 involuntary CS 집어넣는다. 대부분의 시스템콜이 짧는데, 메모리 카피가 많은경우 혹은 메시지가 길경우 