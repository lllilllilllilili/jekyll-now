---
post : layout
title : 시스템프로그래밍4
---
## I/O Systems
OS 는, I/O device 하나의 파일로 맵핑한다. 우리가 흔히 아는 print도 파일로 맵핑해서 open/write를 통해서 print해서 나가게 된다.

같은 파일, API로 쓰기 위해서는 항상 스페셜 파일로 맵핑해서 I/O 디바이스 한다.

일반적으로 키보드, 모니터, 캐릭터 단위 => 즉시 나가지만 
++디스크 I/O는 write시 디스크디바이스드라이버가 커널속의 인터럽트핸들러하고, 파일시스템 API를 통해서 디바이스드라이버한테 실제 디스크로 내보낼것을 전달해야 하는데++ 
++대부분 CPU는 바쁘고, 디스크도 바쁘다.++

서버 시스템의 경우는 디스크가 한개 여러 프로세스가 디스크 I/O를 하려면 줄을 서야 한다. 디스크가 줄을 서있다. I/O하고 싶은게(끝나지 않았기 때문에) 새로 들어온 I/O 줄을 세우고 줄을 세울때 어디에서 무슨 I/O를 할건지 지정해야 한다. 이것을 *I/O request block* 이라고한다.

I/O request block 하나를 만들어서 queuing 하고 디스크 드라이버는 디스크에 시킨일이 있다. 디바이스가 일을 다하면 인터럽트가 들어온다. 인터럽트가 들어오면 인터럽트 핸들러로 즉시가게 되니까 I/O가 아까 시킨게 하나 끝났다라는것을 디바이스 드라이버가 알 수 있게 되고 I/O request queue에서 데이터를 뽑아서 그 다음 명령을 수행한다.


### Device
CPU하나도 하나의 Device, Disk도 하나의 Device, 메모리도 하나의 Device, 프린트도 하나의 Device한다. Device는 하드웨어가 다르니까 I/O할때 줄을 서야하고 교통정리는 커널이 한다.

줄을 설때 성능을 높이기 위해서 순서를 변경할 수 도 있다. = 스케쥴링.

리소스쓸때, I/O할때 줄을 서야 한다. 하나씩 처리하는걸 인터럽트 들어오면 다음걸하고 인터럽트 들어오면 다음걸 내보내고 하니까
##### 인터럽트는
I/O 디바이스 한테 일을 시켜 놓고 다했다 라는 보고를 받는 신호 체계 이다.


## Device Controller : H/W
디바이스 컨트롤러는 모든 디바이스 (프린트, 디스크, 네트워크) 구축하고 있는데 보통 디스크 같은거는(9,12) 거기에 불러들여 오는걸 디스크컨트롤러라고 부른다.
키보드도 디스크 컨트롤러가 있다. (받아야 하니까)

##### Interface
키보드 처럼 간단한것을 인터페이스 라고 부른다. 

##### Controller
종류는 같은건데 기능이 복잡하면 컨트롤러라고 하고 간단하면 인터페이스라고 한다.
## • Major registers of a controller
##### Command(instruction) register
current I/O command received from the device driver
##### Status register
BUSY (in I/O) or DONE (an I/O has been finished); When the DONE is set, an interrupt occurs to notify an I/O completion to CPU.
##### Data buffer register 
current data in I/O
컨트롤러에는 지금 Read/write 하는건지 지금 수행하고 있는 건지 명령에 대한 이것을 저장하고 있는 commend 레지스터가 있어야 하고 데이터를 내보내고 받을때 중간단계가 있는데 네트워크를 통해서 들어오면 한 규모 PC로 들어오면 1kbyte, 1byte 중간단계 bit가 쌓이니까 그것을 쌓은 다음에 인터럽트를 걸어야 한다. 이러한 목적으로 ++Data buffer register++ 가 필요하고 나갈때도 마찬가지다.

##### I/O processor
디바이스 컨트롤러가 굉장히 기능이 복잡한 경우가 있는데 그럴 땐 아예 거기서 cpu를 집어넣어서 프로그래밍 할 수 있게 한다. I/O 전용
CPU를 집어넣어서 컨트롤러를 구상하면 I/O 프로세서 라고 한다.

보통 안쓰는 CPU를 특수목적으로 집어넣어서 복잡한 기계에 I/O 프로세스를 쓴다.
Interface (for KB) < Controller (for Disk) < I/O Processor

## busy와 done
컨트롤러의 상태를 나타내는 status register가 있는데 2개(busy, done) busy는 일을 하는중에 명령어를 내리지 않도록 하고, done은 디바이스 드라이버가 시킨일을 다했으니까 done이 set되면 하드웨어적으로 인터럽트가 발생해서 이게 다 끝났다 라는 것을 커널에 알려준다.

##### Intelligence & Cost
Intelligence 고급, 지능이있고 가격도(Interface는 싸고) 
디스크 컨트롤러도 복잡해지면 CPU를 써서 I/O 프로세스를 만들기도 한다.

## Device Driver : Kernel S/W
디바이스 드라이버는 유저가 파일시스템 API를 통해서 Write 명령을 내리면 거기에 디바이스 드라이버를 거쳐서 하드웨어 컨트롤러로 나가게 되는데 여기서 디바이스가 일을 다하면 인터럽트를 건다. 
인터럽트가 걸리면 디바이스 드라이버로 와서 또 다음 명령어를 내려야 한다.

++항상 디바이스 드라이버는 커널 안에 있다.++

주된 업무는 인터럽트를 받아와서 다음 명령을 내리는데 업무를 하기 때문에 pc에다 마우스 혹은 프린트 설치시 디바이스 드라이버를 깔아야 하는데 요즘에는 OS가 자동으로 찾아서 깔아주기 때문에 사용자가 잘 모르는 경우도 있다.(디바이스 드라이버가 중요하다.)

디바이스 드라이버는 디바이스일을 다 했을 때, 인터럽트가 들어오기 때문에 인터럽트가 들어오면 ++CPU는 I/O 디바이스 에서 실행되지 않고 다른 프로세스를 돌려주고 있었을 텐데++ 인터럽트가 발생하면 즉시 중단 하고 인터럽트 핸들러로 들어가는데 그 인터럽트 핸들러가 디바이스 프레임의 대부분이다.

인터럽트가 들어오면 인풋의 경우에 키보드를 예로 살펴보자, A글자가 들어오면 커널한테 가져가라 OUTPUT 같은 경우도 프린트를 예로보면 키보드로 A글자를 커널이 가져갔기 떄문에 프린트가 A를 찍으면 다음 글자를 내보내줘야 한다는 의미이다.

I/O하는것중에서도 문자단위(키보드) 인터럽트발생.
디스크는 ++Block oriented device++ 라고 해서 한번에 읽을 때 4KByte한번에 읽는다. 쓸때도 마찬가지다. ++따라서, 한 byte 마다 인터럽트를 거는게 아니라 4kbyte를 다 올리고 나서 Interrupt를 건다.++ 은행 500만원씩찾으면 편한데 만원씩 찾으면 불편한것과 비슷한것.

## Device driver (request handling & interrupt handler)

## I/O Systems
I/O 프로그램을 짜는데 프로그램은 CPU가 I/O를 디바이스 에게 명령어를 내리고 다음 명령어를 내릴려하면 Done flag가 set 되어야 한다.
명령어를 내리고 나서 done이 set 됬는지, 그렇지 않으면 계속해서 loop을 돈다.
I/O 디바이스가 일을 끝마칠 때까지 CPU가 LOOP을 도니까 CPU가 하는일이 하나도 없다.
ex) 은행에서 500만원을 찾아오려고 하는데 전화가 10초에 한번꼴로 걸리는 모습
이것은 CPU가 I/O하는 동안 놀게되니까 CPU가 빠른 이유가 없어진다. (성능이 저하됨) ++Programmed I/O++

요새는 I/O를 시켜놓고 인터럽트가 들어올때 까지 CPU는 다른 프로세스를 돌려주고 있다.
CPU와 I/O같이 돈다해서 ++CPU I/O over lap++이라한다.
이것을 ++busy wait loop++ 이라고 한다. 바빠서 loop을 돌면서 기다린다.
I/O 디바이스는 무지하게 느리고 CPU는 빠르다. 낭비를 최소화 한다.

## Busy Waiting Loop
polling은 계속 물어보는 형태를 의미한다.

## I/O Systems : Interrupt I/O
시스템이 I/O로 발전한다.
CPU는 I/O 명령을 인터페이스나 컨트롤러한테 내리고 이때부터 I/O 디바이스가 일을 하고 I/O 하는 동안에 CPU가 free해지니까 다른 프로세스를 돌려준다. ++CPU I/O overlap++ 이라한다.
I/O가 끝나면 다음 명령을 내려야 하기 때문에 디바이스가 I/O가 끝나면 인터럽트를 걸고 인터럽트가 들어오면 CPU는 현재 돌리고 있던 프로세스를 즉시 중단하고 자동적으로 인터럽트 핸들러로 점프하게 된다.(하드웨어 적으로) 일어난다.
하드웨어적으로 인터럽트핸들러로 커널속에 들어가면 인터럽트 처리를 한 후에 다시 예전에 돌렸던 프로세스로 돌아올 수 있다.

==디바이스 드라이버에 메이저 모듈은 인터럽트 핸들러다.==
## I/O Systems : IO unit types
인터럽트 핸들러는 어렵다. ++I/O  Unit time++ 문자단위로 I/O하는것을 ++Character oriented I/O++ 라고 한다. 키보드가 대표적이다. 인터럽트가 매 캐릭터에 I/O를 발생 시킬 때 마다 키보드 하나 딱 두드리면 인터럽트가 발생해서 하나를 가져가게 된다.

## Block oriented IO
++Block oriented IO++ 블락 오리엔티드 디바이스는 디스크 라든가, 네트워크 같은거
네트워크는 패킷 단위로 구성되는데 2Kbyte 미만, 네트워크로 들어오면 2Kbyte들어오면 2천번을 인터럽트 걸 수 없으니까 한꺼번에 들어온 다음에 인터럽트 걸고 디스크도 4Kbyte로 읽어오거나 쓴다음에 인터럽트가 발생한다.
physical block : disk sector 말한다(4kb) , 네트워크는 패캣 프라임이 된다.

## DMA
디스크에다 커널이 명령을 내린다. 너 어느 트랙, 어느 섹터에서 4kb 읽어와. 명령을 내렸어. cpu는 다른데로 가버렸다.
디스크 컨트롤러는 4kb 어디에 집어넣어야 한다. 이게 키보드라고 하면 인터럽트가 바이트 마다 들어오니까 어 인터럽트 들어와서 하나 줘버려서 cpu레지스터 가지고 올수 있다. 그때마다 대화를하니까
디스크 같은 경우는 4kb 하는동안 인터럽트를 안건다. cpu는 다른데로 가버렸으니까 4kb 다 읽어 들이는동안 cpu 개입안함. 따라서 디스크 컨트롤러는 4kb 한 바이트 읽어와서 메모리에다
자기가 직접 때려넣어야 한다. ++Direct memory access(DMA)++ 라고 한다.
cpu 거치지 않고 디스크 컨트롤러가 4kb 스트림 올라올때마다, 네트워크 프라임 올라올때마다 cpu를 거치지않고
메모리를 직접 access한다.

## 충돌
그러면 메모리 입장에서 손님이 cpu 손님이고, 디스크 컨트롤러도 손님이다. 네트워크 카드도 메모리를 access한다. 메모리 입장에서 cpu도 있고, 디스크 컨트롤러도 있는거고, 네트워크 카드도 있다.
자기를 access 하는 디바이스들이 된다. 메모리를 서비스를 해줘야 한다.
메모리 입장에서 보면 메모리 버스에서 read/write signal 오면 데이터를 메모리로 보낸다. 보내면 메모리가 거기에 해당하는 주소를 가져다 주거나 쓰거나 메모리인데 이게 cpu는 다른 프로세스 수행하는게 명령어를 계속 fetch한다. cpu도 메모리 계속 건들인다. 디스크컨트롤러에게 명령을 내렸으니까 디스크 컨트롤러도 메모리를 access할꺼다.(dma니까)
그게 시간 차이가 나면 괜찮은데 충돌이 생긴다. 메모리에 어느 순간에 cpu도 메모리를 쓸려고하고 디스크 컨트롤러도 메모리쓸려고 하고 충돌 가능성
cpu 가 메모리쓰는건 굉장히 빠르다.(명령어 패치하는거) 디스크 컨트롤러는 상대적으로 속도가 느리다.

## Cycle stealing
메모리 입장에서 cpu하고 디스크컨트롤러 같이 request 시 누구를 먼저해줘야 하나? 느린걸 먼저해줘야 한다.
왜냐하면 cpu 하면 디스크는 계속 밀리고 밀리다보면 디스크는 돌아가 버린다. 디스크 하고 cpu 메모리에 대해서 같이 요구가 들어오면 디스크를 먼저해준다.
cpu는 한번 쉬어야 한다(메모리 엑세스 해야 인스트럭션 수행할수 있는데) 그것을 사이클 스텔링 즉, dma가 cpu의 메모리 사이클 하나 훔쳐서 cpu가 지연이 된다.

## Block-oriented I/O and DMA
4kb 한번씩 인터럽트가 들어오니까 인터럽트 프로세싱 짐이 굉장히 줄어든다.
디스크 I/O 형태를 그림으로 그려보면 
순번이있다. (그림을 따라 본다.)
1. CPU는 디스크 컨트롤러에게 I/O 커멘드를 내보낸다. CPU는 다른 프로세스를 돌리기 시작한다. (다른 프로세스는 메모리에 있다.)디스크 컨트롤러는 CPU와 별도로 일하게 된다. 
2. 4KB 드라이버로부터 읽어들이기 시작한다. 읽어들일때마다 메모리에다 직접넣으니까 DMA I/O라고 한다.
3. byte 단위로 메모리에 직접쓴다.(컨트롤러가)
4. 메모리하고 access하는게 cpu access 하고 디스크 컨트롤러도 access 할때 충돌이 생길때 cpu가 양보를 한다. dma 가 cpu의 사이클을 훔친다고 해서 cycle stealing이라 한다.
5. block이 완료되면, CPU는 인터럽트를 보낸다.

## I/O Systems
디스크 컨트롤러가 4kb 를 메모리에다 넣으면 다, cpu한테 인터럽트 보내서 다음 명령어를 달라 요구하게 된다.(Busy Waiting(polling))

I/O 시스템 발전을 보면 busy 하냐고 loop 그거를 하다가 notify 다한다음에 알려주는 시스템(cpu 해방시켜주기 위해서 인터럽트 도입) 
키보드 같은건 인터럽트를 바이트 단위로 하다가 dma 디스크 같은건 dma + 인터럽트 : 4kb 한번씩 인터럽트를 건다.

**키보드 같은건 성격상 1캐릭터당 1바이트 인터럽트를 걸 수 밖에 없다.**
## Interrupt Handing
인터럽트는 하드웨어 시그널이다. I/O interface 나 컨트롤러에서부터 cpu로 들어오는 하드웨어 시그널이다. 

인풋이 준비가 되었으니까 가져가라, 아웃풋은 니가 아까 시킨일 다했으니까 다음 명령을 내려달라.

인터럽트가 발생하면 현재 프로세스는 중지가 되고 cpu의 컨트롤은 인터럽트 핸드러로 즉시 가게 된다.

## Interrupt Handling
인터럽트 핸드러는 커널 속에 있다. 
유저 모드로 돌다가 인터럽트 핸드러로 들어가면 커널 모드가 된다. 
인터럽트 핸드러 들어오는 거까지 보통 하드웨어 의해서 자동적으로 들어온다.(cpu에 의해서) 
디스크컨트롤러가 인터럽트 걸었으면, 디스크 인터럽트 핸들러로 들어오고
키보드가 인터럽트를 걸었으면, 키보드 인터럽트핸들러로 들어오고 이게 다 커널속에 있다. 

인터럽트가 들어오면 즉시 중단되고 cpu에 의해서 컨트롤러가 인터럽트 핸들러로 들어온다. 과정은 어떻게 되는지 살펴본다.

1. context save 직전에 다른 인터럽트가 또 들어와 인터럽트핸들링이 또 인터럽트를 당하면 이상하다. 세이브를 못하고, 
context saved 동안에는 인터럽트를 못들어오게 막아버린다. 
모든 인터럽트를 비활성화 한다.
disable all interrupts 
다른 인터럽트 핸들러에 또 잘리는걸 막기 위해서 인터럽트를 못들어오게 한다. 하드웨어적으로 인터럽트가 들어오는데 cpu가 반응하지 않도록 한다. 인터럽트 모르게

2. 이 프로세스를 돌리고 있었는데, 레지스터를 사용중, 하다가 인터럽트가 들어오면 중지하고 인터럽트 핸들러로 가면 이게 돌면 레지스터 깨져버린다. 나중에 다시 돌아올려하면 레지스터 내용을 saved 해야한다. = context

3. 그리고나서 현재 돌고 있는 프로세스에 레지스터 내용을 세이브한다. 나중에 돌아가야 하기 때문에 세이브 했기 때문에 인터럽트를 enable 해야한다.  인터럽트를 들어올 수 있게 => 키보드 인터럽트 내가 처리하는 도중이라고 치자. 클럭 인터럽트가 들어왔다. 어느게 더 중요할까?
클럭 인터럽트 더 중요하면 키보드 인터럽트핸들러도 잘려야 한다. 인터럽트 핸들러 도 더 중요한 인터럽트가 들어오면 인터럽트는 인터럽트 당할 수 있게 만들어야 한다. 더 중요한 인터럽트
정전이 되고 있다. 인터럽트를 enable 하는데 나보다 낮은 priority 인터럽트 있을거고 나보다 높은 priority 인터럽트 있을거기 때문에 뭐만 enable 시키냐?
나보다 priority 높은 인터럽트만 들어올 수  있게 처리를 한다.
++Interrupt masking++ 이라고 한다.
++키보드 인터럽트 처리 도중에, 디스크 인터럽트가 더 높다. 디스크 인터럽트 enable하지만 마우스 인터럽트는 동급은 enable 하지 않는다.++
++자기보다 priority 안터럽만 파셜리 enable 하는데 그걸 인터럽트 마스킹, 인터럽트 매스크 델타 sector한다.++

4. 인터럽트를 건 디바이스에게 ack를 보낸다. (잘받았다) 잘받았으니까 인터럽트 더이상 걸지마!

5. 인풋의경우 가지고 오면되고, 
6. 아웃풋경우 다음 아웃풋을 보내면된다.(프린트경우), 디스크는 좀 다름
7. 다음 I/O를 시작한다.(I/O interface/controller)
8. 모든 인터럽트가 들어올 수 있도록 허용한다.
9. 중단된 프로세스로 돌아가서(저장된 context) 혹은 커널의 스케쥴러로 보낸다.

## 7,8,9
큐가 밀려 있으면, 다음 I/O 또다른 명령어 내리고 인터럽트 처리 다했음, 인터럽트를 전반적으로 ENABLE 시킨다. 그리고 나서 중단됬던 프로세스가 점프
해서 인터럽트핸들러로 들어온거다. 글로 다시 돌아가야 한다. 다시 돌아가는데 OS가 중지됬던 프로세스로 돌아가는 경우도 있지만 대부분 다시 스케쥴러로 가서
짤렸던 프로세스로 갈 수도있고 그 사이에 어마무시한 중요한 프로세스가 생겼으면 다른걸 먼저 처리할 수 도있고 그것은 스케쥴러 마음이다.

## Multi-priority interrupts
인터럽트는 H/W priority 가지는데, Multi priority 인터럽트 , 하드웨어 적으로 서포트 된다.
lower priority 인터럽트 핸들링을 하는데, 높은 인터럽트 들어오면 짤릴 수가 있다.

인터럽트 priority 순서를 보면, 
1. Machine malfunction
2. Power fail
3. Clock interrupt (주기 1/1000), 정상상태에서 가장 중요한 인터럽트이다. 
시스템 시간도 업데이트한다. Time slice check 하고, 클락으로 알람 설정도 할 수 있고, 주기적으로 하는일(클락 인터럽트 핸들러 관련)
4. Disk, network I/O completion interrupt : DMA interrupt.(메모리로 Controller가 직접 access 하는 경우)
5. Char I/O completion interrupt, 키보드가 우선순위에서 제일 낮다.

## Asynchronous Concurrent Process
시간을 예측할 수 없는게 비동기식이고 Concurrent Process의 풀네임이다.
병렬인것과 병렬처럼 보이는것을(cpu가 하난데 번갈아 가면서 돌리는 행위 = concurrent)
multi-tasking system에서 Process states는 총 3가지가 있는데, 
1. Running 
CPU에 의해서 현재 실행중인 process를 의미한다.
2. Ready
scheduling queue에 안에서 schedule이 되는것을 기다린다. 
정지된 상태(CPU를 기다린다.)
프로세스가 많을 때 프로세스가 CPU를 기다린다.(중간에 억울하게 뺐겼기 때문에)
3. Blocked
정지된 상태에서 이벤트를 기다리는 중이다. (I/O가 완료되는것을 기다리며, 메시지를 기다린다.)
I/O 실행중에서는 CPU가 내놓는 상태이고, 이러한 상태를 Blocked 상태라고하고 다른 프로세스를 위해서 내놓는것이다.
event(인터럽트)가 발생할 때까지 스케쥴링이 되지 않는다.(CPU가 다른 프로세스로 떠났기 때문에)
==scheduling queue에 없고 sleep queue에 있다.(여기서 줄을 선다.)==
중지된다(CPU의 사용은 없다.) but the I/O device 는 프로세스에서 계속 일하고 있을 것이다.
CPU는 다른 프로세스에서 돈다.(프로세를 양보한다.)

## Process State Transition
New는 돌기전의 상태이고, Ready는 Scheduling Queue에서 프로세스가 실행중인 상태이다. 이게 scheduled가되면 Running 상태가 된다.(정지된상태, cpu를 뺏긴 상태가 된다.) 여기서 Terminated로 가면 종료되지만(좀비상태를 고려해봐야 하고)
Blocked상태로 가면 다음의 경우에 CPU가 다른 프로세스를 돌리고 있는 중이다.(I/O request, wait for an event ex) sleep(3), wait for a msg, In Sleep Queue) 이러한 상태에서 끝나야 인터럽트를 발생시켜서 CPU가 커널에게 인터럽트핸들러를 통해 처리할 수 있는것이다. Blocked 상태는 cpu를 내놓은 상태고 
I/O 끝나거나 대기 이벤트(sleep(3) 끝났다던가) 발생했을 때 Ready로 돌아간다.

## Process State Transition
Running이 User mode running이 되고 이게 System Call을 하껀데 I/O 작업이 실시되서 CPU를 내놓은 상태로 blocked 된거다. I/O가 끝나면 인터럽트가 올것이고, 디바이스 드라이버에서 커널속에서 인터럽트 핸들러로 처리해주면 blocked 된 상태가 Ready로 될거고 이역시 cpu가 중지된 상태다. Ready에서 스케쥴러를 통해서 System call을 작업하고 return 하면서 다시 Running 상태로 온다. ++프로세스가 blocked 되는것도 커널 안이고 다시 살아날 때도 죽은자리인 커널 속에서 살아난다.++
