---
post : layout
title : 시프(기)2
---
## 시프(기)2
시프(기)2

## Signal Processing(Asynchronous Event Processing)
밖에서 외부디바이스가 cpu한테 나 급한일이 있어서 거는게 하드웨어 인터럽트다. 그렇다. 컴퓨터시스템에서 돌아가는것중에서 제일 쎈것은 인터럽트다. 모든것을 다 자르고 무조건 즉시, 인터럽트 핸들러로 들어가서 뭔가 처리를 한다. 근데 sleep에서 꺠워주는것은 인터럽트 핸들러라고 썻는데 클락 인터럽트 핸들러가 꺠워준다. 인터럽트라는것은 인터럽트는 하드웨어 인터럽트를 말하는것이고 그것은 컴퓨터시스템에서 제일 쎈 거기 때문에 즉각 처리를 해줘야 하는게 인터럽트 핸들러이다. 거기에는 클락 인터럽트도 있었고 디스크 아이오가 끝났다는 인터럽트도 있고 메모리가 고장났다는 인터럽트도 있을것이고 그런것들이 하드웨어 인터럽트다. 그런데 이제 유저레벨에서 인터럽트 핸들러는 다 커널만드는사람이 만든다. 어쨋든 커널하고 관계없이 유저레벨에서도 급한일이 발생하면 그것을 즉각처리하는 그러한 인터럽트 핸들러랑 비슷한것을 유저레벨에서도 프로그램 레벨에서도 만들수가 있다. 그것이 signal이라고 하는것이다. 인터럽트 대신에 유저한테 signal이 들어오면 signal handler로 즉각 가서 처리를 인터럽트 대신에 처리를 하게 되어있는데 이것은 주로 어디에 사용되냐 하면, 이것도 프로그램이 돌아가는데 먼가 이상한 급한일이 생긴거 나 발생했다는것을 알려주는게 signal이다. 우리 cond_signal했듯이 유저프로그램에게 signal이 들어왔단 얘기는 signal에는 종류가 50가지가 된다. 나중에 나오겠지만 어떤 급한일이 생긴것이고 거기에 대해서 급하게 처리하는것을 인터럽트핸들러랑 비슷하게 유저레벨에서 만들수있는게 시그널 핸들러다. 그래서 asynchronous한것이다. 비동기적으로 어떤 이벤트가 생겼을때 즉각 처리가 되어야 하는것 그것을 하는게 signal processing이다. 그래서 일종에 소프트웨어적인 인터럽트다. 개념적으로 그렇게 생각해도 좋다. 돌아가는 원리가 비슷하다.

## Signal Handling
그래서 signal은 누가 누구에게 전달하는것이냐? 첫번째는 급한일이 생긴것은 커널이 대부분안다. 커널이 유저프로세스한테 signal을 보낼 수 있다. 커널이 유저프로세스 한테 signal을 보낼 수도 있고, 또 프로세스가 프로세스한테 signal을 급한일이 생겼어 하고 보낼 수 있다. 프로세스 끼리 보내는 signal은 일종에 프로세스간에 통신의 한 방법이 된다. 급한일 이 생겼어 빨리 처리해줘 
signal은 커널이 유저 프로세스에게 보내기도 하고 프로세스가 프로세스한테 보내기도 한다. signal을 보내는것은 shell에서도 가능한데 shell command가 kill이라는 command가 있다. kill 해가지고 signal을 프로세스한테 보낼 수가 있는데 이 kill이라는것은 영문적인 의미로 죽인다 의미인데 그런뜻이 아니라 signal을 보낸다 의미다. 그런데, signal을 보내면 대부분 자살을 한다. 받은 프로세스가. 그래서 kill이라고 부르는데 사실은 죽으란 뜻이 아니라 signal을 보낸다. 라는 시스템콜인 ! kill이 있다. 그리고 shell command에 있다. 

그래서 이제 signal이 어떻게 배달되고 처리되는지에 대한 여러분들의 입장에 유저의 입장 사용자의 입장에서 프로그램의 입장에서 보면 유저모드 러닝을 하고 있다. 자기가 프로그램 돌것이다. 커널이나 다른 프로세스가 시그널을 보낼것이다. 시그널이 오는순간에 더이상 유저모드 러닝은 없다. 즉각, 시그널이 발생하면 유저프로그램이 여기 인터럽트(여기서 인터럽트라는것은 하드웨어 인터럽트를 말하는것이 아니라 짤린다 의미이다.) 즉각 짤려서 어디로 가냐면 시그널 핸들러로 가서 그 해당되는 시그널의 핸들러로 가서 시그널을 처리를 하는데 이것은 인터럽트 핸들러처럼 커널속에서 도는게 아니라 그냥 유저모드에서 돈다. 우리가 짤수도있다. 유저모드 러닝을 하고 시그널 핸들러에 가서 죽어버리거나 더이상 할 수 없으면(exit을 하거나, exit은 누차 말하지만 자살을 하는것이다.= 프로세스 자살) 아니면 계속할 수 있는거면 다시 유저프로그램으로 돌아와서 예전에 짤린 인터럽트 핸들러에서 돌아오듯이 짤렸던 데서부터 다시 시작할 수 있다. 일종에 소프트웨어적인 인터럽트다. 그러면 하드웨어 인터럽트하고 다른점은 커널의 입장에서 보면 나타난다. 커널의 입장에서는 커널이 먼저 어떤 이벤트가 발생헀다 라는것을 이제 알게된다. 예를들어서 sigment fault 라는게 뭐냐? 어드레스를 다른곳을 침범했을때 생긴다. 리눅스에서 메모리를 다른데를 잘못건드렸다. 그러면, 그것을 원래 다른 os 같으면 커널속에서 그 프로세스를 죽여버려야 했다. 근데 리눅스는 그렇게 하지 않는다. 커널이 그것을 감지를 하면 커널이 그것을 감지했는데 우리 프로세스에는 메타 데이터 pcb가 있었(프로세스 정보가, 프로세스 컨트롤 블락) 는데 그 pcb안에는 signal table이 하나 존재한다. 이 프로세스에게 배달된 signal의 목록이다. 우편함 같은것이다. 거기에다가 표시를 한다. signal이 발생했다고 pcb안에 있는 signal table에다가 마크를 한다. 누가 돌고있냐? 커널이 돌고있다. 커널이 돌고있으니까 이 프로세스는 도는 상태가 아니다. 커널속에 있다. 커널은 이것을 배달을 해놓고 단 프로세스를 돌리거나 했으면 그것을 다른것을 돌리거나 한다. 근데 내가 누차말했지만 프로세스는 커널속에서 block 되고 살아나는곳도 커널속에서 살아난다. 나중에 저 signal을 받은 프로세스가 돌기 시작했을때 살아나는곳은 커널속에서 살아난다. 그러면 그것이 커널 모드일것이다. 커널 모드에서 뭔가 시스템콜을 나머지를 마치고 나서 다시 어디로 돌아가냐면 유저모드로 돌아갈 것이다. 그렇다. 그래서 커널 모드에서 돌다가 유저모드로 돌아갈때 유저모드로 돌아가는 그 시점에서 signal이 뭐가 배달됬는지를 프로세스가 스스로 체크를 한다. 그래서, 시그널 테이블을 봤더니 sigment fault라는 시그널이 들어와 있다고 이런말이다. 그러면, 원래는 커널모드를 마치고 어디로 돌아가야 하나? 시스템콜이 끝났으면 시스템콜이 끝난 자리로 돌아가야 한다. 유저모드로 그거 가기 바로 전에 뭘 거쳐서 간단 말이냐? signal handler을 유저모드에서 돌리고 간다. 이말이다. signal handler로 가서 대부분 죽는다. 자살한다. 왜냐하면, sigment fault는 더 돌릴수가 없다. 남의 메모리를 침범했으니까 그렇다. 그러니까 인터럽트, 유저의 입장에서 보면 인터럽트 처리하는것과 같다. 즉각 유저모드 러닝은 없으니까! 그냥 유저 모드에서 돌다가 시그널이 발생하면 시그널 핸들러로 갔다온다. ++그러나 그 안에를 자세히 들여다 보면 프로세스가 살아났을때 커널속에서 살아나게 되고 커널 모드가 끝나면 어디로 돌아가나 유저모드로 돌아갈텐데 그때 시그널 핸들러를 처리를 하니까 이게 즉시인가 아닌가? 약간의 딜레이가 있다. 약간의 딜레이가 있는게 인터럽트와 차이가 있다. 하드웨어 인터럽트는 아무런 딜레이가 없이 즉시 인터럽트핸들러로 가서 처리를 해야하는것이고 이것은 유저의 입장에서 보면 즉시지만, 커널의 입장에서 보면 그건 그 프로세스가 살아나서 스케쥴을 받아서 유저모드로 돌아가기전에 시그널 핸들러가 돌아가는거니까 실제로는 약간의 딜레이가 있다.++ 
그러나 프로그램 짜는 입장에서는 마치, 내가 인터럽트 핸들러를 만든다 라고 생각해도 무방하다. 그래서 소프트웨어 인터럽트다 이렇게 얘기를 한다.
그래서 시그널 핸들링은 시그널이 배달이 되면 이건 커널이 pcb속에다가 그 시그널이 발생했다라는 bit을 세팅을 한다. mask를 set해서 하고 그 프로세스가 돌기 시작하면 (context_switch해서 돌것이다.) 그러면 항상 커널속에서 살아나니까 커널모드에서 유저모드로 돌아가기 직전에 원래는 시스템콜안에들어가서 스택에 ??? 쌓여있는데 그것을 ??? 해서 어디로 가게 만드냐? 시그널 핸들러로 가게 만든다. 그래서 시그널 핸들러로 갔다가 안죽으면 다시 유저모드로 돌아오는것이다.그래서 ++pending signal 이라는것은 시그널이 커널에서 배달은 됬는데 아직까지 시그널핸들러까지 돌아서 처리가 안된것을 의미한다. 그래서 펜딩 시그널이 있을때는 프로세스 커널모드 러닝은 존재할수있지만, 유저모드에서 러닝은 존재하지 않는다.++ 유저모드에서는 볼때는 즉시적이다. 라는 말이다.

우리 인터럽트 핸들러 배운면서 인터럽트 처리하는 도중에 나보다 덜 중요한 인터럽트를 못들어 오게 한다. 인터럽트도 mask를 해서 블락킹해서, 인터럽트를 disable 시킬 수 있다. 못들어오게 
못들어오는게 아니라 들어와도 cpu가 반응하지 않도록 하는것이다. 인터럽트 핸들러를 갖지 않게끔 시그널도 마찬가지로 어떻게 되냐면 유저가 원할때에는 blocking을 할 수 있다. 그래서 blocking 처리가 되어있는동안에는 signal이 일어나냐 못일어나냐? 안일어난다. 저것을 다시 어떻게 해야지? unblocking 처리를 해야 시그널 처리가 돌아간다. 의미이다. 

++example 프로그램이 있으면 돌려봐라++

## Three Ways of Signal Handling
시그널 핸들러는 3가지 종류가 있다. 하나는 default다. 기본이라는것은 시그널이 발생하면 디폴트 시그널 핸들, 그 시그널에 대한 디폴트 핸들러가 이미다 존재한다. 그것을 커널이 제공을 해준다. 물론 시그널 핸들러는 무슨 모드에서 도냐? 유저모드에서 돈다. 이것은 커널모드가 아니다. 이미 커널시스템이 제공하는 디폴트 핸들러가 있다. 디폴트 핸들러는 대부분이 자살한다. 왜냐하면 안좋은 일이 발생한것이기 때문에, 시그널이 발생했다는것은 
코어 덤프는 많이 해봤겠다. 프로그램 잘못돌리다가 어떻때는 코어 덤프 액싯 이라고 메시지 나오면서 죽는데 그것은 무슨말이냐면 디버깅을 할 수 있게 메모리에서 돌아가는 프로세스를 디스크에다 그 이미지 그대로 덤프를 해준것이다. 그래서 디버거로 돌릴수가 있다.(어디서 왜 죽었는지 알아볼 수 가 있다.)
그냥 자살하는 경우가 있고, 코어 덤프를 해서 디버깅을 할 수 있는 코어 파일을 만들어놓고 자살하는 경우가 있다. 이말이다. 
왜 시그널은 대부분 안좋은게 일이 발생한것이다. 

그다음에 시그널을 이건 내가 자주쓰는건데 signal ignore, 시그널을 무시할 수도 있다. 이런것은 어떤때 쓰이냐면 내가 네트워크 프로그램을 많이 짜는데 네트워크 프로그램을 짤려고 그러면 저쪽에 기대??? 하고 tcp나 이런것들로 주고받는다. 근데 그게 여러분이 배웠던 파이프 배웠던것과 똑같다. 시스템콜 이름만 리시브센더 하고 리시브로 바꼈을 뿐이지 파이프랑 다른것이 없다. 다 똑같다. 네트워크 소켓이라고 하는데 
그러니까 주는놈이 있고, 받는 놈이 있다. 보내는놈이면 send를 할것이다. 그런데 저쪽 프로세스가 무슨 이유에서인지 죽어버렸다. 네트워크가 끊어졌거나 그때 시그널이 발생을 하게 되는데 그때 발생하는 시그널이 broken pipe다. 파이프가 깨졌다. 읽는놈이 없어졌다. 브로큰 파이프가 날아오니까 프로그램이 죽어버린다. 네트워크 프로그램이 저쪽이 죽었다고 해서 내가 서버인 내가 죽으면 되냐? 안된다. 그래서 sender에서 에러메시지가 리턴된다. -1이 리턴이 되면 다시 접속을 할려고 애를 쓰던지 또 조치를 취해야 한다. 그때 signal을 ignore해야 한다. 브로큰 파이프가 날라와서 시그널 핸들러로 가게 되면 대부분 죽는다. 그래서 시그널을 ignore 할때도 있다. 시그널중에는 sigkill이라는 시그널이 있다. 이것은 물론 define variable이다. 숫자가 있는것이다. sigkill이라는것은 너죽어라. 너죽어라 라는 시그널이다. sigstop은 뭐나면, 컨트롤+z를 누르면 프로그램이 약간 일시중지가 되기도 하고 디버거를 써보면 프로그램 돌리다가 break point 넣어서 중지 시킬 수 있다. 자기가 원하는 위치에 이때 중지된 상태다. 중지 시키는게 sigstop이다. 
여러분들이 shell로 들어가서 $ ./a.out , $ps 하면 뭐가 나오냐? 프로세스 state 내가 만든 프로세스들의 모든 프로세스의 상태를 알려달라는 ???커맨드이다. 프로세스 상태 그러면 내가 만약에 이전에 뭘 돌렸냐? ./a.out &으로 돌려놨다고 치자. 그러면 지금 돌고있는 프로세스가 뭐가 나올까? 프로세스가 뭐가 있냐? shell(이거 하나 돈다 프로세스로), 그다음에 a.out 나온다. 여기에는 상태(프로세스의 상태) - ready냐 block이냐 그 다음에 프로세스의 번호(id) 이 런정보들이 쭉나온다 하나더 나온다. ps -a를 하면 그것은 시스템에서 돌고있는것을 몽땅 다 보여달란 말이되고, ++그냥 ps는 내가 만든것만 보여줘 라는 뜻이다.++ 내가 만든 프로세스가 뭐가 있어? ps가 있다. ps도 프로그램이다. ps도 shell이 만든 프로세스니까 그것 자체도 프로세스다. 이 3가지가 나온다. 그런데 a.out 이 1234라고 하자. (id가) a.out이 백그라운드로 돌리고 있는데 그런데 a.out이 죽지도 않고 막 엉터리로 돈다고 가정을 하면 죽여야 한다. 이것을 죽일때 어떻게 하냐면 a.out이 포그라운드로 ctrl+c를 누르면된다. 그러면 죽어버린다. ctrl+c를 누르면 
그런데 background니까 kil -9 1234 한다. 1234는 프로세스의 번호다.(a.out의) 그렇다. 아까 kil은 모라고 했냐? 죽이라는 의미가 아니고 시그널을 보내란 의미이다. 그러면 여기에서 9의 의미는 9가 바로 sigkill이다. 즉, 죽어라라는 시그널이 9번이다 이말이다. 너 죽어라 라는 시그널을 보낸거이다. kill자체가 죽인게 아니다. 이것이다.
9번시그널을 1234프로세스 한테 보내주시오 해서 저 프로세스를 죽인것이다. 
근데 sigkill하고 sigstop은 ignore할 수가 없다. sigkill을 ignore 해버리면 그 프로세스는 절대로 죽일 수가 없다.  그렇다.

세번째가 이번 강좌에서 하고싶은 말이다. ++ 유저가, 시그널 핸들러를 만들수가 있다.++ 자기가 시그널이 들어오면 프로그램을 만들수가 있다. 
예를 들어서 여러분들이 fore ground 프로그램을 죽일때 ctrl+c를 누르면 프로그램이 죽는다. 그래서 control+c를 받았을때 커널이 그 프로세스를 죽인게 아니다. 그게 아니고 ctrl+c를 누르면 뭐가 발생하냐? 키보드에서 눌렀으니까 키보드 인터럽트도 발생할 것이다. 
그러면 어디로 가냐? 키보드 인터럽트 핸들러로 갈것이다. 키보드 인터럽트 핸들러에서 보니까 abc가 아니고 뭐가 들어왔다? control+c가 들어왔다. control+c가 어떤 프로세스에 의해서 돌아온것인지 알 수 있다. 그러면 control+c 가 발생했다는 signal이 sig_inerrupt, sig-int 그래서 control+c를 누가 눌려졌다 라는 시그널을 어떻게 한단 말이냐? 
해당 되는 프로세스한테 누가? 배달을 가나요? 커널이 배달을 해서 테이블에다가 sig-int 발생했어, control+c가 눌렀다 라는것을 표시를 해놓고 커널의 일을 끝낸다. 인터럽트 핸들러는 
그럼 나중에는 아까 얘기했듯이 그 프로세스가 언젠가는 살아날텐데 살아나는것은 어디 속에서 살아난다? 커널속에서 살아나니까 유저모드로 돌아오기 전에 ctrl+c가 발생했냐라는 알수있다. 그래서 어떻게 하냐면?스스로 signal handler로 가서 exit 하기 때문에 프로그램이 죽는것이다. ++control+c를 누르면 커널이 죽이는게아니라, 커널은 sig-int라는 시그널을 배달할 뿐이고 그것을 받은 프로세스가 스스로 자살하는 기술원리다.++  (ctrl=control+c)
그런데 만일에 우리가 게임프로그램을 짠다. 나는 컨트롤 c를 누르면 이건 프로그램이 죽는게 아니라, 미사일이 발사 된다고 치자. 컨트롤 씨가 들어왔을때 시그널핸들러를  미사일을 발사하는 프로그램으로 바꿔야 겠다. 자기가 자기 프로그램으로. 그런식으로 할 수 있다.

## Signals(1)
시그널은 메뉴얼 치면 다 나오는데, 시그널이 다 50~60개가 된다. 리눅스나 유닉스 버전에 따라서 조금씩 달라질 수있기때문에 define variable은 signal.h에 define되어 있다.(define variable - 정의변수??) 그래서, sigabrt는 뭐냐면 여러분이 프로그램 짜다가 뭐 잘못되면 자기 스스로 죽을때 abrt한다. abrt가 수행을 하면 이게 발생을 해서 프로그램이 중단이 되는데 요때는 디버깅 할 수 있게 코어 덤프하고 파일에다가 (디렉토리에다가) 그리고 나서 exit을 한다. 요쪽은 default handler다. 
그다음에 이번강의에서 제일 많이 설명해야 하는것이 sigalrm이다. 아침에 새벽에 일어나야 할때 시계맞춰놓고 alarm 울리게 하잔아! 알람(3)하면 무슨 뜻인고 하니, 지금부터 3초 있다가 시그널을 발생시켜주시오. 그럼 내가 시그널 핸들러를 만들면 거기가서 할 수 있는일을 할 수 있는것이다. 
내가 숙제를 내줬다고 쳐보자! 지금부터 3초있다가 무엇을 해 ! 라는 숙제를 내주면 그 3초가 지나간다는것을 어떻게 알수있냐? sleep가지고 되냐? 안된다. 3초동안에 다른일을 해야되. 그럴때하는게 알람이다. 알람 3 걸어놓고 다른일을 하다가 언제가 될지는 모른다. 그렇지만 3초가 경과한후에 알람이라는것이 날라와서 시그널 핸들러로 간다. 
리눅스에서 프로세스는 시계가 하나다. 그래서 알람을 3초를 세팅해놓고 조금잇다가 알람 2초를 세팅해두면 하나밖에는 유효하지 않다. 마지막에 한거
모든 프로그램에 프로세스는 딱 2가지 밖에 없다. 타임 트리거드(너 1초에 한번씩 돌아! 1초에 한번씩 센서가 ?? 컨트롤해 무인기 컨트롤해 이런것은 타임트리거드 일초에 한번씩 혹은 50번씩 돌아야해 헬기날릴려면 그다음에 또하나는 이벤트 트리거드다. 언제 발생할지 모르는 이벤트가 날라왔을때 거기에 반응하는 소프트웨어 혹은 flag 이 두가지 밖에 없다.)
시그널은 이벤트 트리거드다. 이벤트가 언제 날라올지 모르니까! 프로그램 입장에서 언제 일어날지 모르기 때문에 비동기적인 이벤트라고 한다.
초록색으로 나온게 중요한거고, sigchild : child 프로세스는 exit하는데 exit하면 parent는 wait하고 기다리고 있을텐데 그때 날라가는 시그널이 데쓰 오브 차일드 이다. 시그차일드, 근데 그것은 그냥 ignore한다. 왜냐면 죽는다는것을 알기때문에 
sigcont라는것은 디버거 같은데서 일시중지 시킨다고 했는데, 그랬다가 다시 속기할때 sigcont가 날라간다. restart한다. 
sighangup(sighup)은 네트워크라든가 옛날에는 터미널을 썻는데 로그인하잔아 밖같아서 이게 connection이 끊어진것이다. 그러면 뭘 할수가 없냐? getchar()라든가, printf 할수가 없다. 끊어졌으니까! 그때 날라오는게 sighup이다. 
sigill이라는것은 우선, 프로그램은 텍스트하고 데이터하고 스텍하고 힙이 있는데 프로그램이 돌아가는 자리는 text에 있는 명령어만 돌아간다. 프로그램이 이상하게 돌아가서 거기서 점프 잘못해서 어디로 점플르 했냐? 데이터로 점프를했다. cpu는 거기 instruction이 있구나 하고 데이터 섹션에서 데이터를 cpu안으로 가지고 와서 디코딩을 한다. 디코딩을 하는데 그런 instruction이 있는가 없는가 없으니까 나못하겠다. 
sigint - 컨트롤 씨를 누르면 커널이 프로세스를 죽이는게 아니라, sig-int 라는 시그널이 배달이 되서 스스로 시그널 핸들러 속에서 자살한다. 
sigkill - 너죽어라 하는것이다.
sigpipie - 브로큰 파이프, 파이프 에다 썼는데 저쪽에 읽는 놈이 전부다 close 하거나 끊어졌버렸다. 이것은 파이프, 네트워크에 적용이 된다. 네트워크 파이프를 소켓이라고 한다. 소켓은 버클리 대학교 학부 학생이 만든것이다.

sigsegv-프로그램짜다가 특히, 포인터 잘못썻을때 포인트 잘못쓰면 이상한데 access하는데 포인터에 값이 0가 들어갔다 던가 그것은 이상한 메모리를 건드리기 때문에 
sigstop-디버거 같은데서 프로그램을 일시 중지시킬때 발생하는 시그널이다.
default handler 는 프로세스가 만들면 그 루틴들이 따로 붙어있다. default로 가는데가 있다고 다! 유저레벨이다. 시그널 테이블에 (pcb속에) 시그널이 뭐가 발생했다는것이 있는데 거기서 이제 어느 핸들러로 가야하는지 그 addr가 있는데 그 default라고 따라붙게 된다.

컨트롤 c라는가 이런게 발생하면 커널이 안다. 커널이 아는데 프로세스끼리 시그널을 보낼 수도 있다고 했다. 그때이제 약속하고 쓰기 위해서 여유분을 만들어놨는데 그게 sigusr1하고 sigusr2다. 이것은 의미가 없다. 그냥 걔네하고 나하고 약속해서 내가 sigusr1 보낼게 그럼 너 그거 받아서 처리해줘 이거 급한 신호야 이렇게 정의를 하는것이다.

## Signal(2) function
여기에 signal이란함수, 시스템콜이 나온다.
signal이 보낼달라는 의미가 아니고, 시그널 핸들러를 자기가 만든것을 등록하는것이다. 그래서, 
```java
#include<signal.h>
typedef void(*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler); //리턴 타입이 sighandler_t 인데 함수의 펑션포인터다. 함수의 주소인데 여기에 리턴되는것은 내가 여기서 새로운 시그널 핸들러를 만들어서 넣으면 펑션 이름을 주면 그럼 이거말고 옛날에 만들었었던 시그널 핸들러가 있을텐데 그 옛날 시그널 핸들러의 주소를 주게 된다.
그것을 왜주냐? 나중에 원상복구하고 싶으면 해라 이것이다. 올드 시그널핸들러의주소가 리턴이 되고 sighandler_t라는게 펑션의 주소를 말하는건데 실제쓸때 여기다 펑션이름을 쓰면 된다. 펑션이름이 주소니까 새로운 내가 만든 시그널 핸들러의 이름이 들어가고 
요기에는 뭐가 들어가냐면, 시그널 번호가 들어간다. 번호를 못외우니까 sig-int 라는것처럼 define variable이 있다고 했잖아. sigsegv 이런것을 주면 새로운 시그널의 핸들러가 등록이 되는것이다. 

그리고 이 펑션은 자기가 만들어야 한다여기 이거 r은 t에서 type define void에 요렇게 괄호하고 포인트 sig // typedef void(*sighandler_t)(int)라는것은 sighandler_t가 포인트라는 뜻인데 그게 무엇의 포인터냐면 함수의 포인터라는 뜻이다. 포인터는 캐릭터 포인터도 있고, 인테져 포인터도 있고 소프트?? 포인터도 있고 그런데 포인터중에 한 가지 스타일이다. 함수를 포인터 하는 포인터라는 의미이다. 이렇게 쓴다. 
```

## Using a Signal Handler(1)
```java
#include<signal.h> //해야된다 꼭!
#include<stdio.h>
#include<stdlib.h>
static void sigcatcher(int); //static 은 함수앞에 static 붙이면 이건 요파일 안에서만 쓰겠다. 
void (*was)(int); //was는 함수의 포인터다 이런말이다. 

int main(void)
{//시그널 핸들러를 바꾸겠다. SIGINT, 컨트롤 C를 누르면 원래 default handler로 가야하는데 이제는 내가 만든 sigcatcher로 가라 이런뜻이다. 그리고 옛날에 default handler의 주소를 어떻게 하냐 was에다 save 해둔다 저건 뭐 ??? 하지 않아도 된다. 사실은 상관이 없다.
	if(was=signal(SIGINT,sigcatcher)==SIG_ERR){
    	perror("SIGINT");
        exit(1);
    }
    while(1) pause(); //그리고 loop을 돌아도 된다. 뭐 들어올때까지? 컨트롤+c 칠때까지 처리 하는것을 볼려고 하는게 아니냐! 그런데 이제 loop을 돌면 cpu를 낭비하니까 여기다 pause()를 집어넣는데 pause()는 시스템콜은 시그널이 들어올때까지 블락되어있겠다. 라는 뜻이다. any signal이다. 아무 시그널이 라도 들어오면 깨어나겠다. 물론 시그널이 들어오면 pause()해서 깨어나지만 어디로 갔다 와서 깨어나느냐? signal handler로 갔다와서 깨어난다. 당연히. 그래서 이제 여기에 static void sigcatcher라는 펑션을 만들었다. 여기에는 항상 signal number가 들어온다. signal handler로 들어올때는 발생한 시그널의 번호가 들어오는데 지금 여기서는 컨트롤+c 밖에 들어올것이 없다. 그런데 여기는 그냥 노파심에서 swtich를 썼다.
}
static void sigcatcher(int signo)
{
	switch(signo){// 
    	case SIGINT : //컨트롤 c를 눌렀으면 제대로 들어온것이다. 그럼 프린트해서 원래는 죽어야하는데 getpid()해서 프로세스의 번호를 찍어다 준다. 그래서 sigint를 받았다. 캐치했다 라고 이제 프린트를 하고 signal 
        		print("PID %d caught signal SIGINT .\n", getpid());
         	signal(SIGINT, was); //signal(SIGINT, was)를 한다. 이것은 옛날시그널 핸들러로 다시 돌려놓는것이다. was가 옛날 꺼였으니까 
            break; //그리고 나간다.
        default: // 이건 뭔가 잘못된것이다.
        	fprintf(stderr, "something wrong\n");
            exit(1);
            //그래서 exit한다.
    }
}
$./a.out //그래서 이 프로그램을 돌리면
^CPID 22986 caught signal SIGINT. //main 프로그램이 pause()하면서 loop을 돌텐데 그래서 그때 a.out을 돌려놓고 컨트롤 +c 를 누르면 일로 들어갈테니까 signal handler로 갔다와서 이것을 찍고 또 어디로 가냐 또 puase()로 또 갈꺼 아니냐 loop이니까	시그널 핸들러로 갔다와서 pause()에서 깨어나서 시그널 핸들러로 갔다와서 while loop으로 돌아가니까 또 loop을 도니까 또 pause()로 들어갈것 아니냐 그런데 시그널이 한번들어왔을때 시그널 핸들러를 원상복구 해놨다. 그러니까 ++ 두번째 컨트롤 c를 치면 이제 default handler로 돌아가니까 프로그램이 죽어버린다++ 그래서 여기보면 두번째 컨트롤 +c를 누르면 프로그램이 죽었다. 그런말이다. 
^C$ //프로그램이 죽는다.
```
그러면, 여기서 signal을 이렇게 해서 sigcatcher로 해놓는것이 이것을 한번하면 컨트롤 c를 가져다 여러번 눌러도 계속 sigcatch로 가느냐 그 signalhandler가 일회용이냐 아니면 여러번 계속해서 쓸수있는 거냐 라는 의문이 생긴다. 그것은 버전마다 다르다.

일회용인지 먼지 버전마다 자꾸 바뀌기 때문에 제일 안전하게 하려고 하면 그것을 또쓰고싶으면 시그널핸들러속에다 또 뭘하면되냐 또 sigcatcher를 집어넣으면된다. 항상 들어올때마다 계속 재설정하는것이다. 그렇게 하는것이 보통이다.

## kill() : sending a signal to a process
kill이라는 시스템콜이라는것이 있는데, kill은 shell도 있다고 했다.(??) 시그널을 어떤 프로세스에게 보낼때 사용하는것이다. 시스템콜이지, 죽이는게 아니다. kill하면 시그널을 보내는데 이건 수신 프로세스의 아이디이고 (pid_t pid), 이건 시그널 번호를 보낸다(int sig). 그런데 수신 프로세스의 아이디는 이게 1,2,3 처럼 항상 0보다 커야된다. 
프로세스 아이디가 근데 0을 주면 이건 근데 내가 만든 모든 프로세스한테 시그널을 왕창 다 보내라 뜻이 된다.
-1일때는 ????? 시스템 전체에 보내는건데 이런것은 리부팅할때만 사용된다.

```java
## kill() usage
#include<stdio.h>
#include<signal.h>
#include<unistd.h>
#include<stdlib.h>

int main(){
	int pid;
    if((pid= fork())==0){ //fork를 하고 
    	while(1); //while(1) 이니까 child procss 가 infinite loop을 도는것이고 
    }else{ //parent 프로세스가
    	kill(pid, SIGKILL); //pid가 child process의 id이다. 이게 받은 child process한테 SIGKILL을 보내서 child를 죽이는것이다. 그리고 나서
        printf("send a signal to the child\n");
        wait(); //wait를 하는것이다. 이렇게 하면 child가 죽을것이다. sigkill을 보냈으니까 죽을것이다. default handler로 들어오니까!
        printf("death of child\n");
    }
}

```

## raise()
raise()는 자기가 자기한테 signal을 보내는것이다.
```java
#include<signal.h>

int raise(int sig); //자기가 테스트할때 써볼 수 있다. 자기가 signal 을 자기자신한테 보낼때 
예를 들어서 자기가 프로그램짜고 자기가 raise sig usage 원하면 이제 ?? 들어와서 새로 
```

## raise()
예를 들어서 자기가 프로그램 짜고 자기가 ???
```java
#include<signal.h>

int main(){
	printf("Self Process signal : \n");
    raise(SIGUSR1); //usr1이 들어와서 self process signal 이라는 메시지가 나오고선 죽어버린다, signal을 만드는 default가 다 죽는거니까 
}
```
//이건 버리자.
## alarm()
#include<unistd.h>
많이쓰는게 alarm이다. 여기서 초를 주게 되어있는데 아까 말했듯이 alarm(3)하면 3초 뒤에 나에게 sigalarm을 보내달라는 말이된다. 그러면 3초가 경과했다는것을 알수가있다. 나중에도 나오겠지만 네트워크 통신을 하는것은 tcp를 하던지 udp를 하던지 이런게 되겠지만 내가 만일에 저쪽 끝에 있는 미국에 있는 컴퓨터하고 통신을 한다고 가정을 하면 미국까지 단번에 가는게 아니다. 중간중간에 컴퓨터, 라우터를 여러개 거쳐가지고 내 패킷이 가는것이다. 그러면 가는동안에 라우터가 10개가 있다고 하면, 라우터는 배달해주는것이다. 경로지정해서 
그 라우터는 다른게 아니고, 컴퓨터도 라우터의 역할을 할 수가 있다. 별개아니다. 그런데 저쪽에서 10단계를 거쳐서 가야된다고 하면 치면, 그러면 메시지가 패킷이 한꺼번에 가는게 아니라 일단 자기 근처로 오던 애한테 보내고 이놈이 중개해서 보내고 보내고를 한다. 그런데 메시지가 파일같은것은 클때 왕창보내지않고 네트워크에서는 다 패킷단위로 잘게 쪼개 보내서 (패킷이 1.5kbyte 정도되는데) 그 이유는 나중에 설명, 좌우지간 쪼개서 보내는데 그러면 네트워크 프로토콜이라는것은 통상 에러가 항상 발생할 수 있다. 	 번개가 친다든가 접선이 끊어진다는가 통신절차가 어긋난다든가 대비해서 돌아가야하는게 네트워크이다. 
에러가 많이 발생하는 채널을 통해서도 굳건히 통신을 해야하는게 tcp이다.
그런것을 하기위해서는 저쪽에 미국의 컴퓨터까지 보낼때 일단 옆에 있는 컴퓨터에게 보낸다. 옆에 있는 컴퓨터가 잘 받았다 라는것을 확인해야 다음것을 보낼 수 있다. 잘받았다라는것은 어떻게 아냐? 잘받았다는것은 잘받았다라고 대답을 해줘야 한다. 그것을 acknowledge라고 한다. 반드시 내가 옆에 노드한테 보내면 ack를 보내야지 그게 잘받았다 라고 그다음 스텝으로 넘어가게 되는것이다. 이 컴퓨터가 받은 것은 옆의 컴퓨터에게 뭘 보내냐? 	 패킷을 보내고 또 ack를 받고 계속 전달이 되는데 
라우터라고 하는 이유는 라우팅이라는것은 경로배정을 한다는 것이다. 근데 이 컴퓨터가 미국의 컴퓨터까지 가기 위해서는 나한테 붙은 컴퓨터가 여러개 있을 수 있다. 그중에서 누구한테 보내야지 제일 가깝다. 그리고 빨리 보낼 수 있는지를 결정해야 하기 때문에 경로를 배정한다. 그게 ip이다. tcp/ip할때 ip가 하는일이 그것이다. 내가 이 패킷을 받았다. 쟤한테서 받아서 미국에 있는 데 까지 보내는데 미국에 있는데 까지 도착할려면 얘한테 보내는것이 나은지 얘한테 보내는것이 나은지 결정하는게 ip이다. 그런데 가다가 잘못되는 경우는 가다가 없어져 버리는 경우이다. 그렇다. 가다가 없어져버리는 경우는 ack가 오냐? ack가 안온다. 그러니까 ack가 올때까지 내가 보낸 패킷을 keep하고 있어야 한다. 왜냐하면 ack가 안오면 재전송 해야 하기 때문이다. 	 	가다가 메시지가 없어지는 패킷이 없어질수도있고 또는 ack를 보내는데 ack가 없어질 수도 있다. 잘받았는데 그래서 나는 ack를 못받았으니까 메시지를 또 보내야 한다. 그러니까 이 사람을 똑같은 메시지를 또 받는것이다. 그럼 중복 체크를 할 수 있어야 하니까 패킷에는 번호가 있어야 한다. 그것이 슬라이딩 윈도우 프로토콜이라고 하는데 그렇게 해서 중복체크도 하고 모든 경우에 대해서 다 카바를 해야하는게 네트워크 프로토콜이다. 굉장히 복잡하다. 네트워크는 엄청 복잡해서 한층으로 되어 있지 않고 7층으로 되어있다.

그런데 내가 메시지로 패킷을 보냈다. 그러면 ack를 받아야 하는데 ack를 이틀동안 기다리냐? 삼일 동안 기다리냐? 아니다. 시간을 정해놓고 기다려야 한다. 그래서 3초동안에 ack가 안오면 어떻게 한다. 이것은 못받은것으로 하고 다시 재전송을 한다 이런 로직이 들어간다. 그래서 3초동안 기다린다라는것은 어떻게 해야 한다 바로 ++이런 알람(3)을 쓴다.++ 사발 시계를 프로그램에다 걸어둔다. 
3초가 지났는데도 아직 시그널 핸들러, 시그얼람으로 갈것이다. 가서 보니까 ??? 아직 안왔구나 그럼 재전송한다. 

그래서 얼람은 굉장히 많이 쓰인다. 근데 이제 알람을 듀플리케이티드에서 쓰거나 하면 아까도 말했다 싶이, 시계는 하나밖에 없기때문에 프로세스 하나당 이게 중복해서 쓰면 안된다. 그리고 또 조심해야 할것은 sleep에서 깨어날때도 뭐가 오냐? 시그얼람이 들어온다 똑같이 시간의 개념이기 때문에 
++sleep하고 얼람을 같이써도 안된다.++ 왜 sigalarm이 들어오기 떄문에


## alarm() usage

```java 
파일1 하고 파일2가 있는데 컴파일을 다르게 한다는 의미이다.
일부러 그렇게 해놨다. 
File#1
#include<stdio.h>
#include<signal.h>
#include<unistd.h>
#include<stdlib.h>
static void sig_catcher(int);
volatile //이게 뭐냐! 이거는 얼람하고 상관이 없다. 그냥 나온김에 설명할려고 한다. volatile이 없어도 돌아가는데 이것은 파일을 가져다 따로 컴파일 하는 프로그램인데 나눠놨기 때문에 파일1을 컴파일 할때 만일에 그냥 컴파일 하면 아무상관이 없는데 컴파일러가 무지무지하게 똑똑한 컴파일러가 있는데 그게뭐야 ! optimizing compile다. 이것은 프로그램을 왠만큼 잘못짜도 다 고쳐준다. 쓸대없는것들 집어넣다라든가 다 빼버린다. gcc 하잔아! 또는 g++ 할때 -O 옵션을 주면 optimizing compile 이라고 한다. 무지하게 똑똑하다. 컴파일러가 어떻게 생각하냐면 얼람드 variable이라고 0이라고 만들어놨네 variable은 default 로 메모리로 들어간다.(global variable이니까 data area에 들어간다. 메모리에 들어가야하는데 프로그램을 optimizing compile가 분석을 한다. 분석을 하고 프로그램을 보니까 while(alarmed==0) ++테스트하는데 얼람드를 변화시키는게 프로그램에 없다. 얼람을 변화시키는것은 다른 파일에서 하니까 컴파일을 자기가 아직까지 안하는거 컴파일러는 뭐라고 생각하냐면 얘가 상수를 쓸것을 변수로 만들었네 라고 생각한다. 상수가 빠르냐 변수가 빠르냐 변수가 메모리에서 가지고 와야하니까 느리다. 프로그램을 상수로 바꾸면 더 빨라진다. 그래서 이것을 그냥 상수로 바꿔버린다. 그러니까 나중에 이거랑 돌리면 제대로 안돌아간다. 바뀌지가 않는다. 여기서 이렇게 해도 그래서 volatile은 무슨 뜻이냐면 옵티마이징 컴파일러에게 알려주는것이다. 이것은 다른 프로그램에서 건드리기 때문에, 다른 파일속에서 거든리기 떄문에 니가 이것을 상수로 바꾸지 말아라 반드시 변수로 해라 이런 뜻이다.++)
+ 그래서 여러분들이 소프트웨어를 개발할때 개발을 하는 단계에서는 옵티마이징 컴파일러는 보통 안쓴다. 디버깅이 끝나면 마지막에 넘길때는 옵티마이징 컴파일러를 돌리기는 한다. 이전에 쓰면 문제가 생길수가 있다. 그래서 volatile은 옵티마이징 컴파일러에게 야 이거 옵티마이즈 하지마! 상수아니야 이거 변수야 이런것을 알려준다.
int main(){
	메인프로그램이 있고 시그얼람이 들어오면 어디로 가냐, 시그캐처로 가! 
    시그널 핸들러를 디파인했다. 그러고 얼람3을 걸었다 3초있다가 나한테 시그널을 보내줘 라고, 하고 do sth 뭔가 다른일을 한다. 그러고 다른일을 다 할것을 하고나서 더이상 할게 없으면 얼람이 0이면 얼람이 발생한거냐 안한거냐, 얼람0
	int pid;
    signal(SIGALRM, sig_catcher);
    alarm(3)//3초가 여기서 지나갈수도있고, while loop에서 걸릴 수 있다. 이것은 뭐 상관이 없다. 
    do something;
    while(alarmed==0); //얼람이 0 라고 초기화한것은, 그래서 시그널 핸들러로 가면 어떻게한것이냐 얼람 발생했다고 일로 바꾸는것이다. 지금 프로그램이 그래서 얼람이 아직 발생하지 않았기때문에(3초 있다가 바뀌는것인가?) 뭘 하냐 더할일이 없어서 while loop을 돌고있는 중이다. 물론이렇게 하지 않고 다른일을 해도된다. 그러나 이렇게 해놨다. 여기서 돌고있는데 3초가 지나가지고 시그얼람이 발생하면 컨트롤이 짤려가지고 어디로 가냐? 인터럽트 핸들러처럼 시그캐처로 가게된다. 가서 여기서 얼람을 1로 만들었다.
     
얼람을 0로 한단 얘기는 얼람을 끄란 얘기다. 시계를 끄고 나서 돌아오면 while loop으로 다시 그자리 돌아오겠다. while loop으로 돌아와서 얼람이 뭐가 되어있냐? 1이 되어있으니까 빠져나와서    
    printf("after alarm in main\n");
}
```

```java
File#2
void sig_catcher(i){
	alarmed=1; //1로 만들고
    alarm(0);  //얼람을 0로 한단 얘기는 얼람을 끄란 얘기다. 시계를 끄고 나서 돌아오면 while loop으로 다시 그자리 돌아오겠다. while loop으로 돌아와서 얼람이 뭐가 되어있냐? 1이 되어있으니까 빠져나와서 얼람이 발생했다 라는것을 찍고 다른일을 한다. 
}
```

그런데 얼람드 를, 

## abort() usage
이것은 프로그램 짤때 abort를 많이쓴다. 내 문장에 a=b/c가 있는데 나누기 하기전에 이 c가 0면 이것은 뭔가 잘못됫다. 그러면 프로그램이 끝난다.
끝날때 프로그램을 코어 덤프를 해주기 때문에 그것을 디버거로 돌려볼 수 있다.

## pause()
이것은 a signal이 들어올때까지 뭐가 된다. block이 된다. 그다음에 시그널이 들어오면 pause()를 하다가 block되어있다가 signal이 들어오면 깨어나서 어디로 가냐? 시그널 핸들러로 갔다 와서 가서 죽던지 아니면 돌아오는거면 살아나든지(낮은 확률로 살아날수도있다.) 
그러나 이게 살아서 계속 돌아갈려면, 우리가 만든 signalhandler가 필요하다. 죽지않는 signalhandler가 필요하다.

sigusr1 했습니다. usr1은 아무런 의미가 없다. 그냥 내가 정해서 쓰는것이다. usr1이 들어오면 어디로 가냐? sigcatcher로 가 
## pause() usage

```java
#include<stdio.h>
#inlcude<signal.h>
#include<unistd.h>
void sig_catch(int sig_no){}
int main(){
	int pid;
    signal(SIGUSR1, sig_catch); //sig_catch는 뭐냐! 안나와있다.sig_catch가 있다고 치자, 아무것도 안하고 return 하는 시그널 핸들러가 하나 있다고 가정하고 sig_catch는 생략이 되었다. child process는 뭘했냐? pause()를 했다.
    if((pid=fork())==0){
    	pause(); //여기군, 시그널이 들어올때까지 기다려라! 뜻이다. any signal이라고 했다. 
        printf("Child wake up\n");
        exit();
    }else{//parenrt process는 뭘하냐면 sleep(1)을 해도좋고 안해도 되고 
    	sleep(1);
        kill(pid, SIGUSR1);//kill pid는 누구의 pid냐면 child pid고 child한테 뭘 보내라 SIGUSR1을 보내라! 이런뜻이다. 그러면 child는 뭘하고 있었냐? pause()하고 있었다. 그러다가 SIGUSR1이 들어오니까 어디로 sig_catch로 갔다와서 다시 돌아와가지고 child가 꺠어났습니다 하고 exit()을 하게 된다.
그런 프로그램이다.
        wait(); //얘는 시그널을 안보내고 wait하고 있고 
    }
}
```
그런데, 이것을 할때 문제가 있다. pthread_cond_signal도 마찬가지인데 pthread_cond_signal은 쌓인다? 안쌓인다? => 안쌓인다. 이것도 마찬가지다. sleep(1)이 있는데 없다고 가정을 하면 kill을 해서 시그널을 보낼 당시에 child process가 pause()하기 이전 상태일수도 있다. 그렇잔아요. child가 시작이 되서 아직 pause()를 아직 시작하지 않았다. 누가 먼저 돌아갈지 모르니까 만일에 parent가 먼저돌아가지고 이게 signal을 먼저 ,..?? 뭘하기전에 child가 pause()하기전에 
pause()하기전에 시그널이 들어왔으니까 여기서 pause()에 들어가기전에 어디로 들어가냐? ++ 시그널 핸들러로 갔다와서 pause()로 들어갈것 아니냐! 그러면 시그널이 없어질것이다. 처리를 했으니까 그러니까 여기서 pause를 해서 깨어날 수 있냐? 없냐? 꺠어날수 없다. 이미 처리가 되었기 때문에 그런데 대부분은 깨어나게 되면 , 대부분은 pause()를 한다음에 signal이 전달이 될것이지만, 이게 sleep(1)이 없으면 어떻게 되냐? signal이 pause()하기 이전에 먼저 들어가면 이것은 프로그램이 죽어버린다. 죽는것보단 계속 block 되어 있는다. 얘는 signal을 안보내고 wait하고 있고 얘는 pause()해서 기다리고 있으니까 두개가 다 block이 되어버리는꼴이다. 	 
아무것도 안돌아가는 상태가 되어버린다. 그래서 signal을 보낼때에는 pause()를 할때 이놈이 pause()를 하고 있는지 없는지 	 알아서 보내야 한다. 확실하게 
그런 문제를 해결해야 하는 동기화 문제가 존재한다. 그것을 어떻게 해결하느냐! 라는거다.
++

그래서 결론부터 얘기를 하면 child를 만들기전에 아까 내가 잠 깐 무슨얘기했냐면 signal blocking 이라는 말을 했다. signal blocking이 뭐냐면 signal이 들어와도 해제 하기 전까지는 signal handler로 가지 않는다. 시그널 처리를 하지 않는다 라는 얘기다. 그러니까 pause()하기 전에는 뭘 해버리는것이냐? 시그널을 blocking 시켜버린다. 가도 처리하지 않게(시그널 핸들러로 처리하지 않게끔)
그리고 나서 어떻게 하는 거냐? pause()를 하면 깨어나냐? 안깨어난다. 시그널이 배달되지 않았으니까 ! block을 해버렸으니까 ! 그러니까 pause()하기 직전에 무엇을 해야 하느냐? signal을 풀어줘야 한다. 다시 unblock을 해줘야 한다. 그런데 그렇게 도 안된다. 왜안되냐면, 예를들어서 이런게 있다고 하는것이다. 
fork()를 하기전에 여기서 sigblock이라는게 잇다고 치자. (필기상으로는 sig_catch대신 sig_block이라고 썻네 ) 여기에서 usr1을 가져다 blocking을 시켜버렸다. signal이 들어가도 반응하지 않도록 그리고 fork()를 해서 이제 이게 

```java
signal(SIGUSR1, sig_catch);
if((pid=fork()==0){ //fork를 해서 이제 이게 child란 의미인데, child면 여기서 뭘 해야하느냐? pause()를 해야한다. pause()라는건 signal이 들어오면 깨어날려고 하는데 block을 시켰으니까 signal이 안들어온다. 여기다가 pause()를 하기전에 sig_unblock이라는게 잇다고 하면 시그널을 가져다 풀어버려야 한다. unblocking은 그래야지 시그널이 배달이 될것이 아니냐! 그렇다. 이렇게 하고 parent에서는
	pause();
    printf("Child wake up");
    exit();
}else{ //parent에서는 여기서 kill을 해서 pid에다가 (child 의 프로세스 넘버죠!) 뭘 보내냐면 SIGUSR1을 보낸다. 이거 지금 돌아가냐? 돌아갈때도 잇고 안돌아갈때도 잇다. 왜냐면 SIG_unblock을 시키면 시그널을 unblock시킨 시점에서 시그널이 만일에 들어와있었다고 치면 어디로 가냐, pause()하기전에 시그널핸들러로 가서 또 없어져 버릴것이다. 즉, 이사이(unblock된 시점에서)에서 또 시그널이 들어올수도 있다. pause()하기전에 그럼 이 프로그램은 또 안돼고..  이것을 없애도 안되고 그럼 어떻게 해아하나?  어떻게 해야하나 이 프로그램이 완벽하려면? signal을 block 시키는것은 맞다. 당분간 처리하지마라! 그리고 pause()를 하는 시점에서부터 시그널이 배달되게끔 해야한다. 그런데 저렇게 문장을 다른 문장으로 하면 요사이에(unblock된 시점에서) 들어와서 깨져버릴수있으니까 결론은 머냐, ++ sig_unblock 하는것과 pause()를 가져다 어떻게 하면되냐? 시스템콜로 합쳐버리면 된다. 합쳐서 시그널핸들링을 같이 해버리면??? 그러면된다. 그러기위해서는 동시에 해야 한다. 그얘기를 하려고 하는것이다.++
++signal blocking과 unblocking과 pause()의 관계  그래서 pause()와 unblocking을 같이해야 한다. 그래야지 저런 문제가 발생하지 않는다.++
그래서 프로그램을 이렇게 짜면 돌아갔다가 안돌아갔다가 이런다. 마찬가지로 그래서 여기 영어로 필기 되어있는것에는 좋지 않다 라고 써있다. 무슨 일이 발생하든 ??? signal이 있을떄 ??? pause()하기 전에 signal이 배달되면 영원한 pause()로 들어간다. (시그널 핸들링이 먼저 처리한다는 의미인거같음..)

	sleep(1);
    kill(pid, SIGUSR1);
    wait();
}
그래서 우리가 쓰는게 뭐냐면 sig_process_mask라는 시스템콜을 쓴다. 
```

## sigprocmask()
이것은 어떤 시그널을 블락시키거나 언블락을 시킬때 사용하는 시스템콜이다. 일단 블락을 시켜야 한다. 시그널 블락을, 블락을 시켜야 하는데 그떄 사용하는게 sigprocmask()이다. mask는 항상 뭐냐면, 이렇게 bit mask는 이렇게 있어가지고 이거는 sig-int 고 이것은 sigment 바이얼레이션 이고 이렇게 시그널이 쭉있으면 이게 1010이러면 이거 1로 되어있는것을 어떻게 하라라는것이냐? ++블락을 시켜라 이뜻이다++ 저런걸 mask라고 한다. bit mask 라고 한다.  (그림참고)
그래서, 여기보면 sigprocmask()에 how 라는것은 다음 페이지에 나오지만, 시그널을 블락시킬꺼나 어떻게 할꺼냐 언블락을 시킬꺼냐 아니면 해당되는 시그널을 하는게 아니라 요 mask 를 가져다 원래 있었던 mask가 있었을거 아니야 거기다가 이제 엎어 쓰기를 하겠느냐 라는것을 의미이다. sig set mask는 replace input signal set
input 
	-how : blocking or unblocking(see the next page)

## how Argument
SIG_SETMASK : Replace the input signal set with the old signal set mask in the signal set mask of the process(for blocking)
요것은 추가하거나 빼는것이다. 블락시키는 시그널이랑 언블락하는 시그널을 그러면
요 mask를 줘야 한다. 입력값으로 줘야 한다. 그것을 가져다 여기서는 set이다 라고 말하고 있다. 집합이다. 집합이다 라는 말이다.
그다음에 요골 하면 새로운 mask가 여기서 setting이 되고 여기에는 뭐가 리턴이 되냐면 옛날, original mask의 값이 return이 됩니다. 이것도 역시 나중에 원상복구할, 원상복구할려면 여기다 세이브를 해둬야 한다. 
그러면 인제 남은것은 뭐냐? 만일에 signal을 block시킨다하면 여기서 how ??? 를 어떻게 하면 되냐? how 를 sigblock으로 여기서 세팅을 하면 된다. 그다음에 뭘해야하나? 이 set에서 내가 원하는 블락킹을 시킬 수 있는 시그널에 해당되는 필드를 1로 set해야 한다. 이제 무슨 라이브러리 루틴들이 필요하냐면 이 집합을 갖다가 주무를수 있는 펑션들이 필요하다. 
그게 다음에 나오는것이다.

## Mask set handling : sigemptyset()
sigemptyset에 set, sigset은 요 mask에 있는것을 어떻게 하라는 의미냐 전부다 뭘로 깔라는 말이냐 mask를 전부다 0으로 clear 하라는 말이다.
초기화할떄 사용하는것이다. 


## Mask handling : sigfillset(), sigaddset() 
sigfillset이라는것은 요고 한칸을 채워라 이런말이다. 하나를 채우는게아니라, 전부다 뭘로 만들어라? 올 1으로 만들어라 
우리가 할껏은 sigemptyset()을 하고 sigaddset()한다. 그래서 원래 있었던 set에다가 내가 원하는 시그널을 거기다 1로 세팅을 하는것이다. 

## Mask handling: sigdelset(), sigismember()
delete는 거꾸로 뺴는것이다.
해당되는 시그널을 signal mask에서 빼는것이다. 
sigismember는 이 시그널이 이 집합속에 있느냐 없느냐 물어보는것이다.

## sigpending
몰라도된다.

## sigsuspend(), sigpasue()
자 여기 두개가 나와있는데 
둘다 똑같은건데 무슨 뜻이냐면, 아까 pause()를 하기전에 signal을 어떻게 해야 한다고 했냐 unblock을 해야하는데 이거를 두문장으로하면 중간에 짤리니까 문제가 생긴다라고 했다. 그래서 이것을 어떻게 한다고? 하나로 합쳐야 한다고 말했다. 이것을 하나로 합친것이다. signal을 가져다 어떻게 하면서 unblocking을 시키면서 pause()로 들어가라 이런말이다. 이걸동시에하는것이다.
//문제되는 코드
if(fork() == 0)
{
	sigunblock(sigusr1);
    pause();
}
그래서 siguspend 는 input이 set으로 주는거고 sigpause는 signal 번호로 주는것이다. 아무거나 써도 된다 argument만 달라서 그렇지 

권장 sigpause


## sigsuspend() usage

```java
#include<stdio.h>
#include<signal.h>
#include<unistd.h>
#include<stdlib.h>
void sig_catch(int sig_no)
{

}
int main(){
	int pid;
    sigset_t mysigset, oldsigset;
    sigemptyset(&mysigset);
    sigaddset(&mysigset, SIGUSR1); 
    signal(SIGUSR1, sig_catch);//sigusr1이 들어오면 어디로 가라, sigcatch로 가라 sigcatch에서 아무일 안해도 상관없다. 죽지만 않으면된다. 프로그램이 sigcatch라는 펑션을 만들어놨다 치고
    handler
    sigprocmask(SIG_BLOCK, &mysigset, &oldsigset); //mysigset, oldsigset을 하는데 이거 하기전에 sigset이라는 변수를 두개 만들었다. oldsigset = mask set하고 새로운 내가 만들 mysigset을 만들었고 내가 만들것을 어떻게 했냐? sigemptyset해서 다 clear해서 초기화를 했다. 초기화를 하고 그다음에 sigaddset, 이 sigset에 뭐를 더해라? SIGUSR1을 1로 표시를 해라 SIGUSR1 에 해당되는것을 1로 표시를 해라 그런다고 blocking이 되는가? 아직 blocking이 되는게 아니라 집합의 1로 세팅만했다 세팅하고 이것을 가지고 
sigprocmask(SIG_BLOCK,&mysigset=SIG_USR1이 1로set 되어있는데 해당되는 signal을 어떻게해라 이제 blocking 시켜라, &oldsigset);
시그널이 발생해도 처리하지 말아라. 어디로 가지말아라? sig_catch로 가지말고 그냥 hold해 놔라 이말이다. inerrupt disable하는것처럼 그리고 옛날 signal set은 oldsigset에다 임시로 받아놓는다. 그래서 이것은 무얼 하는데 쓰는거냐면 sigusr1을 어떻게 해버린거다? signal을 당분간 blocking을 시켰다. 마치 뭐하듯이? 인터럽트 디스에이블 하듯이 시그널을 블락킹시킨다.

if((pid=fork())==0){  // 포크를 했는데 옛날에는 pause를 했었는데 pause를 하면 안되서 주석, 왜안되냐면 blocking을 시켰으니까 그래서 다시할려면 unblocking을 시키면서 pause()로 들어가야 하잔아 그게 이것이다. sigpause(SIGUSR1) 무슨뜻이냐? signal usr1을 unblock 시킨데다 받아들이면서 뭐를 동시에 해라 pause()를 동시에 해라 그러니까 signal이 먼저들어왔으면 여기서 즉각 깨어날것이고 signal이 이후에 들어오면 아무문제가 없다. pause()한다음에 unblocking을 시키고 들어갔으니까 
그러니까, signal이 이 전시점에 배달이되든 이후에 배달이 되든 상관이 없는 프로글매이 된다. 이것은 항상 돌아간다. sigpause를 쓰기 싫으면 sigsuspend에 oldsigset 주면 이것은 옛날로 원상복귀하는것이다. ++원상복귀를 하면서 unblock된 pause, unblokcing을 시키고 sigUsr1을 unblock, 옛날로 돌아간거니까 unblocking시키고 pause를 한꺼번에 해라 이말이다.++ 그래야 프로그램이 건전한 프로그램이 된다. 그러면 이제 이런 sleep(1) 같은것은 하지 않아도된다. signal을 아무떼나 보내도 상관이 없다.
	//pause();
    sigsuspend(&oldsigset);
   // sigpause(SIGUSR1);
    printf("Child wake up\n");
    exit(0);
    }else{
    	sleep(1);
        kill(pid, SIGUSR1);
        wait();
    }
}

```
//프로그램을 돌려보란 말이다. 외울수가 없으니까 
## sleep()
몇초있다가 깨어달라는 얘긴데 이것도 역시 얼람이 발생을 한다. 똑같이 그러니까 아까 얘기했듯이 얼람하고 sleep을 같이 중복해서 쓸수가 없다. 
cf.
nanosleep(nano-sec) nano는 10의 -9승, nanosecond 단위로 10의 -9승으로 
usleep(micro-sec) 10의 -6승 단위로 주는 마이크로승도 있다.

그러나 nano sleep이나 usleep을 하면 정확하냐? 정확할 수가 없다. 왜냐하면 clock interrupt가 몇초단위로 들어오니까? 1/1000초 단위로 들어오니까 사실 그거밖에 count를 못한다. 

쭉쭉 넘어가서...
## System call and a signal
시그널하고 시스템콜의 관계다. 규명을 해보자!
내가 지금 read() 시스템콜을 설명하라고 그러면, 1. 페이지 캐시를 찾아본다. 2. 없으면 디스크 I/O를 한다. 3.I/O request block을 만들고 4.나를 block 표시를 하고 5.sleep queue로 빼고 6.스케쥴링 큐에서 priority가 제일 높은애를 뽑는다. 뽑아서 context_switch를 한다. 디스크 완료 인터럽트에서는 디스크 I/O가 하나 끝났으니까 그 프로세스가 block 되어 있으면 ready로 깨워줘야 한다. 그게 중요한일이고 그다음에는 다음 I/O할것이 queue에 밀려있으니까 그것을 인식하는게 두가지 중요하다고 말했다. 

자그래서 이건 무슨말이냐면 프로세스가 만일에 디스크I/O를 했어 read() 시스템콜을 했다. 그래서 디스크 I/O가 수행되는 도중에 무슨 상태가 되냐 block() 상태가 된다. 내가 block() 상태에 있어 그런데 block()상태라는것은 내가 디스크 I/O가 끝났다 라는 이벤트를 기다리는것이다. 그래서 block이 되어있다. cpu를 내놓고 cpu가 다른데 가있는 상황이다. 그렇다. 그런데 그때에 뭐가 발생한것이냐? 그때 signal이 발생한것이다 .++나한테, 디스크 I/O를 하고 있는 도중에서 내가 중지가 되어있는 시점에 시그널이 날라왔다 라는 말이다. 그런데 이 시그널은 아까도 얘기했듯이 대부분다 급한것이다. 지금보면 그러면 시그널을 먼저 시스템콜을 잠시 중단하고 시그널을 먼저 처리할려고 하면 ready에서 running이 되어야할것이다. 그래야 유저모드에서 시그널핸들러가 돌아가야 하니까 block 되어있던 놈을 어떻게 해야하나, 깨워야 한다. 원래는 기다리는게 디스크I/O가 끝나야지 깨우는건데 siganl이 들어오면 깨워야지 signal처리를 할 수 있으니까 그러니까 block 되어있는 상태에서 signal이 들어왔을때 이것을 깨울까 말까 고민하기 시작한것이다. 커널이 그래서, 디스크 I/O 같은것을 하면서 기다리면서 block 되어있을때 시그널이 발생했다라고 가만이 생각해보니까 디스크 i/o는 시간은 좀 걸리지만 금방 끝나죠 좌우지간, 디스크 I/O 경우에는 어떻게 하기로 했다? 안깨우기로 했다. ++
즉, 시그널 처리를 언제한다? 시스템콜이 다 끝난다음에 디스크 i/o가 끝난다음에 하겠다. 이런얘기다. 그런것은 디스크I/O 끝난다 라는것이 보장되어 있으니까 그런데 이런거 보자. 
C프로그램에서 getchar를 했다. getchar를 했으면 키보드에서 칠때까지 block 되어있는거다. 캐릭터를 안쳤으니까 키보드에서 enter 키까지 쳐야 들어가니까 
그런데 getchar를 하고 있는데(겟 캐릭터를 하고 있는데) 그래서 block되어 있는데 signal이 발생했는데 도대체 키보드에서 언제 칠지 알수가 있냐? 모른다. 그건 확실하지 않다. 그래서 그런것은 어떻게 해야하나? 그건 시스템콜을 포기해야 한다. 포기하고, 먼저 뭐부터 처리해야 하나 시그널을 먼저 처리하고 그다음에 두가지 옵션이 생기는것이다. 무슨 옵션이냐 겟캐릭터를 포기하고 -1로 에러 리턴하던지 아니면 자동빵으로 뭘하던지 겟캐릭터를 다시 콜하던지 os에 옵션이 두가지가 있다.
버전마다 다르다. 유닉스가 다르고 리눅스가 다르고 그래서 확실하지 않다. 
무조건 에러리턴 해라 하게끔 하는 시그널이 들어오면 그런걸 세팅하는게 존재한다. 어찌됬던 타입1은 뭐냐면 

## System call and a signal
타입1은 뭐냐면
I/O을 기다리고 있는데 시그널이 발생했다. 그러면 이것은 먼저 뭘 하느냐 I/O가 끝날때까지 무조건 기다린다. I/O가 끝난다음에 이제 시그널이 핸들링 된다 라는것이다.
이것은 예를 들어서 디스크 파일에 대해서 read하는것은 이것은 확실히 ++끝난다 라는 보장이 있기때문에++  먼저 뭐부터 한다? 디스크 I/O 부터 한다. 
그러나 겟 캐릭터 경우에는 키보드 같은데서 하는거는 기다릴수가 없다. 그래서 이것은 먼저 뭘 처리하느냐? 시그널을 먼저 처리하고 시스템콜을 포기한다. 포기하든가 반복하든가 이런뜻이다. 그래서 리눅스에 서는 프로세스의 상태를 얘기할때 중요한 상태 3가지, ready(스케쥴을 기다리는 ready상태), I/O하기때문에 block 된상태가 있고, 그다음에는 뭐가 있냐!!! running 상태가 있었다. 이 3가지 상태가 있었다. 그런데 리눅스는 running하고 ready는 똑같이 취급한다. 
그것은 왜냐하면 스케쥴링 큐에서 살아나서 와서 cpu 왓다갓다 빠른 속도로 하니까 구별을 안한다. 다만 현재 돌고있는 프로세스는 뭘 가리키고 있냐면 리눅스에 current라는 variable이 있어서 그 pcb를 가리키고 있기떄문에 누가 ready인지 running인지 구별할 수가 있다. 그래서 리눅스에서는 task의 상태를 ready인지 running인지 어떻게 표시했었냐면 task_running이라고 표시를 했다. 
그런데 block에는 두가지가 있다. 그게 뭐냐면 task_interruptible 하고 task_uninterruptible(용어 중요) 있다. 저것은 하드웨어 인터럽트와 관련이 있는건 아니라 task_uninterruptible은 block 상태다. block 상태인데 signal이 들어와도 어떻게 하란 말이냐? 짜르지 말라 이말이다. 짜를수가 없다. 시그널이 나를 짜를 수가 없다 이말이다. block 이 되어있는데
디스크 I/O할때 block 될때는 상태를 TASK_uninterruptible로 만든다. 
그런데 겟캐릭터 같은것을 하면서 I/O 시 block이 되면 뭘로 만드냐면 task_interruptible로 만든다. 이것도 block 상태인데 이것은 시그널이 들어오면 i/o가 중간에 짤려버린다. 의미이다. 
그런데 이것을 확실할려고 그러면 siginterrupt를 쓰면된다. siginterrupt(signal_no(number)= 시그널 넘버를 쓰고, true 하게 되면 어떤 시스템콜을 하게 되더라도 시그널이 발생하면 에러리턴해라 의미이다.)

last 6분

## Example Program(alarm() & getchar())(개중요)
```java
서버에 들어가서 로그인 할려그러면 뭘 물어보냐! 유저네임하고 패스워드를 물어보는데
그런데 유저네임만 물어본다고 쳐보자.
유저 네임이 들어왔는데 이사람이 5초동안 아무짓도 안한다. 이름을 쳐넣지 않았다. 
그러다가 5초를 기다렸다가 삑소리 내면서 유저네임을 다음줄에 또 찍게 된다. 
또 안치면 어떻게 되나? 5초동안 안치면 또 삑소리 내고 반복한다. 
그걸 몇번 까지 반복하나 5번까지 반복한다. 5초동안 기다릴때 얼람을 써야한다. alarm(5)를 써야한다. 그프로그램이다.
#include<stdio.h>
#include<signal.h>
#include<unistd.h>

#define TIMEOUT 	5 //login time limit = 5esc. After alarm, ring a bell
//5초동안 기다릴때 얼람을 써야한다.
//timeout은 머냐면 5초동안 로그인을 하지 않으면 로그인해서 enter까지 유저네임을 치지 않으면 삑소리 내고 다시 반복한다. 그걸 몇번까지 반복하냐면 max try 5번까지 반복한다. 
#define MAXTRIES	5 //retry login five times when timeout
//5번까지 반복한다. try를 
#define LINESIZE	100 //login name/passwd buffer size
//유저네임 몇자 까지 받냐, 100자 까지 받겠다 이런말이다.
#define CTRL_G		'\007' //bell
//007인데 이것을 printf하면 삑소리가 난다. 
#define TRUE		1
#define FALSE		0

volatile int timed_out; //set when an alarm occurs
char myline[LINESIZE]; //character buffer
//100자를 가져다 이름을 저장할 것 이다. 
void sig_catch(int);   //alarm signal handler
//시그널을 쓸껀데 무슨 시그널을 쓴다고? 얼람을 써야 한다. sig_alarm이 들어오는데 sig_alarm이 5초마다 들어올때 받을 signalhandler이다.


```

```java

char *quickreply(char *prompt){
//로그인 네임을 찍어라!! 밑에서부터 봐야댐
	void(*was)(int);//was라는것은 옛날 시그널 핸들러를 잠시 저장할것이고
    int ntries, i; 
    char *answer;
    was=signal(SIGALRM, sig_catch); //sigalarm이 들어오면 어디로가나? sig_catch로 가서 삑소리를 내! 이런말이다. 그리고 timed_out을 true로 만들어줘!
    siginterrupt(SIGALRM, 1);//set error return when a signal
    //sigalarm이 signal이 시스템콜을 하는데 뭐가 들어오면? sigalarm이 들어오면 시스템콜을 잘라버려라! 에러 리턴을 해 
    for(ntries=0; ntries<MAXTRIES; ntries++){
    //여기보면 for loop이 있는데 for loop이 여기서부터 시작해서 아래까지 하는데 실패할경우 5번 반복한다. 맥시멈 
    	timed_out =FALSE; //얼람이 발생하지 않은것으로 초기화를 해야한다.아직 5초가 안지났으니까! 
        printf("\n%s>",prompt); //유저네임 찍고(물어본다. 유저네임을)
        fflush(stdout);  
        alarm(TIMEOUT);//5초에 타임아웃을 건다 얼람을 걸어놓고 뭘 하냐!
        
        for(i=0; i<LINESIZE; i++){ //캐릭터를 계속 받는다. 캐릭터를 언제까지 받냐면, enter 키가 들어올때까지 받는다. enter 키가 들어와야지 이게 유저네임이 끝난거니까 홍길동을 찍는데 홍자만 들어오면 안되고 반드시 5초안에 enter까지 찍어야 한다. 
        	if((myline[i]=getchar())<0) //getchar를 해서 error가 없으면 myline에다 집어넣고 i++하고 그다음에 들어온 캐릭터가 enter 키이면 거기다가 null을 집어넣고 break해서 나온다.
            	break;
            if(myline[i]=='\n'){
            		myline[i]=0;
                  break; //end of line input
            }
        }//그러면 이름을 다 받는데는 성공한것이다. 
        
        그런데 이렇게 이름을 받고 있는데 이거하고 있는데 이사람이 게으르게 단짓을 하고 있던 것이다. 그러면 그동안에 뭐가 발생하느냐! 5초에 alarm이 발생한다. 대부분 어디서 발생하겠냐? getchar를 기다리고 있는데서 발생할 것 아니냐 그래서 alarm이 발생하면 getchar가 어떻게 된다고? 시스템콜이 중지가 되고 error를 리턴한다. 어디로 갔다 오면서 조금전에 했던 sig_catch 갔다오면서 -삐 소리를 내고 time_out을 뭘로 만들고?true로 만들고 -삑소리를 내고 다시 어디로 돌아오냐? getchar로 돌아왔는데 (겟 캐릭터) 시스템콜이 짤렸잖아. error 리턴을 하니까 mygetchar(마이 겟 캐릭터에서) myline으로 들어온게 에러리턴이니까 다시 결과가 어떻게되냐? 0보다 작으면 에러가 난게 아니냐! 에러가 났으면 break;를 한다. break;를 해서 5초동안 지나도록 뭐를 안한거냐? 이름을 안친것이다.for loop을 벗어낫을때에는 break;가 두개가 있으니까 어떤 경우가 있는것이냐? enter키 까지 잘받아서 나온경우가 있고, 그다음에 enter키까지 치는데 5초가 다치지 못하고 경과가 되서 나온 두가지 경우가 있다.(중요) 2가지 경우에 대해서 이제 뭘해야 하나? 이제 alarm을 꺼야 한다. alarm을 0로 해서 끄고 
        alarm(0); //alarm을 0으로 해서 끄고 아까 만일에 얼람이 들어왔으면 time_out을 뭘로 만들었냐? true로 만들었을거 아니냐! 시그널핸들러에서 그래서 time_out이 true인가를 본다. 근데 이게 false다 라는것의 의미는 그러면 time_out이안됬다라는 의미이다. 그러면 이게 정상적으로 다친것을 의미한다.그러면 break;를 해서(아예 탈출을 하는것을 의미하나보다.) 벗어나서 return 한다. 시그널핸들러로 원상복구하고 main 프로그램을 리턴해서 뭘 받았다. 몇번만에 성공했다.
        
이런것을 return 하고 만일에 time_out 이 true였단 소리는 alarm 5초에 걸렸다 라는 뜻이 된다. 그러면 어디로 가냐 다시 loop으로 올라간다. loop으로 올라가서 또 어떻게 하냐 ! time_out을 다시 false로 하고 유저네임 다시한번찍고(prompt) 그다음에 다시 alarm 5초를 또 걸고 또 똑같은일을 반복을 하는데 5번까지 반복을 한다. 
        if(!timed_out)
        	break;
          
    }//end of retry loop
    answer= myline;
    signal(SIGALRM,was);
    return(ntries==MAXTRIES ?((char*)0):answer);
}

void sig_catch(int sig_no)
{
//5초에 얼람을 걸어놓고 5초가 지났을때 일로 들어오게 된다. (이게 시그널 핸들러다. 아닌가???)

	timed_out=TRUE;//5초가 지나면 timed_out이 true가 되고 
    putchar(CTRL_G); //삑소리가 나게 하고, 모니터로 내보내면 
    fflush(stdout); //확실하게 내보내는것이고
    signal(SIGALRM, sig_catch); //signal을 일회용으로 쓸지도 모르니까 확실하게 할려면 여기서 다시 설정해주는것이 안전한다. 그래서 시그널 한번 들어올때마다 다시 ???? 도도림표를 하게 된다. sig_alarm 이 들어오면 또 일로 와라! 이런말이다.
    handler; //signal_handler를 만들어놓고
}

int main(){
	quickreply("login-name"); //quickreply라는 루틴을 콜한다. login-name으로 본다. 프롬프트로 해서 
}
```
