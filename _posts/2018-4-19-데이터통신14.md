---
post : layout
title : 데이터통신14
---
## 데이터통신14
데이터통신14

## PCM 복호기 구성 요소
Pulse Code Modulation

아날로그 데이터를 디지털 신호로 바꾸고 있다.
PCM 신호를 받은 receiver 입장에서 원래의 signal을 복구하는 회로를 간단하게 표현하면 

디지털 데이터가 오면 pcm 신호라고 하면 각 샘플당 몇 bit다 라는것이 서로 알고 있다. 받은 신호를 몇 bit씩 그륩핑 지어서 그륩핑 지은 값을 가지고 레벨을 만든다.

디지털데이터 0110, 0001, 0111, 1010, 1110, 1000, 0110 디지털 데이터를 4bit씩 끊어서 계단을 만든다.
원래 신호는 아날로그 신호였다. 
make and connect samples 이라는 샘플들을 서로 연결해라 계단형태로 쭉 샘플값이 만들어졌으면 (홀드해서 계단이 만들어지면) 아날로그 신호의 샘플된 값일 테니까 원래의 유사 커브를 찾아내야 한다. 찾아내는 방법은 변화를 변화를 완만하게 바꾼다. 장치하나 통과함으로써 가능한대 그것이 low-pass filter이다.

장치가 하는일은 급격히 변화되는 부분들을 잘라낸다.
완만하게 계단을 쫓아가는 형태가 나올것이고 원래의 아날로그 시그널을 복구해낸다. 

간단하게 표현되어있다. 섬세한 기술이 요구된다. 개념적으로 바라본다.

계단 형태를 만든다음에 low-pass filter를 통해서 얼추 아날로그 시그널을 유추해낸다.

원래 아날로그 시그널이 있었는데 디지털데이터로 바꿔서(0011011011) 보내는것이다. (pcm을 이용해서)
대역폭 측면에서 살펴보면 아날로그 시그널이 fmax다. (어느지점이) 
아날로그 시그널이 타임도메인에서는 이러한 형태였는데
주파수 도메인에서는 fmax의 값까지의 0부터 주파수를 갖는 신호더라.

아날로그 전송을 그대로 한다면 전송매체가 제공되면 되는데 
++디지털 데이터로 바꿧는데 디지털 데이터를 전송하기 위해서는 어느정도 대역폭이 요구될까?++

미디어를 통해서 데이터를 보내야 하는데 어느정도의 대역폭을 필요로 할까 중요한 주제다.(pcm 신호의 대역폭)

앞절에서 디지털 데이터를 전송하기 위해서 필요한 대역폭은 신호 레잇과 비례관계를 갖는게 당연하다. 신호가 빨리 변하면 (신호레벨을 L개를 두면, 4레벨을 갖고 01 10 11 00 이런식으로 디지털 데이터가 그대로 전송이 될때 이렇게 만들어지는 신호가 필요로 하는 대역폭이 얼마나 되냐는 따지면 대역폭은 신호의 변화에 대충 유사하게 비례가 되는데..

수식은 C*N*1/r 표현했다.
c가 0~1 평균 1/2 r은 하나의 신호레벨이 몇비트를 전송하냐요소. B와 S은 비레관계이고 비례관계라는것은 상수 a가 곱해짐으로써 equal이 될 수 있다.
따라서 B(MIN)=c*n*1/r 이라고 소개된 바가 있다.
이런 디지털 신호를 전송하는데 필요한 최소한대역폭에 대한 관계식이 위의 모양으로 주어져있다.

아날로그 signal을 pcm을 통해서 디지털 데이터로 바꿨는데 이때 필요한 대역폭이 얼마나 필요할까

아날로그 데이터가 보내는 bps 값을 N에다 대입을 한다.
pcm 을 통해서 만들어 졌다면 나이키스트 샘플링 이론에 의해서 디지털 데이터의 bps는 초당 fmax의 두배의 초당 샘플링을 해야 한다. 
1초에 아날로그 신호의 주파수 영역대에서 제일 큰 주파수 영역의 값의 두배만큼 이런 빈도수로 샘플링을 하고 샘플당 N(B) bit라는 4bit 혹은 8bit로 맵핑을 시킨다. 

샘플에서 8레벨중에 어느 하나로 집어넣는다 하면 3bit에 맵핑 시키는것이고 256개의 레벨중에 어느하나로 맵핑한다 하면 8bit로 맵핑한다. 

++샘플하나당 몇 bit로 표현할것인지 N(B)로 표현한다.++

stream의 속도는 N(B) * 2fmax bps 속도로 만들어지고 있다. 바로 이것이 N이다. 
N에 대입할 수 있다.
pcm 데이터에 최소로 요구되는 대역폭은 c*2fmax*N(B)*1/r
c는 1/2 r는 1이다. 일반적으로 신호 요소 하나당 한비트를 전송하는 방식을 쓴다.

ami 방식이 이러하다. 1이면 +, -가 오고가고 0이면 0을 유지한다.
ami 방식이 많이 쓰여서 예로 나타냈다.
이방식이 신호 element 하나에 한 bit씩만 전송된다. 따라서 r=1 c는 1/2 사용한다.

N(B)*fmax 관계가 나온다.
관계가 심플할수록 좋다.
주파수 대역이 0~fmax 성분을 갖는 아날로그 시그널을 pcm으로 디지털화해서 전송할때 필요한 대역폭의 크기는 아날로그 때의 최대대역폭크기 * 한샘플당 몇비트를 했는지 N(B) 곱한 값이 된다.
대역폭이 N(B)만큼 늘어난다.

샘플당 8bit씩 샘플을 했으면 대역폭은 8배가 된다.
++원래 아날로그 신호를 전송할때 필요한 대역폭에 비해서 pcm으로 바꿔서 전송하다보면, N(B) 배 만큼 주파수 대역이 늘어난다.++

## 4.15
아날로그 시그널이 있는데 low-pass 아날로그 시그널인데 4khz이다. low-pass 아날로그 시그널은 대역이 0부터 시작한다 4Khz내에 주파수 성분을 갖고있는 아날로그 시그널이 있다. 아날로그 시그널이 주파수 성분에서는 4kHz 대역내에 들어가는 low-pass signal 이있다.
이놈을 전송하고자 하는데 4Khz면 충분하다.
샘플당 8bit로 만들어서 샘플링을 해서 digitize 한다음에 그다음에 데이터를 보낼려고 하면 대역폭이 얼마나 필요할까
++아날로그 신호를 그대로 보내면 4Khz면 충분한데, pcm을 이용해서 한 샘플당 8bit를 만들어서 디지털데이터를 만든다음에 이 신호를 보낸다면 대역폭이 얼마나 필요할까?++

8 * 4kHz = 32kHz

8배 늘어난 대역폭이 필요하다.

pcm으로 데이터를 바꿔서 보내면 디지털 전송이라고 하는 고품질의 전송을 퀄리티는 얻을수있지만 거기에 대해서 지출하는 비용은 N(B)만큼 곱해진 대역폭을 지출해야 한다.
TRADE-OFF 관계
대역폭 증가 비용증가

## Nonlinear coding
지금까지 본 것들이 linear coding인데
여기서는 nonlinear 방식
pcm 방식으로 digitize 했다.
샘플링했을때 레벨을 균등하게 나오고 있다.
16개중에 어느하나로 맵핑시킨다 하면 16개 동일한 간격을 갖는 16개 값중에 어느 하나로 맵핑시킨다.
시그널 변화가 큰애는 별문제가 없는데

작게 변하는 signal 입장이 되면 
첫번째로 알아야할것이 error가 있다. 간격에 반값이 error다. 띠에 중간값에 다 mapping 시킨다하면 경계에 있는 값들은 위로 가든 아래로 가든 띠 간격의 1/2만큼 error가 있다.  

띠간격을 델타라고 하면 델타/2 만큼의 maximum error가 발생할 수밖에 없다. 큰 시그널들은 자기 시그널 값에 비해서 델타/2 error가 차지하는 비중이 크지 않은데 비해서 작은 시그널들은 자기 값 자체가 0.5인데 error 크기도 0.5 라면 error가 100%다.  (에러/자기시그널대비)

++시그널 변화 값이 큰 시그널 입장은 맵핑에 큰 문제가 없지만 아주 작게 변하는 weak한 시그널들은 error가 크다.++

++계산하기 위한 방법이 2가지가 있는데 첫번째 방법은 시그널 크기가 작은 부분은 띠 간격을 아주 작게 만들어준다.++

시그널 간격이 큰 양쪽 끝단은 넓게 해준다.(그래야 맞으니까) 띠간격을 not linear 하게 분배한다.

전에는 띠 3개에서 변화하는것들이 띠를 6개내에서 변하는 식으로 다양하게 작은변화도 섬세하게 표현할 수 있는 방법이 동원된다.

대신에 큰쪽은 시그널 레벨이 크기때문에 띠 간격이 주는 에러의 비중이 큰 비중이 없다. 그래서 약한 시그널을 퀄리티를 높여주기 위해서 약한쪽은 띠간격을 좁게 시그널 레벨이 큰쪽은 넓게 이렇게 digitize 하면 보낸쪽이나 받은쪽에서 동일한 띠간격에 대한 맵핑만 갖고있으면 완벽하게 에러가 작은 시그널에 대한 보상이 충분히 이루어진다. 이런식으로 pcm이 만들어질수있다. pcm을 개선했다.

digitize할떄 퀀타이제이션할때 간격을 not linear하게 설정함으로써 약한 시그널을 보안한다.
간격을 조절하는거였고
## Companding
두번째 방식은 시그널 레벨을 키워주는것이다.
시그널이 들어왔는데 파란색 시그널이 들어왔다. 여기에 파란색 커브를 갖는 시스템을 작용을 시켰다. 하는일은?

++증폭기이다.++

linear하게 들어오면 증폭되지 않고 Input이 output으로 나간다. 커브는 작은 Input이 커지는 것이다. 큰쪽은 원래랑 비슷하게 나온다.

++커브의미는 작은 부분은 상대적으로 많이 키워준다. ++

그러면 원래 파랑색 인풋이 들어갔는데 증폭기를 거치면 빨간색 그래프처럼 작은 부분이 증폭되서 나온다.

이러게 증폭하고 pcm에 집어넣는다. 이때는 linear하게 적용해도 괜찬다. weak signal이 증폭기를 통해서 팽창이 됬으니까! (weak signal이 갖는 문제해결)

signal 자체를 증폭시켜서 linear한 인코딩 방식을 사용한다음에 받은쪽에서는 역기능을 수행한다. 
작은쪽 signal을 키웠는데 수신한쪽에서 디지털 데이터를 아날로그 신호로 복귀해보면 작은 시그널이 증폭된 형태로 복호화가 된다. 받은쪽에서는 거꾸로 이런 모양의 함수를 작용시키면 역함수를 작용시키면 빨간색 커브가 파란색으로 복구될 것이다.

++입력단에서 10배로 키웠으면 받은쪽에서는 1/10로 줄여야 한다. 대칭되는 함수를 작용시키므로써 다시 위의 함수를 원래 아날로그 함수로 복구해 내도록 한다.++

compress 줄이는거고 expanding이 늘이는것이다.

pcm이 갖는 문제를(시그널 레벨 자체가  작은 시그널 이거에 대한 개선 방식중에 하나가 companding이다.)

다른하나는 notlinear하게 encoding방식
++2가지다 신호레벨이 작은 신호에 대한 복구를 하고자 하는것이다.++

아날로그 데이터를 디지털로 바꾸는 것중에 하나를 pcm을 배웠고 두번째방식
## 델타변조

아날로그 시그널이다.
디지털 데이터로 바꾸는데 sample해서 sample된값을  디지털로 바꾸는것이 아니라, 이 커브를 트랙킹하는 형태의 정보를 만들어낸다. 
t0 시점에 아무 정보가 없다 시그널 레벨이 그래프에서 보이는 바와 같다.
0부터 시작하는데 시그널 레벨이+ 얼마 있는 상황.
내가 갖고 있는 값이 시그널보다 적으면 점프를 해야한다. 점프는 시스템에서 정해진 값이다.
이후에도 내가 시그널보다 작으니까 또 점프한다.

계속 signal과 내가 유지하고 있는 값을 비교해서
내가 작으면 점프, 홀드 한담에 보니까 내가 더 크면 줄여나간다. 아날로그 신호를 추격해나간다.
점프했을때 1 줄였을때 0 
이렇게 맵핑 시키는것이다.

증가시엔 1 감소시엔 0로 표시
++시그널을 모방하기 위한 계단함수의 정보만 있다++
받은쪽에서 stream을 받는데, 그걸 바탕으로 계단을 만든다.
올리고 내리고의 간격은 시스템 함수가 되서 ++d++라고 표현한다.

띠간격을 델타(앞서 본 pcm 델타라는 시스템 파라미터있듯이)도 시스템 파라미터가 있다. d값이 크면 쭉쭉 따라간다.
대신 error가 커진다. d값이 작으면 쫓아가는데 오래걸린다. d값을 optimal하게 정하는것도 시스템에 성능을 좌우하는 중요한 변수이다.
++델타변조의 기본개념은 추적하는것이다++

## 델타변조구성요소
델타변조 장치를 간단하게 표현했다.
갖고있는 추적하고 있는 어떤 값이 있다. 계단이 있다. 그값을 일정시간 유지한다음에 비교를 한다. 내가 현재 가지고 있는 계단 모양과 비교를 한다. 크다 작다를 통해서 1또는 0을 만들어낸다.그값을 가지고 잠깐 유지후 또다시 잠깐 후에 비교를 한다. 계속 만들어내는값이 0또는 1. 

## 델타복조구성요소
receiver쪽에서는 stream을 받으면 계단을 만들어낸다.
1이면 한칸 올라가고 0면 내려간다.
계단을 만들어낸다.++
계단 변화가 급격하게 변하니까 low-pass field를 통해서 부드럽게 변하는형태로 아날로그 시그널을 대충 모방한다.++

low-pass field는 급격히 변하는 부분을 잘라낸다. 서서히 쫓아갈수있는것이 목적이다.
아날로그의 모양을 갖게끔 한다.

## 4-3
디지털 데이터를 만든후 전송하는 방식은 parallel transmission, Serial transmission  두가지 방식이 있다. 

## 병렬전송
패럴레는 8bit면 8줄에 나눠서 각각 동시에 보낸다. 1byte를 8줄에 담아서 
샘플 8bit 만들어주면 8bit를 동시에 각각 8라인을 통해서 쭉 보내는 방식이다. 

## 직렬전송
한줄로 일렬로보낸다.
시리얼 전송의 경우 한줄로 보내는데 byte 단위로 보내냐 아니면 경계없이 쭉 보내느냐 비동기방식 동기방식 동시성 개념이 있는데 독학으로 돌파한다!


## Chapter 5 Analog Transmission

아날로그 트랜스 미션, 전송
소스를 데이터라고 표현하고, 전송하기위한 변형된 형태를 signal로 말하면
경우의수가
아날로그 디지털

아날로그를 디지털 시그널 만드는것이 pcm, 델타모듈레이션(4장)
디지털을 디지털로 바꾸는것이 디지털 전송인데 소스 디지털일때 디지털로 바꾸는 방식이 ami,멘치스터 방식
라인블락코딩이 여기에 들어간다. 4장의 뒷부분에 해당

5장은 아날로그 전송인데 소스인 아날로그인경우 원래 소스가 디지털인경우 어떤 기술들이 있느냐가 5장의 부분이다.
아날로그 -> 아날로그 5.2
디지털 -> 아날로그 5.1
ASK, FSK, PSK, QAM 5.1절
AM,FM,PM 개념이 비슷한데 5.2절

전송을 아날로그로 한다. 디지털이 퀄리티면에서 더 좋다는것을 안다.++
대역이 이 밴드패스 대역이더라 일정한 대역이더라, 이 대역이더라다른사람은, 갖고 있는 시그널이 대역에 들어가도록 모듈시켜야 하는데 아날로그 전송으로 가능하다. 이 부분이 중요하다 그래서 무선통신에서 많이 사용하는 방법이다.++

여기 KBS, MBC 방송국 나라에 지정해주는 대역폭에 내가 만든 데이터를 어떻게 집어넣는지 집어넣는방식이 이 챕터에서 배울 내용이다.
소스가 아날로그든 디지털이든 아날로그로 보내야 한다.

내가 지정한 대여폭쪽으로 어떻게 가져가느냐
반송파(캐리어 시그널) 이것은 sin, cos 정현파인데 그 함수의 주파수 성분이 cos2파이 f씨t 표현되는 하나의 정현파인데 cos 함수가 갖고있는 주파수 성분이 내가 옮겨야 되는 그 주파수 대역이 중간포인트 갖는 그런 반송파 시그널을 사용할수밖에 없다. 내가 보낼 시그널이 m(t)인데 이 cos함수에다가 어떻게든 집어넣어서 cos함수의 반영을 시켜서 이 주파수 대역으로 내가 보내고자 시그널이 들어오게 만들어야 한다. 

## 디지털 - 대 아날로그 전환ㄴ
왜 아날로그를 배우는가? 캐리어 시그널이 중요하다. 단순한 sin, cos함수다. sin cos 표현할때 Acos(2파이fct+위상) 3가지 파라미터를 주면 정확히 어떤 정현파를 그릴수있다. 3가지 중에 정확히 주는게 없으면 못그린다.
페이스가 0이고 fc가 10hz고 a가 3이다. 이런식으로 주어져야 cos 함수를 주기가 어떤 cos함수를 그려낼 수 있다.
++바로 캐리어 시그널이 갖고있는 파라미터는 3가지가 있다. 앰플리튜드, 프리퀀시, 페이스가 있다. 내가 이 반송파 시그널을 이용해서 내가 지금 보내고자하는 시그널을 반송파신호에 넣어서 담아서 보낸다. 어디에다 보낼것이냐 amplitude에 넣을것이나 주파수에 넣을것이냐 위상에 넣을것이냐에 따라 3가지 방식이 나온다. ++

디지털 to 아날로그, 아날로그 to 아날로그 원래의 소스인 이놈들을 이 아날로그 신호에 집어넣는 방식 3가지에 의해서 말할 수 있다.
소스가 디지털 일때 amplitude에 넣어서 보내는방식 amplitude shift keying 이라고 한다. 우리말로 해석이 진폭편의변조
주파수에 집어넣어서 보낼때는 Frequency shift keying 
페이스 집어넣어서 보낼때는 face shift keying.

이렇게 3가지 를 살펴볼수있다.

아날로그 to 아날로그 변화하는것도 마찬가지다.
아날로그 시그널을 진폭에 집어넣어서 보내면 am, 주파수에 집어넣어서 보내고자 보내고자 하면 fm
페이스에 넣어서 보내면 페이스 모듈레이션이다.

정확히 매칭이 된다.
반송파 시그널의 어느 성분에 내가 보낼 데이터를 신호로 보낼까가 3가지가 있고, Quadrautre amplitude modulation.
(더많이쓴다.) 
amplitude sk과 face fk을 동시에 사용하는 방법이다.

## 디지털-대-아날로그 전홚[계속]
디지털을 아날로그 신호로 변환시키는데 3가지가 있고 그리고 QAM(앰플리튜드와 페이스 시프트킹을 동시에 사용해서 보내는방식)
모듈레이션 의 자유도가 커져서 BPS를 굉장히 늘릴수있다. 효과적으로 늘릴수있다.

소스가 디지털인데 아날로그로 바꿔서 보낸다(모듈레이터를 통해서)

## 디지털 - 대 - 아날로그 전환 유형

## 디지털 신호의 변조
디지털 전송되고 맨처음에 나왔던 baud rate과 bit rate간의 관계 	

디지털 전송의 경우에 표현됬던 식이 s=c*n*1/r해서 r이 신호, 하나의 신호요소가 전달하는 데이터요소의 개수.

정의는 같은데 신호 rate (boud rate)는 여기서 c라는 표현이 없고 bit rate * 1/r 표현한다.

c라는 변수가 없어졌다. 아날로그 전송에서 애기다.

## 디지털 신호의 변조[계속]
반송파의 진폭, 주파수, 위상중에 어느 한가지를 변화시키는 방식이 변조라고 한다. 모듈레이션이다.
반송파 신호가 중요하다. 캐리어 시그널


## ask
내가 보낼 데이터가 10110 디지털 데이터가 있을때 아날로그 어떻게 반영시키느냐 가장 심플하다.

내가 갖고있는 sin파가 있는데 1이면 사인파 진폭이 크다. 0이면 진폭을 0로 만들었다. 간단하다.

이런 시그널을 보낸다 받은쪽에서는 아날로그 신호 그대로 간다. 
받은 쪽에서는 진폭이 없으면 0 진폭이 보이면 1.
디지털 데이터를 복구해내는 방식이다.
개념상 가장 간단하다. 시그널 요소가 하나 c라는것이 없어졌는데 없어진 요소 보낸 시그널 자체가 캐리어 시그널과 같은 정현파 파형 을 갖다보니까 c 라는 값이 의미가 없어진다. 
1비트를 갖기 때문에 r=1이다.

진폭이 유지되면 1이고 없으면 0이다.
S=N 이다.
원래 반송파 시그널은 fc 하나가 있었을것이다.
cos2파이fct이 캐리어 시그널이었을것이다. fc라는 성분이 있는것이다. 이 시그널을 변조시켰다. 주파수 대역에서 어떻게 될까? 사라졌다가 나타났다가 이런형태의 시그널이 되면 주기함수가 아니다. 주파수 평면에서는 중심으로 이런모양이 완성되어 진다. 이런 시그널을 만들기 위해서 수많으 주파수 성분들을 갖다가 정형파를 다 더해야 이런 시그널이 만들어진다.

++대역폭은 이런 관계식을 갖는데 d는 의미하는것은 범위내에서 넘어가고 결과만 얘기한다. 대역폭이 d는 0에서 1사이값 형태를 갖는다. 이런 모양을 갖는다.++

정보를 끄집어낼려면 d가 0부터 1사이 되기는 대역폭이 최소 s고 최대 2s다. baud rate에 2배까지 대역폭이 나올수있다.(최대) d는 그때마다 파라미터로 정해진다 대역폭이

이정도 대역폭을 갖는다. 따라서, 1010 디지털 데이터를 갖고있는데 어느 특정한 대역에 집어넣어서 보내고 싶다 그러면 바로 이 부분이 fc 내가 원하는 대역의 중간포인트가 되게 만드는 반송파 시그널을 만들어낼 수 있다. 변수는 어떻게 구현하는가? 101010 마치 표현된다면 

## 디지털 신호의 변조[계속]
실제 구현한 방식
1010101 마치 표현된다면 
not return to zero로 유니폴라 방식인데 여기다가 반송파 시그널을 곱하면 0일때는 없어진다.1일때는 그대로 시그널이 보존이되고 이렇게 만든다. 곱셈기 하나와 캐리어 시그널을 생성하는 오실레이터 하나 있으면 보내고자 하는 인풋데이터를 이런식으로 표현해서 곱해버리면 바로 내가 원하는 ask 시그널이 나오게 된다. 
amplitude에 집어넣은것이다. 이 시그널의 amplitude가 온전할때는 1, 0일때는 0 디지털데이터가 디지털정보를 amplitude에 집어넣었다. 이것이 ask이다.

## 5.3
밴드위쓰가 100khz 띠를 갖고 있는데 200khz~300khz 사이에 있는 띠 대역이 주어졌다. 이 속에다가 내가 보낼 데이터를 이 전송 대역에 집어넣어야 한다. 캐리어 포인터는 중간값 250khz가 되어야 한다. 캐리어 시그널을 사용해야한다. 띠 대역의 중간포인트, 주파수 성분으로 갖는 캐리어 프리퀀시 가져야 할것이고
bit rate은 d를 1로 두고 ask를 사용한다면 bit rate은 d=1이라고 한다. 밴드위쓰는 2*s가 된다. s는 n*1/r이 되니까 n을 찾는것이다. ask는 r이 1이다. 
2n이 100khz 하니까 n은 50kbps가 만들어진다.
이 대역폭을 이용하면 ask를 적용한다하면 내가 얻어 낼수있는 bps는 50kbps이다. 
ask를 쓰면 대역폭의 반정도의 bps를 얻어낸다. 

## 5.4
대역폭 통신에서는 주로 full duplex를 쓴다.
나에게 주어진 대역폭을 한반향으로 쓰는게 아니라 저쪽으로 가는거 내가 받는거 양방향으로 주파수를 두 전체를 나눠서 쓴다라는것이다. 요부분은 저쪽으로 가는방향 이부분은 반대로 오는방향 쓰는게 full-dulpex 이다. 서로 통신을 양방향으로 주고받는다는것은 주파수를 나눠서 쓰니까 가능하다. 예제가 우리는 보통 양방향의 full-dulpex 방식으로 통신을 한다. 그러기 위해선 밴드위쓰를 두개로 나눠야 한다. 그리고 각각 방향이 서로 캐리어 시그널을 별도로 쓴다.
얘를 쓰는 캐리어 시그널은 중간, 얘가 쓰는 캐리어 시그널은 얘의 중간
2250, 275khz 라고 하는 두개의 캐리어 시그널을 각각 방향별로 써야 한다. 서로 다른 방향에서 서로 다른 캐리어 시그널을 써야 한다. 그래서 두개쓰고 bps는 어떻게 될것이냐 반으로 줄어든다.25kbps 그림으로 표현하면 이와같은 모양이된다.
전체 100kbps를 두개로 나눠서 써야 되고각각 방향별로 반송 캐리어 프리퀀시가 두개의 캐리어 시그널 사용하고 각방향별 50khz밖에 할당을 못주고 ++이것도 수식에 넣어보면 25kbps를 각각 양방향으로 활용할 수 있다.++

25kbps 만큼씩 밴드위쓰를 갖고 데이터를 전송할 수 있다.

## 주파수편이 변조(fsk)
주파수의 0과 1을 집어넣는다. 1일 때와 0 일때 프리퀀시가 다르다. 간단하다. 주파수 정보를 집어넣는데 내가 집어넣을 정보가 1또는 0이라는 스트림이면 1일때의 주파수 0일때의 주파수가 다르면 된다. 다르면 받은쪽에서 신호를 받았을때 순간순간 주파수를 보고 0또는 1의 값을 추출해낸다.

주파수에 어떻게 디지털 데이터를 실어 보내는가 알고보면 간단하다. 주파수를 서로 다른것을 쓴다.

대역폭을 어떻게 될까 살펴보면, 이런 시그널은 이런모양이 나온다. 왜이렇게 될까? 유추를 해보자.

fsk는 대역폭 필요로 하는 모양을 보면 2개가 된다. 개념적으로 간단하게 이렇게 나올수밖에 없는근거.
이시그널을 보고 어떻게 유추를 할 수 있을까?

시그널이 몇개 있다. 나눠서 살펴보면, 빨리 변하는 측면에서 없고
가다가 변하고 없고 
amp 비슷한게 하나있고,  두놈이 더해진것이다.
두개의 ask인 대역이 어딘가 있을텐데 각각 어딘가 있을텐데 두개가 합해졌으니까 프리퀀시 도메인에서는 위와 같이 그려진다. 두개가 나오도록 각각이 빠르게변하고, 느리게 변하게 나타나게 된다. ask가 2개가 나오면 주파수도 당연히 이런 그림이 나올것이다. 
중요한것은 두개가 있는데 두놈이 겹치면 안된다. 떨어져 있어야지 비슷한 대역에 겹쳐있으면 받는쪽에서 분리하기 어렵다.

반듯이 분리되있어야 한다. 간격을 말하는 변수를 2df 라고 하고있는데 각각의 대역폭은 s*(1+d) 같다. 대역폭이 전체대역폭이 2개 너하게 대역폭이 같다.(각각이)
반더하기 반은 온전한것 하나 두 캐리어 시그널 간의 간격을 2df 라고 표현한다. 전체 대역폭을 ppt에 보이는대로 표현한다. 2df 가질수있는 가장 최소한의 값은 s다. 겹치면 안된다라는말은 밀착되어있다라고 치면 캐리어시그널의 사이 간격이 하나의 대역하고 같다. 간격이나 이간격이나 같다. 같으니까 2df라는놈이 가질수있는 최소한의 값은 s다.(s라는것이 하나의 간격을 의미한다.)

주파수편이 변조방식을 쓰면 벌써 한눈에 볼 수 있는것이 ask 에 대해서 비해 더 많은 대역폭을 필요로 한다. 

d가 0과 1사이의 값이고 2df는 요구대역폭이다.

## 5.5
d락 정의하기를 그림에서 두개의 반송주파수 간격을 2df로 표현한다. 수식을 이용해서 똑같은 200~300khz를 써서 fsk를 쓰면 몇 bps를 얻어낼 수 있을까?

ask랑 비교해본다. 아까는 50kbps얻어낼수있었는데 이제는 d를 1이라고 치면 ask도 d를 1로 쳤다. 가질 수 있는 가장 작은 값을 s라고 했으니까. 2s가 될것이다. fsk를 쓰면 2df가 50khz되고
100khz 대역인데 2df는 딱 반인 50khz이다. 
s는 25kbaoud가 되고 r=1이기때문에 n도 25kbps이다.
ask는 50kbps얻어낼수있었는데 fsk는 그거에 반인 25kbps만을 얻어낼 수 있다.

## 디지털 신호의 변조[계속]
FSK 어떻게 만드는지 
FSK 만드는 그림을 보면 
FSK를 어떻게 만드느냐
0이냐 1이냐에 따라서 주파수가 달라진다. 빨리 변하는놈, 천천히 변하는놈 볼티지 컨트롤 오실레이터라고 하는 장치가 있다. 하는일은 볼티지 값에 따라서 주파수가 서로 다른 출력을 만들어낸다. VOLTAGE값이 1또는 0다. 1일때는 주파수가 어떤값이 나오고 0일때는 또다른 주파수가 나오는 VCO 장치를 쓰면 원하는 FSK가 되는것이다. 

발진기인데 나오는 주파수가 입력볼티지 값에 따라서 서로 제어가 되는 

이런 시그널을 만들어주면 10110 시그널 입력해주면 순수하게 생성되는 캐리얼 시그널이 있을때 변조된 신호가 출력으로 나온다.
B는 Binary 2개, 2개중에 하나를 쓴다.
B가 아닌 Q를 쓰면 4개에, 주파수가 4가지로 조절될 수 있다 라고 하면 신호를 4가지 레벨로 집어넣으면 4가지 주파수 성분의 합이 만들어질것이고 한 주파수가 2bit를 표현하는 방식이 되는데 

bfsk : 두개중에 하나 (주파수 성분이 2개인 fsk 만드는 사례만 보여주고 있다.)

## Multilevel fsk
두레벨이 아니라 그러면, 두 레벨 보다 더 큰 주파수 성분을 사용한다 하면 fsk를 사용해서 주파수가 3비트로 표현하게 할려한다 그러면 주파수 8가지를 만들어서 보내준다. 8개중에 어느 주파수 를 보면 그 주파수에는 3bit 정보가 들어있다. 8개 중에 시그널 레벨을 8개 만들어서 보내듯이 주파수를 8개 조합으로 만들어서 보내면 각 주파수가 3bit의 정보가 된다.

그것을 그림으로 표현하면 주파수가 8개면 
8개의 주파수 성분을 갖는 8개의 캐리어 시그널을 보내는 셈이 된다. 예를들어서

## 5.6
전체 멀티레벨의 경우에 전체 필요한 대역폭이 어떻게 되느냐?이식에 집어넣는데 
logL개의 레벨을 만들어서 Lbit 주파수 캐리어 시그널로 보내면 전체 필요로 하는 주파수 양은 B= (1+d) * S+(L-1)2df
그림을 그려보면 2df가 있고 2df라는 놈이 L-1개가 필요하다. 캐리어 4개가있으면 3개가 필요하다. + 나머지 (1+d)S반씩 더하면 온전한 한개가 되므로 
반송 시그널이 L개가 있으면 전체 필요한 주파수 대역은 이런식으로 표현이 될 수 있다.
아까 봤듯이 d=0, 2DF를 최소의 값인 S로 두면 S*L만큼의 대역폭이 필요하다.  (기본지식)

내가 지금 3Mbps를 얻어내고자 한다. 한번에 3bit를 보내고자 한다. 신호엘리먼트 하나에 3bit를 넣어서 보내고 싶다.fsk를 쓰면 주파수를 8가지 써야 갈수있다. 각 주파수 별로 구별이 된다라는것은 3bit 정보를 갖고 있다. 그리하여 주파수 성분이 8개인 fsk를 써야 가능하다.

그렇게 해서 3Mbps를 쓴다. 결국은 신호는 1Mbps만큼 1Mbaud로 가도 신호 element가 하나가 3bit니까 3Mbps가 된다. 내가 갖고 있는 캐리어 프리퀀시는 10Mhz 인데 레벨 디프런트 프리퀀시가 몇개가 되야 하고 baud rate이 어떻게 되고 필요로 하는 대역폭이 어떻게 되고 하는것을 구해라 문제다.

레벨이 L이라고 하는것이 Level이라기 보다는 구별되는 신호 요소이다. 캐리어 시그널의 종류 혹은 개수다.

신호 rate은 r=3이니까 1Mbaud가 나온다. S가 1이니까 8개가 나오니까 전체 8MHz가 필요하다.

10mhZ를 중심으로 전체 8Mhz라는 대역에 각각 전송 프리퀀시가 8가지를 쭉 모아서 보내면 전체 대역폭, 8Mhz를 활용해서 3Mbps를 얻어낼 수 있다. 

## 위상편이변조(psk)
0과 1의 페이스가 다른데 1 일때와 0일때가 180도 차이가 난다.
단지그것밖에없다.
1일때 이렇게다가 0이되면 페이스가 180도라는것은 신호가 완전히 -로 바꼈다는것을 의미
1일때는 온전히가다가 0이되면 시그널이 마이너스가 곱해진다.
amplitude 변화없고 frequency변화없다.
이 둘간의 변화하는건 페이스만 변화한다. 180도 라는 차이가 있다.
파형을 보면 주파수변함이 없고 앰플리튜드 변함이 없다.
페이스만 180도를 차이를 두면서 0과 1을 표현하고 있다.

psk가 장점이 많은것이 noisy가 끼면 ask는 진폭으로 1이냐 0이냐를 보는데 노이즈가 진폭에 지대한 영향을 미친다.
ask는 노이즈에 약한데

psk는 진폭이상관없다. 페이스의 차이를 갖고 0과 1을 보는것이다. 노이즈가 페이스에 영향을 미치는것은 드문일이다.
psk는 ask에 비해서 훨씬 장점이 있다.

주파수도 하나만 쓴다.
ask에 비해 장점은 노이즈에 강하고, fsk 비해서는 주파수 하나만 쓴다. 그런장점이 있다. 주파수 필요한 대역폭도 fsk비해서 좁다.
주파수 대역에서 보면 psk는 ask와 비슷하다. (1+d)*s로 표현이 되고 s는 n이고 r이 1이고 이와 같이 표현이 된다.

구현하는 방식은
## psk(2)
1을 +, 0을 -로 두고 캐리어시그널을 곱하면 1일떄는 그대로 0일떄는 - 곱하는것이다.
-곱해주면 페이스가 180도로 바뀐다.
모양새가 되면서 psk 시그널이 만들어진다.
페이스 시프트 킹????
구현하는 그림은 간단하다.
B가 붙은 이유는 바이너리 두개중에 하나로만 표현하기 때문에  위상을 0이냐 180도냐 요것 갖고 표현하기 때문에 바이너리 PSK(BPSK) 하는것이다.
QPSK다 라고 하면 위상차를 4가지를 두는것이다 0 90 180 270도 이렇게 서로 위상차가 90도씩 나게 4개 시그널을 만들어 내면 그걸 qpsk라고 한다.

Q가 4개라는 뜻이다. Quarter 4라는 의미다.
뒤에 나온다. 
## QPSK 
위상차가 4개가 나게 어떻게 만들까? 90도씩 차이나면 된다.
어디로 가냐하면 psk를 표현하고 나면 ...

QPSK 잘 이해해야한다.
coswct2파이f, 주파수 쪽을 들여다 볼 필요가 없으니까 wct로 표현한다. 얘와 90도 차이나는 놈이 누구냐면 coswct 더하기 파이/2 이다.  
위상 차가 캐리어 시그널을 하나를 쓰고있는데 얘와 90도 차이나는 sin함수도 만들 수 있다. 위상차가 0 과 또는 180도 차이나게 psk를 이용하면 두개를 만들어 낼 수 있다.
0과 180도 차이나는 애로 (+1, 0)
이럴때 얘와 0과 180도 차이가 나는 애는 애하고 90도 차이가 난다.
90 , 270
++페이스가 내가 똑같이 coswct 이용해서 bpsk를 적용하면 나오는 두개는 0과 180도 위상차이가 있다.++ 
똑같은 일을 sin 함수를 갖고 psk를 적용하면 
여전히 0과 180도 위상차가 나는 놈이 나오는데 그놈은 원래 시그널 cos 비교해보면 애당초 90도 차이라는것으로 시작을 했으니까 더해야 한다. 
cos과 비교를 하기 위해서 0+90 = 90 180+90 = 270으로 계산한다.
그러면 90도 차이나는 애와 270도 차이나는 애로 만들어진다. 위상 차가
++종류가 0,90, 180, 270 4가지가 만들어진다.++

요놈은 0과 1 cos함수라고 하면 cos 함수에서 위상차가 0인놈과 180 인놈이 서로 만들어지고 아래는 sin함수가 된다. cos과 90도 위상 차이나는 사인 함수에다가 이것을 곱한다. sin함수에다가 
bpsk 시그널이 나온다. 그리고 요놈과 요놈은 서로 90도가 이미 기본적으로 90도 위상차가 있는 시그널 들로 만들어진 psk이고 따라서 얘들이 알고보면 서로 90도 180 270 위상차가 나오는 4가지의 
얘들이 갖는 위상과 얘들이 갖는 위상을 비교해보면 4가지 위상이 나온다. 한쪽은 0과 180 다른 한쪽은 90과 270
이렇게 2가지가 나온디 (각각에 대해)
그림으로 그리면 이렇게 된다.
두비트를 받아서 한비트는 위로 한비트는 아래로
위 아래는 내가 지금 곱하기 시그널이 위에는 cos이고 아래는 이것에 90도 위상차가 있는 아래는 sin 함수를 곱한다.

똑같은 모양인데 서로 cos, sin이다. 각각 들어온 시그널에 cos,sin을 곱해서 이런 시그널들이 결과로 나온다.
파란색 시그널들을 더해서 내보내면 출력에 있는 시그널이 이건데 이 출력에 있는 시그널은 위상차가 4개인 시그널이 더해진것이다.

0, 90, 180, 270 4개가 더해진 함수가 나온다.
한쪽은 0 180, 다른한쪽은 90 270 더하면 4개
4가지 위상이 출력으로 나온다.
++나오는 출력은 4가지의 위상이 보이니까 그중 어느 하나의 위상은 2비트의 정보를 갖고 있는 셈이 된다.
4가지 중에 하나니까.++

출력이 뭐냐하면!

## 마지막
여기는 cos함수면 오실레이터에서 나온 놈을 cos함수라고 치면 90 위상 차가 있는 놈은 sin이다. cos오메가ct 라는 놈이 sin오메가ct 라는 두가지가 있는데 출력은 sum인데 앞에 위에있는 놈은 +-1이 곱해진것이다. 
+또는 -이 곱해진 sin, cos함수, 출력에 나오는 커브다.

+ - 플러스 마이너스 1을 변수 A라고 하자
Acos오메가ct, Bsin오메가ct
삼각함수 두개가 더해지니까 두개가 보기 싫은데 삼각함수 하나 모양으로 바꾼다.
과정은 ppt를 볼것 인위적으로 요런 놈을 만들어서 양쪽의 앞의계수에 나눠줬다.
삼각형을 생각해보자 A,B 빗변은 직각삼각형에서 루트 A^2 + B^2 관계를 갖는다. 요것이 쎄타라고 하면 

++고등학교 삼각함수 기본공식에 의해서 하나의 COS함수로 표현이 된다.++
쎼타가 뭐냐 내가표현한 함수의 페이스(위상이다.)++

출력으로 나온 시그널이 COS(오메가ct-쎄타)로 표현이 된다.시그널의 변수가 위상이라는 놈이 있는데 위상이라는 놈이 A와 B 모였다 보다싶이  A,B (+ - 1인데) 
B/A가 가질수조합은 4가지가 있다.
1/1, 1/-1, -1/1, -1/-1 조합이 있다.
A와 B가 각ㄱ가 + - 를 가지니까 조합은 4가지가 나온다.
이 페이스가 가질 수 있는것이 4가지다. 4가지가 뭐냐! A와 B의 + - 1 + -1 조합을 해서 4가지를 끄집어냈을때 나온 값이 페이스다. 4가지 페이스다.

페이스를 어떻게 찾느냐, 삼각형을 그려보면 좌표에서 +1 +1 일때 A =1 B=1 45도고 A가 1이고 B이고 -1 이면 -45도이다.페이스가 A=-1이고 B=-1이면-135도다. 
A가 -1이고 B가 1이면 135도다.
쎼타값이 4개가 만들어진다. 
A와 B가 가질수있는 +, - 1조합으로 적용하면 4개가 나오고 그떄의 페이스들은 45 135 -45 -135 그림처럼 표현된다.
이런값들을 쓸수있느냐 유도식을 통해서 설명할 수 있다. 이 출력이 페이스를 4가지를 가지고 있다. 종류가 4개가 있다. 신호레벨이 4가지가 있다. 유사하다. ++그중에 어느 한페이스를 알아냈으면 그 속에 bit가 2bit가 있다.++

QPSK 라고 한다. Q에 의해 4번째 방식 PSK+ASK를 쓰는 QAM 방식 제일 중요하다.

