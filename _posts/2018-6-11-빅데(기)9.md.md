---
post : layout
title : 빅데이터(기)9
---
## 빅데이터9

## 뒷부분이어서하고
끝나고 나면 데모 보여주고 스파크 들어가겠다.
지난 다음 주면 끝임
그래서 

## 강의진행

## Cap Theorem : Brewer's theorem
지난시간에 우리가 그 버전 벡터를 배웠다 어떻게 
체크를하는지 
그 버전벡터가 디텍한 알고리즘이다 솔루션이 아님
어떻게 디텍션하는지 우리가 배웠다.

이거는 이제 어 뭐냐면은 간단하다 이게 어떤 이론인데 
캡 씨어램은 분산환경에서 이제 그 캡이라는게 사실은 저 3개의 단어의 약자다 보시면 알겠찌만 
컨시스턴시랑 어밸러빌리티랑 파티션 톨러런스가 있는데 요 3, 각각 글자에 첫번쨰 에 약자임
고거를 따서 만들어진것이다 

컨시스턴시는 우리가 이미 알고있는거다 데이터 분산환경에서 데이터가 얼마만큼 똑같이 유저들이 봤을때 그데이터를 얼마만큼 똑같은 데이터를 두느냐 컨시스턴시이고
어벨러빌리티는 마찬가지다 어떤 상황에서 든지 간에 그게 유저가 자 그 핑을 때리든 뭔가를 했을떄 거기에 대한 리스판스를 가져다 즉각적으로 해줘야한다
어벨러블하다라는걸 자체를 알려주는게 이것임

파티션 톨러런스는 파티션이 설사 일어나더라도 그 자체가 이제 어쩃든지 이 3개의 프로퍼티중에 분산환경에서는 저 3개를 동시에 만족할수있는 시스템은 없다 라는게 이 캡 씨어램이다. 뭔얘기냐면 이 3개의 프로퍼티 중에 2개를 만족시킬순있어도 동시에 

제가 말씀드리는건 동시에이다 동시에 두개를 만족시킬 순있어도 저 3개를 동시에 만족시키는 그런 분산환경은 없다 이게 캡씨어램 입니다 이 이이론은 어 
??? 라는 사람인데 교수인데 버클리 교수가 2000년도에 얘기했던것이다.
그래서 사실은 캡 띠어램 은 이사람 이름을따서 brewer's theorem 이라고도 합니다 어쩃든지간에 2000년도 나왔다 이 3개의 프로퍼티 중에 분산환경에서는 자 3개를 만족시키는건없다 2개를 만족시킬지언정 3개를 만족시키는 경우는 없다 라는거다 

## cap (그림)
어 이 3개 중에 2개를 만족시키는데 그 두개를 가져다 어떻게 어떤 2개를 만족시키느냐 에따라서 시스템이 달라진다 그 달라지는 시스템 자체는 여러분 도메인이나 애플리케이션에따라 달라진다 보시면알겠지만 
이 cap 각각에 대해서 자 각각 두개를 만족하잔아요 그쵸
그렇지만 한가운데 이 그 맨 가운데를 보면 자 3개를 만족시키는 그거는 x라고 되어있어요 저런 시스템없다. 
그리고 이제 컨시스턴시와 어벨러 빌리티 두개를 만족시키는 그런 시스템을 ca 시스템이라고 얘기한다 그리고 비슷한 이치로 자 어벨러빌리티랑 파티셔닝을 갖다가 만족시키는 그 시스템을 갖다가 ap 시스템이라고 하고 컨시스턴시와 파티셔닝을 가져다 만족시키는 동시에 만족시키는 그런 시스템을 cp 시스템이라고 한다 요거를 갖다가 조금더 예제를 통해서 살펴본다 그게 더 편한다

## 예제
어떤 사람이 있어요 이사람 이름이 앤입니다. 이 앤이라는 사람이 호텔, 뉴욕에 있는 그런 에이스호텔이라는것을 갖다가 내가 부킹을 하고싶어 그 예약을 하고싶은데 자 이사람은 어쩃든지간에 이 앤이라는 사람은 어 영국사람이다 런던에 있다 이 프라돕이라는 사람은 인도에있습니다 이사람역시도 똑같이 그 뉴욕에있는 에이스 호텔을 부킹을 하고싶어 그런데 봤더니 하나만 남은거야  자 하나만 남았는데 이 순간에 예를들어가지고 이 링크가 깨져버렸다 
네트워크가 만약에 둘사이에 네트워크가 만약에 꺠져버렸다
라고 가정했을떄 어떤 시나리오가 가능한지를 여러분들이 조금은 생각을 해보시기 바랍니다
자 첫번째 
이게 ca 시스템이죠
cap 인데 , ca 입니다 컨시스턴시는 만족을하고 어벨러빌리티 만족한다 그런데 자파티셔닝은 지원하지 않는다 아시겟죠 이런 시스템 이런 ca 시스템 일거같은경우는 
아까 그 시나리오에서 어떻게 대응하냐면 둘다 부킹을 못합니다 왜 
파티션 팔러런스가 파티션이 설사 일어나더라도 작동을 
그게 로컬 락이든지간에 어쩃든지간에 작동을 해야된다 라는 얘긴데
파티셔닝을 갖다가 만족시키지 않으면 파티셔닝 을 갖다가 그냥 폴트가 났을떄 얘네들 시스템은 동작하지 않는것이다 그러다 보니까 
그러다 보니까 이 두명 자체가 둘다 예약을 못하는 ca 시스템이 된다면

그리고 마찬가지로 cp시스템 같은 경우는 자 파티셔닝을 만족시키기 떄문에 어쨋든지 간에 동작은 분명히 할거에요 페일러가 일어나더라도 
근데 그동작 그 형태가 어떤식으로 동작하는지에 따라서 그게 cp 시스템, ca시스템 도 되기도 한다 

ap 시스템 계속 
cp 시스템은 이게 예를드는거에요 그 페일러가 일어났다고 치더라도 그 인도에 있는 그 사람이 접속하고 있는 그 노드 그쪽서버를 갖다가 그냥 마스터 서버당 , 이 에이스 호텔에 대한 마스터 서버다 라고 일단은 가정을 해봅시다 그렇게 가정을 하고나면은 자 프라보드는 그 하나 남은 그걸 갖다가 부킹을 할 수있습니다 왜냐하면 일단  기본적으로 파티셔닝 팔러런스 하기 떄문에 기본적으로 작동은 한다 누가 어떻게 작동하는지에 대한 문젠거지 
그런데 이제 프라모드에다가 어쩃든지 간에 인도에다가 그 우선순위를 두었다고 가정하는거에요 그리게 되면 이사람은 그 작동을 하지만 앤 같은 경우는 어 그 나머지 하나를 갖다가 부킹을 할수없다 왜냐하면은 cp 시스템이잔아 
어벨러빌리티는 만족하지 않기떄문에

마지막으로 ap 시스템은 
자 a하고 p잔아요 어벨러빌리티랑 파티셔닝 팔러런시를 갖다가 만족시킨다. 기본적으로 p를 갖다가 만족시키기 떄문에 어떻게든 작동은 합니다 아까 달리 
그런데 어떻게든 작동은 하는데 이제는 자 어벨러빌리티 만 만족을 하고 컨시스턴시는 만족하지 않는다 아시겟죠 이런경우 , 어벨러블 해 인도에서 도 어벨러블 하고 그리고 런던에서도 어벨러블 한거임 그리고 둘다 작동을 해요 그런데 컨시스턴트 하지는 않습니다 
자 이게 무슨 일이 일어나냐면 오버 부킹이 일어난다

어벨러블하기때문에 런던에서 어벨러블 하고 작동을하기떄문에 나도 그거 하나 남은것을 부킹을할수있고 반대로 인도에서도 어벨러블 하기떄문에 봤을떄 하나가 남아있기떄문에 부킹을 할수있다 아시겠쬬 
근데 컨시스턴트 하지는 않는다
왜냐하면 그걸 만족시키지 않는다

그렇게 싱크가 되어있지 않기떄문에 이런 경우 ap 시스템 같은 경우는 오버부킹이 일어나는 케이스이다 그런 이제 요거는 예제이기때문에 예를들어놓은것이다 

캡 띠어렘 이라는거 자체가 분산 환경에서 저 3개의 프로퍼티를 갖다가 2개만 만족시킨다. 그런데 그거는 여러분들 어떤 도메인 이나 애플리케이션에 따라서 달라진다. 
그런데 여기에 나와있다 싶이 이게 도메인 따라 달라지는건데 이게 뭐 파이넨셜 관련된 그런거다. 그런거 같은 경우나 블로그 라든지 아니면 뭐 쇼핑 카트 라든지 
블로그예를 들면 사실 이게 구지 얘는 어벨러블을 더 중요하게 여길것이다 파이넨셜 같은 경우는 컨시스턴시를 굉장히 중요하게 생각한다 

자 그런식으로 ㄱ각가 걔네들에게 맞게끔 택하는 그런 이론이 된다. 자 근데 이게 사실은 2000년도에 나오고 나서부터 그 굉장히 소위 얘기하는 그 말이 많다 이게 어떻게 들어보면 말은 되는거같은데 이제 그 이후에 사람들이 테글을 걸기 시작하다 진짜 맞느냐 진짜 3개를 만족시키는 시스템이 없느냐 정말 2개만 만족하냐 계속 이제 실제 회사에서도 아니면 학계에서도 갑론을박 공론이 벌어진다

그러다 보니까 12년 후에 이사람이 어떻게 보면 살짝 완화 시켜서 발표를 한다 다시 이제 12년후인데 이사람이 

## 12년후
자 3개 중에 2개 를 결과적으로 만족시킨다 
그게 사람들한테 미스리딩 할수있다 라는거임 
자 자기가 얘끼할려고 하는건 두개를 만족시키고 하나는 무조건 떙 아니라
두개는 분명히 동시에 만족을 하는데 그 나머지 하나가 만족을 동시에 안한다 가 아니라 거기는 에스태밖?? 
지원 해줄 수있는한 최대한 지원을 해준다 라는거임 그러니까 보장은 아니지만 그 두개를 제외한 나머지 하나에 대해서는 최대한 best ever .. 보장을 해줄려고 노력을 해준다 약간 완화를 시킨다 제외를 완전히 시켜버리다 보니까 
어떤 경우에 따라서는 그게 100% 가 아닐지라도 동시에 만족시키는 만족 시켜버리는 그런 시스템이 나오기 시작한다
그런데 거기에 대해서 이사람이 할말이 없어진다 조금은 완화시킨다. 
그래서 보시면 
디자인 스페이스를 갖다가 조금만 디자인 스페이스를 작은 파트만 희생을한다
전체적으로 다룰떄 한단얘기가 아니에요 요기 조금 자세하게 나오는데 결과적으로 이제 그 분산환경이기떄문에 키는 만족을 시켜야 합니다 통상적으로 분산환경에서 여러분 네트워크 파티션 낮다고 해서 작동안하는게 무슨 분산환경이에요 그렇잔아요 로컬 환경도 아니고 기본적으로 캡 씨어렘 자체는 결과적으로 뭐와 뭐에 싸움이냐면 
싸움이라기 보단 뭐와 뭐에 갑론을박 이냐면 이 
consistency vs aaiability 에 문제다.
파티션은 통상적으로 만족을 한다고 가정을 들어간다
아시겟죠 분산환경이잔아요 

그래서 그런상황에서 그사람이 뭐라헸냐면 
결과적으로 이 컨시스턴시와 어벨러빌리티를 갖다가 키를 만족하고 있는 상태에서 결과적으로 c아니면 a를 만족을 시켜야 되는데 이게 고온? 이게 바이너리 처럼 하나가 1이면 하나는 0 하나가 1이면 0이고 그런게 아니다 라고 이사람 애기를 하는거다
그래서 여기서 보면 ap 시스템 같은 경우는 자 
ap , a를 선택한것이다 어벨러빌리티선택 어벨러빌리티를 선택을 한다고 해서 이게 c를 갖다가 무시하는게 아니라 베스트 에펄트 로 c를 제공할려고 노력은 한다 라는거임
자 마찬가지로 cp 시스템도 역시도 c하고 p선택하긴 했지만 자 a를 갖다가 어느정도 선에서 희생하고 베스트 에펄트 어벨러티 를 보장을 할려고 노력을 한다라는 얘기지 저걸 가져다 상그리 그냥 무시하고서 c하고 p만 서포트하는것은 아니다 
이사람이 얘기 한다.

## 예제
그 cap 잔아요 
컨시스턴시를 만족하고 어벨러 빌리티를 만족을 합니다 그런데 파티션 톨러런스는 물론 베스트 에펄트로 통상적으로 일단 거기에 대한 프라이어티는 낮춰놓고 일단 c하고 a를 갖다가 만족하는 그런 시스템을 생각해보면 티피컬하게 rdbms이다
그쳐 
rdbms 그래요 
데이터가 굉장히 디스트릭트 하게 컨시스턴트 함을 보장을해야한다 그쵸 어벨리어블 함도 보장을 해야함 그런데 파티셔닝을 갖다가 팔러런씨가 일어나는것에 대해서는 충분히 얘네들은 ok 입니다. 그게 데이터가 컨시스턴트하기만 하면은 그리고 그게 직접적으로 여러분들한테 어벨러 빌리티를 갖다가 보장을 해주면 상관이없죠 항상 예를들면 여러분 뱅킹 시스템을 생각해봐요 그 네트워크 장애가 일어났다고 해도 사실은 별상관이 없다 여러분들 한테 들어있는 그 돈이 정확하게 남아있고 항상 명확하면 상관이 없다 아시겟죠 그게 ca 시스템이다.

p에 대해서는 어 이면 좋지만 아니어도 굉장히 스트릭트 하게 요구를 하지 않는다 뱅킹 시스템 같은 경우는요
자이게 그리고 어 c하고 a시스템이죠

c하고 p를 바라봐라 이것역시도 마찬가지인데 이게 rdbms 가 많
ca cp 시스템은 굉장히 비슷하다 cp시스템이 아까 얘기한거와 더 맞는 시스템이다이거는 수정을 할게요

cp 시스템이 사실은 뱅킹 시스템, 이때말하는 뱅킹 시스템 같은경우는 파이넨셜에서 나오는 그런 그 주식같은거 그런 시스템을 얘기를 하는건데 얘네같은경우 cp 시스템이다 그리고 ap 시스템을 조금 바라보면 우리가 지금까지 배웠던 어 nosql 같은 경우 티피컬 하게 nosql 디비같은게 ap 시스템이다 왜냐하면 이 컨시스턴시 자체를 굉장 히 스트릭트하게 요구를 하지 않아도 된다. 

그래서 얘네들은 이벤츄얼 컨시스턴시를 갖다가 만족시킨다 이벤츄얼 컨시스턴시 자체가 사실은 베이스 에펄트 컨시스턴시에요 걔네들이 제공해줄수있는한 베스트 에펄트 로 제공하고 안되더라도 어쩔수 없다라는게 베스트 에펄트다

티피컬하게 

dns도 마찬가지다 여러분들 네트워크 dns 가져다 업데이트해보면 그게 dns가 곧바로 그게 프로퍼게잇 되지 않는다
아시져 네트워크 dns 를 갖다가 이름을 딱 바꿔보세요 바꿔보면 어느정도 일정시간이 지나서 바뀐다 굉장히 nosql 데이터 베이스ㅇ 얘네들한테 굉장히 비슷한 이치로 작동한다
그리고 클라우드 컴퓨팅 같은것도 마찬가지다 얘네들도 컨시스턴시 자체가 중요한건 아니다 클라우드 서비스 자체가요 
자 어쩃거나 cpa 시스템에서 예를 봤다.

## 노시험
철저하게 정보, for you information

# Spark
제가 생각하기에 빅데이터 수업 커리큘럼을 짜면서 스파크 
할수있다면 하자 
스파크였었다 구지 얘기하자만 이 두개가 사실은 가장 핵심이 됩니다 제가 첫시간에 
그런 키워드를 갖다가 꼽을떄 몇개만 꼽아봐라 하둡 맵 리듀스 라고 했음
유효, 모든 기술 그렇듯이 발전을 하기떄문에 지금 들어와서 지금 들어와서 현재 만약에 핵심 단어 뽑아봐라 여러분들은 스파크 라고 해야한다. 하둡 조금더 말씀드리면 하둡이라는 
스파크를 갖다가 별도로 생각하지마라 
하둡이라는게 맵 리듀스를 말하는건 아닙니다 하둡에 그 에코 시스템은 굉장히 넓다 그리고 이 스파크 라는 거는 뭐에 대한 
스파크 라는건 맵 리듀스에 대한 카운트 버프?? 지 이 하둡에 
스파크 라는게 하둡에 카운트 파트가 아님

아파치 스파크도 궁극적으로 결과적으로 하둡에 프레임워크에 들어간다 하둡 그 밑단에 있는 그 하둡 프레임 워크 가 있고 그 위에 뭐가 돌아가느냐 에 요 근데 우리가 예전에 이제 했던 맵 리듀스가 하둡을 
그런 컴퓨팅의 프레임워크였고 그런 모델이었다 그게 아니라 걔네들이 어느정도 시간에 따라그런 한계가 나온다 그런 한계가 보이니까 새로운 컴퓨팅 모델로 나온게 스파크지 기존에 하둡이란걸 자르고 노면 하둡 나는 스파크 이런게 아니다

아시겟죠 
그 굳이 얘기하면 하둡이 있고 그위에 맵 리듀스라는게 있고 그거랑 카운트 파트로 스파크가 있는것이다 그 두개가 맵리듀스와 스파크가 동등한 관계다.
스파크와 하둡이 동등한 관계가 아니라

## 리미테이션 오브 맵 리듀스
하둡이 나온게 2000년대 초반임 그러다 보니까 물론 하둡 자체 가 문제라긴 보다는 하둡은 그 나름대로 하둡의 맵 리듀스 라는것은 그 나름대로 그 시대에 맞는 굉장히 최적화된 새로운 어떤 어떻게 보면 굉장히 혁신적인 모델은 맞아요 그자체가 틀린것은 아니다 
근데 저 시대는요 2천년대 초반은 ssd 나 그런시대가아니다 그런 좋은 시대는 
사람들이 다 하드디스크를 쓰던시대고 
그리고 메모리값이 똥값이 된 시대가 아니다. 비싸거든요
자그러다 보니까 그런 환경, 그런 클러스터 로 이루어진 하드 디스크 위주에 램이 많지 않고 하드디스크 위주로 돌아가는 그떄당시에 클러스터 분산 환경에서 얘네들이 나온 모델이기떄문에 지금의 환경에 들어서 점점 리미테이션이 보이기 시작한다.

일단은 요거는 하둡의 면이거는 일단 접어놓고 나중에 다시 말씀드리기로 하고 맵 리듀스가 사람들이 집행을 하게되는 리미테이션 얘기를 해보고 넘어가지
하둡은 제가 아까전에 보여 드렸다 싶이 기본적으로 밑단에 hdfs 가 깔려있다. 있고 그위에서 그데이터를 읽어가지고 맵과 리듀스 라는 그런 커뮤니케이션 프로그래밍 모델을 가지고서 어 작동을하고 다 컴퓨테이션이 끝났을떄 그걸 다시 hdfs로 해가지고 
클러스터에다가 데이터를 씁니다 자 티피컬한 과정입니다.

인풋데이터가 있고 그인풋데이터를 갖다가 hdfs를 이용해서 읽어요 
그러고 서 하나의 그런 언털액션을 둡니다 그런데 이 하나의 과정을 살펴보면 여러분 이미 알고있다 이 인풋데이터를 갖다가 128 메가나 64메가 단위로 청크를 쭉쭉 나눠서 걔네들 각각 맵에다가 할당이 되겟죠 맵이라는 공간에 할당이 되고 맵퍼 가 각각 맵퍼가 
결과값을 갖다가 리듀스에다 던져준다 그럼 그 리듀스는 중간 결과값을 가지고서 다시 지네들끼리 컨커런트 하게 돌아가면서 최종 아웃풋 은 내고 개네들을 hdfs 를 돌려서 다시 씁니다. 그렇죠 그게 굉장히 티피컬한 과정임 
근데 예를들어가지고 이런 과정 이 자체가 만약에 이게 또 한번 더 돈다 여러번 돈다 라고 생각해보면은 굉장히 문제가 생긴다 왜냐하면 자 이런 오퍼레이션이요 한번에 컴퓨테이션이 끝나면 괜찬은데 이런 게 여러번 돌아야 되는게 있어
가장 쉬운게 바로 잘알고있는 머신러닝이다. 흔히 애기하는 딥러닝이다. 
딥러닝은 어느정도 개념알겠지만 자 그 데이터를 읽어가지고 트레이닝을 하고 결과값이 나오면 다시 읽어서 트레이닝 하고 그런 관계로 계속 돈다 그게 몇 레이어 냐에 따라가지고 계속 돈다 결과적으로 이런 인터렉션이 계속 반복된다. 근데 그거를 갖다가 여러분들이 하둡을 가지고 이 맵 리듀스 프레임 워크 가지고 해보면 자 hdfs 읽어가지고 또쓰고 읽어가지고 또쓰고 그짓을 계속한다 아시겟죠 근데 이거의 문제 가 뭐냐면 기본적으로 얘네들은 하드디스크에다가 이게 플러시 한다라고 가정을 한다. 그럼 하드디스크를 갖다가 썻다 읽었다 썻다 읽었다 그짓을 계속한다 그러다 보니까 이 디스크 i/o 라든지 이게 실질적으로 많은 부분이 네트워크 바틀렉이 많이걸린다

네트워크 바틀렉 이라느 이런 모든것들이 특별히 어떤데 잘 안맞느냐면 저런식으로 반복적으로 계속 스테이트 돌면서 해야되는 그런일에는 이 모델이 잘 안맞는다.
돌아갑니다 실제 돌아가는데 훨씬 오래걸린다.
그리고 이제 그래프가 되도 
그리고 또 나오는게 뭐냐면 모든 프로그램들이 배치 작업만 있는건 아니다
당장 그것만 쉘 스크립터 제가 곧바로 타이핑을 하잔아요 그게 인털액티브 모델이거든요
자 어떤 빅데이터를 처리를 하고 뭔가를 할떄 항상 뭐 모든 하나의 갖다가 배치를 만나서 던져놓고 끝나는 그런 모델만 있는건 아니다 내가 하다가 그떄그떄 맞게 에드 혹 콜 이라고 하잔아요 그런 에드워쿼리 같이 
중간 결과값을 통해서 내가 잽싸게 무슨 결과값을 받아내고 싶은 경우도 있는것이고 하다가 다른일을 할수있는거고 그런게 인털액티브 모델에 그게 기본적으로 하둡 맵 리듀스 모델에는 맞지 가않고 그런 기능 자체를 제공하지 않는다 걔들은 인털액티브 모델로 나온게 아니라 철저하게 배치작업으로 나온것이다
그런 모델에는 맞지가 않다 얘네들이
그러다 보니까 이제 조금더 얘네들 그 단점 을 살펴보면 

## MapReduce : Weaknesses and limitations
네트워크 커뮤니케이션 코스트가 굉장히 많고
그리고 그 ??? 계속 쓴단 말이에요 읽고 쓰고 읽고 쓰고 디스크 I/O 가 많다.
그리고 메인 메모리를 갔다가 얘네들은 잘 이용하지못한다 인메모리 형태로 나온게 아니다. 그때 당시는 메모리가 비싸서 애시당초 그래서 아웃풋 을 디스크에다가 괜히 많이 쓰는게 아니라 어쩔수없어서 선택이었던것임

프로그램 모델 측면에서 바라보면 
빅데이터를 가져다 처리를 하는데 항상 그 처리할 수있는 모델링 형태가 옛날 맵 리듀스 요형태로 만 구성되는게 아니다 처리를 할떄 얼마든지 다른 맵만 쓸수 도 있는거고 리듀스만 쓸수도있는거고 아니면 그런 모델이 아니라 전혀 다른 모델로 처리를 할수있다고 하는데
맵 리듀스 모델은 기본적으로 항상 그런 그 프로그램 모델 자체를 맵퍼 로 짜고 그맵퍼에 결과값을 던져주면 리듀스가 받아가지고 최종결과값을 내는 그런 과정이다. 그런데 모든 프로그래밍이 그렇게 구성되는건 아님 실제 그렇다
그리고 어 기본적으로 보시면 이게 멀티플라이로 돌아가서 그렇지 통상적으로 그 하둡의 맵 리듀스 단계는 멀티플라이 이렇게 돌아가지 않는다 제가 그 워드카운트에서 보여드렸잔요 한번 큰데이터를 쭉읽어서 배치처리해가지고 맵 동시에 쫙 보내고 그러고 리듀스돌고 탁 던지고 끝나는 경우가 더 많거든요 인털랙티브 경우가 별로 잘없어요
여기다가 끼어 맞출려다 보니까 그런거지 통상적으로 이셋트 도는경우가 많다 근데 말씀드렸죠 이 머신러닝 이라든지 이런것들은 멀티스텝을 돌아야 되는 경우 굉장히 많다 멀티스테이지를 돌아야 되는 경우가 많다.
그러니까 이 멀티플 맵 리듀스 같은 경우는 그런게 잘맞지 가 않다 이 리듀스 
맵 리듀스 모델 자체에서는 
그리고 데이터 타입이라든지 sutrct 을 가져다 컨트롤 한다라든지 글고 리얼 타임 프로세싱이 나오는데 애시당초 맵리듀스 배치 잡이기 떄문에 리얼타임 프로세싱이 맞지 않다 우리가 그 스트리밍 모델을 빌려오면서 거기 보시면 애시당초 큰 데이터가 실시간으로 들어오는데 그걸 가져다 처리하기위해서 어떻게든 최대한 뭔가를 세이플링을 한다던지 뭔짓을 해가지고 최대한 데이터 규격으로 아니면 컴퓨테이션을 줄일려고 하잔아요 그게 왜냐면 리얼 타임 처리에서는 많은것을 가져다 동시에 기다렸다가 한번에 촥 그런 모델이 말이안됨 그런데 보시다싶이 맵 리듀스 잡 자체는 데이터를 기본적으로 쭉 다읽어요 다 큰 데이터를 읽어서 그거를 파싱을 하고 파싱을 하던지 아니면 가져다 청크를 가져다 나누던지 해가지고 다 맵핑을 시키고 그다음에 리듀스가 태스크를 받아가지고 다시 처리한다던지 그방식으로 돌아간다 잘생각해보면 말씀드렸죠 그런 거는 스트림모델에 맞지가 않는다. 그 스트림모델이라는게 들어온거, 나가면 그만인건데 그걸 가져다 언제 다 모아가지고 기다려가지고 그많은데이터를 다 읽어가지고 맵핑을 시키고 리듀스를 시키겠냔 말이에요 실질적으로 얘네들은 그런 리얼 타임 프로세싱에 잘맞지 않는다.
그래서 이제 생각한게 뭐냐 이런 문제점이 나왔을떄 그 이걸 만든게 버클리에서 만들었는데

## 솔루션
메모리값 싼대 
메모리값 싼대 메모리 많이 씁시다.
가 첫번째 솔루션이고 두번쨰가 그 디스크 를 ssd로 바꾸자 이거는 
좀 현대 시대에 맞는 얘기일 뿐이다
이거는 그런데 
첫번쨰 가 
인 메모리 프로세싱이다. 메모리를 가져다 굉장히 많이 박아가지고 메모리를 촥 읽어들여서 메모리에서 처리
아까 성능 차이 보여드렸죠 그래프 지나가는데 몇초도 안걸립니다 근데 저 몇분이 걸렸던일이 몇초밖에 안걸리거든요 그게 가능한이유는 디스크에서 처리를 하느냐 아니면 그거를 가져다 매번 아니면 메모리에서 처리하느냐 차이이다. 상식 적으로 생각해보세요 비교가 되냐고 메모리 속도랑 디스크속도가 비교가 어떻게 비교가되요 스파크 가 빠른거는 너무나 당연한 얘기다

근데 다만 시대에 흐름에 맞춰서 가는거다. 
데이터를 갖다가 메모리에다가 로드를 하자 

요즘 들어서 ssd 값이 싸지니까 하드 디스크를 갖다가 이제 ssd 로바꾸게 되는데 이게 
이거는 얘네들의 핵심 아이디어 키아디어가 아니다 바꿔말하면 얘네들 디스크에 다 많이쓰잔아요 이거를 ssd 로 바꾸면 얘네들 더 빨라져요 실제 그렇다. 하둡을 ssd바꾸면 성능 좋아진다
근데 이게 얘네들이 ssd로 바꿔서가 아니라 인메모리 프로세싱을 하기떄문에 그렇다
그래서 키 아이디어가 첫번쨰

이거 트레이닝 하게 요즘 시대에 맞게 넣어놓은것이다

## what is apache spark?
자그래서 스파크가 나오게된다.
어 이게 뭐냐 스파크가 뭐냐 자 클러스터 컴퓨팅
프레임워크다 
맵 리듀스 마찬가지다.
오픈소스다
그리고 자 얘네는 기존에 있는 맵 리듀스 펑션을 가져다 확장을 한다 어떤 책에서는 맵 리듀스의 모델이 아니라 새로운 디자인을 했다 전혀아니다.
맵 리듀스를 확장 한것이다. 실제 그 소스코드를 더 변경한것이다 실제 얘네들도 맵퍼와 리듀스에 그런 어 모델을 많이 따릅니다 실제 워드 카운트 보여드렸죠 그게 슬라이드 .? 맵과 리듀스로 되어있다 그래서 기존에 있던 맵과 리듀스 모델을 더 확장해서 다양한 실시간 리얼 타임이라든지 아니면 그런 인털액티브한 그런 머신러닝이나 그런데 더 잘 작동하도록 그 컴퓨터 모델을 바꾼거고 더 확장을 시킨거고 더 성능
그걸 가져다 개선한것이다.
말씀드렸죠 인메모리 프로세싱을한다. 
## Why Apache Spark?
스파크 좋은이유
어쩃거나 스파크니까 스파크 칭찬
왜좋으냐 
디벨롭퍼가 쉽다
자 실제 그 인털액티브 한 모델에서 쉘이용해서 거기서 실제적으로 여러분들이 인터프린터, 스칼라 아니면 그런 파이썬 라인 바이 라인으로 실행가능 근데 여러분들 이 하둡 맵 리듀스 에서 워드 카운트 실행시켜봤죠, 거기서 여러분들이 코드를 자바로 짜고 그거를 가져다 jar 파일로 만들어 가지고 일일 히 다 그렇게 해가지고 배치적으로 촥 던진다. 물론 얘네들 도 똑같이 할수있다. 똑같이 jar 파일 만들어서 그대로 던질수있다 얘들은 거기다가 +알파로 이런 인터렉티브한 쉘이나 그런 기능도 같이 제공을한다 훨씬더 수월하고 여러분들이 쉘이 (인터렉티브)이 있으면 뭐가 좋으냐면 초기에 여러분들 작업을 갖다가 어 테스트 해보기 위한 코드를 짜보거나 그런 테스트용 그런거 금방금방 해볼수있다 근데 하둡같은 경우는 그런것을 하기위해서 그런 풀 센텐스를 만들어가지고 jar 파일로 만들어서 배치작업 던지고 계속 그짓을 해야함 그래서 훨씬 디벨로퍼 하기가 편해 
그러면 이제 유니파이 스택이 나오는데 어 계속 말씀드렸다싶이 배치작업 뿐아니라 스트리밍 모델도 제공을 하고
디펠로먼트가 플렉서블하다 기존에 있는 hdfs나 로컬파일 시스템 이런거 다쓸수 있을 뿐더러 여기보면 yarn 뭐 리소스 이렇게 나오는데 이 yarn라는건요 얘네들 한테만 있는건 아니에요 사실 하둡 2.0 여러분 숙제하시면서 쓰셨을떄 거기 이미 어 yarn들어있어요 그리고 얘네들 만의 특별한모드는 아니니까 
여기에 얘네들 모를 리소스 라는게 들어간다 리소스라는게 어 yarn 과 똑같은 일을 하는데 얘네들은 똑같이 아까전에 버클리 랩에서 만든 그 클라우드 리소스 매니지 먼트 에요 yarn이랑 똑같은 놈임 어쩃든지간에 스토리지 라든지 디플로우 할떄 그 리소스 매니지 먼트 레이어는 또 다양하게 쓸수있다 라는거 
그리고 랭기지를 가져다 자바나 그런거 뿐만아니라 스칼라 지원하고 파이선 지원 r도 자바 지원
그리고 이제 빠르다 물론 얘네들이 주장하는건 빠르다 이다 가장 중요하다
훨씬 빠르다.
100배 인메모리 프로세싱을 하니까요 업투 
통계에 민감 ㄴㄴ

## project history
2009에 나옴 최근임
버클리에서 굉장히 유명한 랩임 amp랩
시대를 바꿔놓은 혁신적인 아이디어가 여기서 많이 나옴
만들고 나서 오픈소스로 뿌림
아파치 라이센스 에 뿌린다
내가 쥐고 있는게 아니라 풀어서 같이 발전
얘네들은 이때 만들었던 이사람은 졸업하고 나서 어디로
스파크가 워낙 될성 싶은거 굉장히 뜨기 시작함 회사 databricks 를 차림
데이터 브릭스는 하둡에서 그런 걔네 디스트리비우트
스파크에서도 똑같은 일을 담당 왜냐하면 지가 만든거다. 이회사를 차려서 디스트리비우터로 하게된다.
지금 여러분들 딥러닝 할떄 쓰는 프레임 워크임
스파크 클러스터 잔쯕 만들어서 
실제 현재이다. 포스트가 아님
2013년 뛰져 나와서 회사를 차렸는지 그래프만 봐도 알수있다 폭발적으로 인기를 얻는다 거의뭐 지금 현재로서는 왕인거 같다. 

머신러닝, 딥러닝 할떄도 많이쓴다.
## why a new programming model?
새로운 프로그램 모델이다 
맵 리듀스 랑 클러스터 컴퓨팅에 그런 컴퓨팅 모델, 프로그래밍 모델 이었다.
그 프로그래밍 모델에 따라서 여러분들이 코딩을 해야했고 그리고 모델에 따라서 데이터 처리한다 그거랑 다르게 이제 얘네들 이제 맵 리듀스 라는 모델이 나오고 나서 새로운 그런 그 프로그래밍 모델에 대한 그런 크레이밍? 그런 그 발전 이라고 해야되나 그런 경우
사람이 그렇다 모든지 일단 좋은거 받아들이고 적응하고 나면 절대로 나빠지기 힘들다 새로운걸 좋은걸 바라게 된다 맵 리듀스 모델이 나오고 나오서는 열광을 했지만 사람들이 써보니 하나 둘씩 불만을 보인다 
실제 사실은 맵 리듀스 라는 프로그래밍 모델 이 그떄는 굉장헀었다.
진짜 핫함
그런식으로 사람들이 생각하지 못함 그런거를 만들어놨는데 쓰다보니 배치프로세싱 전담해요 근데 데이터를 프로세싱을 해 보다보니 배칭 프로세싱만 답은 아니다이런거임
그러고 이제 물론 그 맵 리듀스가 사실은 금방 나오자 마자 

사람들이 좋은걸 요구함
가장 이거임 멀티스테이징 
말씀드렸죠 한번 딱 인털액티브하게 돌고 끝나는게 아니라 돌고 중간 결과값을 가지고 또돌고 이런 방식 멀티 스테이지를 도는 그 인컬시브하게 인털액티브 하게 도는 이런 프로그래밍 을 가져다 이런 그런 모델 요구하게 된다.
그래프 모델 이나 머신러닝 가장 굉장히 티피컬하다. 

이런걸 하는 사람들 그런 불만이 나온다 그런것들도 지원해주면 안되겠니라고 컴플레인 하기 시작함 그리고 

클러스터 컴퓨팅을 하게될때 이제 가장 대표적인 컴퓨팅 모델이 있는데 어 배치 작업과 리얼 타임 작업이다. 배치작업은 굉장히훌륭하다. 근데 리얼 타임 경우는 잘 맞지 않았다.
그리고 이제 db나 그런쪽 한 사람은 불만 , 이건 에드쿼리를 갖다가 좀 지원해주면 안되겠니 이런 생각을 하게됨 에드워쿼리를 갖다가 지원을 하게된다 라는 말자체가 인털액티브 모드인것이다. 인털액티브 모델이 아쉽게도 그 맵 리듀스에서 는 인털액티브 모델 자체를 지원하지 않는다아시겟죠 그런 아쉬움들이 나온다 그런 현장에서 요구 + 램값도 싸지게 되고 예전에 비해서

그러고 ssd 조금더 보편화 되고 이런 하드웨어 환경과 그리고 현장에서의 그런 요구가 맞아서 나오게 된 모델이 스파크 이다.

## Data Sharing in MapReducce
그리고 데이터 쉐얼링이 나와야 되는 이유가 멀티 스테이지를 고르기 위해서는 어쩔수가 없어요 데이터를 가져다 좀 쉐어링 해서 계속해서 멀티스테이지 인털액티브 달라고 해야하거든요

근데 아까 말씀드렸다싶이 hdfs 같은 경우는 애시당초 그런 모델이 맞지 않다.
애시당초 
쓰고 하드디스크에 읽고 돌고 쓰고 이런 모델링 자체가 안맞게되는데
자 스파크 경우는 말씀드렸죠 인메모리프로세싱 기본적으로 인메모리 프로세승을 하게된다 한가지 오해하지 말아야 할것은 인메모리 프로세싱이라고 해서 주구장창 메모리에서만 다 올려놔서 하는건 아니다 기본적으로 얘네들이 인메모리 프로세싱을 가져다 페어프렌스 하는거지 하드디스크에서 안돌아가는 그런 전혀아니다 
그 메모리를 가져다 얘네들 파악해서 최대한 잘 활용하는것이다 
실질적으로 얘네들 캐시까지 활용해가지고 실질적으로 얘네들 캐싱까지 활용하는 그런 프리세스턴트라는 그 펄시스트 라는 그런 명령은 아니짐 캐슬이라는 명령을 이용해가지고 여러분들이 원하는데이터를 가져다 아예그냥 메모리에 다 박아놓고 쓸수있는 그런 기능을 제공하는 정도로 기본적으로 메모리를 잘활용하는건 맞지만 메모리 가 부족하다고 해서 안돌아가는건 아니다 프로그램이 모델링 이 달라졌다는 측면에서 이해를 해줘라

어쩃든 얘네들은 기본 핵심 자체는 인메모리 프로세싱이다. 
데이터를 가져다 제일 처음에는 당연히 빅데이터를 가져다 어 디스크에서 읽어와야겠죠 읽어오지만 그다음에 돌고 나서 나오게되는 그 처리가 되는 데이터들은 기본적으로 용량자체가 일단적으로 작아지게 떄문에 그 작아지는 데이터를 가져다 어 메모리에 넣어가지고 계속 메모리프로세싱을 한다 계속 인털액티브하게 메모리에서 돈다
그러니까 기본적으로 빠를수밖에 없는것이다
자 이건 뭐 맵 리듀스랑 스파크 차이점 제가 슬라읻 그림이 예뻐서 넣어놨다.

## MapReduce vs spark
똑같은 얘기다.
설명하지 않는다.
같은 얘기다.

## spark data flow
이건 뭐 제가 누차말했다.
디스크 에서 읽어들어와가지고 이제 그 프로세싱을 하고나서 이제 메모리에서 계속 인털액티브 하게 돌리는데 얘네들의 프로그램이 모델이 다른게 
이제 맵 리듀스 란 다른게 그런점이다.
맵 리듀스는 기본적으로 항상 맵퍼에 투 스테잊 
얘네들은 그런 투스테이지 모델을 따르지 않는다. 
인털액티브 하게 도는데 여기에서 훨씬더 다양한 종류의 그런 프로세싱, 프로그램 모델이 따로있다 얘네들은

그런데 맵 리듀스는 기본적으로 무조건 데이터 프로세싱 모델 자체가 맵 과 리듀스로 두단꼐로 나눠져 있다. 그리고 여기서 보면 데이터를 갖다가 어떤 데이터가 지나가느냐 어떤식으로 보면 뭐 wroking set을 갖다가 extract 하고 캐시를 하고 그리고 반복적으로 쿼리를 한다 
어쩃거나 이런 액션 자체를 가져다 메모리 라고 작업을 하는데 그래서 얘네들이 홈페이지 들어가면 맨날 과장되었다고 생각하지만 매일 자랑하는게 나오는게 데이터 왜
100배가 되는애들이 더 좋은데
라고 했을때 맨날 내세우는 홈페이지에 떠있는데
이겁니다
머신러닝에서 가장 많이 쓰게 되는 기본적인 릴레이션이다 그런 알고리즘이다 그거를 가져다 이제 하둡 에서 돌리는건아니고 맵 리듀스라는 프로그래밍 모델로 실행했을때랑 그리고 그거를 가져다 스파크 모델로 실행했을떄 성능차이를 봣더니 거의 100배이상 차이나더라 100
그래서 우리는 100배 짱 빨라요 사실은 

맵리듀스 
서킷에 얹혀놓고 트럭 달리면서 애시당초 용도가 그게 아니다 틀린감 자체는 아니기 때문에 좋든 싫든 스파크 다룰 생길 거라고 생각하는데 그떄 여러분들한테 

이런 데이터를 가지고서 우리가 100이상 빨라요 주장함

## Spark architecture
아키텍쳐는 크게 다르지 않다 왜냐하면 기존에 있는 하둡 위에서 돌아간다. 
그래서 여러분들이 하둡 을 이해하셨다면 이자체는 낯설지 않다
얘들도 기본적으로 마스터랑 슬레이브 구조로 돌아간다 보자마자
스파크 드라이버가 있는데 이게 뭐 스파크 드라이버라고 뭐 특별한거 아니다 이 드라이버 프로그램은 여러분들이 그 맵 리듀스 하시면서도 이미 말씀드림 그런 잡에서 런 프로그램 같은 실제 배치작업을 잡 자체 
맵퍼 와 리듀스는 여러분들은 짤수있찌만 그거를 가져다 실행하기 위한 그 자바에서 코드가 있는데 그 코드, 소스코드
런이랑 코드 그게 드라이버 코드다 
실제 그게 맵퍼와 리듀스를 가져다 어떤 식으로 수행할껀지에 대해서 실제 수행을 시킬려는 코드인데 이것 역시 똑같다 이거는 이제 대신 맵 리듀스가 아니라 스파크 용 그런 드라이브 코드이기 때문에 드라이버 스파크 드라이버 써있을뿐이다 그런 맵 리듀스에서 보셨던 그런 런 코드랑 같다.

그게 있고 클러스터 매니저 가 뭔데 지금 여러분들 노트북에서 따로 실행시키면은 이 클러스터 매니저 쓸일 없다. 리소스나 얀을 쓸일은없다 클러스터에서 리소스매니지 먼트 하는 레이어다 어쩃거나 기본적으로 클러스터 컴퓨팅 모델이기떄문에 자 그 클러스터를 가져다 리소를 가져다 매니지 하게 되는 어떤 태스크를 어느자리에다가 어디다가 할당하고 아니면 어떻게 읽어오고 스케쥴을 어떻게 하고 그 모든것을 가져다 이 클러스터 매니저 담당함
이 레이어가 여기만 있는건 아니다

맵 리듀스도 똑같이 있다. 
그리고 마스터가 있고 그리고 그 밑에 실제 일을하게되는 노드들 슬레이브들
노드들이 잔뜩있다.
스파크 워크 라고하는데 얘네들은 워크노드라고 애기를 해요 근데 똑같은 얘기이다.
데이터 노드에요
하둡에서 데이터 노드랑 똑같습니다
데이터 노드들이 있고 hdfs 밑에있잔아요 그렇죠 아까 보여드렸죠
그게 요 구조가 그대로다 구지 hdfs 
그런 밑에 그런 클러스터 위에서 돌아갈수있는 그런 분산 파일 시스템이 존재하고 그 위에서 이제 어 데이터 노들이 쫙쫙 올라가 있겠죠
그쵸 그리고 이제 그 데이터 노드를 가져다 매니지 하게 되는 그런 매니저 가 있고 그위에 실제 그런 코드을 갖다가 이제 드라이브 하게되는 그런 여러분들의 노트북이 될수도있고 아니면 컴퓨터가 될수도있고 그런 드라이브 코드로 돌아가게 되는 구조이다 그런데 이거는 조금은 하드웨어 적 스페스픽한 그런 아키텍쳐다 근데 좀더 소프트웨어 사이드 에 와서 보게되면 자 비슷하다
드라이버 프로그램 

아까 여기도 드라이버 있었죠
요거는 이제 클라이언트 뭐가 되든 그런 노드고 그거는 이제는 소프트웨어 적 바라봤을때 그 여러분들이 
제 노트북 실행해서 제 서버에서 일을 던져준다 드라이버 프로그램 자체도 노트북에서 돈다 그런 드라이브 프로그램이 있고 그속에 스파크 컨텍스트 라는게 있는데 이게 여러분들 
맵 리듀스, 코드를 
그떄도 context 있었음
이 코드에서 여러분들이 만약에 드라이버에서 일을해라고 던져줄때 그러면 어떻게 어디가서 뭘가지고와서 그렇죠 그런 컨텍스트 그게 컨텍스트에요 , 그런정보를 던져주는 프로그램이 스파크의 컨텍스트 프로그램이다 이게 물론 개최 클래스있고 파라미터만 주면그만인데
이 들어가는 파라미터가 그런거 파라미터다 실제 마스터 가 있는 ip주소 아까 같은 저같은경우는 그 로컬 로 줬잔아요 그쳐 로컬 주면 그 아이피는 따로없으니까
그다음에
그런 마스터의 아이피주소라던지
아니면 그런 클래스이름 jar파일 위치라든지 그런걸 명시해준다
컨텍스트
그거를 가지고 그 드라이버 프로그램 을 만든다. 실제 드라이버프로그램내에서 스파크 컨텍스트가 있다

그리고 실제 아까 그 클러스터 매니저 가 있는데 여러분들이 뭔가를 볼 필요가 있는건아님 사이에 그 리소스 매니지먼트 하게되는 리소스 얀 같은 게 들어가고
그 밑에 이제 각각 들어가게 되는데 노드들이 들어가게 되는데 밑에있는 실제 그 일을 수행하게되는 자 이게 맵퍼였었잔아요 
맵퍼가 리듀스였단 말이에요 왜냐하면 맵 리듀스는 그 두개에 어 프로그램으로 돌아가기 떄문에 얘네들은 그걸 가져다 따로 맵퍼 아니면 리듀스 따로 두잔아요 원래 맵 리듀스 두개를 줬으면됬는데 애들은 엑스큐터라서 그런다
근데 실제 하는일은 어쨋거나 개네들 그런 태스크 받아가지고 그런 일을 담당하는건데 그 걔네들 그 코드, 그 데몬 코드를 갖다가 얘들은 엑스큐터라고한다
그 엑스큐터가 그 태스트 쭉쭉 봐가지고 일을 처리한다 맵 리듀스에서도 똑같이 그 데이터를 나눠가지고 그 태스크를 가져다 던져주면 맵퍼가 그 각각 맵퍼들이 그 태스크를 받아가지고 컴플릿트하게 돌리잔아요 리듀스도 마찬가지고 

걔네들은 이 하나의 노드 속에 맵퍼랑 리듀스가 같이 돌아간다. 그렇죠 같이 돌아간다 근데 얘네들은 그런얘들이 아니니까 엑스큐터가 따로있고 캐시가 뭐죠 이 노란색으로 치뤄내고 있는 얘네들이 핵심이기떄문에 그런데 이 태스크를 받아가지고 이제 이 데이터를 가져다 그 메모리에다가 던져놓고 거기서 계속 작업을 한다 실제 그 중앙값 결과값도 그렇게 던져주고 
제가 아까전에 그 데몬을 보여 드렸는데 맨마지막에 3번쨰라인에 뭐라고 썻냐면 save as text data 

하둡.세이브애즈 텍스트데이터 
hdfs에다가 아웃 풋 줬다
그렇게 하게되면 로컬이든 아니든 hdfs 에서는 그렇게 저장을 해버리지만 그게 아니라 그렇게 하지말고 그전에 데이터를 가져다 읽어가지고 그 데이터를 가져다 여기 캐시에 가져다 올려둘수있다 
실제 그 여러분들이 어 거기까지는 예제가 없는거같은데 일단은 
캐시라는 명령어 써가지고 여러분들이 원하는 데이터를 가져다 따 꼬집어서 얹어 넣을수있다
여러분들 생각하시기에 프로그래밍하고 모델링 하실때 요데이터는 많이 쓰일거 같고 요 중간데이터는 많이쓰일거같다 싶으면 그런 데이터는 코딩을 할떄 찍어가지고 그냥 실제 os에 핑잉을 하듯이 dram에다 올려놓을수있다 그래 놓고 나면 그다음부터는 그데이터는 사라지지 않고 계속 거기서 읽고 또읽고 또읽고 그작업을 한다 자 이 태스크가 어잿건 캐시로 올라와서 이렇게 
작업을 하게되고 그런 노드들이 여러개 붙어가지고 클러스터로 구성이 되는데 
