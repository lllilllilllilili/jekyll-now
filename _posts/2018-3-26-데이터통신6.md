---
post : layout
title : 데이터통신6
---
## 시작하기...
cmd에 telnet cnn.com 80을 치면 cnn.com은 names이고 80은 port 번호다. telent은 멀리 있는 시스템에 원격으로 접속하는것이다.  cnn.com을 입력해서 IP를 얻어오는 과정이고, application 유저입장에서 cnn.dot.com의 IP주소를 알아야 하는데 그것을 Domain name system에서 도와주고 gethostbyname 함수에 cnn.dot.com을 인자로 줘서 IP를 얻어온다. 
cnn dot.com은 유저와 컴퓨터간에 알아야 할 것이고 home server에서 Ip주소를 얻어오는것은 서버에서 컴퓨터의 관계다. name시작해서 DNS시스템을 이용해서 IP주소를 얻어온다.

##address
상대방의 IP 를 얻었다고 전제하에


![데이터통신0.PNG](C:\Users\hik35\Desktop\데이터통신0.PNG)
엘리스는 자신의 IP주소와 밥의 IP주소를 안다.
처음에 Network layer에서 우선 Forwarding table로 간다. 여기서는 목적지 주소 N(B)를 Forwarding table로 보내주면 라우터가 다음 라우터가 어디인지 알려준다.(Forwarding table은 라우팅 프로토콜이 만든다.) 
특히, 라우터는 접점마다 다른 IP주소를 가지고 있기 때문에  다음으로 R1을 갈껃네 그 IP주소가 N1이고 ARP(address reserution protocal), 네트워크 레이어에 있음 - 맥주소를 알려달라 프로토콜이다. 이것에 의해서 메시지를 만들어서 alice에 노트북에 쫙 뿌리면(ARP에 의해서 만들어진 request 뿌려지면) 라우터가 쭉 받아서,R1에 있는 ARP가 받아서 N1에 해당하는 MAC주소를 반환한다. Alice 노트북에 있는 네트워크레이어는 다음 hub의 Mac주소를 얻어왔다.
그 MAC 주소 이용해서 프레임으로 활용하여, 캡슐활르 진행하고 어드레스만 보여주므로써 헤더영역에 붙여서 보낸다.
Network layer을 지나서 data에 헤드로 N(A),N(B)를 붙이고 앞에 MAC주소를 포함하는 L1(목적지 네트워크의 MAC주소)을 붙이고 에 해당하는 L(A)(Alice 노트북 포트의 MAC어드레스 까지 보냄)도 붙인다. 소스와 목적지는 쌍으로 기록
++N(B), N(A) 는 네트워크 IP주소고 L(A), L1은 Alice 디바이스에 MAC주소 목적지의 MAC 주소가 된다.++

++Data-link layer에서는 MAC 주소를 본다++ L1, L(A) 링크레이어 주소도 붙인다. Physical layer에는 다 받으며, 바이너로 해석한다. 이제 보내준다. 

목적지로 와서 Physical layer가 받아서 "내꺼다" Mac주소를 확인하고 올린다. (디캡슐레이션) 
네트워크 레이어에서 N(A), N(B)를 받고 밥의 ip주소가 있으므로 Foewarding table이 있으므로 어디로 갈지 결정을 한다. 하지만 Ip주소만으로는 알수가 없고 mac주소를 알아야 하기 때문에 N3가 갖고있는 MAC주소를 요청해서 R2의 ARP에서 대응되는 자신의 L3을 보내준다.
그다음에 다시 인캡슐레이션을하고 목적지 MAC주소 L3, 자신의 MAC주소 L2를 헤더에 포함해서 보낸다.
네트워크의 ID값을 변하지 않지만 데이터링크 layer에서는 한 홉갈때마다 값이 변한다. 바뀐정보의 값은 ARP을 통해서 온다.
네트워크단에서 R2로 보내지고 Forwarding table로 와서 Ip를 알고 ARP를 통해 BOB의 MAC주소를 받음.
IP주소는 링크주소를 얻어오는데 불과하다, 한 홉 가는데 링크주소만 필요.
L(B)내꺼다, 받는다 데이터링크레이어에서
IP는 링크주소를 얻어오기위한수단에 불과.(그 다음주소)
한홉 갈때는 링크주소를 얻어야한다.

PORT넘버라는게 쓰이는게 없었는데, 트랜스포트레이어에 있다. 어플리케이션 바로 아래에 정의된 주소, 엘리스가 보낸 패킷이 밥의 PC를 찾아오기까지의 과정이다.
밥의 어플리케이션 프로그램이 많으면 도달한 패킷이 밥의 쓰고있는 어플리케이션에 어느것에 해당하는것이냐? 많은 프로세스중에 누구껏이냐를 그것에 대한 PORT를 통해 얻어간다.

PORT가 없으면 어플리케이션에서 어디로 가야할지 모른다.
트랜스포트계층에 헤더 16비트를 차지한다.

## Multiplexing and demultiplexing
Multiplexing and demultiplexing은 트랜스포트 계층서 이루어진다. 트랜스포트 계층은 TCP/UDP 하나를 거쳐야 한다.
TCP/IP는 아래 층이 위층에 서비스를 제공하는 형태다.
FTP나 HTTP는 source이고 FTP 25, HTTP 80 이런식으로 되는데
TCP나 UDP는 PORT 번호를 80보내고, FTP는 25번을 보내는데
하나의 프로토콜인데 특성이 다란 프로토콜을 수행하는것을 멀티플렉싱이고 반대가 디멀티플렉싱이다.
#### Multiplexing and demultiplexing
FTP나 HTTP가 트랜스포트 계층으로 내려오면서 TCP나 UDP에 묶어서 보내지고(멀티플렉싱)
#### Demultiplexing at destination
위와는 반대로 패킷을 읽어올때 트랜스포트계층에서 어플리케이션 계층으로 분화되서 나갈때 디멀티플렉싱이라고 한다.
++tcp는 loss에 대한 복구가 가능하지만, udp는 loss복구가 없다++
## OSI MODEL
네트워크 통신을 전체적으로 다루고 있는 ISO 표준 개방 시스템 상호연결 모델이다.(Open System Interconnection 모델, 일명 OSI)
## OSI 모델의 목적
기본적인 하드웨어 또는 소프트웨어의 변경 없이 서로 다른 시스템 간에 개방 통신을 가능
유연하고 상호 연동할 수 있는 네트워크 구조를 설계하고 이해하기 위한 모델
모든 유형의 컴퓨터 시스템 간의 통신을 허용하는 네트워크 시스템의 설계를 위한 계층구조
++통신과 관련된 모델로 7개의 계층으로 나눠진다.++
## The OSI model
Application
Presentation
Session
Transport
Network
Datalink
Physical
위의 Application, Presentation, Session은 묶어버렸다 TCP/IP 모델엔!

## OSI versus TCP/IP 
전자는 7계층이고 후자는 5계층이다.

## TCP/IP and OSI model

![데이터통신2.PNG](C:\Users\hik35\Desktop\데이터통신2.PNG)
SMTP : 이메일이 이 프로토콜을 사용
FTP : 파일 전송시 이 프로토콜을 사용
DNS : 네임으로부터 IP를 얻는다
TELNET : 원격접속 프로그램
ICMP : 핑 기능을 수행하고
RARP : ARP의 반대 기능을 하며 MAC주소를알때 IP를 얻어준다.
ARP : IP주소 갖고 해당 MAC주소를 구해준다.
라우팅프로토콜 : 포워딩테이블을 만든다. (포워딩 프로토콜은 주기적으로 라우터끼리 데이터를 주고 받아서 어느 PORT로 보낼것인지 라우터끼리 정보를 공유해서 만들게 된다.)

## OSI VS TCP/IP
#### OSI 모델의 실패
이미 TCP/IP로 많이 자리잡고 있을때 OSI로 변경시 돈이 많이든다.
OSI 모델의 계층의 정의가 불명확하다. 계층에 대한 소프트웨어개발도 미비
OSI모델로 전환하기 위한 높은 수준을 보여 주지 못했다.(개선이 많이 안됨)

## Lack of OSI Model' Succes
위에..

## 물리계층
물리적 접속 모드 : mesh, star, ring, bus, hybrid
전송 모드 : simplex(단방향), half-duplex(전방향), full-duplex(양방향)

물리계층은 hop by hop으로 전송하고 각각의 bit가 관심사이며, 한 bit 단위로 한 hop을 보내는것을 책임진다.

## 데이터 링크 계층
MAC 주소를 정의한다. 한 hop단위로 유효하다.
한 hop 단위의 데이터 전송이 관심이다.
데이터 전송 단위가 프레임이다. 
###### 상위 계층(네트워크 계층)에서 오류 없는 물리층으로 보이도록 하나. -> 오류가 발생시, 오류를 복구하면 된다.(물리계층에서 발생한 문제를 데이터 링크 계층에서 복구해준다.)
프레임 구성은 네트워크에서 Header, tail을 붙이는 작업(mac주소를 붙이는 과정)
흐름제어는 hop by hop으로 전송이 되는데 보내는쪽이 너무 빠르고 받는쪽이 느려서 흐름의 미스매치가 생긴다. 따라서 이것을 해소하기 위해 보내고 충분히 응답이 오면 보내고 Receiver의 속도에 맞춰서 보낸다.
오류제어는 10장에서
접근제어는 여러명이 공유자원을 순서를 제공해준다(mac), (multiple access control) 다중접근제어이며 데이터 링크계층에서 한다. 인터넷 접속은 api를 갖고있는 mac을 통해서 제어가 되고 충돌을 벗어날 수 있다.

## 데이터 링크 계층
데이터링크에 앞에는 헤더가 붙여지고 뒤에는 테일이 붙여지고 인캡슐레이션 그리고 디캡슐레이션 과정을 보여주고 있다.

## 데이터링크 계층은
한 hop 단위의 프레인 전송에 책임을 진다.
physical은 한 bit에 대한 정보를 책임진다.

## LAN
이거는 처음에 나왔던것에 축소판인데,
LAN에서 브로드캐스트를 하면(모든 스테이션에 다 보내준다.) 내껏인지 아닌지 MAC주소를 보고 판단을 하게 되는데(ARP 프로토콜을 이용하고) IP만 가지고는 갈 수 없다.
그래서 결론적으론 IP주소만 알고있는 상태에서 ARP를 이용해서 MAC주소를 가지고 보내는게 포인트다.

## 네트워크 계층
패킷을 발신지 대 목적지 전달에 대한 책임을 갖고 있고
라우팅 - 패킷이 최종 목적지에 전달 될 수 있도록 경로를 지정하거나 교환기능

네트워크 계층은 각각의 패킷을 스스로부터 목적지까지 전송할 책임을 갖는다.(HOP이 아니다.)

## 발신지 대 목적지 전달

![데이터통신3.PNG](C:\Users\hik35\Desktop\데이터통신3.PNG)
라우팅을 통해서 다음 목적지 라우터까지 알 수 있고, 구체적으로 (네트워크레이어에있는)forwardtable을 table애서 정보를 주게 된다. hop by hop, 위와 같은 스케일을 보여주고있다.

![데이터통신4.PNG](C:\Users\hik35\Desktop\데이터통신4.PNG)
A와 P는 IP주소이고 10과 20은 MAC주소다.
최종 MAC주소는 95 66 인데 
디바이스 A에서 E로 넘어갈때 링크의 주소는 다음홉에 (20번)이 담겨있어야 하지, 95번이 담겨있으면 안된다. hop by hop으로 mac주소를 파악해서 넘어가야한다.

## 전송계층(transport layer)
전체 메시지의 프로세스 대 프로세스 전달에 대한 책임을 갖는다.
네트워크 층은 개별적인 패킷의 종단 - 대 - 종단전송을 담당 한다.
전송계층엫서는 데이터링크계층과 다르게 오류대상이 다르다.
흐름제어와 오류제어의 단위가 다른데, 복구를 하기 위해서 도움을 요청하는 위치는 그 소스 자체가 된다. 소스와 소스간에 통신이 이루어지고 이것은 데이터 링크 계층보다 스케일이 더 두드러진다.

데이터 링크 계층에서는 데이터가 한 홉 갈 때마다 체크를 해서(받은것을 한홉 단위로 보기 때문에mac이나 이런걸로.. 패킷에 대해서 오류를 찾지 못하지만)
hop 간이 아니라 소스와 목적지간의 오류 복구 개념

전송계층은 패킷이 없어지면 타임아웃이나 다른 방법을 써서 복구하게 된다.

프로세스와 프로세스 간에 메시지를 주고받는 것을 책임진다.

## 전송계층(transport layer)
Network layer(Host - to - host delivery) : 네트워크에 관심이있고 ( 소스 - 목적지 )
Transport layer(Process - to - process delivery) : 각각 시스템에서 도는 프로세스 간에 책임을(전달)지는 transport layer이다. 
어플리케이션 계층으로 프로세스를 확인하기 위해서는 port가 필요하다.

## 표현계층
Encryption : 보안 목적을 위한 데이터 암호화와 복호화 기능
cf, TCP/IP 어플리케이션에서 수행한다.(계층에 흡수)

Compression : 데이터 압축 및 확장 기능

## 응용계층
사용자가 네트워크에 접근할 수 있도록 해줌
사용자 인터페이스 제공

## 각 계층의 기능 요약

## 주소 지정방식
physical, logical, port, and specific

## TCP/IP 주소지정
physical, logical, port, and specific address가 있다.

## TCP/IP 계층과 주소관계

![TCP헤더.PNG](C:\Users\hik35\Desktop\데이터통신이미지\TCP헤더.PNG)

TCP 헤더는 기본 5줄이다.(option은 뺀다.)
프로세스를 구분하는데 port number가 (소스, 목적지) 필요하고 각각 16비트로 되어있다.
port number가 16비트이면 2의 16승만큼 생길수있는데 이중에서 0~1024는 자주쓰는 프로토콜을 위해 지정하지만(http, 80등)
나머지숫자로 port 넘버를 지정한다.
그다음에 있는것이 sequence number이다.
패킷별로 번호 정보가 있다. 이것을 보고 패킷이 없어졌는지 확인할 수 있고 오류 발견시 tcp를 실행하면서 복구한다. ack를 통해 
상대방에게 알려주기 위한 field이고
window는 흐름제어다. 흐름제어는 보내느쪽과 받는쪽이 속도를 맞춘다.
TCP도 흐름제어고 데이터링크도 흐름제어가 있는데
TCP는 end system간에 흐름제어를 하는반면 데이터링크는 hop 단위로 이웃간에 노드의 속도를 맞춘다.
메모리에 받는게 많다보면 메모리 버퍼에 쌓이는데 보내는쪽이 메모리에 남는 부분만 만큼만 보내게 된다. sender에서 남는만큼만 크기를 알려주는 역할을 하는게 window다.
(목적지가 속도를 못넘어가도록 제어한다)
TCP는 REAL TIME 서비스 구현이 어렵다.

![UDP헤더.PNG](C:\Users\hik35\Desktop\데이터통신이미지\UDP헤더.PNG)
UDP는 같은계층 또다른 프로토콜이다.
PORT 두개(소스와 목적지) 기능이 별로 없다. 흐름제어도 없고 오류처리도 없다. 그냥 오면 보낸다.(TCP는 Window field가 처리를한다.)
Real Time이 가능하다. 헤더를 보면 알수가 있다.(프로토콜의 기능)

![IP헤더.PNG](C:\Users\hik35\Desktop\데이터통신이미지\IP헤더.PNG)

마지막으로 IP를 보면 처음에나오는 Version이 Ipv4, Ipv6 맨앞에 표기를 해야한다.(헤더모양이 각각 다르기 때문에) 따라서 버전을 명시하고
요즘에는 pmd가 증가하고 있기때문에 Ipv6로 변경되는 추세인데 이게 2의 128승이다.


## Reference
Behrouz A.Forouzan 저, 데이터통신과 네트워킹