---
post : layout
title : 빅데이터9
---
## 들어가기 앞서서
최소한 한개정도는 존재, level당 한개의 windowsize가 있어야한다. page29
숫자가 있을때 n이라고 치면, n에 자연수를 bit로 표현하고 싶다. logN 요구
logN으로 처리되는 값이 있으면 그 자연수N을 값으로(bit)로 표현할 수 있다.

## 들어가기 앞서서(2)
Exponential window 방법을 배우는것은 컴퓨터내에 bit들이 2의 좌승으로 증가되는것과 같은이치다. 

## 타임스탬프
타임스탬프 
스트림 데이터중에 n사이즈만 볼것이다, 새로운것이 들어오면 n사이즈중에 끝에있는것이 나간다.
n개만 본다. 타임스탬프가 굉장히 큰값이다.(증가만한다.) DIGIM method에서 타임스탬프를 표현할때 logN만 필요한이유, 실제 타임스탬프 값 신경쓰지 않는다. 들어오는 데이터들의 순서만 비교한다. 타임스탬프의 용도임 (긴 숫자를 저장하려면 필요없으니까 모듈러 n을 해준다. 커봐야 n을 넘지 못한다.)
0~n-1 값밖에 안나온다. 그래서 타임스탬프값을 n만큼만 가지고 있으니까 logn의 bit만큼 가지면 표현할 수 있다.

## logNlonN
loglogN, Digim은 exponential 기반 이고 버킷의 사이즈 자체는 0을 카운터하지 않는다. 버킷사이즈라는것은 버킷에 들어있는 1의개수, 1의개수에 제약조건을 썼는데 개수가 2의 k개만 카운터에 들어가도록 해두었다. 카운터를 할때2의 1,2,4,8의 카운터를 다 더해야 한다. (한묶음씩)
저장해야하는 비트자체는 3이된다. log8=3 (앞에서 얘기한것) 

카운터를 표현하기 위해서는 logn bit가 필요. 그리고 0승 1승 2승 3승의 값을 최종적으로 구하는것이므로 log 한번하면 카운트의 개수를 세는것이고 log를 한번더 하면 0승 1승 2승 3승을 계산하게 되는것이다. 결과적으로 지수를 표현하기 위한 bit로 loglogn만큼 필요하다.

## 에러율 50%
exponential window는 에러율이 100%가 될 수 있다. 그래서 나온것이 Dgim method다. 50%이기는 하기지만, 절대로 50%를 넘지 않는다. 사실 이것보다 낮다.
왜? 맨마지막에 걸쳐지는 window n에 대해서 left most에 있는 카운터 값을 2의 r승 이라고 하자.

에러가 될 수 있는 사이즈는 left most의 size에 절반이다. 재수없어도 이값만 틀리고 나머지 즉 뒤에값을 멀쩡하다. 잘못된 값이 될수 있는 left most의 절반값의 MAX 값은 2의 r-1승(절반값) 

분모를 구해보자, left most를 뺀 나머지 1의 값을 다더하고 마지막에 2의 r-1승 값을 더해서 %을 확인할 수 있다. 

worst case는 window size가 각각 하나씩 있는게 worst다. window가 많으면 유리하다. 
왜? worst는 1,2,4,8 이렇게 간다. 이렇게 가서 bucket이 하나씩만 있는게 worst다. 
bucket의 개수가 up to 2개가 가능하다. (이전에 window 여기서는 bucket)
왜? bucket이 하나씩 오면 left most에 있는 애가 제일 커진다. bucket이 두개씩 오면 left most값이 줄어든다. 
best case - 같은 사이즈가 2개씩 오는경우 worst case - 같은 사이즈가 하나씩 오는경우
(등비수열의 합 공식은 Google 하자)

left most가 절반이 에러이긴 해도 정확한값이 2의 r승 -1인데 +1을 해서 2의 r승이다. left most에 1이 항상 왼쪽에 있다. 따라서 1을 더 더해줘야 한다. 이것은 exponential window에서는 보장이 안된다.(0까지 고려함) 시작이 항상 1이 됨 (잘 보면)

left most에도 최소한 하나는 제대로 된 값이다. 최악의 경우 50%
같은 사이즈의 버킷이 늘어날수록 에러율이 줄어든다.

## Further Reducing the Error
버킷개수가 2개이상은 안될까?
50%가 너무 높다. 더 낮을 순 없을까? r의개수(=버킷의개수) 증가시킨다. 1/r로 계속 줄어든다.
left most 버킷의 사이즈가 2의 j승으로 가정 버킷의개수가 2개에서 증가되서 r이라고 가정한다.
분모로 들어가는 값이 1+r(2의 j-1승 + 2의 j-2승 + ... + 1)=1+r(2의 j승 -1) 이 된다.

overly estimated part 는 left most의 절반값 2의 j-1승인데 사실 1을 더 빼줘야 한다.(이미 오른쪽에 보장되는 값으로 넣어줬기 때문에)

r이 변수고 j는 이미 정해진 상수, j는 버킷의개수로 정해져 있다. (상수값으로 저장된다.)
O(1/r) 된다. O를 쓰는이유는 근사값을 알아보기 위해서

r값이 계속 늘어나면 문제가 된다. 저장해야하는 bit가 많아진다. 저장해야 하는 카운터수(버킷수)가 증가한다. application에 따라 달라진다. 에러율은 높더라도 메모리 사이즈가 중요하면 r을 줄인다. 

## Extensions
n개의 버킷을 갖고 안에 있는 1의 개수를 세고 있다. n개보다 작지만 k만큼만 셀수있을까? n->k로 바꿔서 생각

## Extensions, 양의정수
음수는 안들어온다. 양수값이 들어오면 window에 있는 양수값을 요약할순없을까?
integer 값을 더해줄 수 없을까? 1만 세우는것이 아니라, 정수값

자연수 계산 하는 방법 간단하다. 2의 비트로 바꿔서 (단, 2의 m승의 값은 넘지않는다.)
비트에 제한을 두는것이다. 10bit라고 가정하자, 들어오는 정수값이 10bit내로 표현가능하다면 자기에게 해당하는 것을 각각 뽑아서 스트림으로 묶고 2의 좌승의 형식대로 알맞는 위치의 값을 곱해준다. (DGIM Method를 돌린다.)




