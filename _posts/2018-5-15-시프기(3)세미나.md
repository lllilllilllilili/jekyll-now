---
post : layout
title : 시프(기)3 세미나
---

## Process ID

```java
#include<sys/types.h>
#include<unistd.h>
pid_t getpid(void); //프로세스 아이디 반환

pid_t getpgrp(void); //이제 프로세스 그륩 아이디를 반환한다. 쉘에서 프로그램에서 실행하면 쉘이 세션이 리더가 되고 세션이 종료되면 그 그륩에는 모든게 종료된다.

로그인하면 쉘이 뜨는데 쉘이 뜨는 상태에서 a.out 다른 프로세스 만들어내고 하는건 쉘이 그륩이 리더다 쉘의 아이디가 그륩의 아이디이고 쉘을 죽이면 나머지도 죽는다.

fork 하면 자식, 부모 프로세스가 생기는데 

프로세스마다 고유번호가 있는데 프로세스 아이디라고 하고, pid_t 이다.


```


## Parent Process ID

```java
#include<sys/types.h>
#include<unistd.h>

pid_t getppid(void); // 부모프로세스 반환
pit_t getpgid(pid_t pid); //함수가 부모 프로세스가 있는 그륩의 아이디를 반환해주는 함수이다.

```

## Process ID Example(1)
```java
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

int mina(){
	int pid;
    printf("Original process : pid =%d, ppid =%d, pgrp =%d, pgid )
    ...
    //출력문에서 양쪽에 오타가 존재한다. 
    //직접 실행해보면 된다.
    pid =fork();
    if(pid!=0){
    	printf(...)
    }
}
ppid가 1 인경우, 부모 프로세스가 먼저 종료되서 고아 프로세스가 됬다 그래서 1이 나오는 경우고 이것을 해결하는데 wait()을 하면된다.

parent 먼저 죽으면 장레를 치뤄줄 프로세스가 없어지니까
자식프로세스가 남겨지잔아! 그래서
장례 지내줘야 하기때문에
부모가 먼저 exit를 하게 되면
자기 위한테 입양시키는데 그게
입양 시키는 프로세스 init() 선조, 0번(프로세스 넘버) 이고
init() 부팅시 시작하고 항상 wait 고아를 장례 치뤄준다. 기다리게 된다.
```

## Process ID Example(2)
```java
else {
	printf(...);
}
return 0;
}

..

```

## Process Group Leader
프로세스는 pid 있고 (각각) 
프로세스는 그륩속해있는데
그륩 아이디와 동일한 pid 를 가지고 있는 프로세스가 그 그륩의 리더이고
프로세스 그륩의 리더는 그 프로세스를 실행할 수 있는 권한을 가지고 있다.

프로세스 그륩 아이디 관련해서 pgid 함수 설정하는 란인데 옆에 표를 보게 되면

## Setting Process Group ID
int setpgid(pid_t pid, pid_t pgid);
표를 보게 되면 pid가 0인 경우는 지금 호출한 프로세스이고 
pgid 0이면 지금 호출되어있는 그륩을 의미하고
두 값이 같으면 그 그륩의 리더를 설정할 수 있게 된다.

pid=0 pgid=0 을 주면 자기가 그 그륩의 리더가 되고
그륩의 리더는 원래 쉘이었는데 자기가 그 그륩의 리더가 된다(그 프로세스가)
자기가 그륩의 리더, 자기가 fork 하는것을 자기의 그륩에 속한다.
사람에 비교하면 장가를 갔다. 즉 가정을 꾸림 분가했다.
원래, 자기 선조 shell인데 분가해서 그 프로세스가 그륩의 리더 되고 
그리고 그륩 리더가 죽으면 밑에 있는게 다 죽는다. (속해있는게 다 죽게 된다.)

쓸일이 없다.


## fork(1)
pid_t fork(void)

fork, 배웠다.


## fork(2)
fork 하면 그 순간에 자원을 공유하게 되고
그 다음 생기는것은 각자가 가지게 된다.

텍스트, 힙, 데이터, 스택 있는데
텍스트는 변하지 않는다. child parent 돌리는 위치만 다를뿐 메모리에 두 카피 가있을 필요 없음 메모리 한 카피만한다. (텍스트시점)

데이터 힙 스택은 포크를 하게 되면
데이터 힙 스택 따로 포크 시점 parent의 데이터 힙 스택을 카피해서 별도로 가지게 된다. 그래서
parent A child A 다르고
fork 시간이 오래걸림, 카피하는데 걸림

쓰레드는, 쓰레드는 다 공유하기 때문에 스택 포인트 다름(유일하게)
메모리 카피 할 필요없음 무진장 빠름 메모리 차지 하지 않음 포크는 메모리 차지함
나중에 배울텐데, 이것도 데이터 힙 스택이 fork 시점에서 카피 x
나중에 배울텐데 카피 앤 라이터라고 
따로 써야 되는 변수 a 있다고 함 fork 하면 자식이 생기고
자식, 부모가 읽기 만 하면 값이 변하지 않음
그러면 카피가 필요가 없다. 같은 값이기 때문에
언제 카피를 하냐? 라이트가 일어나면 한쪽에서 달라지기 때문에
부모가 라이트하고 자식이 라이트 한시점에서 os가 알아채서 카피를 시작한다.
2학기 버츄얼 메모리 매니지먼트 관련 부문에서 배운다.

## fork example(1)
변수 분류 추가함으로써 a가 어떻게 바뀌는지 확인하자!

원래는 a가 3으로 졌고 프로그램상에서 돌려보면 parent 5
child 4로 반영이된다.
fork 하고 나서 프로그램 돌때
작업관리자에서 fork로 프로세스가 생성된것을 확인할 수가 있다.


## fork example(2)
실행화면

## fork Example2(1)
usleep 부모 자식 번갈아 수행하게 된다.
출력을 하고 usleep 통해서 3십만 마이크로 세컨드 세고 다시 수행하는 프로그램
(자식)

자식에서 a는 0에서 2씩 증가, 짝수값으로 증가하고 child는 30만 마이크로 세컨드 한번씩 돌면서 짝수를 증가 시켜서 프로그램이 수행된다.

다음 페이지에서는

부모는 홀수 찍는다 똑같이 30만 마이크로 세컨드

부모 자식 번갈아 찍지만 순서가 뒤짚힐 수 있다.
## fork Example2(2)

부모는 홀수 찍는다 똑같이 30만 마이크로 세컨드를 돌면서 찍고

부모 자식 번갈아 찍지만 순서가 뒤짚힐 수 있다. (결론 중요한것이다.)
## fork Example2(3)
순서가 뒤짚힌다.

## File Sharing between Parent & Childs
task_struct는 process control block 파일 오픈 뭐가 들어가냐
(파란줄 없앳는데 그려넣음) 위에 부모가 가지고 있는 pcb 내용과 젤 위에 있는 fs파일 시스템이다. 이러한 정보를 가지고 있다. 
fs에 관한 정보는 (파일 시스템 루트는 뭐고, mask는 뭐고, count 뭐고 알필욘 없음 우리가)
task_struct는 open file table 있다. 그게 파일스가 가리키는게 이거다.(files struct) 안에 있다고 설명되지만 안에 있는게 아니라 포인터로 연결 되어있다.(그림을 보면 이해가능, 안에있다기보단 포인터로 연결되있다.)

결국엔 오픈파일 테이블이다. 255 나와있다라는 는건 파일을 255개 오픈할 수 있다.(파일 디스크립터니까)
이것은 누가 가지고 있냐 프로세스 ??? 가지고 있다.
누구입장에서 커널 입장에서 프로세스 100개 오픈하면(오픈파일 100개가 생길것이고) 파일 전체 정보가 들어가는게 file(파일이라고 나온부분)이다. 여기에 들어가는것은 
몇백개가 있다. 파일을 opne해서 나오는 정보들이 있다. 시스템 전체, 내프로세스만 해당되는것이다.

중요한것은 이게(f_inode) inode 가리키고 있다.
오픈해서 하는일은 디스크 inode 가지고 와야 파일 access하는데 d entry cache, main cache, i cache 쓰는것이고 여기에 중요한건 inode 포인터도 있지만 
f_pos 현재에 read/write offset 을 의미하고 
그래서 이 파일을 오픈했다 하면 오픈 한것을 read하면 여기와서 몇번째 파일 찾아가고(read/write offset으로 찾아가고) 디스크에서 read/write offset fetch 하고(read/write offset으로 디스크에서 찾아가면) inode 찾아가면 디스크 블락 주소가 있다. 
그것을(디스크 블락 주소를 이용해서) 실제 주소계산 해서 디스크를 access 한다. 

디스크를 access할땐 페이지 캐시 항상 먼저 찾는다.
files_struct가 부모죠,이게 포크하면 자식은 이것을 물려받음 오픈파일을 자식은 따로갖는다.
여기있는것을 고대로 복사, 그래서 자식도 f_pos 같은 위치 가리킨다.
같은것을 씀 카피한다. 요놈이(자식프로세스)
read/write offset 같이하게된다. 부모/자식 같은 파일 read/write 하면 offset 공유 하나뿐이다.

그러나 내가 똑같은 파일 두번 오픈하면 하나 오픈한게 여기, 다른게 read/write offset을 각각 생성(파일마다)그래서 자식과 부모는 따로쓴다.(따로 가기켜야 겠다.) 같은 파일이라도 그때는 이 파일이 두개가 생김 그러나 indoe는 하나다. 그런구조다.

