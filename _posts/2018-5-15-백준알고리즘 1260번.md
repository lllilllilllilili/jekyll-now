---
post : layout
title : 백준알고리즘 1260번
---

DFS는 계속 가다가 더 이상 갈 수 없게 되면 다시 가까운 갈림길로 돌아와서 이곳으로부터 다른 방향으로 다시 탐색을 진행하는 방법
깊이 우선 탐색은 그래프의 시작 정점에서 
BFS는 '폭'의 의미를 설명함
한 사람을 기준으로 메시지를 전달하는 사람의 수(폭)
한사람을 기준으로 자신에게 연결된 모든 사람에게 메시지를 전달하는 방식
순서를 정해야되 동시에 전달하는것이라도 순서를 정해야함
하지만 차례는 지켜준다.
연락을 취하지 못한 애는 연락을 취할 기회를 얻어야만 한다.

vector 컨테이너는 대표적인 시퀀스 컨테이너로 배열과 비슷하여 사용이 쉬우며 자주 사용한다.(배열인가..?)
메모리블락에 연속으로 저장이됨

```java
#include <stdio.h>
#include <cstring>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
 
vector<vector<int>> vec(1001);
bool bVisit[1001];
 
void dfs(int x)
{
    bVisit[x] = true;
    printf("%d ", x);
    for (int i = 0; i < vec[x].size(); ++i)
    {
        int iNextVertex = vec[x][i];
        if (!bVisit[iNextVertex])
            dfs(iNextVertex);
    }
}
 
void bfs(int x)
{
    queue<int> q;
    memset(bVisit, false, sizeof(bVisit));
    bVisit[x] = true;
    q.push(x);
    while (!q.empty())
    {
        int iQueueFront = q.front();
        q.pop();
        printf("%d ", iQueueFront);
        for (int i = 0; i < vec[iQueueFront].size(); ++i)
        {
            int iNextNode = vec[iQueueFront][i];
            if (!bVisit[iNextNode])
            {
                bVisit[iNextNode] = true;
                q.push(iNextNode);
            }
        }
    }
}
 
int main()
{
    int iVertex, iEgde, iSearchVertex;
    int u, v;
    scanf("%d %d %d", &iVertex, &iEgde, &iSearchVertex);
 
    for (int i = 0; i < iEgde; ++i)
    {
        scanf("%d %d", &u, &v);
        vec[u].push_back(v); vec[v].push_back(u);
    }
 
    for (int i = 0; i <= iVertex; i++)
        sort(vec[i].begin(), vec[i].end());
 
    dfs(iSearchVertex);
    printf("\n");
    bfs(iSearchVertex);
    printf("\n");
 
    return 0;
}
```