--
post : layout
title : 데이터통신13
---
## 블로코딩
블록코딩 4비트를 5비트로 바꾸어서 보내는 방식이다. 4비트를 5비트로 늘려서 보내는 까닭은 n비트를 m비트로 늘려서 보내는 경우다. n<m 
오히려 데이터 rate 늘려서 보낸다. 필요성은?
표가 있어야 한다. 4비트가 만들수있는 16가지 5비트로 표현된방식 사실 4비트가 5비트로 바꿔서 표에의해서 연속적으로 값이 오는것을 막기 위함이다. 
보내는쪽과 받는쪽은 동일한 표를 가지고 있어야 한다. 안쓰는 표시들은 control sequence 용도도 가능, 안쓰고 있는것도 5비트도 32bit 표현가능, 빈자리 안쓰고 있는 코드다. error check를 쓰고 있다. 데이터 받았더니 빈자리에 속한것이다. 그럼 error다. 이런식의 mapping은 error 찾기 가능하다.(안쓰는 코드가 왔을경우)

32가지 중에 16가지 어떤것을 골라서 쓸까? 결과적으로 우리가 얻고자 하는것은 어떤 패턴을 5개를 이어서 붙이던간에 0이  3개를 넘게 연속되서 만들어 지지 않는다. 보낼 데이터 0010 이면 내가 보내야될 데이터는 10100 이다. 넣어서 보낸다. 가장 최악의 경우는 앞에 여러개 시작하는 경우 가는 케이스 
0010 0101 -> 10100 01011 
다섯개로 이어지는 2개를 코드를 연달아 붙였을때 0이 연달아 나온 케이스가 3개가 넘지 않는다. 

오리지널 데이터에 0000 0000이라 함은 8개가 이어지고 있다 5개로 거쳐서 보내면 1110 1110 그러면, 원하는것이 된다. 이와 같은 데이터가 간다. 인위적으로 0을 집어넣어서 1이 연속되지 않게 했다.

++동일한 시그널이 계속이어지는 경우를 막자 1이 4개이상 이어지지 못하게, 0은 3개를 넘지 않도록 코드를 선택했다.++

싱크문제, dc문제 해결할려고 한다. 

## 4.5
보내고자하는데 데이터가 1Mbps인데 4B/5B, 4bit를 5bit로 만들어서 보내는 코딩을 하면 필요한 밴드위쓰는 얼마나 될것인가. 맨체스터 방식을 쓰면 밴드위쓰가 얼마나 될것인가
4b는 5b로 보내니까 1Mbps가 1.25Mbps가 된다. 
1/4 만큼 늘어난다.
1.25 Mbps를 NRZ-I 라인코딩 방식으로 보낸다. 4bit 를 5bit로 만든다음에 nrz-i 방식 non return to zero inversion 방식으로 보내면 c*n*1/r 방식으로 해서 밴드위쓰를 구하는게 있었다. n/2이다. 1.25 Mbps보내는데 그것에 반만큼의 밴드위쓰가 필요하니까 625kHz다.

이렇게 안하고 라인코딩방식에서 유력한 멘체스터 코딩방식을 쓰면 r이 1/2였다. s=n 관계가 나왔다. 
1Mbps 를 보내면 멘체스터 코딩방식은 1MHz 밴드위쓰가 필요하다.
4b를 5b를 적용한다음에 nrz-i 625kHz가 필요했는데
라인 코딩 방식으로 멘체스터 코딩 방식을 쓰면 1Mhz 
밴드위쓰가 더 필요하다.

어느것이 더 좋을까? 평가가 뒤에 있다.
nrz-i는 1이 연속되어 오거나 0이 연속되서 오면 막아놓은 다음에 nrz-i 방식을 적용하니까 직류성분의 문제가 심각하게 안올 수 있는데 여기서는 오히려 강조했다.
++nrz-i 방식을 쓰면 밴드위쓰는 작게필요하지만 dc 컴포넌트 문제는 여전히 남아있다.++
++맨체스터방식은 1bit 보낼때마다 중간에 바뀌기 때문에 signal을 바꾸기 때문에 dc component 문제가 없어진다. 더 큰 대역폭을 필요로 한다.++
서로 장단점이 있다.

## 8b/10b
8bit를 10bit로 바꿔서 보내는것 블락 코딩 스케일을 키운것이다. 5bit 를 6bit로 바꾸는 블락하고 3bit를 4bit로 바꾸는 블락을 합쳐서 8bit를 10bit로 바꾸는 블락 구현한다.

구현은 ppt 그림처럼
disparity controller는 각각 5b/6b와 3b/4b가 나가서 10bit를 만들어서 보내는데 했더니 두개의 블락코딩을 합했을때  0이 연속해서 많이 나올수도있고 1이 많이 나올수도 있다. 그런 경우에 대비해서 0또는 1에치우친 값이라고 하면 안쓰는 코드를 대신해서 사용한다 라는것이다. 

2의 8승개(256)를 1024개로 맵핑한것이다. 여유가 엄청많다. 800개의 여분이 남는다. 여유분을 이용해서 disparity controller가 하는일은 두 블락으로부터 나온 10비트 데이터 짜리 데이터 1이 과도하게 많으면 안쓰고 있는것으로 바꿔서 보낸다. 받은쪽에서는 안쓰고 있는 쪽이 오면 거꾸로 맵핑해서 10비트를 만들어내는 테이블이 있다.
8비트를 10비트로 만드는이유, 역할을 알아야 한다.

## 스크램블링
ami 방식은 +, - 번갈아가는 신호였다. 
110111 ami방식이 유력한 방식이었는데 1일때는 마크를 거꾸로 갔다가 0으로가면 0이란 시그널로 쭉간다. 1이오면 아까 -였으면 +로 되고 또 다른 1이오면 - 또다른 1이오면 + 이런식으로 0이 이어지면 0으로 쭉가게 이게바로 ami 방식이다.

1이 계속 이어지면 +, - 반복하기 떄문에 dc성분없어지고 동기화문제 해결되고 0이 계속이어지면 0이 온다. 1이 계속이어지는것은 좋은데 0이 계속이어지면 시그널의 동기화를 잃어벌리수있다. 시그널이 안가니까 받은쪽에서 0이 몇 비트왔는지에 대한 동기화가 굉장히 어려운 데이터 전송이다.

ami 방식에서 zero가 연달아 이어질때 대비방식으로 스크램블링 방식을 쓴다.

0000 0000 이어지면 그전에는 손을 안쓰다가 손을 쓰는것이다.
8개의 뭔가로 바꾸는데 8000VB0VB로 바꾼다.
V는 바이올레이션 하고, B는 룰대로 따라간다.

## 스크램블링(뒤섞기)
ami 방식으로 8개의 0을 보낸다. 그러면 8개를 요대로 집어넣는데
000VB0VB (V가 바이올레이션) +다음에 0이 아닌 데이터를 보낼일이 있으면 ampi방식에서는 반드시 앞에의 역이 되는 극성값을 보내야 ampi 방식은 룰이 지켜진다.
+->-->+

그런데 - ,+ , + 또 +가 오는것은 바이올레이션
000V(바이올레이션)B(룰대로간다 +였으니까 -)
이패턴을 0 8개를 대체하는 패턴으로 정한것이다.

++받은쪽에서는 저거가 원래 0이 8개를 어떻게 알까?++
그 관건이 바이올레이션에 들어있다. 받은쪽에서 보니까 0 3개 뒤에 V가 왔다. (-가 와야 하는데 +가 왔다) 
8개 패턴을 따라가봤더니 000VB0VB 확인하고 0이 8개인것을 확인한다. receiver입장에서 대체됬다라는것을 알려주기 위해서 일부러 바이올레이션을 취한것이다. 취하지 않고 +다음에 0가 오게 하면은 전혀 receiver는 000다음에 1(마이너스가 1인식, 룰대로 가고있으니까)
바이올레이션을 함으로써 경각심을 준다.

negative였으면, 0이 8개보낼려면 violation을 보낼땐 앞에 극과 똑같은것을 보낸다. 

++중요한이유, 바이올레이션을 왜 주느냐?++

## 스크램블링, 뒤섞기(2)
0이 8개인 경우고 0을 4개만 생겨도 (연속된 0) 조치를 취하는게 HDB3 라고 한다. 4bit의 0이오면 어떤 패턴으로 바꿈 
바이올레이션을 어딘가 넣어야 receiver는 알수있는데..
4개 연속된 0을 000V, B000V 로 대체한다.
0이 아닌 시그널이 짝수개 있었다 +와 - 이 패턴을 보내고 (B00V, 룰대로 극을 만들어보낸다. B가 +니까 V도 +다.) 1이가면 V가 +니까 -로 가게 되고 앞을 따져보면 1이 아닌개수가 홀수개다. 1이 아닌개수가 홀수였으면 000v패턴을 넣는다.

hdb3의 룰이다. 바이올레이션을 하나 넣어서 보내는데 그 시점 직전까지 1이 아닌 시그널의 개수가 짝수냐 홀수냐에 따라서 두개중에 어느 하나를 넣어서 보낸다.	
두가지를 쓰는 이유는 dc component를 줄이기 위해서다.

4장이 디지털 데이터를 4-1 디지털 데이터를 디지털 시그널로 바꾸는것이고 4-2 소스가 아날로그 인데 이것을 디지털 시그널로 바꾸는 내용이다.

## ALAOG-TO-DIGITAL CONVERSION
디지털 시그널이 아날로그 시그널에 비해서 당연히 전송 측면 품질이 좋고 소스가 아날로그 라고 하더라도 디지털로 바꿔서 전송하는게 여러가지 통신 품질 측면에서 도움이 된다.
쓰이는 방식이 Pulse Code Modulation(PCM), Delta Modulation(DM) 이 있다.

아날로그 데이터를 디지털 방식으로 바구는 두가지 방법을 살펴본다.

## 펄스 코드 변조(Pulse Code Modulation,PCM) 부호화기
아날로그는 그림에서 보다싶이 continuous한 형태로 curve가 보이는데 결국 얻고자 하는건 1과 0으로 이루어진 디지털 데이터를 얻고자 한다.

샘플링을 한다음에, 샘플링한값은 여전히 아날로그 값이다.
아날로그 값이라는것이 값이 무한대값을 취할수있는게 아날로그 값이다.
샘플링한 상태는 아날로그 값이고 아날로그 값을 

ppt 아날로그 시그널을 디지털 시그널로 바꿀려면 샘플링을 하는데 샘플링 한값은 여전히 아날로그다. 

아날로그 값들은 이 축상에 다 가질 수 있다. 4개의 레벨로 나눠서 보내겠다. 11 / 10 / 01 / 00 이중에 어느하나 이와 같이 디지털 데이터 2비트를 전체 시그널을 맵핑시켜서 보내겠다 4단계로 맵핑시켜야 하는 일이 ++가장 가까운것으로 갈것이다.++
맵핑시키는 과정이 두번째 있는 Quantized 이다. 비로소 Sample 추출한 값이 디스크립터한 값이되고 (유효한값) 디지털 데이터 되었다. 여기에서 디스크립터 데이터를 이런저런 인코딩 방식을 통해서 1,0 블락코딩을 하던지 전송할 수 있는 데이터로 바꾼다. 디지털 데이터가 만들어진다.

샘플링하면 무한대의 값중에 어느 한값을 가질 수 있는데, 이것을 유한개의 몇개의 값으로 맵핑시킨 값으로 맵핑시킨다.(Quantization)

++0이 연달아 많다든지 그러면 라인 코딩, 블락 코딩 방식을써서 데이터로 바꾸는 방식 pcm이다.++
Quantization은 아날로그 값을 유한개의 어느 한값으로 맵핑시킨것이다.
양자화 라는 의미. 8개중에 어느 하나로 맵핑시킨다든지 16개중에 어느 하나로 맵핑한다든지 이런일 을 한다.
## Sampling
샘플링은 다른말로 pulse amplitude modulation 이라고 한다. 샘플, 주기를 갖고 아날로그 값을 일정한 값을 갖고 진폭을 측정을 한다. 측정을 하면 Ideal한 케이스는 측정한 포인트 값을 개념적으로 쓰고 있지만 실제 회로 구현하면 샘플한 아주 짧은 시간동안 이라도 아날로그 커브 만큼 같이 변하는 용도
아니면 샘플한 한 순간을 잠깐 유지하는 방식을 (sample and holes flat top 방식) 이런식으로 샘플된값을 이렇게 볼 수있다. ++개념적으로 ideal하게 샘플된 순간의 값으로 본다.++

## memo
샘플링을 하는데 보다싶이 커브를 목적지에서 복구를 할려하는데 샘플을 자주 할수록 목적지에서 커브 복구하는데 도움이 된다. 어느정도 자주 샘플링을 자주 해줘야 커브가 목적지에서 복구될것이 보장되냐? 나이키스트 샘플링 이론이다.
* 라인에 최대 bps 구하는 공식에 나이키스트 공식이있었다.(이전에)
복구가 될려면 적어도 아날로그 시그널의 가장 높은 frequency 성분의 2배만큼의 속도로 샘플링을 하면 원래 시그널이 복구된다.

## Low-pass 와 bandpass 신호의 Nyqulst sampling rate
내가 지금 샘플하고자 하는게 방대한 frequency한 성분을 갖고 있다. 디지털 데이터를 바꾼다음에 목적지 에서 다시 아날로그 시그널의 형태로 복구할려면 f(max)의 2배만큼으로 샘플을 해야한다 
위에 그림이 0부터 1khz다 라고 하면, 1초에 1000번 왔다갔다 하는 시그널인데 이것에 2배(2천번 샘플링해야한다.)

밴드패스 시그널, 모습 형태로 중간부터 시작해도 상관없다. 제일 큰 주파수의 2배 만큼의 rate로 샘플링을 자주해야 아날로그 시그널이 복구될수있다.

## 4.6
샘플링이 많고 적음에 따라서, 원래 커브를 상상할 수 있는지 예
sign wave가 하나있는데 sign wave가 한번 주기 4f 한 주기내에서 2번 샘플링하면 나이키스트 이론을 따른것이다. 

그림 맨위, 한 주기내에서 두번 샘플링하면 frequency 성분의 2배만큼 샘플해라.(빨리) 일치한다.

맨위의 케이스 한 주기 동안에 2개씩 샘플링해서 샘플한 값만 보면 왼쪽과 비슷한 그림이 나온다. 이으면 얼추 sign curve와 비슷하다.
두번째 그림은 4배만큼 샘플을 하면 한주기에 4번 하면 그래봐야 같은 모양이다. 오버 샘플해야 득을 볼게없다.
++중요한것은 Under sample, 나이키스트 rate 만큼 샘플하지 않은 경우, 한주기 한번 샘플했고 두번 샘플했고.. 나이키스트 샘플링 rate보다는 적게했다. 한주기 2번씩을 지키지 않음. 그렇게 샘플한 값을 보면 이으면 나이키스트 샘플링 rate을 최소한 지켜줘야 원래의 signal이 될 수 있다.++

## 4.25 
한바퀴 도는게 한 주기다. 한 바퀴 돌때 두번 샘플링하면 나이키스트 rate 맞는것이다. 
12시에서 시작해서 12로 가는데 2번 샘플하면, 12시 한번 6시 한번 된다. 12시다음에 6시고 다음에 12시면 방향은 잃어버릴수있다. 거꾸로 돌아도 이상할게 없음. 돌긴 도는구나!

중간그림은
나이키스트 보다 2배 더 빨리, 한번 돌때 4번 샘플링하면 정확히 도는 방향을 알수있다. 12시 다음에 9시 6시 3시.. 방향까지 알아낼 수 있다.

샘플링을 자주하면 오히려 더 많은 정볼르 알 수 있다.

마지막 그림은 under sample인데, 9시간마다 샘플한것이다 12시 다음에 9시간만에 샘플하고 6시에 한번하는 나이키스트 샘플링 rate보다 늦은것이다. 12시지나면 9시고 계속 흐름을 지켜보면 시계바늘이 반대로 도는것처럼 보인다.
++샘플링을 너무 적게하는 바람에 원래의 정보를 잃어버렸다++

## 4.8
자동차가 정향향으로 가는데 보이는건 거꾸로 바퀴가 도는것처럼 보인다. 영화 동영상 보면 1초에 24개의 프레임이 만들어지면서 동영상으로 보는데 자동차 속도가 1초에 12바퀴 (샘플링 rate 24라고 할 수 이다) 샘플링 24가 유효한 나이키스트 샘플링이 될려면 원래 시그널의 12바퀴 이내로 돌면은 나이키스트 샘플링을 만족시키는 프레임 보이는 속도가 된다. 바퀴가 20바퀴가 도는데 샘플링을 24하면 ++under sample++이다. 바퀴가 거꾸로 도는것처럼 보인다.

영화에서 바퀴가 거꾸로 가는것처럼 보인다. 굉장히 빠르게 간다. 거꾸로 보이고 천천히 갈때 제대로 보인다.

## 4,9
가청주파수라는것이 일반적인 2000Hz~4000Hz정도까지 편안하게 듣는소리이다. 음성데이터를 (아날로그) 디지털화할때 샘플링할때 음성데이터가 갖는 가청주파수 대역의 가장 높은 부분 4000이면 *2 8000번을 샘플링한다. 초당 8000번 샘플링하면 전화음성데이터를 디지털화할때 한버 샘플할때마다 8bit로 Quantization 한다. 256개 중에 어느 하나로 바뀐다 레벨이
어느 한 레벨당 8bit가 된다. 그림은 ppt 참고

++256 개의 어느 하나의 값으로 맵핑한다는것은 각각의 레벨은 8bit로 표현된다. 음성을 샘플링하면 초당 64000bit/s 가 나온다. 64kbps가 만들어진다.++
전화망이 아날로그전화망에서 디지털화 될때 가정집마다 하당되어줘야하는 대역폭이 64kbps라고 하는 중요한 숫자다.
여러가지 코딩 기술을 써서 음성을 64k 까지 안가도 11k가도 복구되는 기술이 적용되는데 처음에 음성에 해당되는 밴드위쓰 얘기할때 64kbps가 나오고 실제 전화망들을 이루는 교환기들이 잇는 트렁크들 속에 한 전화 콜에 대해서 할당해주는 64kbps가 되게 링크상에 내가 지금 누군가 통화하고 있는 나를 위한 채널은 64kbps되게 할당주고 있는 식으로 전화망이 만들어지고 있다.

64kbps 음성은 4000 Hz 가장 높은 주파수 성분이라고 보고 나이키스트 샘플링 이론에 의해서 그것에 2배, 8000번 샘플링하고 샘플값을 256개 중에 어느 한값으로 맵핑하다 보니까 매 샘플을 8비트짜리로 디지털 데이터를 바꾼다. 초당 8*8000=64000bps

++음성을 디지털 데이터로 만들때 기본적인 소요되는 밴드위쓰가 64kbps이다.++

## Quantization and encoding of a sampled signal 
Quantization은 어떤 샘플된 값이 있는데 들어있는 값은 아날로그 값이다. 디지털 데이터로 바꾸고 자 하는데 8개 중에 어느하나로 맵핑시키는 사례를 보여주고 있다.

띠에 가운데 값들이 지금 디지털 데이터로 바꾼다. 000부터 111 까지 맵핑 시킬려한다. 각 띠별로 가장 가까운 값으로 맵핑하는데 아래보면
Quantization code가 나온다. 얘들의 각각의 바이너리 넘버도 나온다.
3bit로 바껴서 밑에있는 값들이 샘플된값이 Quantization 된 값이다.
샘플링해서 010 101 111... 이런식으로 데이터가 전송이 되고 디지털데이터가 들어오게 된다. 그 사이의 값은 에러에 관한 값이다. ++디지털 데이터값을 끌어냈다.++
 
error을 줄일려면 당연히 띠에 폭이 줄어들어야 한다. 띠가 줄어든다는것은 8개가 아니라 16개로 늘려서 레벨을 띠를 16개로 만든다.
반씩 줄어들것이다.
256개로 만들면 점점 크기가 줄면서 error가 줄어들것이다.

## Quantization error to the SNR
과연, 몇비트로 표현했을때 error 일종에 원래 시그널이있는데 약간의 에러가 낀 시그널이니까 노이즈가낀 시그널로 인식 할 수 있고, 내가 몇비트로 Quantization 했을때 SNR 값과 어떤 관계를 갖는지!

아날로그는 무한대로 갖는 값인데 유한개로 표현하다보니까 당연히 Quantization error는 어쩔 수 없다.

SNR(Signal to Noise rate) 노이즈에 대해서 시그널의 파워가 어느정도냐 이값이 클수록 좋다.  
몇비트로 Quantization 하느냐에 따라서 snr이 어떤 관계를 갖는지 ppt참고
6.02n+1.76dB, n이 몇비트로 Quantization 했느냐 4bit로 Quantization한경우 16개중 어느하나...
경우의수를 Quantization 개수를 늘릴수록 에러가 떨어진다. 
에러를 snr로 표현해서 어느정도 주느냐를 보여주는게 더 중요하다.

4bit로 하다가 5bit로 했다. 32 중 하나. db로 얼마나 줄어들까 
4,5집어넣는경우하고 6.02 값의 차이다. Quantization 하나를 늘릴때마다 6.02 db만큼의 snr이 증가된다. 
여러 비트로 맵핑할수록 snr이 커질수있다.

3비트로 샘플하는경우 snr이 수식에 단순히 집어넣서 19.82db이다.

## 4.13
전화서비스인데 40db 이상으로 하고싶다.
n이라는 숫자를 찾아라 6.35 이상 7bit이상으로 Quantization 해야 snr이 40db 이상으로 얻어낼 수 있다. 중요한 수식이다. 
