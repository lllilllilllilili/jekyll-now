---
post : layout
title : 컴퓨터구조(기)4
---

성능을 저해하는 요소 해저드 라고함
크게 3가지
struct 해저드
data 해저드 - 명령어 상에서 데이터 종속 관계 떄문에 발생
앞선 명령어에서 값이 write 되고 나서 뒤에 read 해야하는데 
앞에서 값을 wrtie 하지 않았는데 뒤에서 값을 읽어가면 상황발생

control 해저드 - 브랜치, 점프명령어에서 발생하는 해저드
파이플라이닝에 들어가는 메모리에 있는 명령어들이 계속해서 파이플라이닝 계속 들어가다 보니까 사실은 브랜치 명령어들은 브랜치 판단 결과에 따라서 전혀 다른 명령어로 가야될 수도있는데 이미 파이플라이닝에 뒤 명령어들이 뒤따라 들어옴 이게 컨트롤 해저드 처리

## A Single Memory Would Be a Structural Hazard
예를들면 앞선 명령어 파이플라이닝에 있는 어떤 명령어가 파이플라이닝이 얼핏보면 
실제 보면 생각을 해서 볼려면 많ㅇ ㅣ생각해야함 과정에 대해서
이런경우에 struct 해저드 경우임
이 명령어가 쭉감, clock 마다 가면서 얘가 이제 fetch하고 decode 한 다음에 바로 뒤따르는 명령 fetch 시작하고 파이플라이닝은 앞선 명령어가 시작하면 다음 순간 자기명령어도 시작함

load 의경우는 4번째 clock에서 메모리 access함 그 시간에 
걔보다 3번째 뒤떨어 져 있는 이명령어가 시작이 되기 때문에 이 명령어는 메모리에 있으니까 메모리에 읽어와야함 메모리에서 읽는 동작
두동작이 같은 시간에 일어남, 여러가지 기법이 있지만여기서 해결한 방법은 
명령어 메모리 하고 데이터 메모리 구별한다. 분할 시킴
한번 access하는 port를 한 port만 두는게 아니라 2개 4개 멀티 포트 지원하기도함 한 메모리 뱅크에 여러개의 access가 동시에 들어올수 있도록 

한메모리 쓴다하면, 동일한 메모리 뱅크를 쓴다고 하면 듀얼 포트로 포트를 2개를 허용하는것도 방법임

## How About Register File Access?
이것은 좀 다른 상황임
이것은 reg에서 충돌이남

번호를 1,2,3,4 
1번 명령어가 write back할때 
4번 명령어가 레지스터 값을 읽는 상황 발생
같은 시간에
이건 어떻게 해결?
한 사이클을 전반부 후반부로 나눠서 전반부에 값이 쓸수 있게 후반부에 값을 읽을 수 있게 함
클락이 있으면 rising할때 값이 찰각하고 레지스터에 들어감 클락이 떨어질때 값이 떨어질수있게 해결함
그다음에 

## Data Hazard(RAW hazard) & Data Hazards : RAW(2)
종속관계
이 명령어
1,2,3,4,5 명령어있음
1번 레지스터 어떤 값을 쓰는 명령
뒤따르는 명령이 1번 값을 이용해서 먼가함
이게 파이플라이닝 생각안하고 순차적으로 하나하나씩 처리하면 문제가 없음
파이플라이닝 이 뒤따라 들어가다 보니까 실제로 여기서 $1에 1번레지스터에 write가 되는 시점은 이시점이다 시간상으로 
읽는 시점은 그것보다 앞선시점에서 읽는다.
이값을 과거로 보낼 수 없다.
이것보다 두명령 뒤에있는것은 문제가 없다(초록색)
문제는 얘와 바로 뒤따르는 두개의 명령어가 종속관계에 의해서 해저드 발생
뒤에 명령어가 시작되는 시간을 늦춤
두클락 늦추면 됨 
뒤따르는 명령어가 여기서 시작하면댐

## Stalling : one way to "Fix" a Data Hazard
그래서 명령어를 instruction fetch단계에서 바로 다음 명령어를 가지고 오지 못하게 하고 
거기서 기다리게 한다 한클락 기다리게 두클락 기다리게 세번째 클락에서 가지고 오게끔 한다.
이게 STALL 시킨다. 여기서 기다리 게한다. 
다시 할려고 했는데 기다리게한다 .두번 STALL하고 그다음에 비로소 새명령어를 시작하게끔 한다.
이것의 문제는 파이플라이닝이라는게 쭉 파이플라이닝이 채워지면 매 사이클마다 딱딱 완료되서 나오도록 되어있는데 지금 보면 이 시점에선느 한번 뻥, 두번 뻥 그다음서부터 이렇게 한번 STALL 들어가면 STALL 들어간 횟수만큼 명령어가 안나온다. 그만큼 전체 처리 성능상에서 효율성이 떨어진다. 들어간 버블에 수만큼!!!!!

조금더 효과적으로 처리하는 방법은 없나
forwarding 기법을 써보자.

## Forwarding: another Way to "Fix" a Data Hazard
forwarding이 전달임
값이 사실은 여기에서 레지스터에 쓰이는게 맞고 그때부터 다음 레지스터 읽어가는게 맞는데 
사실은 여기에 쓰여질 레지스터 값은 어느단계에서 계산이 끝나냐면 이단계에서 값이 끝남 
alu 앞에 여기에 이미 레지스터 값은 나와있음 그값을 가져가서 쓸수있게 회로를 연결해주면 그러면 구지 안기다려도 된다.

값이 나왔어 그런데 레지스터 1 이라는건 여기서 읽어서 alu로 넣을려했던 레지스터였음 그것을 이값을 여기로 alu에서 나온 결과를 다음 사이클에서 다시 쓸수있도록 해주면  여기까지 기다리지 않아도댐
그다음에 이 뒤의 명령어들은 두 사이클이 지나고 나면 여기에는 write가 되니까 자연스럽게 가져갈 수 있음
alu나온 결과를 alu input으로 되돌려 넣어주는 과정을 forwarding이라고 함 
그러면 forwarding 할수있는 집어넣는다 하면 stall이 필요없음
없이 진행가능
왜 값이 alu에서 나오기 때문에
## Forwarding with Load-use Data Hazards

같은 종속관계라도 load 명령어에 load 사용하는 경우는 상황이 다름
이것도 종속관계임 $1의 값은 alu에서 $1의 값이 나오나? 메모리로부터 나온다.
$1 이 레지스터에 들어가는 값이 어벨러블 한게 아니라 메모리에서 나온다. 메모리에서 나오는 값이다. 그값이 메모리에서 나오는데 그값이 
이 alu의 인풋으로 들어가야함 그래서 방향이 거꾸로 뒤로간다.
그래서 load 사용할때 stall 없이 아무리 forwarding 쓴다해도 stall없이 가능하지 않다.

이사이클에서 얘는 끝에서 값이 나오고 얘는 이 사이클에 시작할때 값이 필요한데 
load 를 사용하면 load-use 일경우는 불가피하게 한 사이클 뒤의 명령어가 뒤로 밀어줘야함
(stall 사용한단 말인듯)
여기서 나온값을 여기에 레지스터에 값을 읽을때 이값을 전달한다. 그래서 일반명령어는 forwarding 쓰면 stall이 필요없지만 forwarding 회로를 구성하면
load 명령어는 그대로 한 사이클 stall은 필요하다. 

data 해저드 해결하는거 첫번째 무식하게 stall시키는것 두번째 내부에 forwarding logic ,circuit을 구성하는것 세번째 회로를 전혀 손대지 않고 컴파일러가 할 수있으면 컴파일러가 이 c언어를 기계어로 바꾸는건데 컴파일러가 해결
어떻게 해결하는가 

## Code rescheduling to avoid stalls
어떻게 해결하는가 왼쪽은 컴파일러가 생각없이 얘를 곧지 곧대로 컴파일 한것이고
오른쪽은 파이프라이닝에 데이터 해저드가 발생한다는것을 인지하고 그것을 자기가 나름대로 조정한것이다. 명령어의 순서를 바꿔서 현재 우리가 사용하는 대부분의 컴파일러는 상당한 지능이 부여되어있음 사용자가 이렇게 코딩하라 해도 그게 성능에 저하가 되하가 되면 정확성 해치지 않는 범위내에서 명령어순서 재배치 할 수 있다.
원래는 사용자는 이렇게 문장을 써라 한건데 컴파일러가 볼때 바보같아서 자기가 임의대로 바꿈 결과만 이렇게 보장하면서 파이플라이닝 성능을 높이는 순서대로 명령어 순서를 바꿈 

"하나 뛰고 작성해야함"
결과가 바뀌면 안됨
값을 쓰는거 읽는거 한 사이클에 떨어져 있음 
내부에서 forwarding 한다고 하도 한 사이클 stall 필요함
바로 이렇게 뒤따르면 영향을 받게됨
그래서 얘를 적어도 한 명령어 이상 건너뛴 자리로 이동해야함 
둘 뒤에 있는 데 가져다 놓음 왼쪽 보면
그자리에다 $t4를 끼워넣고 명령어 사이를 벌어놓음
둘 사이의 종속관계에 해저드 발생하지 않도록
내부에 forwarding 회로가 있다고 가정할때 그럼에도 불구하고
load 같은 경우에는 바로 뒤따라오면 안됨
하나 건너 뒤따라와야함
그다음에 얘와 얘 사이
얘가 앞으로 오면서 얘와 얘사이 더 벌어짐 t4를 말하는듯

다 해저드 관계가 있었는데 실제로 돌려보면 바로 뒤따라 와서 있으면 한칸 버블이 들어가는 형태로 바꿈 끼워넣고 순서를 바꿈으로써 둘 사이를 벌여놨다. 이런것을 instruction reordering 이라고 한다. 

기본적인 시도에 해당됨 
가끔 방황하는게 뭐냐면 프로그램 디버깅 할때 어셈블리 수준으로 디버깅 하는데 디버깅 코드를 어셈블리 코드를 보면 내가짠 코드가 아닌데 이렇게 생각이 드는 경우가 있음
이런 경우는 파이플라이닝 stall 해결하기 위해서 컴파일러가 나름대로 재배치한것임
그것을 원치 않는다. 내가 프로그램 이해하는게 중요하면 옵티마이징 하지말라고 최적화 하지말라고 정할 수 있고 
고지 곧대로 해줌 성능은 나쁨 디버깅 단계에서 프로그램을 이해하는데 하고 그렇게 함으로써 프로그램 정확성 문제 없다고 하면 배포판에는 성능의 최적화 읽어줘야하니까 옵티마이징 해서 내보낸다.

## Control Hazard
브랜치나 점프 뿐만이 아니고 
return도 사실은 명령어의 주소위치가 바뀐다. 
그냥 메모리에 들어있는 word 들이고 여기가 메인 프로그램이다
그림참고
foo 어쩌구 저쩌구 하고 이걸 함수로 
함수호출하는 mips 명령어 뭐였냐면 jar 이었음
분기하고 그 다음에 수행끝나고 돌아가는거 $ra에 들어있으니까 jr ra함
파이플라이닝에 얘들이 따라 들어가기 때문에 얘가 들어갈때 이 뒤따르는 명령어들도 다음 우리 순서야 파이플라이닝이 따라 들어간다. 여기서 jar 이야 그럼 어디로가 이 명령어 수행해야함 
얘명령어 수행하고 다음에 이 명령어 
뒤에 뒤따르는 전혀 쓸대없는 명령어가 뒤따라감. 이게 실행되면 프로그램에 영향을 줄 수 있음
뒤따르는 애들, 야 너네 차례 아니야 얘들을 무효화 시켜야함
파이플라이닝 진행되서 가면 얘가 실행될때 jump register해서 사실은 돌아가는 명령어인데 
파이플라이닝에 얘가 들어가니까 뒤에 있는 놈들도 곧 자기 차례인줄 알고 파이플라이닝에 쭉쭉 따라 들어간다. 마찬가지로 여기서 점프하고 나서 파이플라이닝에 얘들 소거 시켜줘야함
이와같이 pc 변경시키는 동작에 의해서 발생하는건데 문제는 파이플라이닝은 메모리에 있는 명령어들을 그냥 기계적으로 파이플라이닝에 채워넣는 동작이기 때문에 한편으로 이런 부주의한 일들이 발생함
mips 파이플라이닝에서는 비교적 타겟을 일찍 계산하도록, 타겟이 늦게 결정되면 결정될수록 파이플라이닝에 들어가는 놈들이 많아짐
타겟을 비교적 일찍 결정해서 타겟이 다른 주소다 라고 판단이 되면 빨리 들어와있던 놈들을 소거시키고 그 다음으로 분기할수 있도록 하기 위해서 굉장히 이른 stage에서 하고 있다.

instruction decode stage에서 타겟 어드레스를 결정할수있도록 
타겟 어드레스는 alu에서 타겟 주소가 결정됬는데
여기에서는 instruction decode 단계에서 이 타겟을 계산하고 레지스터를 서로 비교할 수 있도록하는 extra 하드웨어 구성해놨다. 파이플라이닝을 위해서

그래서 가정이 뭐냐면 instruction decode 단계를 지나면 다음 명령어에 정확한 주소를 알 수 있다. 여기서 가정임
뒤에 data path를 보면 그렇게 할 수 있는 하드웨어를 instruction decode 단계에 구비해놔야함 
insturction decode 단계가 끝나면 branch다 이것은 세번째 단계까지 가야 이 branch 주소를 알수있었는데 2번째 단계에서 알수있다. 이제 아까도 말한것처럼 명령어가 있으면 사실은 이 뒤에 명령어가 있을텐데 애들이 파이플라이닝 뒤따라 왔을거야 그렇게 하지말고

branch 명령어면 branch 명령어 바로 알 수 있음 그럼 stall 해서 한 사이클 쉬어서 다음 명령어 시작되게 하나 stall 할때 이때 요단계에서 branch는 decode와 함께 타겟도 결정하고 비교하는 register도 그 비교결과도 2번째 단계에서 할 수 있음 
그러면 다음 주소가 타겟주소가 될지 내 다음 뒷 주소가될지 여기서 알 수 있음 이단계에서
그러면 여기에서 그에 해당하는 주소에 해당하는 명령어를 뒤따라 들어오게끔 그렇게 할 수 있음
이와같은 경우가 하드웨어적으로 지원되더라도 최소 1개의 stall은 필요함
1개도 안기다리고 바로 뒤이어서 결정 불가 그럴려면 fetch에서 가져오면서 동시에 뭔가 막 해야되는데 그러면 하드웨어 로직이 훨씬더 복잡하게 해야함 한사이클은 decode를 위해서 미뤄둔다.

## Solutions to Control Hazard
그래서 경우에 따라서는 저 한사이클 조차도 아낄려고 
한 stall 되어있지만 branch는 굉장히 많이 나타나는데
for, while 이런거 다 branch 임
loop이 굉장히 많음 
10만번 돌면 stall이 10만번 나타남 

저게 작은 stall 이아니다 쌓이면
저 stall을 어떻하면 줄일 수 있을까?
branch를 predict함 예측함
그래서 이번에는 가야될거 같다. 이번 branch는 가는거다 빠져나가는거다
predict 하고 predict가 맞으면 stall이 하나도 없이 바로바로 채워짐
predict가 틀리면 한 사이클 stall함
그 prediction을 마이크로 프로세스 레벨에서 함 프로세스가 계속해서 
여기에 for문이 있고 for(..)
					branch ... branch하는데
                    이런것은 대부분 branch가 선택된다고 predict함 
                    그럼 대부분 선택된다고 하니까 다음 주소를 이지점으로 알게됨
                    그런데 한번 실패함 맨 마지막 for loop 나갈때 실패함.
                    그때는 빠져나가니까 다음 명령어를 가지고 오도록 predict 해야했는데
                    습관적으로 가는것으로 predict 하니까 
                    그거 마지막 한번 빠져나올때 실패 그때는 어쩔 수 없이 한 사이클 stall할수밖에 없음
                    이렇게 predict 않하고 매번 그냥 분기를 두번째 사이클에서 결정하는것은 앞에서 봤던것처럼 너무 많은 stall 발생함

## More on Branch Prediction
이게 이제 predict 제대로하면 predict 된 명령어가 바로 뒤에서 따라감
잘못되면 여기서 decode 했더니 predict 주소와 여기서 decode target 주소하고 다르다.
그러면 여기를 stall 시킨다. 그다음 다른 주소로함

branch prediction 할때 두가지 타입있음
Static branch prediction
여기있는데로 이지점에서 branch는 타겟으로 고정시켜놓는 prediction은 컴파일러가 함
컴파일러가 쭉하면서 for문이네 이러면 여기서 branch는 branch target으로 prediction함
고정시켜놓음 한번 실패함 
그런게 loop, if문장 이런것들을 컴파일러가 함
대부분 현재 위치에서 뒤로 가는 prediction 한다든지 현재위치에서 앞으로 가는 prediction한다던지 이게 결정되있음
근데 컴파일러가함
Dynamic branch prediction
마이크로프로세스가 하는것임
여기 명령어, 그 위치에 history에 해당하는 count 정보를 둠
최근에 히스토리 각각의 브랜치 명령어마다 최근의 히스토리 기록하는 메모리를 둠
그래서, 이게 실행될때마다 최근에 이 위치에서 여기로 브랜치로 타겟으로 갔는지 아니면 실패했었는지 히스토리 기록해둠 일종에 로그해둠
이와같이 하면 뭐가 좋으냐면 이것은 위에는 컴파일러가 프로그램에 실제 행태를 보지 않고 결정적으로 해놓은것에 반해서 이것은 계속해서 돌면서 프로그램이 보여주는 형태가 달라질 수 있음 프로그램이 굉장히 많은 형태로 타겟으로 갈수도있고 한번 갔다 한번 안갔다 이런식으로 움직이는 경우가 있음 if statement 가 대표적인 예 
if ~~ 하면 갔다가 if~~ 안갔다가 굉장히 반복적으로 다이나믹하게 나타남
static 하게 predict는 반은 실패함 branch로갈지 안갈지 결정하는거니까 다이나믹은 걔에 형태에 맞게 predict할수있음 하드웨어적으로 실제 실행하는것

## MIPS Pipelined Datapath(1)
여기가 메모리 단계이다. 메모리 access 단계에서 결과가 나와서 pc로 들어갈 수있다는거
여기서 wb단계 마지막단계 wb단계의 결과가 실제로는 register로 들어감 
항상 생각할건 그 왼쪽이 시간이 흐르는걸보면 왼쪽이 앞선시간 오른쪽이 뒷시간 
뒷시간쪽 결과가 앞선 시간쪽으로 흘러가게 하는것은 불가능 서로 다른시간대다

단계와 단계사이에 그이전 단계 저장하고 다음 단계 그 결과 쓸 
자동차 파이플라이닝이 있는데 쭉있는데
단계와 단계사이에 이 단계에서 생산된 결과물을 놓는 선반이 있어야함 그 선반이라고 생각하면댐
여기서 처리한 결과물을 선반에 올려놓고 그다음 단계에서 그 선반에서 일감을 가져가서 다음일을 하는 그런 단계에 역할을 하는 일종에 버퍼 
레지스터 이다. state register, state buffer 임
여기서 나온 모든 결과물을 저장하는 

## Pipeline Flow(lw example)
로드를 가지고 예를들면 첫번째 단계에서 lw pc
lw 명령어를 가지고와야함 pc가 전달되서 여기에서 해당되는 lw명령어와서 쓰일것이고 
lw 명령어 가정
그다음에 insturction decode 그다음 얘는 여기에 있는 가져온 명령어 해석
lw 명령 rs, rt 다 나올것이고 일부는 offset으로 쓰일것이고 여기다 읽어낸 레지스터값쓰고 offset 으로 나온 16비트를 32비트 확장해서 쓰는 이때 얘는 놀까 ? 얘는 lw 바로 뒤에 명령어를 가지고 온다 (이거 중요)
그다음에 execution lw에서 execution 단계에서 하는일은 메모리에 address 계산한다.
execution 단계에서는 ea계산한다.
다음단계는 그 주소를 메모리에 보내서 메모리에서 읽어냄 여기에 여기에 결과가 담기고 memory access 단계 그 결과를 다시 

이때 저기서 이렇게 가서 결과를 메모리에서 나온 결과를 여기다가 전달해서 써줄려고 했는데 그런데 문제가 생김
이때 여기에 들어가는 레지스터 넘버가 있는데 이 레지스터 넘버가 누구의 레지스터 넘버일까 lw명령어가 원했던 레지스터 넘버일까? 이때 아니다. lw 뒤에뒤에뒤에 명령어가 읽혀들어와서 해석된 레지스터 넘버가 여기 들어감 이렇게 놔두면 여기서 load 가져왔던 값이 전혀 엉뚱한 레지스터로들어가는 문제발생 
이때는 여기서 들어온 레지스터 넘버를 바로쓸게 아니라 이 load 명령어가 원래 목적한 레지스터넘버가 어딘가 기록되어있을텐데 여기에 기록되어있어 그 기록을 계속해서 가지고옴

write register number을 여기서 들어온 놈을 쓸게 아니라 여기에 load가 지금 자기가 원하는 register number 기록하고 있을거니까 그 번호를 같이 보낸다. 이렇게 
해서 여기에 write register number를 여기에 계속 써줘서 계속 이어지게 하고 그 결과가 다시 여기로 들어가게끔 함 
여기서 보는 register number 바로쓰면 저 뒤에있는 놈이 쓸려고 하는 곳에다 써버리게 된다.

지금은 데이터 패스봤고

## Pipelined Datapath with Control Signals
컨트롤 시그널은 지금 
레지스터 write, alu 소스, operation, regdst, 그다음에 mem read/write, branch pc src
, memtoreg, 앞에서 나왔던거 그대로 나옴
이게 뭐야 이 regdst가 원래 이쪽에 있던건데 싱글사이클 멀티사이클 보면  regdst가 이쪽 write register number를 결정하는 앞에 mux가 붙어있음 이게 가져온 명령어를 해석하면서 이 명령어에 write register number를 계속해서 가지고 가기로 했는데 가지고 갈 번호가 rs, rd자리 번호냐 이것을 결정하는 mux임 
load는 rt 자리에 있는 번호를 가지고 가는것이고 일반 r-format 명령어는 rd자리에 있는 명령어가지고 가는거잔아 
그것을 여기에서 regdst 여기에서 신호선을 넣어서 결정한다.
write register number 임

## Control Signals Generation
그다음에 지난번에 말했음
instruction 가져온 다음에 그것만 들어가면 전체적으로 모든 파트에 필요한 컨트롤 시그널이 다 생성된다. 이건 바로 
그중에서 일부는 execution 단계에서 쓰일것이고 일부는 memory access 단계에서 쓰일것이고 일부는 write back단계에서 쓰일건데 
가면서 이 신호들을 다 가지고가! 왜 이 신호는 누구를 위한것이냐? 현재 와있는 이 decode된 이 명령어를 위한 신호이기 때문에 이 너는 이 신호는 나하고 같이 가줘야해 끝까지 데리고 다니면서 여기서는 내가 가지고온 신호중에서 execution 단계를 써서 내 명령어를 처리해줘!
다가지고 가도대 내명령어에 memory access단계에있는데 거기에서는 memory access단계를 가지고 나를 처리해야해 이렇게 해서 가지고 가야함
그런데 이것을 다가지고 갈 필욘없음 바보같이
여기서 execution단계는 썻으면 뒤에는 쓸필요가없음 걔네는 버리고 남은 부분들 앞으로 쓸부분만 가지고 앞으로 전진함

그래서 이제 전체적으로 만들어진게 이것임

## The Grand Example
이 example 연습해와라
명령어가 메모리에 5개가 쭉 있음 
얘들이 앞에 있는 파이플라이닝에 하나씩 들어가는 상황을 뒤에 보여주고 있음 슬라이드로 
고민해서 찾을 거 없게끔 값이 나와있음 왜 그런 값들이 나와서 막 움직이는지 따라가면서 이해해본다. 여기서 보다싶이 data 해저드가 없음 
branch 없으니까 컨트롤 해저드 없음 
아주 단순한 명령어들의 배열임 
이게 쭉 10 clock까지 갈때 어떤 과정속에서 명령어가 수행이 되나
특히 control에서 신호가 나옴 이 신호는 현재 가져온 명령어를 해독한 신호임
그게 다음 단계로 갈때는 이게 여기에 저장이됨 그리고 얘가 가지고 값은 이쪽으로 옮겨짐
그 과정을 머릿속에서 시뮬레이션 하면서 봄

이 example 잘 이해하면 파이플라이닝에 반은 이해함

