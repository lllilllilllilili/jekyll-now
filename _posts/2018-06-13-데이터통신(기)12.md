---
post : layout
title : 데이터통신(기)12
---
# Multiple Access
지난번에 봤던 시스템 데이터링크 레이어 를 어떻게 서브 레이어
아래쪽에서 
아래쪽을 배우는것이다.
아래쪽은 매체 라는게 피지컬 레이어 에 있는 통신 매개체를 얘기하는거임
이 매개체가 어 내가 
여러유저가 공동으로 사용하는거라면 이번주에 12장을 해요
3시간만에 
공유하는 이 아래에 미디어 제어를 하는 방식 이런거를 이제 살펴본다 이번주에
그런 멀티프로세스 컨트롤 멀티플 엑세스 컨트롤
크게 우리 3가지 로 분류
랜덤 액세스 임의로 아무거나 접속을 하는방법

누군가가 제어를 통해서 순서를 정해준다던지 누군가의 지시를 받아서 이 공유된 자원에 자원을 나눠쓰는 제어를 기반으로 하는 프로토콜 방법
채널 화 하는거는 뭐 프리퀀시 를 나눠서 쓰던지 시간을 나눠서 쓰던지 아예 1/n 해서  쓰는방식 채널 화
이 3가지 방식 이 개념이 다르다

제일 이해 하기 쉬운게 제일 생각 할게 많은게 랜덤임
누구도 여기에 가령 ap가 여기 무선 접속을 위한 ap가 채널을 열수있는 ap를 쓰고 있다고 그럴때 우리가 60명 되죠 
60명이 채널 16개 밖에 없는것을 어떻게 서로 충돌없이 접속해서 쓸수있을까 이런걸 얘기하는건데 아무런 제어없이 이 랜덤하게 접속하는 방식이 첫번째 소개되고 우리가 보면 알겟지만 3가지 접근 중에 랜덤엑세스가 효율이 좋다 혼동속에 더 어떤 성과가 더 좋다.

그 내용을 먼저 살펴본다

## 랜덤엑세스
어 각각 지금 3가지 접근 방식중에 각가의 여러가지 3분류속에 디테일 들어가면 여러가지 접근이있다
랜덤 엑세스는 알로하 부터시작해서 멀티플 엑세스 방식임
멀티플 엑세스, 공유되는 자원 하나밖에 없는 자원을 여러명이 어떻게 공유하느냐 서로 충돌없이 그거에 대한 최초의 방식이 알로하 방식임

그다음에 csma 이런 방식 발전해왔고
컨트롤이 있는 방식은 리절베이션, 폴링, 채널을 나눠서 1/n 쓰는 방식은 우리가 이미 비슷한 얘기를 했죠 통신에서도 
fdma tdma 
여기서도 같은 개념이 쓰이고 다뤄진다.
3시간동안 이것들을 몽땅 볼려고한다 3시간동안

랜덤액세스 4가지는 하나의 줄기다 살을 붙여나가는 방식이다.
랜덤 액세스는 요 문장을 보면 
또는 병합 방식이라고 하는거죠 랜덤 액세스는 병합이라고도 부른다 여기는 어느 그 단말기도 어느 스테이션, 어느 단말기도 다른 단말기에 우선권을 갖고 있지 않다 누구도 누구보다 우월하지 않고 동등한 입장에서 어 누가 누구를 지시하거나 이런 그런 제어 개념이 전혀 없는것이다
단 각각의 그 노들은 어느 한순간 각각의 순간에 보낼 데이터가 있을때 과연 이거를 보낼까 말까를 스스로 판단한다. 남들 상관없이 내가 보낼까 말까 라는걸 판단하는데 과연 그 판단하는 룰이 무엇인가 이거 랜덤 액세스 중요한 얘기다 그 룰이 이와같이 알로하 에서부터 시작해서 점점 발전을 한다 현재는 
현재 csma ca 하는 무선 방식
csma cd는 유선쪽에서 쓰인다.
우리가 생각하면된다.
현시점에 쓰인다
자 우리가 여러 유저가 하나의 매개체를 접속을 하고자 할떄 이것을 충돌을 결국 피해야 되는데 어느 한순간에는 하나의 유저만 요 매개체를 사용하고 있어야 한다 그러면 충돌을 피하기 위해서 우리가 고민을 할것이 무엇인가 생각을 해봤는데
언제 내가 여기에 접속할수있는가 를 결정해야 되겠고 내가 접속할려고하는데 다른 유저가 사용하고 있으면 내가 무엇을 해야하는가 자이런게 맥이란 프로토콜을 만드는데 필요한 내용들이다 내가 보냈는데 과연 이게 실패했는지 성공했는지 어떻게 파악할 수있을까? 
이걸 알아야 여기에 대한 후속작업을 하죠 실패했다면 다시 보내고 뭐 이래야된다 이것도 당연히 알야겟죠 무조건 전송하면 끝나면 안되고 충돌이 발생했다면 다음 어떤 액션을 취하냐, 재전송을 해야되는데 재전송 을 무조건 할것인가 또 어떤 절차를 통해서 재전송 할것인가 이런게 지금 이 맥이라는 그 프로토콜 만드는데 중요한 주제들이다. 이거 하나하나가 
이런 것들이 하나 하나 답이 주어지면서 프로토콜이 완성이 된다. 그래서 저런것들에 대해서 과연 아까 우리가 본 10가지 정도에 해당되는 맥들이 어떻게 해결을 했는지 살펴본다. 
이런 문제들에 대해서 랜덤 엑세스 를 먼저 살펴본다

## 이어서 랜덤엑세스
랜덤 엑세스는 4가지라고 했늗네
4가지를 발전순서를 보면 이런순서다.

할로하가 여깄다, 알로하 ma 
단순한 멀티플 엑세스 라고하는 어 기능만 있는 알로하가 여기있고 
cs ma 앞에 cs가 붙었죠 ma는 그냥 내가 보낼게 있으면 전송하는 아주 단순한 기능인데 이것이 발전해서 cs라는게 앞에 붙음 케리어 센스
케리어 센스는 이제 내가 사용할 매개체를 센싱한다 그래서 누가 보내고 있는지 아닌지를 감지를 하고 나서 내가 보내든지 말든지 하는게 csma 
cs 라는게 없는 ma는 그거 없다 라는거임 내가 지금 채널을 누가 보냈는지 안보냈는지 감지하는 기능 없이 내가 보낼게 있으면 보내고 없으면 안보내고 하는게 아주 가장 단순한 ma다.
cs는 채널 유효 상태를 살펴본다 얘기고
자 그렇게 해서 보낸다고 하면 남이 사용하지 않을때 당연히 보내겠죠 당연히 캐리어 센스 이 매개체를 아무도 사용하지 않을때 당연히 보냈는데 다 그러면 문제 가 해결되는거 같이 보이지만 그래도 충돌이 발생한다.
왜 충돌이 발생할까 내가 지금 요 공기속에 신호가 누구한테서 오는 신호가 있는지 없는지 봤더니 아무 신호도 없더라 그래서 내가 데이터를 보낼게있으면 보냈다 이거임 저 내가 혼자 쓸수있는 ap조 ?? 데이터를 보냈어 그런데도 충돌이 발생할수있다 왜그럴까
왜 충돌이 발생할까 충돌이 발생하면 여기서 끝나면 되지 캐리어 센스 멀티플 엑세스 에서 끝나면 되지 
충돌이 발생할것이기 떄문에 자 여기는 충돌이 발생한걸 디텍션  할수있는 기능이 보완 된것이다 csma에서 내가 보낸게 충돌이 발생했는지 안했는데 collison detection이다. cd라는게 충돌을 감지 해서 거기에 맞춰서 내가 무엇인가 액션을 취하는것이 보강된 게 이기능이다. csmacd 
어 때에 따라서는 컬리션 디텍션이 불가능한 경우가 있다 실제 무선 통신에서는 이 컬리션 디텍션이라는게 뭐냐면 내가이 데이터를 보냈을때 내가 보낸정도의 이 공기중에 시그널 레벨이 올라가야 되는데 계속 감지해보니까 이시그널 보다 더쎈 시그널이 느껴지더라 그러면 내꺼 말고 또 다른 사람이 있다는거지 여러 시그널 이 합해졌단 식으로 시그널을 감지하는데 
이런것을 유선통신에서는 그 시그널 이 명확히 그 증가되는것을 감지할수있는데 이런 무선에서는 아주 그 미묘하다 이거임 
내가 혼자 만 내보낸 상태 와 다른 사람이 동시에 보냈을때 시그널 차이가 별로 눈에 안띄게 그 차이가 안느껴진다. 
무선에서는 컬리션 디텍션이 굉장히 어려운것이다. 그래서 그러면 컬리션 어보이던스 그럼 최대한 컬리션, 충돌을 피하는 방식으로 내가 조심하자 
이거죠 
그래서 무선쪽에서는 csmaca방식을 충돌감지가 어렵기 떄문에 이 방식을 쓰는거고 유선통신에서는 csma cd를쓰는것이다 유선이 우리가 유선이 뭐죠 버스를 여러 유저가 같이 쓰는 이더넷 같은거
랜에서 버스가 하나밖에 없는데 여러 유저들이 여러 pc들이 지금 굉장히 빠른 버스를 공유하는것이다 
버스구조에서 살펴봤어요 

이럴떄 동시에 2개이상 이 시그널을 보내면은 충돌이 나서 서로 데이터가 꺠지는것이다.
이와같이 유선으로 사용하는 환경에서는 시그널의 레벨이 명확하다 이거에요 이런 유선에서는 컬리전 디텍션이 가능한대 
무선에서는 어 그 신호변화가 감지가 어렵다 그래서 애당초 조심하자 이거임 컬리젼 어보이던스
충돌 방지 기능이죠
캐리어 센스도 하고 그러니까 누군가가 보내는지 안보내는지도 확인을 하면서 그것보다 더 보수적으로 충돌 방지를 위한 더 보강된 메커니즘에 의해서 채널을 억세스 하겠다. 
이렇게 분류된다 그래서 발전이 이렇게 3단계로 간다 이거죠 그래서 한줄기 로 쭉 살펴보면은 저 4가지 기능을 다 살펴볼수있다. 제일 먼저 나오는게 가장 무식한 다중접속 그냥 멀티플 엑세스 , 캐리어 센스도 없다,.

## ma 
1970년대 인공위성 어 인공위성 여러가지의 여러 단말기들이 그 인공위성과의 그 통신을 하는 그런 환경에서 이게 처음 나왔다 이방식에서 는 그냥 멀티플 엑세스 말그대로 이 스테이션들이 보낼게 있으면 무조건 보내는것이다. 무조건 케리어 센서도 없이 무조건 보내는것이다.

이그림보다는 이그림을
## figure 12.3
지금 매개체가 하나인것인데 스테이션이 4개가 있다 유저가 4개가 있다. 내가 보낼겟있어서 보낸다
여기 노란색을 보내는거고 여기 파란색 보낸다 여기 진한 녹색 여기는 자두색 
무조건 보낸다. 그러다 보니까 이와같이 이 케이스가 얘들이 충돌이 난케이스 오른쪽으로 가면서 이 시간 축에 흘러하니까 동시에 겹쳐있는경우가 얘 두개는 충돌 얘는 이경우에 4개가 다 충돌이난것이다
얘들은 전혀 충돌난것에 대한 감지나 에방조치가 없다 알로하방식은

단 그러면 여기서 충돌이 발생하기때문에 나름대로 가지고 있는 장치라고 하면 확인 응답을 가지고있다 전송후에 저거는 얼마든지 충돌이 발생할 수있기때문에 ack 확인 응답을 기다리는것이다 일정한 시간동안 이 일정한 시간동안 확인 응답이 오면 잘받았다라는 상대방, 수신측으로부터의 ack메시지가 오면은 잘된것이고 읿정한 시간동안 타임 아웃동안 이게 오지 않으면 충돌됫구나 해서 다시 전송하고 단지 요런 기능만 있는것이다 알로하는 
간단하다 무조건 보내는 데이터를 그리고 나서 일정시간동안 ack가 오는지 안오는지 기다렸다가 안오면 또보내고 계속 이런 방식으로 어 하는게 바로 알로하다.

## 순수알로하
자 우리가 이거를 분석을 하는거죠 이경우에 과연 내가 어느정도에 성능 을 얻어 낼수있을까를 이제 또 엔지니어는 이런 순수 할로하를 퓨어 알로하 라고도 하는데 말그대로 너무 단순한 요게 순수라고 붙은 까딹은 뒤에 요거에 약간 변형된 조금 발전된 슬랏티드 알로하라는게 또있어서 
알로하라는게 2가지가 있어서 구별하기 위해서 순수 알로하라는 이름을 붙였다.
이런 방식으로 데이터를 보내면 충돌이 나겠죠 순수 알로하 과연 어떤 방식으로 제어 가 되는지 무조건 보낸다고 했는데
ack가 오지 않으면 타임 아웃 지나면 다시 보낸 다고 했는데 나름대로 순수알로하도 이런 알고리즘을갖고있다 앞으로 이 랜덤 액세스 방식들은 이런 플로우 차트를 각각 보여주고있다 근데 하나하나 이게 처음 보여주는 플로우 차트인데 여기서부터 시작해서 그다음버전, 그다음버전을 조금씩 이 루틴이 하나씩 추가가 되는 식이니까 이게 처음 들여다 보지만 가장 기본적인 루틴이기때문에 나름대로 살펴본다.

이 어느 스테이션이 어 보낼 데이터가 이제 생겼다 그러면 k는 보내는횟수죠 내가 이 충돌나면 계속 재전송을 해야하는데 지금 현재 한번도 안보냈죠 처음 생겼으니까 지금 
k=0 에요 k는 보내는횟수다 이거임 무조건 보내는거지 이 ma는 이 보내보고 
보내보고 타임아웃 까지 기다려본다. ack가 오는지 안오는지 
타임 아웃을 기다리는 시간이 2* tp 다 당연히 내가 어딘가에 이 어디에서 어디에 보냈는데 여기 가는시간이 tp 면 응답이오기까지 또다른 tp가 걸린다. 그래서 2 * tp 라는시간이 이 왕복시간이잔아 내가 가고 ack가 오기까지 근데 이거보다는 큰 시간을 기다려야 되는 거죠 타임아웃의 값은 대개 이 2*tp보다는 오랜시간을 기다려 봐요 그래서 기다려봣더니 ack가 왔다 그러면 끝난거네 이 패킷전송은 끝난거죠 
오지 않았을 경우가 이제 과연 이 퓨어 알로하가 어떤장치가 있는지 살펴보자 
한번더 전송해야되니까 전송횟수를 하나를 증가시킨다 증가시키고 나서 과연 이 하나의 패킷을 전송하는 제한이 있다. 그 가령 10번이상은 계속 재전송 하지않게끔 우리가 만들어놨다 이알고리즘을 그렇다면 맥시멈 은 한번 비교해본다. 10번이나 충돌했는지 뭐 이런것이다 계속 10번이나 시도했는데 계속 충돌이 났다 그러면 네트워크가 이상하니까 여기서 멈춰야지 이걸 계속 수행할 수없겠죠 그래서 대충 어떤 맥시멈 넘버가 있다 그래서 그 횟수에 도달했는지 살펴보고 도달했으면 이제 포기하는것이다 포기

도달하지 않았으면 다시 재전송하죠 그런데 그렇다면 무조건 이 타임 아웃 대재? 마다 재전송하느냐 나름대로 여기서 좀 로직을 발휘를 하는것이다 좀 기다려보는데 랜덤한 시간동안 기다려본다 왜냐하면 이 충돌이 났단 얘기는 나말 고 또하나가 있는것이다 상대방이 그러면 상대방들이 다 타임아웃 동안 기다렸다가 즉시 보내면 또 충돌날거아니야서로 계속 이 나말고 또하나 더있단 얘기니까 그렇다면 충돌을 또다시 발생하는것을 방지하려면 서로 기다리는시간을 달리주면은 된다 라는 간단한생각이다 충돌이 나면은 충돌ㅇ이 나면 어떤 넘버를 고르죠 0~2의 k승 -1 가령 k가 지금 3번째 시도 , k가 시도횟수죠 지금 k가 내가 k번3번째 시도면 0~ 7사이에 랜덤하게 숫자하나 골라내는 것이다 그래서 그거 곱하기 그 골라낸 랜덤한 넘버 고합기 또 이만큼의 여기 랜덤한 숫자를 하나 골라서 그거 곱하기 tp 
여기에는 이제 서로 나는 7골랐고 상대방ㅇ은 5를 골랐으면은 서로 기다리는시간이 다른 
다른 시간 동안 기다린다음에 보내니까 충돌할 확률 이적어지게 만든다. 그래서 랜덤한 숫자를 여기서 고른다. 어 그래서 랜덤한 시간동안 기다렸다가 무조건 보낸다 이거지 그시간이 지나면 이게 요런 메커니즘이 충돌났을때 서로 다른 랜덤한 숫자를 골라서 기다리는시간을 랜덤하게 선택하게 하는게 앞으로 나올 모든 그 랜덤 엑세스다 똑같은 이런 기능을 갖는다 
랜덤한 그 기다리는 시간 이게 제일 중요한 골격이다 랜덤엑세스에서 충돌났을때 랜덤하게 기다린다 
각 노드별로 서로 다른 숫자를 고르게 하는거죠 이게 
근데 고르는 범위가 k하고 관계되죠 내가 4번째 시도할때는 0부터 15까지 5번쨰 시도할때는 0부터 31까지의 왜그러냐 이게 지금 계속 반복되서 충돌이 난다는것은 네트워크 가 굉장히 복잡하다는 거임 자꾸 충돌나니까 그래서 이 랜덤하게 기다리는 시간에 폭을 더 넓게 서로 상대방하고 서로 갖을 수있는 범위 를 더 넓게 만들기 위해서 이 상한선 값을 계쏙 키우는것이다 내가 시도하는 횟수만큼 비례해서 점점 키운다. 
그래야 더 서로 기다리는 시간에 그 차이가 커질수있다. 이게 바로 , 가장 간단한 멀티플 엑세스 방식
충돌났을때 서로 기다리는 시간을 좀 달리한다. 이게 제일 예고 그냥
## 12
어 프로퍼게이션 타임이 얼마인 상태에서 랜덤한거 이거는 뭐 간단하게 보면 여러분 알겠고 이게 더 
가령 K가 지금 10회이상이더라 그러면은 어 이걸 무한정 이걸 키우는게아니라 이 허용된게 15번 까지 가령 K가 15번까지 허용된다 그러면 이 랜덤하게 웨이팅 타임을 고르는 이 숫자가 이 K가 2의 15승까지 가면 어마어마한 숫자다 그런 경우에 우리가 대충 15로 상한선을 15까지 허용이 됬어도 10 , 2의 10승에서 1024 요 이내로 끊고 랜덤한 값을 찾아내는 방식으로 한다 이런 내용임

## 12.5
이제 아까 얘기했듯이 이런 식으로 접근했을떄 과연 어느정도 내가 확률적으로 성공할까 이게 엔지니어 도 이런생각을 해봐야한다
엔지니어들은 이런저런 변수, 이시스템 전체 네트워크 상황을 표현하는 변수들을 갖고 과연 내가패킷하나 보냈을때 확률이 얼마냐 이거임 성공할 확률이 그러기 위해선 이런 그림을 한번 살펴본다. 이 파란색 위주로 살펴본다. 이 사이즈는 뭐 패킷사이즈는 일단 어떤 그  성능에 대한 해석적인 거 솔루션 을 구하기 위해서는 여러가지 복잡하게 만들어 놓은것을 재껴버리는 그러니까 단순하게 만드는 가정들을 한다 그래서 지금 이경우는 패킷 사이즈들이 가령 같다 라고 하자 이거임 
패킷사이즈들이 뭐 이런 가정 
자 이 파란, 어 파란 패킷 입장에서는 얘가 충돌이 안나기위해서 는 과연 어떤 조건이 있어야 되느냐 하면은 어떤 조건이 있어야 되냐면 
얘가 지금 패킷을 보내기 시작한 순간에 아무도 없어야 된다. 얘는 지금 있잔아 노란색이 그러니까 보내는 순간 부터 이미 충돌이다.
그렇죠 내가 보내는 순간에 아무도 없어야되 그얘기는 뭐냐하면 다른놈에 보내기 시작한 요 시점이 요 , 이게 패킷을 보내는 전송하는 시간인데 요 아래에 있으면 안된다. 이 시작 시점이 다른 그 스테이션이 이 기간내에 보내기 시작하는놈이 없어야 내가 보내는 시점에 아무도 없는거지 다시말해서 이 노란색이 여기서부터 시작했으면 가봐야 여기서 끝날테니까 충돌이 안난다. 요 구간에 아무도 보내지 말아야되! 
뿐만아니라 내가 보내고 있는사이에 누구도 끼어들면 안되는거지 
초록색이 지금 또 뒷부분에서 충돌 일으켰다 자 그러면 생각 해봐라 
이 어느 만큼 시간동안 나말고 보내는 시람 이 없어야되 이그림을 보면 어느시간동안? 얼만큼 시간동안? 요 한 칸이 전송시간이 tf 라고하면 (티프레임) 두배죠  그 두배다 두배 이 앞에서도 보내고 있으면 안된다고 했잔아 누구도이 상태에서 누구든 시작하면 안된다 보내는걸시작하면 안되고 아울러서 내가 보내고 있는 사이에도 누군가 시작하면안된다. 따라서 두배의 이 곱하기 티프레임 이라고하는 이 시간동안 아무도 보내면 안된다. 보내기 를 시작하면안된다.
보내는 시도를 하면 안된다. 얘들은 채널 엑세스 캐리어 센스가 없기때문에 아무도 보내지 말아야된다 일단'이 요구간을 오로지 나만 보내고 있어야한다 남들은 보내고 남등들은 보내지 않아야 된다. 취약지역이 여기서 여끼자기 취약시간이다.
나를 제외한 남은 개입을 하면안되는 아주 이 취약기간 vulnerable time이라고한다. 요 취약 기간이라고 번역할수있다. 퓨어 알로하는 전송시간 의 2배 만큼의 vulnerable time을 갖는다. 
이거하고 뒤에 이제 요걸 좀 개선해서 여기에 슬랏티드 알로하 개념이 나온다 그거하고 달라지는걸 나중에 비교를 해봐야 된다. 
이제 남들이 저시간동안 전송하면 안된다 라는 얘기가 나왔죠 이제 그러면 수학적으로 이 그 확률값을 구하는 과정을 볼수있다 .
자 여기 그 은행이 라고 하면 
## 확률
은행이라고하면 은행에 여기서이제 우리가 사람이 들어오는 카운트 했을떄 언제들어오고 ㅇ뭐 언제들어오고 또언제들어오고 이렇게 띄엄띄엄 들어오고 이러다 몰려 들어오기도하고 뭐 이런 은행에 사람들이 들어오는 패턴이 있을거라 이거임 
저것도 마찬가지로 여기 인공위성이 하나있는데 여기에 이렇게 데이터를 전송하고 자 하는 시도가 발생하는데 이 발생하는 그 패턴을 시간쪽으로 쭉 늘어나 보면은 누가 시도하고 누가 몰려서도 시도하고 이런식이다
이런식이 얼마든지 모델링 할수있다.
자 그런 패턴을 은해에 사람들이 들어오는 패턴, 통신에 일반적으로 뭐 전화 내가 지금 24 채널 을 쓰고있는데 이 전화를 거는 패턴뭐 어느순간에 누가 전화걸든 걸었는데 얼마후에 전화걸고 이렇게 뭔가 이벤트가 발생하는걸 패턴이 시간축으로 쭉 늘어았을떄 쟤들이 어떤 그 확률적 분포를 갖느냐 이런 얘기를 먼저해야 이 분석이 가능하다 수학적으로 분산이 가능해 우리가 이 시스템을 해석을 할때 이 시스템에 인풋이 어떤모양으로 들어오는지를 알아야 이 시스템에 출력이 어떻게 나오는지 알게된다. 인풋을 어떻게 정의하냐가 굉장히 중요한것이다 엔지니어링 하는데 어느 시스템을 하던지 간에 그래서 우리가 이런걸 구성할떄도 어떤 패턴으로 다른 그 노드들이 데이터를 보내는시도를 하느냐 이 게 중요하다 이런식으로 시간축으로 시간 축으로 이제 발생한 이벤틀르 쭉	늘어놓는것이다.
여러가지 방식이 있는데 이런방식도있죠 정확히 10분간격으로 들어오더라, 이런 패턴은 너무쉬운것이다 우리가 이걸 가정할수있어요? 은행에 문정문에 있으면서 10분에 한명씩 사람이온다 이 이렇게 너무 간단한 가정을 하면 해석도쉽지만 현실하고 너무 떨어진다 그래서 점점 사람들이 현실에가까운 이 도착 발생 패턴을 우리가 만들어가는 이런 저런 확률분포를 찾아내는데 그중에 이 네트워크 쪽에서 이런 어떤 이경우나 저경우나 항상 네트워크는 항상 비슷한 패턴이다 이 유저들이 데이터를 발생하는 인벤트가 발생하는 패턴을 어떤 어 확률적 분포를 보여줄떄 가장 많이 쓰이는게 바로 포아중이라고하는 포아중 디스트리 비우션이라고 하는것을 배운다. 이거를 가정한다. 
포아중 디스트리비우션 여기 뭐 깊이 들어갈 얘기는 아니지만 뒤에 우리 이책에서 다루고있는 예를보면 
이거 소개없이 그냥 나오기때문에 잠깐 이걸 소개했다 왜 그게 나오는지 소개를 해야할 필요가 있어서 한다 
네트워크에서 우리가 큐인이라는것을 배웠죠 queueing 이거는 스펠링이 항상 어렵다 이거는 
큐잉이라는게 기다리는 시간, 자여기 트래픽 들이 막들어오는데 나가는 속도는 일정하다 그러면 트래픽 합격이 들어오는 패턴이 어떤 지를 알아야 얼마야 기다렸다 나가는지에 대한 수학적인 분석이 이루어진다  바로 이때에서 이 큐 에 들어오는 패턴을 제일 많이 사용하는게 코아중 디스트리비우션이다. 이거를 토탈, 람다라고 람다 패킷 퍼 세컨트 초당 평균 너 랜덤하게 만 들어오 게 하는데 평균잡아서 초당 람다개 가 들어온다. 다시말해서 여기서도 지금 할로하를 쓰는데 초당 람다 개의 스테이션들이 100 패킷으로 보낸다 라고 가정을하자 그럴때 포아중 디스트리비우션은 어떤 얘끼를 하냐면 T동안 어떤 주어진 시간동안 N개가 N개 발생학 확률 , 이거야 간단하게 지금 우리가 알로하든 뭐든 똑같다 있거임 이러한 퍼버에 큐에 평균 람다가 들어오는데 N개가 발생할 확률은 요렇게 표현한다. 여기 지금 필요한 변수 다 있다 람다 t, n이 다있다. 이게 지금 그 포아중이고 여기서도 알로하에서도 이 포아중 개념을 쓴다. 

자 이 포아중이 왜 그 많이 쓰이냐면 가령 이 메모리 리스라는 그 기능이 있는데 
그거까지 생각할 필요없이 포아중이 이런 발생한느 패턴이 포아중 디스트리비우션을 갖는다 라고 하면 우리가 이 런 큐잉 할떄 인터 어라이벌 타임이라는게 중요함 간격 
이 간격 이벤트가 발생하는 간격은 또 무슨 확률분포를 갖는냐 인저리 해석하는데 굉장히 중요하다 지금 포아중은 평균잡아 어느 일정한 시간동안 몇개가 발생하느냐 라는거를 얘기하는 확률분포고 그럴떄 각각 이벤트 별로 발생한 간격에 대한 이 각각의 랜덤 베리어블 들은 또 어떤 확률 분포를 갖느냐 이것도 별개다 근데 포아중 방식으로 발생하는 패턴들의 요 인터어라이벌 타임에다 디스트리비우션은 람다 익스포넨셜 마이너스 람다 티라고 하는 큐잉에서 굉장히 중요한 디스트리비우션을 가져요 분포야 익스포넨셜 지수 분포라고 하죠 이게 이 두개가 짝을 이루면서 이 큐잉 세우리에 대한 어떤 해석적인 수학적인 접근을 하는데 이 두가지에 아주 독특한 특성들이 굉장히 도움이 되는것이다 큐잉이 굉장히 어려운 분얀데 얘들의 독특한 특성 그래서 이거를 가정하면 인터어라이벌 타임은 이런또 익스포넨셜 디스트리비우션을 갖고 얘들의 독특한 특성을이용해서 큐잉 세우리가 접근하기 쉬워졌다. 

이렇게 큐잉 이런 우리가 저알로하에서 t동안 n개 발생할 확률이 이렇다 라고 가정을하면 자 여기서 이제 우리가 vulnerable time이 2tf라고 했죠 2 티 프레임 
저기서 우리가 원하는게 뭐죠 내가 보냈는데 내꺼가 성공할려면 p t 2 프라임 동안 어떻게 되야 되죠? 0개가 발생해야 된다. 내꺼 뺴고 0개가 발생해야 된다. 그렇죠 내꺼 뺴고 t 2개의 프레임 전송기간동안 0개가 발생한다 그걸 여기다 집어넣는다 여기다 여러분들 이 집어넣어보면 이게 n이 0이고 t가 2 * t 프라임 임 
이렇게 되죠 
자 이거 지금 분모가 n 팩토리얼 이라고 하는데 여기다 0넣으면 어떻게 되느냐 이거 여기다 0 이면 어떻게되고 이거다 정의상 1이된다 여기 0승이면 1이지 따라서 익스포넨셜 마이너스 람다에 이 티 프라임 이라고 하는 값이 나온다 이게 내가 보냈을때 패킷을 보냈을떄 성공할 확률임 이게 
여기까지 그 요부분이 여러분 적고있는데 대충 정리가 되어있다 이게 성공학 확률 에 더해서 과연 한슬랏동안 한 티 프라임 동안 과연 얼만큼 성공할까 스루풋을 그렇게 정의했는데 여기 로테이션이 다르지면 여기 한번 이걸 다시보면 어라비벌 레잇 여기 람다 라고 했는데 여기서는 스몰 쥐로 표현했다 패킷트랜스미션 타임을 티 프라임이라고 하는데 여기서는 타워 라고 하죠 로테이션만 다르지 지금 여기서 얘기한 정의들이 저기 그대로 가있다 어 하나의 프레임 전송시간동안 평균 몇개 성공하느냐 이 내가 평균 초당 g개를 발생한다 그랬죠 그런데 그중에 타워 하나의 프레임 전송시간이 타워 라고 했잔아 그러면 많아야 1개가 가는거죠 타워 프레임 그 타워 라고 하는 프레임 전송시간동안 그 여기지금 평균 성공하는 그 하나의 전송시간동안 이 제너레이트 뜨네 ? 그 발생한 개수 요 부분이 좀 어려울지 몰라도 한번 보죠

이게 내가 보냈다라는 전제로 성공할 확률이죠 이게 보냈다라는 전제로 그러면 보내는거는 여기에 나와있음 내가 보낼 확률은 g다 내가 쥐, 쥐라는게 여기서 람다죠 람다
여기서는 람다가 되지 내가 보냈는데 자 이 지금 g 초당 내가 보내는 개수가 g개가 있다죠 있다 이거죠 이중에 성공할 확률이 이만큼이니까 이게1초동안에 성공할 개수에요 이게 근데 여기서 지금 보자고 하는건 하나의 프레임 전송기간동안 보자고하는거니까 여기에 타워를 붙인다 이거죠 이렇게 
타워를 여기에 프레임 전송시간은 티에프라고 이 티에프라고 이 여기서는 되고 저기서 타워가 여기서 티프레임이죠 
이놈이 여기지금 표현이 됬죠 이 놈이 자 여기서 나온 이놈이 여기서 얘기한 스루풋이죠 하나의 프레임 전송시간동안 과연 몇개가 성공할까 맥시멈1이다 하나의 프레임 시간동안 성공할 수있는 가령 이게 0.5라는것은 두개 보내서 하나 성공한다 이거죠 이거는 확률이 50% 밖에 안되는 그런 되는거죠 이게 지금 내가 알고자하는 최종 형태다. 
그래서 여기서 이 그 표현하기를 g라고 하죠 라지 쥐라는 놈을 여기서 람다 곱하기 티에프라고해서 이렇게 로테이션을 하나바꾸면 이확률값이 어떻게 되냐면 쥐곱하기 익스포넨셜 마이너스 이 쥐라고 하는 이런 값이 나온다 여기있죠 이게 라쥐 에스 쓰루풋 에스 하나의 프레임 시간동안 성공할수있는 프레임의개수 바로 요개 이퓨어 알로하에 성공을 얘기하는 수식이다 이거죠  저그림을 그려보면 라지 쥐라고하는 변수를 이용해서 저 그래프를 그려보면은 어떤 모양이냐면 이런 모양이다 어느 특정한 값에서 맥시멈 을 하나갖고 줄어든다 이거죠 우리가 필요한것은 바로 이값이다. 이값이 필요하다 스루풋이 최대가 되게끔 하는 저기서 얘기하는 쥐타워 라는것은 이게 뭐죠 하나의 전송기간 동안 몇개를 보내느냐 이거임 어떤 환경? 하나의 이 전송시간동안 몇개를 보내면 이 스르풋이라는게 최대가 되느냐 
함수가 쥐 에 익스포넨셜 마이너스 이 쥐를 디디티 라쥐쥐로 나눠어서 이게 제로가 되는 포인트를 잡으면 이게 최대값을 주는 쥐가 되죠 미분을 해보면 이거 익스포넨셜 함수고 여기에 쥐함수 이거 미분하면 간단하죠 이거는 쥐 익스포넨셜 마이너스 이쥐 뺴기 이쥐 익스포넨셜 마이너스 이 쥐 이퀄 제로가 되서 쥐이퀄 얼마죠 얘뭐 이것들은 다 약분되어버리면 1/2이란 값이 나온다 쥐이퀄 1/2 이다.
이건 간단한 미분식이고 이게 무슨말이냐 쥐이퀄 1/2 .
여기 1/2이죠 여기가 1/2 이죠
하나의 프레임동안 하나의 프레임전송하는동안 반개만 보낸다 다시말해서 두개의 프레임 전송기간 동안 한개만 보내면 맥시멈이 나온다 얘기지 그렇죠 지금 이 쥐라는 값이 갖는 의미가 이게 하나의 프레임 전송시간 동안 몇개가 발생하느냐 라는게 이 라쥐 쥐 의 의미이다. 우리지금 근데 그값이 1/2이라는 것은 하나의 프레임 전송기간동안에 반개만 보내라 다시말해서 2개프레임 전송기간동안 한개만 보내 그러면 맥시멈이 나올것이다 그럼 그값을 원래의 값에 집어넣어보면 요 값이나오는것이죠 이런 퓨어알로하가 얻어낼수있는 맥시멈 스루풋값이 얼마냐 이거죠 1/2값을 집어넣으면 되죠 그값을 집어넣어보면 0.184 라는것임

18.4 프로밖에 안된다는것임 이 퓨어 알로하는 아무리 해봐야 18.4 프로밖에 안된다 다시말해서 내가 1000개를 보내면 184개만 성공한단 얘기지 이 퓨어 알로하 방식을 쓰면은 이게 당연하게 지금 맥시멈 값을 주는게 하나의 프레임 시간동안 반개만 보내라 아니면 두개의 프레임시간동안 한개만 보내라 당연하거 아니야 지금 우리 퓨어 알로하를 보면 vulnerable time이 두배의 트랜스미션 타임이라고 했죠 이 여기서 여기까지의 사이의 나말고 아무도 없어야 성공한다.
이 얘기가 정확히 나오는것이다 이 두개의 프레임 전송시간동안 오로지 한개만 전송을해야 이방식은 맥시멈 스루풋이 나오는데 그래봐야 0.184 , 18.4프로 밖에 안된다 지금 여기가 여기까지가 강의 12장을 설명할때 여러분이 어려워할지도 모를 부분이다 스루풋 얘기하는게
이런 스루풋 을 5분동안에 하나만더 

## 하나만더!!
이런 스루풋 의 문제를 해결하는 방법이 슬랏티드 알로하라고 퓨어 알로하에서 하나발전한건데 이것을 슬랏을 시간을 정확히 쪼개 놓은것이다 슬랏으로 나눈것이다 그래서 이 슬랏티드 알로하 에서는 내가 패킷을 보낼게 있을때 캐리어 센싱을 물론 여전히 안하는데 알로하는 내가 보내는시점 만큼은 딱 지켜줘야되 아무 떼나 보내는게 아니라 이 슬랏이 시작할때 
슬랏이 시작하는 시점에만 각각의 스테이션들이 보내야된다는거임 이렇게 되면 무슨 효과가 있죠 동시에 보낸거말고는 충돌이 없어져야 된다. 
그러겠죠 이 내가 보내고 있는 중간에 누가 보낼일은 절대 없다 이거죠 이거 패킷들이 같은 사이즈라고하면 보내는 시점들을 정확히 슬랏 시작점에서만 보내게 서로 약속을 해두면 정확히 동시에 보낸 애들만 충돌해요
이렇게 되면 이런 방식에서는 VULNER ABLE TIME이 어떻개 되지 취약기간이 어떻게 되? 투프라임 시간이었는데 이경우는 어떻게 되죠? 1티프레임만 되죠 하나 시간동안만 나혼자 보내면 되죠 그똑같은 식을 여기에 이제 퓨어 알로하에서 슬랏티드 알로하는 하나의 티프레임 동안 이렇게 되죠 2가 없어지는거지 2가 없어진다 2가 없어지면 여기도 2가 계속 없어지면서 
요렇게 식이 바뀐다 쥐곱하기 2의 마이너스 쥐승 
저것을 똑같이 미분을 해서 최대값 주는 부분을 찾아보면 쥐이퀄 1이 나온다 당연히 1이나오는게 하나의 프레임 전송기간 동안 하나만 보내면 문제가 없죠 아까는 두프레임동안에 하나만 보냈어야 되는데 이제는 하나의 프레임 시간동안 하나만 보내면 맥시멈 스루풋을 얻어낼수있다 라는거죠 저런 도식해서 이미다 결과를 알수있다 쥐 이퀄 1이란 값을 이 스루풋값에 넣어보면 넣어보면 이시스템에서 얻어낼수있는 맥시멈 스루풋이 아까의 두배값이 나온다 이거죠 0.368 
이 슬랏티드 알로하는 여기가 정확히 두배야 0.184를 두배하면은 0.368이 되죠 
0.368 이제 슬랏티드 알로하를 해봐야 그래도 36.8 프로다 1000개 보내면 368개 만이 성공한단 얘기죠 그러니까 알로하라는방식은 애당초 캐리어 센싱을 안하자 내가 보낼게있으면 보내는데 보내는 시점 , 정해진 시점에 보내느냐 아무떄나 보내느냐 요거에 따라서 스루풋 이 두배로 늘긴 했지만 여전히 캐리어 센싱을 안해 남이 보내고 있을지도 모르는데도 보낸다 이거죠 그런한계 떄문에 많이 가봐야 이 36.8 프로 밖에 성공을 못한다 
그래서 지금 이제 캐리어 센싱이라는 것들이 기능들이 당연히 필요하겠죠 다음이 캐리어 센싱이보강된 멀티플 엑세스
얼마나 이 개선이 되는지 봐야되겟죠 
//제곱이 중요한 케이스가 없다.
분자가 분모보다 작으면 안나눠진다. 그러면안나눠지기때문에 검출이 된다. 
이게 클경우 같거나 이거보다 클때 정말 나눠지는지를 생각해봐야한다. 
r승 에 -1 은 1이 당연히 있을거 아니야 그래서 1을 빼면 r-1승
이렇게 에러패턴이 이런 수식으로 나눴을때 x의 i승 
+1 이라는게 항상있다 라는거지 이런 경우면 이미 있고 분모에도 +1이라는게 있어야 릴라이저 에 기본
이게양쪽에 있을수밖에 없는 케이스 
이제 각 적용되는지 안되는지보고 이런 값들을 고민해봐야된다. 
가령 x의 5승 더하기 x의 3승더하기 나눠지는지 안나눠지는지 
나눠지다가 어쩌다가 이게 나눠지면 여기에 나눴을때 x의 3승 더하기 
그러면 있어야 얘가 이걸로 나눠진다 라고할수있음 이위에 나와요 이런관계 이게 
이런거 