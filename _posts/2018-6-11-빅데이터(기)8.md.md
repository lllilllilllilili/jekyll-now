---
post : layout
title : 빅데이터(기)8
---
## 빅데이터(기)8
마지막수요일

## Solutions
자 우리가 consistency를 하다가 말았다.
rdbms 같은경우는 우리가 잘 알고있는 strong consistency 
왜냐하면 어차피 클러스터에서는 기본적으로 데이터를 여러개 를 뿌려놓기때문에 어 어벨리빌리티나 아니면 릴레이어블리티 때문에서라도 그 샬딩이 됬거나 
특히나 이제 샬딩말고 레플리케이션 같은 경우도 그런 컨시스턴시 문제가 생긴다. 그런 문제가 생겼을때 rdbms 같은 경우는 strong consistency 를 보장하게 되는거고 nosql 같은 경우는 이벤츄얼 디스턴시를 걔네들은 보장을 한다. 
그런 컴플릿을 종류 말씀드렸고요 

기본적으로 컴플릿 자체는 어쨋거나 write 이 수반이 되어야지만 일어나는 그런 컴플릿트가 됩니다.
자 좋아요 이게 
컴플릿트일어난건 좋아 컴플릿트가 일어났으면 그걸 해결할수있어야 된다. 그거를 이제 어떤식으로 해결하는지 에대 해서 우리가 얘기를 할것이다.
그래서 그 솔루션이 크게 2가지로 나뉜다.
첫번째가 

pessimistic 하게 굉장히 좀 염세적 어쩃거나 pessimistic approach가 있고 에이 뭐 잘되겠지 라고 하는 optimistic approach가 있다.

그래서 어 pessimistic approach 같은 경우는요 쉽게 얘기하면 아예 그냥 그런 컴플릿트 자체가 일어나지도 아예 일어나지도 못하게 하자 
애시당초 골치아프니까 그게 pessimistic approach 이다. 
그래서 보통 우리가 흔히들 아는 acid를 propterty를 가져다 보장을 한다던가 
아니면 rdbms 보장하는 스트롱 컨시스턴시 같은 경우는 대부분 이런 pessimistic 한 approach를 가지고 있다.

애시당초 걔네들 같은 경우는 컴플릿트 자체가 일어나지 않습니다. 차라리 레이턴시나 아니면 서비스를 갖다가 떨어뜰일 지언정 걔네들은 컴플릿트 자체가 일어나지 않게 해요 왜냐하면 이런 컴플릿트 같은거 이제 해결하기 위한 방법으로 여러분들 os시간에 배웠었죠 locking 시스템을 갖다가 쓴다. 
그게 뭐 어떤 locking 시스템 형태가 됬든지 간에 그런 locking 시스템 같은걸 쓰게되면 애시당초 이런 어 complete 같은게 일어나지 않는다. 다만 
locking 이 무조건 좋으냐 이 뒤부분에 나온다. 
그런 locing 시스템을 써가지고 이렇게 쓰는 그런 pessimistic approach 가 반드시 좋은건 아니다 사실 문제점도 있다.

고기에 대해서는 나중에 다른 슬라이드에 조금더 얘기할것이다. 그거랑 반대로 이제 통상적으로 nosql 디비같은건 optimistic approach를 많이쓴다. 
에이 뭐 컴플릿트 일어날 수있지 뭐 그렇지만 일어나면 그떄 그냥 고치자 라고 하는게 optimistic approach이다. 그래서 보면은 이제 어 

컨디셔널 업데이트 라든지 아니면 뭐 세이브 모드 업데이트 이렇게 나오는데 이거는 그냥 optimistic approach 에 관련된 그냥 어 두가지 예제일 뿐이다.
반드시 이렇게 한다는게 아니라 

그냥 optimistic approach 자체가 일단은 컴플릿트 일어나는걸 자체를 허용한다라는거임 그게 중요함 
그런데 pessimistic approach 같은 경우는 애시당초 그런 컴플릿트가 일어나는거 자체를 그냥 허용하지 조차도 않는다. 애시당초 막아버리는것이다.
그래서 컨디셔널 업데이트 같은 경우는 예를들어서 업데이트를 하긴하는데 예를들어서 곧바로 업데이트가 일어나기 직전에 이제 테스트해가지고 요거 하나를 갖다가 제대로된 버전 을 갖다가 업데이트를 하는얘기고  

세이브 보스 업데이트 같은 경우는 일단은 애시당초 여러가지 뭐 두개 멀티가 있다. 그러면 일단은 업데이트 를 먼저 떄립니다. 업데이트를 하고 나서 나중에 이제 나중에 나와요 버전 벡터나 그런것을 이용해서 아 
막상 나중에 싱크를 시키다 보니 문제가 있다라는걸 알게된다. 그러면 그제서야 테스터링 해가지고 머지를 하는 방식이다. 
나중에 버전 벡터 를 설명드리면서 다시 설명드리겠다.
어쨋든간에 이게 됬든 저게 됬든 뭐가 됬든 지 간에 optimistic approach 자체는 컴플릿트가 일어나는건 자체를 허용을 한다. 


## Pessimistic vs optimistic approach
이게 옵티미스틱이 됬든 페스미스틱이 됬뜬 이 두개는 어떤게 좋다 나쁘다 라고 제가 말씀드리진 안아요
어떤게 좋다 나쁘다가 아니라 결과적으로 보면 이 두가지 벡터를 가지고서 그 두개의 트레이드 오프 관계를 어 가지고 얘네들이 이제 어 그 여러분들 애플리케이션에 맞는거에 따라 쓰시면된다. 
그 두개가 세이프티랑 라이브니스라고 얘기하는 이 두가지이다. 
이두개에 트레이드 오프를 가지고서 이제 페스미스틱 이나 옵티매스틱 어프로치를 갖다가 이제 선택하게 되는데 
쉽게 얘기하면 이게 말하는  세이프티라는건 어 예를들어서 데이터가 업데이트되고 동시에 그렇게 컨커런트 하게 업데이트 되고 싱크가 일어날때 이 데이터 가 커런트?? 되지 않았다 라는것을 보장 하는데 있다 라는거임
이 세이프티라는건요 

그리고 이 라이프니 같은 경우는 어 쉽게 얘기하면 그 래이턴시인데 어쨋든지 간에 내가 데이터 가 살아있다 라고 곧바로 클라이언트한테 걔네들 리스판스를 곧바로 주는것을 얘기하는것이다. 자 리스판스가 쉽게 그 이 라이브니스랑 이 세이프니 두개에 그 트레이드 오프를 가지고서 얘네들 생각하게 되는데 

패스미스틱 어프로치 같은 경우는요 얘네들이 뭐를 더 중요시 하게 되냐면 당연히 세이프티를 더 중요시한다 얘네들은 세이프티를 더 중요시 하게 되고 그러다보니까 상대적으로 얘네들은 그 반대의 그 트래이드 오프관계로 얘들은 라이프니스를 갖다가 조금은 루스 하게 바라보고 있는데
그러다 보니까 이제 이런 패스미스틱 한 어프로치 같은 경우는 공적으로는 그 래이턴시가 높아질수밖에 없다. 차라리 그런 레이턴시를 갖다가 살짝쿵 좀 늦출지언정 데이터 가 커런트 되는것을 갖다가 우리는 무조건 막겠다. 
라는게 패스미스틱 어프로치이다.
근데 그 패스미스틱 어프로치는 말씀드렸죠 락 같은 락킹 시스템 을 갖다 쓰게 되는데 여러분들 뭐 거듭 말씀드리지만 os시간에 락킹 시스템 다 배우셨죠 그런 그 락킹 시스템을 쓰게 되는데 
이런 락킹 시스템이 완벽하냐 그렇지 않다
os 시간에 배웠죠 락킹 시스템 역시도 궁극적으로 잘못되면 그 싱크 일어나는 그 찰나 순간에 데드락 에 빠질수도있다 
데드락 빠지면 바보된다. 어쩃거나 그런 데드락에 문제가 있을수도있고 결과적으로 궁극적으로 락킹 시스템 자체가 완벽하지 않다.
100% 어 프리벤션 하기 힘들다. 그래서 그 여러분들 락킹 시스템이 일어났을떄 그런 어떻게 만약에 락킹 시스템이 데드락이 일어났을때 어떤 식으로 해결하느냐 그런 걸 다 배우셨을거에요 그런 해결책 나온다는거 자체가 락킹 시스템 자체가 완벽하지 않아요 os 에선 

자그런 문제점이 이제 패스미스틱은 있습니다. 근데 이제 반대로 옵티미스틱 같은 경우는 얘들은 아까 말씀드렸다 싶이 세이프티를 갖다가 조금 줄여야 된다. 
아이거 뭐 데이터 조금 그렇게 되면 어때 그렇지만 우리는 라이브니스를 갖다가 빨리 그 클라이언트한테 그런 리스판스를 갖다가 잽싸게 주는게 우리는 더 중요한데 많은 대부분 웹 사이트 같은 경우는 사실은 어 이런 옵티미스틱 어프로치를 쓰고있다. 여러분들 페북이나 그런 거  대부분 다 패스미스틱이 아니라 옵티미스틱 어프로치를 씁니다 .걔네들 입장에서는 데이터 조금 그렇게 되는게 중요한게 아니라 여러분들이 엑세스 타임, 사진을 클릭하고 뭔가를 보는데 클릭했는데 안뜨면 그게 더 화딱지 난다. 그렇기 떄문에 걔네들은 당연히 이런 세이프티 데이터 커럭션 그런 거 보다는 그 라이브니스 훨씬 더 걔네들은 중요점을 주고서 서비스를 한다. 

## Consistency models
자이게 컨시스턴스 모델 두가지가 있다고 말씀드렸다.
스트롱한 컨시스턴시랑 그런 이벤츄얼 컨시스턴시가 있다.
근데 스트롱 컨시스턴시 이미 말씀드렸다. 이미 통상적으로 알고있는 rdbms 가 얘기하는 그런 acid acid 프로퍼티를 만족시키는 그런 컨시스턴시 모델이 스트롱 컨시스턴시 모델이다. 
근데 이제 이거는 잘알겠고 
이벤츄얼 컨시스턴시는 제가 이미 지난시간에 살짝 말씀드렸는데 자 이벤츄얼 컨시스턴시 nosql 데이터 베이스는 이런 strong 컨시스턴시를 보장하지 않는다. 
걔네들은 서비스 가 주로 목적이 그게 아니다.
얘네들은 그러다 보니까 이벤츄얼 컨시스턴시를 보장을 합니다.
이벤츄얼 컨시스턴시 라는게 말그대로 자 컨시스턴트를 하긴 하는데 이벤츄얼리 컨시스턴트 하다. 라는 얘기다 
여러분들 지금 어 이 얘기를 듣자마자 머릿속에서 여러분들이 생각하는 그뜻 그대로다. 
이벤츄얼리
이게 뭐냐면 예를들어서 어떤 한시간에 모든 사람들이 업데이트를 딱 했을때 그순간 모든 그런 스트레이트한 그런 컨시스턴함을 갖다가 보장하는게 아니라 어느 한 일정수반 동안은 그냥 인컨시스턴하게 내버려둔다. 그냥 
고게 뭐냐면 여기나오는데 그 
블루셋보면 인컨시스턴시 윈도우 라고있잔아요 
그렇죠 고 얘기다. 인컨시스턴시 윈도우 라는건 데이터가 컨시스턴트 하지 않은 그약간의 시간 그 타임 프레임을 갖다가 인컨시스턴시 윈도우 라고 합니다. 
고 인컨시스턴시 윈도우타임동안은 그냥 설사 뭐 컨시스턴트 하지 않더라도 그냥 내버려둔다 근데 왜냐하면 결과적으로는 soon of later 얘가 프로퍼겟 해가지고 데이터가 다 싱크될꺼거든요 
그얘기이다. 그게 이벤츄얼 컨시스턴시다. 
그러다 보니까 얘네들은 뭐를? 아까 말씀드렸죠 
얘네들은 세이프티를 게런티 하지 않는다. 당연한 얘기지만 그러다 보니 대신 얘네들은 그런 리스판스빌리티, 리스판시브 리스를 갖다가 여기는 라이브니스라고 썻지만 같은 얘기다. 그것을 갖다가 더 주안점을 두고 그것을 갖다가 게런티를 할뿐이다.
얘네들은 서비스 자체가 nosql 데이터베이스 자체가
그리고 어 이 rdbms에서 acid 프로퍼티가 나오듯이 제가 말씀드렸죠 
nosql 데이터베이스에서는 베이스 프로퍼티 라는게 있다. 얘네들은 얘네들이 이 베이스라는 프로퍼티를 어 보장을 합니다. 그런데 이게 뭐냐면은
얘네들은 이 베이스라는 프로퍼티를 어 보장을 한다. 근데 이게 뭐냐면 베이직컬리하게 어벨러블 하고 소프트 스테이트하고 이벤츄얼 컨시스턴트하다 요 3가지 프로퍼티를 얘기를 하는데 지금 당장 고민할 필욘 없다. 다음 다음 슬라이드에 나온다. 어쨋든지 간에 nosql 디비 같은 경우는 어 acid 가 아니라 베이스 프로퍼티를 갖다가 보장을 한다 정도까지만 이해를 지금 현재로서 하면된다. 다음장에 나온다.

## Consitency models (그림)
모델 말씀드렸죠
스트롱 컨시스턴시 
이벤츄얼 컨시스턴시 두가지가 있다. 말씀드렸다
스트롱 컨시스턴시 같은 경우는 예를들어가지고 어 이 첫번째 사람이 예를들어서 업데이트 햇, x라는값을 자 v1에서 v2로 업데이트 를 만약에 했다고 가정해봐요 요시간내에 그런데 이시간 이전에 두번쨰 사람이 x을 읽으면 당연히 그 이전값이 v1을 갖다가 리턴을 할껍니다 그렇죠 
이거 굉장히 당연한 얘기다 그런데 고 시간이 지나고 나서 좀 지나고 나서 첫번째 사람이 그 x 값을 v1에서 v2로 업데이트를 해요 그러면 그 이후에 그 어떤 사람 어떤 시간 언제 체크를 해도 이 x라는 값은 무조건 v2라는값을 갖다가 일관되고 싱크되는 값을 보여줘야 한다. 이게 스트롱 컨시스턴시 에요

근데 이벤츄얼 컨시스턴시는 그렇지 않죠 
얘네들이 뭐 이거는 사실은 뭐 여기서 v1을 읽고 v2
자체 의미가 중요한게 아니라 이 순서가 중요한게 아니라 이 각각 사람들에 대해서 똑같이 얘가 첫번째 사람이 업데이트를 x를 갖다가 v1에서 v2 로 요시점에서 했지만 그 이후에 각각 있는 그 사람들은 그때그때 마다 값이 다른 값을 리턴할 수있다라는 내용 자체가 중요하지 뭐 요때는 왜 v1 인가요 요때는 왜 v2인가요 
그 얘기를 할려고 하는게 아니다. 아시겠죠 그런 인컨시스턴 그런 값이 어느 일정시간동안은 어 발생하게 되는데 고게 그 윈도우 , 타임프레임이 인컨시스턴시 윈도우에요 근데 이게 뭐 이제 그런생각이들죠
그러면 이게 그러면 보통 얼마정도 되느냐 굉장히 짧다. 여러분 생각보다 길지 않다. 통상적으로 1초 남짓이다. 1~2초 내에다 끝난다.
왜냐하면 그 네트워크 프로퍼게잇 그 프로퍼게이션 딜레이가 그렇게 까지 여러분 이 생각만큼 길지 않는다. 

진짜 그냥 few 초 다 끝난다. 아시겟죠 어쨋거나 요런 형태 자체가 이벤츄얼 컨시스턴시 모델이다. 

## BASE properties 
그리고 말씀드렸죠 베이스 
설명드린다고
베이스 프로퍼티입니다. 베이스 클리어 어벨러블 하고 그리고 어 소프트 스테이트고 이벤츄얼리 컨시스턴트하다.
요 3가지 프로퍼티를 nosql 데이터베이스 는 보장을 합니다.

첫번째 
Basically Available 하다 라는 얘기는 알아보면 말그대로 availablity를 갖다가 보장한단 얘기다. 아시겟죠 자 
그 basically available 하다 얘기가 예를들어서 네트워크가 예를들어서 페일러가 일어났다 라고 치더라도 최소한 그 시스템은 그 클라이언트하게 리스판스 를 줄수있어야 된다. 이 정의 자체가 어벨러빌리티 이거든요 아시죠 
이게 availability 이다.
그런 어벨러빌리티를 얘는 지원을 해야된다. 
이 어벨러블 하다라는게 왜 가능하냐면 레플리케이션을 쓰거든요 그쵸 통상적으로 말씀드렸죠 레플리케이션 팩터는 3을 많이쓴다. 그 3개의 카피본을 많이 쓰게되는데 어 그러다보니까 설사 그 어떤 한 머신 한 시스템이 다운 되더라도 최소 2개는 남아있다. 근데 통계학적으로 이게 3개가 동시에 죽게될 확률은 지극히 거의 일어나지 않는다. 그래서 3 개 의 모델을 두고 있는거고
이 떄 이제 basically available 라는 그 개념자체가 이 통상적으로 레플리케이션 많이 쓰니까 자 얘네들을 통해서 이러한 availablilty 를 갖다가 보장을 하기때문에 그래요 
그리고 이제 소프트 스테이트 라는 얘기가 나오는데 얘는 그냥 하드 스테이트에 반댓말이다. 소프트 스테이트 라는 것은 어떤 시스템이 그냥 아무것도 하지 않고 내버려둬 그런데도 얘가 스테이트 값 바뀌는걸 소프트 스테이트 라고 얘기해요 쉽게 얘기하면요 이게 뭔 얘기냐면 아까 이게 결과적으론요 소프트 스테이트 가 일어나는 이유 자체가 사실은 이벤츄 컨시스턴시 때문에 그렇다. 아시겟죠 이 사실은 두번쨰랑 세번쨰는 그냥 한 세트 이다. 
이게 말씀드렸죠 이 소프트스테이트 일어나는 이유가 내가 설사 어떤 시점에 아무런 업데이트 도 하지 않고 어떤 시스템에 아무런 업데이트가 일어나지도 않았는데 어느순간 가만 히 내버려 뒀는데 이 state 단위로 데이터가 바뀌는것을 얘기한다 
그게 왜냐면 이벤츄얼리 컨시스턴시 떄문에 그런것이다.
그래서 소프트스테이트 에요 
그리고 이벤츄얼 컨시스턴시 는 제가 이미 말씀드렸죠 사실은 이벤츄얼 컨시스턴시에 한 문장을 외우면 맨마지막에 사실은 제일 직관적이다.
ssooner or later" 어디든지 다 프로게잇 하는거다. 그러다보니까 나중에 싱크가 일어나가지고 자 결과적으로 어느 한순간에 그 고 시간, 고 타임 프레임 동안은 설사 인컨시스턴트 하더라도 결과적으로 이벤츄얼리하게 데이터다 싱크가 일어나더라 라는게 이벤츄얼리 컨시스턴시 입니다. 그런데 여러분들이 이미 다알아요 이미다 수없이 다 경험하고 있는거임 
그게 이벤츄얼 컨시스턴시 이냐 라는 그 단어 자체를 여러분들이 모르셨을 지언정 이미 알고있습니다 여러분 말씀드렸죠 페북 예를들면 생각해봐라
이 밥이라는 사람이 

## Eventual consistency : Facebook Example
이 밥이라는 사람이 아 굉장히 재밌는 스토리가 있어 
열라재밌어 라고 이제 그거를 갔다가 이제 그 엘리스 라는 사람 이 wall에다가 포스팅합니다. 이거 한번 봐바
쉽게 얘기하면 write 한거잔아요 그렇죠 밥이라는 사람이 write를 한것이다. 그리고 그러고 나서 그말 듣 고 나서 이제 엘리스 한테 너 체크업 한번 해봐라 그리고 엘리스가 금방 체크 해보더니 뭐야 아무것도 없잔아 이런거 여러분 많이 경험 하셨을거에요 이겁니다. 그런데 어느정도 조금 지나면 조금 만 기다려봐 좀만 기다려봐라 라고 말을 얘기하잔아요 그렇죠 
좀만 기다리고 나서 나중에 로그인 해서 보거나 아니면 다시 업데이트 해 f5열심이 눌러가지고 보면 뜨거든요 그게 왜 좋은 시스템이냐?(이게 이벤츄얼리 컨시스턴시???)
이미 우리가 일상생활에서 매일 경험하고 있다. 
근데 이 이벤츄얼 컨시스턴시가 아니라 스트롱 컨시스턴시 같은 경우는 여러분 가장 쉽게 얘기하면 그냥 은행 뱅킹 시스템이다.
그렇죠 은행 뱅킹 시스템은 그런 리스판스 같은 시브 같은것은 전혀 중요하지 않아 이게뭐 싱크가 나중에 일어나고 그런게 전혀 중요하지 않다.
무조건 걔네는 내가 돈을 넣으면 그어떠한 순간이라든지 간에 그돈은 무조건 돈이 들어가 있어야한다. 누가보더라도 내통장에 내가 100원 너무작고 100만원을 넣으면은 내 통장에 잔액은 무조건 100만원이 플러스 되 있어야 한다. 누가 어떤 시점에 엑세스를 하더라도 
아 좀만 기다려바바 아 지금은 100만원 안들어왔는데 이거는 통용되지 않는거다. 
그게 스트롱 컨시스턴시다. 
아시겠죠
그게 통상적으로 rdbms에서 보통 많이 들 다루게 되는 그런 모델이다. 걔네들같은 경우는 세이프티가 훨씬더 중요한 케이스가 되는거에요 데이터가 
자 근데 이 페북같은 경우는 그러면 왜 얘네들이 그짓을 하느냐 
뭐 알껍니다 그렇죠 이미 여러분들이 인털액티브 하게 이미 여러분들 키핑 마인드 하고 계실겁니다 왜 얘네들은 그러면 그런 스트롱 컨시스턴시 모델을 안쓰니 
스트롱 컨시스턴시 모델을 어떻게 써요? 왜냐하면 이게 이 페북 유저가 한두명입니까? 그렇죠 동시에 유저가 도대체 원 밀리언이 넘어가는데 그 액티브 유저가 미친듯이 맨날 쓰고 읽고 하는데 그 데이터를 갖다가 그많은데이터를 어떻게 동시에 싱크를 시켜요 싱크를 시킬수는 있습니다. 못하는건아니다. 그 싱크 시키는 동안 은 맘대로 못쓴다. 왜냐하면 락을 걸어놔야 될거아니야. 
그러면 생각해보면 사진 하나 올리는데 어우 잠시만 10초만 기다려주세요 라고 하면 여러분들 페북 쓰겠냐고요 안쓴다. 그냥 그 이유는 굉장히 간단합니다. 그 이유때문이다. 그래서 얘네들은 그 데이터를 갖다가 이제 그 로딩을 갖다가 줄이고 차리르 그냥 어벨러빌리티 그냥 선택하는것이다.

왜냐하면 실질 그 서비스 자체는 그런 우리가 얘기하는 그 소셜 네트워크 라고 하죠 그 소셜 네트워크 서비스에 속성 자체가 그래서 그래요 
사람들이 거기에 더 비중을 더 줬기 때문에 그렇다.
그래서 얘네들은 그런 데이터 에 그런 로드나 아니면은 그것을 가져다 희생을 하고 대신 어벨러빌리티를 택하는것이다. 

## 트랜잭션
자 트랜잭션 
nosql 데이터 베이스에 그 트랜잭션에 대해서 살짝쿵 좀더 얘기를 해보자
자 nosql 데이터베이스는 크게 우리가 지난 슬라이드에서 4가지에 대해서 말씀드렸다. 그렇죠 
그 4가지 
물론 크게 나누면 그래프 베이스 가있었고 그다음에 에그리게잇 베이스 nosql 디비가있었는데 물론 고기 에그리 게잇 베이스에 3가지가 있었는데 
크게 요렇게 어쩃든지 간에 2가지로 나뉘게 되는데 
이 두개중에서도 사실은 이 그래프 베이스 디비가 요 훨씬더 컨시스턴시 모델로 훨씬더 강력하다. 
훨씬 더 강한 , 그 얘네들은 거의 acid에 준하는 그런 컨시스턴시 모델을 얘들은 제공을 합니다.  근데 이제 그떄도 말씀드렸는데 에그리게잇 베이스 nosql 데이터베이스 같은 경우는 그렇지 않다. 다만 얘네들이 제공하지 않으까가 아니라 그 에그리게잇 자기 차지? 하나의 에그리게잇 내에서는 그런 acid 모델을 얘네들 보장을 합니다. 
근데 그게 아니라 여러개의 에그리게잇 단위에서는 그 전체를 묶어서 얘네들이 얘네들이 그 트랜잭션을 보장하지 않는다 라는거임 할수도없고
근데 개별은 서포트하지만 전체에 대해서는 서포트하지않는다.(이거 시험)
그얘기고 아까 제가 말씀드렸던게 실제 그 아마존에 그 다큐멘트 있습니다. 

###### Amazon's documentatoin
얘네들 그 심플 db 심플 db라고 특별히 기억하실 필요는 없지만 얘네들 아마존 랜덤 베이스? 에서 그 클라우드 컴퓨팅 모델에서 제공하는 아마존에서 제공하는 그 db 그 서비스이다. 그렇죠 
그래서 어쩃거나 걔네들 기본 그런 심플 디비가 있는데 걔네 서비스 같은 경우에 통상적으로 인컨시스턴시 윈도우가 1초 내외다. 라고 얘네들이 이제 어 실제 걔네 soa에다가 그런 다큐먼트에다가 얘기를 하고있다. 
그냥 굉장히 짧은 생각보다는 짧습니다. 인컨시스턴스 윈도우엔


## Read-your-write consistency
무슨 컨시스턴시가 자꾸 나온다. 사실은 이거 여러분 헷갈리실까봐 대폭 줄인거다. 컨시스턴시 사실은 이 컨시스턴시는 여러분한테 다 가르쳐 드리면 아마 	7~8가지 될것이다. 요거 포함해서 그중에서 하나만 여러분들한테 사실은 정확히 2갠데 2개만 다루고 마는것이다. 그거까지는 필요없을거 같아서 그래요 
자 nosql 데이터베이스 에서는 자주 나오는 것중 하나가 다시 리드 유어 롸이트 컨시스턴시 라는게 있다. 
이 컨시스턴시 모델은 nosql 특히나 이제 클라우드나 아니면 그런 분산 시스템에서 이런 컨시스턴시 문제가 나오는건 제가 말씀드렸다싶이 데이터를 갖다가 레플리케이션을 하기때문에 그렇습니다. 그렇죠 
그런데 그런 레플리케이션 자체는 그거는 어쩔수가없어요 반드시 그렇게 할수밖에 없습니다. 서비스를 갖다가 어 그런 퀄리티를 높히기 위해서
그런데 결과적으로 이런 레플리케이션이 결과적으로 어쩃든지 간에 인컨시스턴시 윈도우를 갖다가 길게 만드는 역할을 할 수밖에 없습니다. 
이게 레플리케이션이 많아질수록, 그 싱크가 길어지니까 그래요
그런데 예를들어가지고 이런 인컨시스턴트한 그 일이 벌어졌을때 아무리 그 뭐 업데이트 자체가 마스터 , 마스터 - 슬레이브 구조를 많이 쓰니까 
마스터에서 여러분들이 아무리 그냥 열심히 빨리 마스터가 그렇게 처리를 했다 고 치더라도 결과적으로 이런 인컨시스턴트한 일이 벌어지는 이유는 클라이언트랑 연결되어있는 , 클라이언트 라기보단 슬레이브 다루는게 낫겟죠
슬레이브 읽을때에는 그런 네트워크 그 네트워크에 딜레이 때문에 사실은 어쩔수가 없다. 아무리 이거는 어 마스터노드에서 열심히 노력한다고 해서 해결되는 문제가 전혀 아니거든요

그러다 보니까 인컨시스턴시 윈도우가 어 되다 보니까 이제 우리가 말씀드렸다 싶이 뭐 앞에서 그런 서로 다른 데이터를 갖다가 ?했더니 컨시스턴트한 데이터를 갖다가 리턴하게 되는 문제가 생기는데 

자 이것과 관련해서 nosql 데이터베이스 같은경우에 이제 좋아 뭐 저런게 일어나느건 ok, 어쩔수없으니까 그런데 네트워크 프로퍼게이션 딜레이, 네트워크 시간에 다 배웠겠지만 그런 프로퍼게이션 딜레이 떄문에 일어나는것을 갖다가 뭐 어떻 하겠어? 왜냐하면은 이 모델자체가 얘는 그런 클러스터 모델을 갖다가 염두해두고 
네트워크 모델을 염두해두고 만들어진 서비스 이기때문에 어쩔수없지 않느냐 그렇지만 최소한 그 컨시스턴시는 보장을 못하더라도 최소한 read- your wirte consistnecy는 보장을 해야 되지 않겠니 라고 나오는게 read- your write consistency 입니다
별거 없다. 말만 그럴 싸 해보이지 아무것도 아니다 
read -your write consistency 라는게 뭐냐면 어떤 한놈이 예를 들어 가지고 여러분들 이 업데이틀 해용 내가 예를들어서 어떤 시스템 을 딱 업데이트 하면 최소한 아니면 남들은 됫고 걔 업데이트한 나라는 놈이 최소한 내가 업데이트 하고난 이후에 내가 엑세스한 그런 데이터는 최소한 같은 데이터 
업데이트 된 새로운 데이터를 갖다가 나한테 보여줘야 된다 라는 얘기임
내가 a라는 데이터를 갖다가 어느 한순간에 업데이트를 했는데 자 이게 내가 그러고 나서 곧바로 a를 갖다가 엑세스를 하면 그 이전 데이터 업데이트 를 하기전  그 이전 데이터는 최소한 나는 마음대로 됫고 
최소한 나는 새로운 데이터를 봐야 된다 라는 얘기다.
그게 read your write consistency 이다
한마디로 얘기하면 이게 뭐 라고 프로세스 어쩌구 저쩌구 써져있지만 결과적으로 그 얘기이다. 
근데 이거를 갖다가이제 어 얘기를 하면서 살짝쿵 그 
던지기 하나더 컨시스턴시 얘기 하나더 나오는데 

##### 세션 컨시스턴시
세션 컨시스턴시라는게 나옵니다. 이거는 사실은 어 리드 유얼 라이트 컨시스턴시 한 그냥 어 연관된 개념이다. 
그래서 제가 넣어놨는데 세션 컨시스턴시 같은 경우는 리드 유어 라이트 컨시스턴시를 갖다가 보장을 하기는 해야되는데 최소한 그런 세션이 살아있을동안은 
이 세션 얘기가 여기서 왜나오냐면은 보통 여러분들 그런 커다란 서브 나 이런데서 나혼자만 쓰는 경우는 없거든요 
여러분들 노드를 지금 한놈이라고 생각하니까 여러분들이 자꾸 이제 착각을 하실수있는데 이 노드라는 이 서버는 대부분 굉장히 많이 가는게 동시접속 을 한단말이에요 그렇죠 이 마스터에 접속하든 슬레이브에 접속하든 무시 못한단 말이야
그러다 보니까 그 사이에 세션이라는 개념이 생길수밖에 없다. 
그러다 보니까 세션 컨시스턴시란 말이나오는거고 이거는 별게 아니라 최소한 내가 잘못 잡고있는 오픈하고 있는 그 세션 내에서는 최소한 그 세션내에서는 리드 유어 롸이트 컨시스턴시는 보장을 해줘야 되지 않겠니 라는 애기다. 결과적으로 어쨋든 리드유어 라이트 컨시스턴시 에요 근데 그게 이제 여러명이 동시 다발적으로 이제 그 컨커런트 하게 접속을 하다보니 세션이라는 개념이 조금 더 들어갔을 뿐인것이다. 사실상 같은 얘기다. 그리고 이거는 
리드 유어 라이트 컨시스턴시 나 아니면 세션 컨시스턴시 라는 개념자체는 어 당연히 하나의 노드에 한해서 입니다. 이게 네트워크 이 연결되 기 시작하면은 이 속성자체가 만족되지 않는다.
아시겟죠 그렇기 때문에 이 제일 끝에 tied to one node 라고 얘기가 나오는데 그 얘기이다. 최소한 그 한노드에서  내가 지금 쓰고있는 한노드에서는 고 컨시스턴시는 보장해줘야 한다 nosql 데이터베이스 에서는 그얘기이다. 말만 많아졌지 아무것도 없다. 
자 이게 버전 벡터 얘기가 나오는데요 

## Version vector
자 그러면 좋아 머 컨시스턴시 이벤츄얼리 컨시스턴시 도 알겠고 뭐도 알겠고 
뭐 이런 뭐 
레플리케이션 생김으로 인해가지고 그런 인컨시스턴시 가 생기는건 알겠어 좋아 근데 결과적으로 이벤츄얼 컨시스턴시를 해가지고 다 싱크가 일어난대매 
근데 어떻게 어떻게?
그 어떻게를 갖다가 여러분한테 말씀을 드리기 위해서 나오는 얘기가 
버전 벡터입니다. 
왜냐하면 자 결과적으로 그 데이터가 처음에는 싱크가 되지 않거든요 근데 이벤츄얼리 싱크됫다고 했잔아요 그쵸 
그러면 그 싱크를 할때 어떤 메카니즘을 쓰느냐에요 그때이제 그 쓰는게 버전 벡터입니다. 물론 그 어떤 책들에 따라서 버전 타이터 라고도 나오기도 하는데 버전 카운터랑 버전 벡터는 살짝쿵 다릅니다. 그러나 어쨋거나 기본적으로 
카운터에 그런 그 벡터이긴 해요 그래서 버전 카운터 라고도 얘기를 합니다. 살짝쿵 다르다. 알고리즘이 살짝쿵 다를 뿐이거지 어쨋거나 버전 벡터를 쓰는데 이 버전 벡터는 무슨 메커니즘 이냐면 아까 말씀드렸다 싶이 분산 환경에서 데이터 를 갖다가 변경되는 것을 갖다가 계속 트래킹하는 트래킹 시스템이에요 
이 트래킹 시스템을 써가지고 이제 이 어떤 데이터가 얼마만큼 업데이트 되는지 안되지는 갖다가 알 수있는거다. 그리고 그 시스템을 이용해서 나중에 싱크를 시키는것이다 아시겠죠 ?
그래서 이 그런 문제 버전 벡터는 자 그런 싱크를  하게 될때 그런 분산 환경에서 데이터를 갖다가 트래킹하는 시스템인데 결과적으로 얘가 이제 컴플릭트가 일어났을때 그 컴플릭트를 갖다가 디텍트 할수있는 그런 시스템
자 오해하지마라 이게 버전 벡터는 요 디텍트 할수있는 알고리즘이 지 그걸 갖다가 해결하는 알고리즘 아닙니다. 아시겠죠

해결하는 알고리즘은 여기 따로 나와있지 않아요 그건 시스템마다 다르고 일반적으로 그거는 뭐 데이터마다 다르기때문에 그거를 갖다가 일일 차별 일률적으로 여러분들한테 말씀드릴수없어요 이 버전 벡터는 디텍트 하는 알고리즘 입니다. 
아시겠쬬 자 그래서 예를들어가지고 어떤 그 어떤 뭐 데이터를 업데이트했어 데이터를 업데이트하게되면은 그거를 가져다 버전벡터를 먼저 체크를합니다. 이게 그 사이에 내가 읽고 왜냐하면 업데이트 항상 읽고 쓰는거잔아요 그사이에 누군가가 샥 업데이트를 해버렸을 술수도 있기떄문에 아시겟죠 
그리고 나한테 프로퍼게이트 되서 오기 이전에 이미 다른 사람들이 누군가가 업데이트 해버렸을수도 있기때문에 내가 데이터 업데이트할때는 항상 버전 벡터를 체크합니다. 체크해가지고 어 이거를 가져다 자 싱크 를 시킬건지 아니면은 이거를 갖다가 어 컴플릭트 가 일어났는지 안일어났는지에 대해서 체크를 하는거에요 그래서 이게 기본적인 그런 오퍼레이션을 살펴보면 어 자 요거는 버전 벡터의 오퍼레이션 입니다. 버전벡터 같은 경우에 제일 먼저 말그대로 벡터가 있어요 
여러분 들 잘 아시는 아시는 그런 벡터입니다. 콤마 콤마 벡터에요 그런 벡터가 있는데 그 벡터각각은 사실 뭘로 무슨 요소로 구성이 되냐면 카운터로 구성이 됩니다. 이 카운터로 구성되고 이 카운터의 벡터에 차수가 뭐냐 디멘젼 이 뭐냐면은 레플리케이션의 벡터의 개수에요 
아시겟죠 그리고 레플리케이션의 벡터에 그 개수 에 해당되는 , 자기한테 해당되는 그 카운터만 자기는 업데이트할 수있는 그런 권한이 주어진다. 자 여러분 표정이 점점 일그러 지시는데 
어 일그러 지실필요 없다, 왜냐하면 제가 뒤에 헷갈릴 까바 example을 넣어놨다 아시겟죠 지금 걱정할 필요없다. 그런 거다 라고만 알면된다.

어쨋거나 자 버전 벡터란 벡터가 있다더라 근데 각각 버전 벡터의 요소는 카운터로 구성이 되어 있다더라 까지 아시면된다. 그러면 기본적으로 처음에 할때 이니셜라이즈 하지 처음시작할때는 다 0으로 다 셋팅을합니다.

0으로 셋팅하고 나서 그리고 예를들어서 어떤 레플리카가 어 업데이트를 해요 근데 말씀드렸죠, 그 업데이트를 할떄 다른놈것을 건들 일 자격은 없다 자기는 자기 카운트에만 해당되는 그 카운터만 업데이트 할수있다. 업데이트 가 일어날때마다 하나씩 카운터를 계속 증가시킵니다 아시겠죠 그얘기다. 그리고 예를들어가지고 이제 싱크를 해야된다. 어떤 한 순간에 싱크가 해야되는 순간이 반드시 생기는데 그떄 싱크를 해야될 그런 순간에는 그 데이터들, 너꺼랑 내꺼랑 두개를 가져다 싱크를 하게 되면 그 t가(니가?) 갖고 있는 버전 벡터랑 내가 갖고 있는 버전 벡터가 다를 수있거든요 왜냐하면 누가 얼마만큼 업데이트 를 했느냐 에따라서 버전 벡터값이 달라진단 말이에요 그러면 그떄 버전 벡터값을 놓고서 판단을 하게 된다. 같으면 끝 그러면 아무런 업데이트가 일어나지 않았던 거고 값이 다르면 이제 그때서야 싱크를 해야되는데 그거를 어떻게 싱크를 하는지 다음 페이지 말씀드리겠지만 

자 결과적으로 값이 바뀌면 싱크를 하는데 싱크를 하고 나면은 싱크를 하고 나면 너하고 나하고 싱크를 하고 나면 그 이후에 생기는 버전 벡터 값은 같아야 된다. 아시겟죠 왜냐하면 싱크가 일어났잔아요 자 싱크 일어나기 전에 버전 벡터가 다룰수 있지만 싱크가 하고 나면 버전 벡터는 다시 같아져야 된다. 그때 버전벡터를 갖다가 어떻게 어 싱크를 시키느냐면은 각각 요소 있잔아요 요소별로 값이 다를수있는데 너꺼랑 내꺼랑 값이 요소가 다를수 있잔아요 그러면 그 값들중에서 맥스값만 취해요
아시겟죠, 맥스값만 뽑아가지고 싱크를 시킵니다.
자 예제에 나옵니다. 여러분 지금부터 자꾸 표정이 자꾸 어두워지실 필요는 없다.

## Version vector
어쩃거나 그런 방식으로 어 싱크를 시킵니다. 이게 굉장히 기본적인 버전벡터가 작동하는 방식이다. 
그래서 보면 보시면
두개의 레플리카 a 와 b가 있다고 가정을 해봅시다.
a랑 b랑 그 두개의 버전 벡터가 있다고 가정했을때 이 두개를 가져다 체크를 하는겁니다 근데 이 버전벡터를 갖다가 체크를 할떄 나올수있는 히스터? 딱 3가지 밖에 없다.
왜냐하면 심플합니다. 보시면 알겟지만 그냥 그 두개 버전 벡터가 같아 자 같다면은 얘는 싱크가 이미 이루어진것이다. 그렇죠 이거는 더이상 특별히 할일 이 없는것이다. 굉장히 제일 심플한 케이스이다. 자 두번쨰 케이스가 첫번째가 같은게 아이덴티컬한 케이스고 

두번쨰가 뭐냐면 이게 오덜드라고 나와있는데 순서가 명확하게 나눠져 있는 케이스이다. 그러면 그게 a가 두개 레플리케이션 내에서는 a 와 b가 있을때 a가 먼저든 b가 먼저든 어쨋든지 간에 그 순서 관계가 명확한 케이스이다. 사실 이 순서관계가 명확한 케이스도 굉장히 쉬워요. 그 뒤에 업데이트 된놈이 그냥 앞에있는 그 업데이트 늦게있는 업데이트 놈을 그냥 오버라이트 해버리면 끝이다. 
왜냐하면 나중에 된놈이 어쩃든지 간에 더 최신데이터 아니에요 아시겟죠 자 이게 그겁니다. 근데 이 이 오덜드 같은 케이스는 자 예를들어서 b가 a보다 더 나중거다 최신거다. 라는 그 정의자체를 살펴보면 자 ???? 이죠
버전 벡터 에 있는 a가 두개의 레플리카 가 a도 버전 벡터를 가지고 있고 b도 버전벡터를 가지고 있는데 a에 버전벡터를 va 라고 하고 b에 버전벡터를 vb 라고 가정을 해요 그렇죠 그러면 버전 벡터 a에 있는 그 모든 엘리먼트 값 결과적으로 카운트 값이죠 그렇죠 그 모든 엘리먼트 값이 버전 벡터 b에있는 버전 모든 그 값보다 작거나 같아야 되요, 작거나 같고 그리고 최소한 그 한놈 a에있는 그 카운터 한놈이 최소한 b에 있는 놈보단 무조건 작아야 되요 요 조건을 만족시켜주면은 명확하게 b는 항상 a보다 그 이후 버전이다. 라는걸 갖다가 보장을 하게 됩니다. +> 이게 ordered에요 거듭 말씀드리지만 명확하다. 사실은 이건쉽다. 골때리는게 concurrent 이다

이거는 제일 골때리는 케이스이다. 자 이거는 순서가 명확하지도 않고 b가 a보다 늦은것도아니고 a가 b보다 늦은것도아니고 근데 그렇다고 두개 버전 벡터가 같지도 않아 자 이런게 뭐냐면 동시에 컨커런트하게 그 데이트를 갖다가 업데이트를 해버리는 케이스이다. 이런경우가 조금은 복잡해진다. 자 여러분들이 

## Example: version vector 
레플리카 a, b가 있어요
그쵸, 두개가 있는데 자 시작점 어쨋거나 싱크가 되있다라고 우리가 가정하고서 그 두개의 버전벡터가 a 가 2,3 b가 2,3 이라고 가정합시다 아시겟죠 그리고 어 첫번째 자 디멘전이 2잔아요 그쵸 이 디멘전이 2인 이유는 자이 레플리카 가 2개 니까 지혼자 심플하게 두개니까 두개고 요
첫번째 우리가 가정을 하는것이다. 첫번째 엘리먼트는 그냥 a인거에요 a, 내가 내자신의 카운터입니다. 업데이트 카운터고 두번째가 얘는 b 레플리카에 자기자신의 카운터에요 그러면 이 a는 자기 첫번째 값만 업데이트하지 두번째 ,
세번째거는 건드릴수 있는 자격이 없습니다. 
아시겠쬬 굉장히 심플해요 그래서 a가 요상태에서 레플리카 a가 업데이트를 하나 했어 내가 업데이트 하나를 합니다 그러면은 자 a가 2,3에서 3,3 이 되겠죠 
그렇죠 
그럼 보면은, 지금보시면은 a가 b보다는 이순서관계가 명확해진다 이런식으로 요 현재 상태에서 a와 b에 관계를 갖다 살펴보게 되면은 a가 3,3 이고 b가 2,3 이잔아요 근데 이 정의가 아까본 요 정의 그대로 만족하거든요 자세히 보세요 

어쨋거나 이 b라는 놈이 얘보다는 무조건 더 작거나 같잔아요 작거나 같고 그리고 어떤 한놈 최소한 그 한놈이 명확하게 자기는 이 다른놈보다 다 작잔아요 
지금 작은게 하나가 존재하잔아요 그래서
요 관계를 만족을 시켜주면 걔네는 어떤 ordered 관계에요 그쵸 이거는 쉽습니다 아까 말씀드렸다싶이 요상태에서 싱크는 그냥 a 레플리카를 b 레플리카에다 오버라이딩 해버리면 그냥 끝이다

굉장히 간단합니다. 자 좋아요 그것도 모자라 가지고 레플리카 a가 그냥 마구마구 업데이트를 합니다 마구마구 업데이트 했더니 얘가 어 10이 됬어요 a의 버전벡터는 자 10하고 3입니다. 그런데 제가 이예제를 왜 넣어놨냐면 10번을 업데이트를 하든 100번을 업데이트 하든 사실 전혀 중요하지 않아요 업데이트했다 라는 팩터가 중요한거지 10번 20번 10번 뭐 업데이트 했다고 얘가 프라이어티가 이거 뭐 전혀그런거 없다. 어쨋거나 좋아 뭐 연산했어 자 여전히 결과는 같습니다. 다르지 않다.
이제는 13이고 b는 2,3일 뿐이다. 여전히 아까아같은 똑같은 그런 ordered 관계가 여전히 형성이 됩니다
그냥 카피해버리면 됩니다 자 그런데 이제 b가 탄력을 받아가지고 저 안하던 놈 업데이트 해보자 그래가지고 업데이트를 해요 b가 업데이트 했더니 이제는 a는 지금 현재 10 하고 3이고 b는 이제 2하고 4가 되요 자 이렇게 되면 문제가 생긴다 라는거임 이렇게 되버리면 이거 자세히 보시면 아시겠지만 이거는 
아이덴티컬 한것도 아니고 그리고 어떤 순서 관계가 명확하게 존재하는것도 아니고 요런 관계가 형성되면 얘가 이제 컨커런트 한놈이 되는거에요 요럴때 이제 문제가 되는데 그럼 이걸 갖다가 어떻게 뭐 업데이트 싱크를 맞춥니까 그거는  기술적인 문제이기 때문에 그거를 여기서 다루지는 않는다. 그 알고리즘마다 다르고 시스템마다 다르기 떄문에 그 애플리케이션 마다 다르고 어쩃든지 간에 요렇게 되버리면 이제 두개가 이제 디벌저 가 되기 시작한다. 서로 이제 컨커런트 하게 되기 시작한다. 그러면서 이제 어 시컨셜이 사실 조금 복잡해져요 그리고 이거 어떻게 되냐 그런 얘기가 나왔는데 
여기 보시면 나와있죠, 싱크를 맞추는데 유저 어시스턴스(user assistance) 에 힘을 갖다 조금더 도움을 받아가지고 싱크를 한다 그랬죠 왜냐하면 이게 더 복잡한 이게 더 복잡한 문제
그래서 어쩃거나 싱크를 한다 까지만 알아두시길 바랍니다 어쨋든지 싱크를 맞추긴 맞출텐데 싱크를 맞추고 났을때 얘가 그 최종적으로 나오게 되는 싱크가 맞은 그 버전 벡터가 뭐냐면 10하고 4 입니다 왜? 말씀드렸죠 싱크를 맞출때 버전벡터에서는 그 요소는 각 벡터에 가장 큰 x값만 취한다 그랬다. 그래서 10하고 2를 비교하면 10이더 크잔아요, 그래서 10을 택한거고 3하고 4를 보면은 4가 더 크잔아요 그러니까 4를 택한거에요 아시겠죠 
그리고 나서 어느순간 싱크를 하고 나면 이제는 a든 b든 둘다 버전 벡터 10에서 14에서 다시 시작한다고 아시겠쬬 
