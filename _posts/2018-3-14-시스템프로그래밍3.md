---
post : layout
title : 시스템프로그래밍3
---
## Process
현재 실행중인 프로그램
프로세스는 CPU를 공유하기 위해 실행 및 중지를 반복해야합니다.
자원을 경쟁한다.
프로세스는 다른 stats(running or stopped)를 갖고 context(current register contents)를 갖는다.

## Process Context
다른 프로세스가 기다리고 있으면 cpu를 줘야함. 
중단된 시점에서 프로세스가 다시 돌아가야 한다.(이전의) 다른 프로세스가 레지스터를 쓰면 기존의 프로세스를 처리하고 있는 레지스터의 내부의 값을 깨먹을 확률이 있기 때문에.
중단된 시점에서 레지스터의 값을 보관하고 있어야한다.
이러한 내용을 context라고 한다.

address space : text(프로그램에 명령어 부분이 들어간 자리)
data(global variable이 들어가는 장소, data region), heap(MALLOC 할당시 준비된 공간),
stack(함수를 호출하거나 argument passing, local variable역시 stack에 쌓인다.)

## system-level context
context와 같다. 
프로세스 중지시 CPU 레지스터 내용을 저장해야한다.

중지 된 프로세스를 다시 시작할 때 레지스터 내용을 복원해야합니다.
등록 내용은 다른 프로세스에 의해 수정 될 것이기 때문에 중지 될 때 저장해야합니다.
## What should be protected?
### Execution of privileged instructions by user codes.
컴퓨터 시스템에 cpu의 머신 인스트럭션 있는데
arm은 50가지 intel 200 가지 있음. 이런 인스트럭션들이있는데 그중에서
특권 명령어 아주, 막강한 힘을 발휘하는 인스트럭션이 있다.
디스크 I/O 명령어를 내리는 명령어가 있다하자 유저가 하면 안된다.
디스크는 커널이 가지고 있는거니까 커널을 통해서 부탁해야 한다.
OPEN READ WRITE 하는 커널에 부탁.

*홀드라는 명령어가 CPU에 있는데 CPU를 죽이는것이다.
홀트 명령어는 CPU 끌때 돌아간다. 서버 시스템에 로그인해서 쓰는데
사람이 어셈블리 숙제 하면서 홀트 넣어버렸음 기계가 죽음.
이사람 홀트 쓰게 하면 안된다.
유저가 맘대로 쓸 수 없는게 특권명령어다.


I / O 명령어, 인터럽트 처리 명령어. 시스템 종료를위한 "halt" 특별 명령어.
이러한 종류의 명령어가 사용자 코드에 의해 실행되는 경우, 서버
시스템과 충돌합니다!
### Memory areas of the kernel and processes
멀티유저 시스템있으면 두개의 프로세스가 돌아가는데 
가장 쉬운예, 포인트를 쓰다 잘못써서 주소가 남의 프로그램의 주소였음.
건드리면 다른사람의 프로세스가 죽어버림 프로세스가 돌아갈때 메모리 access 
할수있는 upper limit lower limit이 있어서 바운데리를 넘어갈 수 없음.

프로그램돌아갈때 커널로 건드릴수없고, 다른 유저프로세스가 건드릴수없음.
리눅스에서 시그너스 바이레이션 에러가 뜬다.

남의 프로그램이 내 프로그램을 건드리는걸 막는다.
이런 명령어는 커널은 써야 된다. 커널은 i/o 도하고 cpu도 죽이고
커널에 입장에서 여러 프로세스를 들락날락 해야한다.
커널은 자유롭게 써야 된다.

유저프로그램이 돌아갈때는 특권명령어쓰면안되고 메모리 프로텍션의 지배를 받아야한다.

커널 영역 (커널로 이동, 커널 수정이 보호되어야 함)
프로세스의 메모리 영역 (다른 프로세스에 의한 수정)
### By providing the “Dual Modes”
하드웨어 서포트 되는게 듀얼모드이다.
cpu의 빨간불이면 커널모드 돈다. 특권명령어 수행, 메모리 프로텍션에 자유
cpu의 불이 꺼지면 유저모드로 바뀐다. 유저모드로 바뀐다라는것은 cpu가 커널의 코드를 수행하는게아니라
유저의 프로그램을 수행중. cpu가 유저모드가 되서 이떄는 특허명령어, 메모리 프로텍션의 지배를 받는다.

cpu의 모드이기도 하지만, 현재 돌고있는 프로세스를 current process라고 한다.
자기프로그램 수행할때는 프로세스는 유저모드에 있고 그런데 프로세스가 파일을 쓸라하면
시스템 콜을 해야하니까 open 콜했다. open 은 커널 속에 있다. 프로세스가 open 속으로 들어가서
커널 코드 수행. 그떄는 cpu도 커널 모드로 바뀌고 프로세스도 커널모드에서 돈다.

프로세스가 돌때는 2가지 모드 자기코드 속에서 돌때 유저모드, 커널속에 들어가서 시스템콜하면

현재 프로세스의 실행 모드가 cpu의 모드다.

## Dual Modes: User Mode vs Kernel Mode
커널은 도는게 아니다. 커널은 도는게 아니라, 도는것은 프로세스가 돈다.
프로세스가 유저모드에서 돌다가 open call하면 프로세스가 커널 안으로 들어가서 
커널이 짠 코드를 쓴다. 도는건 프로세스 유저모드에서 도는게 커널모드로 바꼈을 뿐.

## User Mode
유저모드는 cpu가 유저가 짠 프로그램을 돌린다. 다른 프로세스가 커널의 메모리의 영역에
유저코드가 접근하려하면 가장 대표적인것은 포인트 잘못쓰는것이다.
시그먼트 바이레이션 이라고한다 리눅스에서는 (다른 영역 침조)

## Kernel Mode
커널 모드에서는 특권명령어가능, cpu는 커널코드로 수행
유저가 시스템콜 했기떄문에 커널안으로 들어간다.
인터럽트가 들어오면 인터럽트 핸들러가 돌아간다. 인터럽트핸들러가 커널 속에 있으니까
이때는 특권명령어사용가능, 메모리 프로텍션하에 통과할 수 있다. 맘대로 건드릴수가있다.
(privileged instructions)

CPU가 커널 코드를 실행 중입니다. 이때, System call 과 Interrupt handler 접근할 수 있다.

시스템 호출에서 복귀 할 때 사용자 모드로 돌아갑니다.

## Dual Modes
듀얼모드에서 설명하면 sin call하면 sin 속으로 들어가면 커널 모드가 아니라 유저모드다.
sin은 라이브러리다. open 은 속으로 돌아가면 시스템콜이니까 커널이 실행, 커널모드가 된다.

## Kernel & Processes
커널은 시스템콜의 집합(“Top-half of
a kernel”) + 디바이스 드라이버 집합(인터럽트 핸들러다, “Bottom-half of a kernel” )으로 구성되어있다.

## Kernel & Resources
커널은 교통신호등. 커널은 리소스 관리. cpu 메모리 i/o 디바이스 파일 데이터베이스 소프트한 리소스 하드한 리소스를 가지고
프로세스에게 나눠지고 회수하는것이 커널의 목적이다.
(리소스 관리자 및 가상 컴퓨터다.)

### System resources
리소스한정되고 프로세스는 많다. 나눠줄려면 천상 줄을 선다.
줄을 스는데는 다른 스케쥴링 방법을 쓴다 => os는 새치기를 허용한다.
이유는 efficiently 효율적으로 컴퓨터 시스템의 리소스가 4개 있는데 하나만 받고 나머지 3개는 놀면 안됨 4개가 다 바빠야 시스템 성능 올라간다. 

cpu가 i/o보다 빠르다.
느린 디바이스 일수록 일을 혹독하게 시켜야 한다. 노는시간있으면 안된다. 그게 efficiently 한거다. 
컴퓨터 시스템에도 같다. efficiently 높이면 fairly이 나빠진다. 적당한 중간선을 찾아야 한다.
프로세스는 항상 리소스가 실행되도록하기 위해 경쟁합니다.

### System calls (API functions in a kernel)
API는 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.
일반적으로 시스템 콜 기능은 allocating/using/protecting/releasing system resources.
리소스를 사용하기위한 쉬운 논리적 인터페이스이다.

##Preemptive Multi-tasking

프로세스는 항상 컴퓨터 시스템의 리소스를 차지하기위해서 경쟁하고 있다.
커널의 시스템의 콜은 소위, 리소스, 커널이 가지고 있는 리소스를 할당받고
(print 할당받아야 쓴다. 내가 사용하는 동안 보호를 해주고) 내가 다쓰면 필히 단 유저를 위해서 반납해야 한다.

이런것과 관련된것이 시스템콜이 된다. 리소스를 사용하기위해서 쉽고 능률적인 인터페이스를 제공해줘야 한다.

윈도우시스템이든가, 리눅스시스템 범용 os는 전부다 preemptive multi tasking os 라고 부른다.
#### Time-slice
CPU는 타임 슬라이스 방식으로 프로세스간에 공유됩니다.

#### Preemption
cpu 쓰고 있는데 시간이 다되면 뺏어와야 한다. 나중에 다시 context 에 의해서 중단된곳에서 부터 다시 시작.
미사일 방어 시스템 프로그램이 돌아가야 하면 급하면 우선순위 높은게 생기면 우선순위 낮은거는 자르고 들어가야한다.
이것을 preemptive system 이라고 한다.  multi tasking 이란것은 task는 프로세스의 다른말이다.
프로세스가 서로 여러개가 돌아가면서 서로 뺏기고 뻇으면서 돌아간다.

## CPU/IO overlap
멀티태스킹(영어: multitasking) 또는 다중작업(이하 멀티태스킹)은 다수의 작업(혹은 프로세스, 이하 태스크[1])이 중앙 처리 장치(이하 CPU)와 같은 공용자원을 나누어 사용하는 것을 말한다. [1]
멀티 태스킹은 하는 이유는 cpu i/o overlap 이 제일 중요하다.
cpu나 디스크 컨트롤러나 같은 기계다. 하는일이 다를 뿐이다. 사고하는것은 cpu 중심은 버리자.

내 프로그램이 계산해야할때는 cpu를 써야함. 파일 i/o를 쓸땐 디스크 컨트롤러 쓴다. cpu를 필요없다. 이때는
두사람의 프로세스가 있는데 한쪽은 계산만함 cpu만 쓴다. 옆에 있는 프로세스는 은행에서 돌아가는 프로세스 이기때문에 
주로 db에서 db가 disk에 있으니까 읽어오고 이자계산해서 쓰고 하는것을 하니까 이자 계산은 곱하기하면 끝
++이 프로세스는 디스크 컨트롤러를 쓴다.++

커널인데 cpu를 가지고 있으면, i/o를 많이 쓰는 프로세스에게 cpu를 준다. 왜냐하면,
cpu를 많이쓰는 프로세스에게 cpu를 나눠줌 커널이 cpu를 계속 씀. 그때 이 사람이 할 i/o device가 놀고 있다.
i/o 시작을 못하니까 디스크 컨트롤러는 할일 없이 놀고 있다. 디스크 컨트롤러는 느린건데도 놀고있으니까 불안정.
cpu를 i/o 하는애한테 먼저주면 이자계산을 금방하니까 디스크에다 쓰라고 할것이다. 디스크 쓰라고 하면 디스크컨트롤러가
일을 해야하기 때문에 이 프로세스에 cpu가 필요가 없다. ++이 프로세스가 디스크 i/o 요청했기때문에 디스크 명령을 내려놓고 디스크 i/o 끝날때까지 얘가 돌아갈 수 가 없다.++ 디스크 읽어달라고 하는데 읽어와야지 돌아간다.

++디스크 읽어 오는동안에 이 프로세스는 cpu가 전혀 필요없다. 디스크 컨트롤러가 쓰이기 때문에 cpu를 스스로내놓는다. i/o하는동안에 그러면 그때 cpu의 프리하게 된다.++
==그떄 이 cpu가 cpu 많이 쓰는 프로세스에게 가면 결론적으로 디스크 i/o 디바이스도 일을하고 cpu도 일을 하게된다.==
cpu를 cpu 많이쓰는 프로세스에게 주면 i/o device가 논단 말이다. 이런게 스케쥴링(줄을 서면 순서를 정한다.)

i/o 많이 하는 프로세스한테 cpu를 줘야지 i/o overlap cpu도 돌고 i/o device도 돈다.
이런게 가능할려면 프로세스가 여러번에 한꺼번에 돌아야함. 어떤 프로세스는 i/o많이 하는거 cpu 많이 하는거 이런게 섞여있어야
스케쥴링 제대로 해서 시스템성능을 올릴 수 있다.
++어떤 프로세스든지 i/o동안에는 cpu를 쓰지 않는다. 생각해둔다.++

이 CPU / IO 오버랩은 시스템 성능을 향상시킵니다!

## I/O System
프로세스가 있다. 커널이 있다. 커널은 시스템콜의 집합과 디바이스드라이버 집합이 있다. 
여기에는 하드웨어가 있다. 일반적으로 프린터를 가져다 사면 interface 카드가 있어야 한다.
디스크를 붙일려하면 디스크 대화할 디스크 컨트롤러가 있어야 한다.

컨트롤러 또는 인터페이스 (컨트롤러는 조금 복잡하다 디스크처럼 값이비싸다)
키보드 같은 경우는 간단하다. ( 키보드는 인터페이스라고 한다, 간단한 컨트롤러라고한다)

I/O 디바이스 하고 접속을 위한 컨트롤러 시스템이 필요하다.
++대부분의 OS에는 디스크 파일도 있지만 마우스, 키보드, 프린터 이런 네트워크 카드 이런 디바이스도 있다.++

이건 디스크 파일이 아니다. 내가 네트워크로 내보는건 네트워크 카드에 쓰는것이다. 쓴다는 행위는 마찬가지다.
네트워크 카드쓸때 API 다르고 프린터쓸때 API 다르고 키보드 API 다르면 외우기가 힘들다.
대부분의 OS 시스템은 키보드건 네트워크카드건 디스크건 어디에 맵핑하냐면 파일로 간주한다.
==뭔가 H/W 쓸때 적는데, 전부 API가 다르니까 파일로 간주한다.==

파일에는 디스크에 만드는 일반적인파일= i/o 디바이스, 기계를 가져다 파일에 맵핑한 스페셜 파일이 있다.

스페셜 파일은 파일이다. i/o 디바이스를 파일로 생각.

i/o  할때 파일시스템한테 부탁한다. open해서 키보드로 파일 오픈하면 3번부터 오픈(0,1,2 이미 오픈됨 0: 키보드 1:화면스크린 2:스크린에러메시지 채널) 디바이스로 이미 오픈되어있다. 우리가 오픈하면 4번째 오픈되어있다.

i/o 디바이스 오픈해서 리드 라이트 클로즈 한다. 
일반적인 디스크파일과 달라서 파일 시스템 api 같지만 
디바이스 내보내고 읽어와야 한다면 디바이스 드라이버를 거쳐야한다.(디바이스 드라이버 = 인터럽트 핸들러) 

디바이스 드라이버는 디바이스와 직접 대화하는게 아니라, 디바이스를 제어하는 제어기와 대화한다. (디바이스 컨트롤러라고한다.)

명령어, 디바이스 명령어 (명령어는 읽고 쓰고가 있다)
프린터라하면 써라 명령어 내보내면
write를 하면 Data Buffer에다 데이터를 준다.
예전에 한 캐릭터씩 주는 방식의 시리얼 프린트, 한 자 단위로 간다. 

반대로 키보드 같은 경우는 a 두들기면 아스키코드가 들어와서 읽어하면 가져간다.
왔다갔다 데이터하고 읽는건지 쓰는건지 명령어가 있다.

## Busy 와 Done
### Programed I/O
한글자씩 내보내는 프린트 했는데 한글자를 내보내라고 했어, write하고 한글자 내보내서찍고있는데 cpu입장에서 긴 시간이다.
cpu는 다음 글자를 내보내야된다. 다음 글자 내보내려하는데 찍고 있는중이면 보낼 수 없음. 일하는 도중이라
그걸 체크하는게 status(레지스터)이다. 두가지다.
busy와 done이다.
busy는 일하는 도중이야, done은 다했다. 다음글자 보내도 된다. 
입력의 경우 키보드 데이터 도착하면 done이 셋팅 (입력디바이스) 한글자 준비됬으니까 가져가세요.

디바이스 드라이브가 한자를 내보냈어, 그리고 다음글자를 내보내고싶어. cpu는 빠르니까 status가 busy상태
그러면 이것을 내보낼려하면 변이되는지 LOOP을 돌면서 물어봐야 함.
CPU가 그 LOOP을 몇억번쯤 돈다. CPU의 낭비다. 프로그램드 I/O라고 한다. CPU가 계속 다음 짝 보내도 되니, DONE이야 BUSY야? DONE이 되면 내보내는게 프로그램드 I/O라고 한다.

### 인터럽트
CPU가 I/O 디바이스와 약속한것이 내보냈어, BUSY가 SET되면 한글자를 찍는동안 CPU는 기다리지 않고, 단 프로그램을 간다(프로세스 돌리러) 다른 프로세스 돌리고있다.
다른 프로세스 돌았는데 언젠가는 I/O 끝났다는것을 알면 다음 글자를 내보내줘야한다. DONE 되면 CPU한테 전화걸어.
하던일 중지하고 전화를 받음 니가 만일에 DONE이 되면 CPU에게 전화를 걸어, 하던일 중지하고 다음 글자 보내줄게 CPU는 또 다른 프로그램을 돌리러 간다. 그 전화가 인터럽트다.
I/O 디바이스가 일을 다해서 ++FLAG DONE++ 되면 CPU에 전기적신호를 찌르는데 인터럽트를 통해서 CPU의 핫라인으로 간다. CPU는 다른 프로세스 열심히 돌리다가 ++인터럽트 오면 하든일 중지하고,
그리고 인터럽트에 대한 처리를 하는데 커널속으로 들어감, 커널속에 전화받는 프로그램으로 들어가는데 인터럽트 핸들러로 들어간다.++ 한글자가 끝났네 다음글자 보내줄게 다음글자를 가지고 있는건 디바이스 드라이버다.

디바이스 드라이버 가 결국은 인터럽트 핸들러가 있다. 한글자를 꺼내고 인터럽트 핸들링이 끝나면 다시 다른 프로세스로 돌아간다. CPU가 인터럽트 I/O라고 한다.
++커널안에 디바이스 드라이버가 있다.++
## Reference
[1] : https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%A4%91%EC%9E%91%EC%97%85
[2] : https://brunch.co.kr/@cysstory/115