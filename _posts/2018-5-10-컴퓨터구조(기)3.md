---
post : layout
title : 컴퓨터구조2(기)
---

## PLA Implementation
and plane은 요기 한줄에 선택된 입력들이 하나의 and gate로 들어가는 그런 형태로 pla해석해야한다. 그러면 여기에 요줄에서 선택된 값은 
s3 프라임, s4 프라임, s1 프라임, s0 프라임 그것들이 and gate로 들어가니까 s0~ s4가 다 0000 이 들어왔을때 선택되는 값이 1이 들어올수있도록 세팅된것이다. 그 아래에 있는 or plane은 위에서 내려온 값이 연결되었을때 연결된 값들, 위에서 내려온 값들 and plane 오는 값을 오른쪽으로 전달하는데 한 줄이, 한줄에 여러점들이 나타날수있다. 여러점들을 oring 시켜서 여기에 신호선으로 전달한다. IorD는 두값이 oring 된다. 한값은 여기에 있는 값들을 and 한 결과 한값은 요줄에 선택된 값들을 and한 결과 두가지 값을 or해서 IorD로전달한다. IorD가 여기에 나타나고 여기에 나타나고 그리고 또 0번에 나타나고 그렇다. 요것은 저기에서는 하나로 취급된다. 왜냐하면 여기 지금 IorD가.. IorD가 0일때는 구지 명시해서 그 0을 내보내야 한다. 를 하지않아도 된다. IorD가 1일때만 값이 1이나가도록 해준다. 나머지는 그냥 default로 0이 나간다. 그러니까 아까 상태에서는 뭔지를 확인하면 되냐면 두점이 두지점이 하나의 state number가 3번이고 opcode가 lw니까 100011 이니까 또한 경우는 state 가 5번이고 opcode가 101011 이다.(sw일경우) 두경우를 표현하것이 IorD의 두점이다. 우리가 여기서 출력값은 기본적으로 state가 정해지면 그 state의 값에 따라서 출력값이 나온다고 했으니까 요점은 state가 밑에서부터 하면 1 1 0 0, state number가 3이다. 1100이면 현재 state number에서 요 값들들을 and gate하면 state number가 3일때 1이 된다. 그러면 그때 IorD가 1이 나갈것이고 요경우는 1010 얼마지?, 5다. state가 5면 그때 IorD가 1이 나가도록. ++(연습을 하자. 시험문제일 가능성이 매우크다.)++

## Summary
다시 한번 정리하면 요 테이블을 조합회로로 구현한 pla인데, pla에서 output(control신호의 output) 어떻게 내보낼지 결정하는거에 중요한것은  다음 state를 몇번 state로 정할것인지를 결정하는 회로다. 제일 중요한것은 입력에 sum of product (=Minterm) product를 minterm이라고 하고 minterm들의 합으로 연산을 한다. 때로는 여기서 볼때 output은 전달해야될, output(control output)은 현재 state를 알면 output은 결정된다. next state는 현재 state와 input(opcode) 을 알아야 한다. control 신호의 output은 현재 state만 알면 되는것이고 next state는 input과 현재 state도 알아야 한다. 같이 알아야 한다. 요 plane는 and gate 바꿔보는것도 case 대해서 
요 중간에 고 접점에 트랜지스터에 들어가서 거기에 on/off switch 기능을 해서 위에서 오는 값을 오른쪽 으로 보내는 그런 logic을 구현한것이 pla고 pla는 이와같은 많은 양의 조합회로를 쉽게 구현하는 역할을 하고 만약에, 여기에 있는 입력값이 몇 bit지(4bit 6bit = 10bit)의 값이 10bit 로 가능한 모든 조합이 2^10인데, 2^10에 해당되는 모든 경우(opcode+현재state) 다 코딩을 해놨다면 0부터 1023 까지 해당하는 모든 경우를 다 여기다가 접점을 다 코딩해놓고 여기 지금 17개의 정도의 case만 나왔는데 2의 10승 =1024의 케이스가 다 나오겠지, 그것의 모든 가능한 접점을 다 여기다가 설정을 해놓고 여기서 그 addr가 들어왔을때 거기에 해당되는 값이 선택이 되서 출력이 나가도록 하면 그것은 뭐랑 같냐면 메모리 하고 갔다. rom 어떤 주소가 들어왔을때 그 주소가 선택했을때 밖으로 나가야하는 값들, 이 값들을 우리가 만약에 전체 addr에 대해서 다 설정한다면 그것은 pla는 결국 메모리하고 똑같은 역할을 하게 된다. 

지난 번에 얘기했던것처럼 싱글 사이클의 여러 문제가 있기때문에 이것을 멀티 사이클로 우리가 지금 계산한것이고 멀티사이클을 다시 한번 정리하면 한 명령어를 몇개의 작은 step으로 파티셔닝을 하고 각각 step 마다 한 cycle씩 그래서 굉장히 빠른 사이클 싱클 사이클에 비해서 훨씬 빠른 사이클로 동작하도록 만들었다. 명령어마다 소요되는 사이클을 다르게 설정했다. 그것이 멀티사이클이다. 명령어마다 동작하는 사이클 다르게 하기 위해서 우리가 final state machine이라는 상태와 상태를 전이하는 그런 다이어그램을 디자인했고 그 상태 기계가 방금 봤던것처럼 이와 같은 조합회로에 의해서 구현될 수 있다. 상태 기계라는것은 현재 상태에서 다음 상태로 몇번으로 움직일 것이가 그것을 구현한것인데 우리가 이제 보면 가로축은 cpi

표) 가로축은 cpi, instruction당 사이클의수 세로축은 clock cycle time 위로 올라갈수록 사이클 타임이 긴것이고 결국 클락 사이클 입장에서는 사이클 속도가 느린경우에 해당한다. 멀티 사이클의 경우에는 명령어마다 cpi는 큰편인데 클락사이클타임은 짧은 그런 위치에 해당하고 싱글사이클은 cpi는 모든 명령어에 똑같이 1이지만 클락사이클 타임이 훨씬 긴 그런 아키텍쳐를 갖는다. 우리가 이제 살펴볼 부분이 이부분인데 파이플라인인데 싱글 사이클은 쉽게 구현할수있지만 성능의 문제가 있기때문에 이것을 개선하는 방법으로 멀티사이클을 살펴봤는데 이렇게 개선할수도있고 이렇게 개선할수도있다. 싱글사이클을 가지고 
pipelined 이란 형식으로 싱글사이클을 개선하는형태를 우리가 이제 살펴볼려한다. 

## Pipelined Datapath
교재에서는 4.5절 부터 시작한다. 다시한번말하지만 이와같은 싱글 사이클은 명령어마다 한 사이클씩 동작하는 cpi=1로 동일하는데 클락 사이클 타임이 너무 길다. 이 클락 사이클은 어디에 맞추냐? 명령어들중에서 가장 시간이 오래걸리는 명령어에 클락 사이클을 맞춰야 하기때문에 load가 가장 많이 걸리는데 load에 맞춰서 클락사이클타임을 주게 되면 어떤 명령어는 불필요한데도 이 만큼의 시간을 기다려야 하는 낭비하는 현상들이 발생하게 된다. 자잘하게 세분화해서 빠른 클락을 적용한게 멀티 사이클이다. 명령어마다 클락의 개수가 조금씩 다르다. 얘를들면 5단계로 나누는데 5단계로 나누면 사실은 얘클락에 5단계로 나누면 한사이클이 이것에 1/5이 되어야하는데 1/5보다 조금 더 길다. 조금 더 긴 이유가 우리가 보면 레지스터에서 읽어서 계산된 결과를 다음 버퍼에다 써야한다. 항상. 읽어내고 쓰고 읽어내고 쓰고 이런 동작이 필요하다. 근데 싱글사이클에서는 그런 동작들이 안나타난다. 그냥 연산이 쭉 이어진다. 그러니까 멀티사이클에서는 멀티사이클의 장점은 명령어마다 다른 사이클을 적용할수있다는 장점이 있는데 반에서 중간중간에 버퍼에서 읽어야 하고 버퍼에다 쓰고 읽고 쓰고 오버헤드가 든다. 그렇기 때문에 전체 토탈 length를 보면 같은 load라고 해도 조금더 길어질 수 있다. 얘들의 장점은 명령어마다 꼭 필요한 만큼의 사이클을 쓸수있다는 장점이 있지만 단계마다 그 버퍼에서 읽어내고 쓰고 읽어내고 쓰는 오버헤드가 들어서 실질적인 어떤 명령어를 놓고 보면 실질적인 소요시간은 약간더 길어질 수있다. 그런 문제점이 있다. 
다시한번 ++ 굉장히 중요한것인데, 어떤 명령어든 처음에 instruction을 가져오는 단계가 있고 가져온 instruction을 해석하는 단계가 있고 그것을 alu에서 실행 하는 단계가 있고 그다음에 필요한 경우에 memory access 하는 단계가 있고 그다음에 마지막으로 결과를 register에다가 쓰는 5단계가 있다라는것.++ 
instruction fetch, decode = instruction decode, execution, memory access (mem), write back(레지스터에 값을 돌려쓴다.)

## How Can We Make It Even Faster?
프로세스를 훨씬 더 빠르게 만들기 위해서 여러가지 시도들을 하는데 첫번째 멀티사이클 했던것처럼 어떤 사이클을 더 작은 스텝들로 나눈다. 많이 나누면 좋으냐? 한명령어를 5단계로 나눴는데 10단계로 나누면 좋으냐? 꼭 그렇지 않다. 왜냐하면 아까도 말한것처럼 중간중간에 state reigster 다른말로 버퍼라고 하는데 버퍼에다 값을 쓰고 버퍼에서 load하는 시간이 실제 거기서 일하는 시간에 비해서 작아야 한다. 근데 이걸 너무 잘게 나누면 실제 그step에서 일하는 시간은 얼마안되고 그전에 버퍼에서 읽어내고 버퍼에 쓰는시간이 더 길어지게 커다. 그러면 효과가 떨어진다. 그런 점을 고려해서 어느 선까지 나눌것인지를 생각을 해야하고 또하나는 이런것이다. 우리가 어떤 일을 하는데 순차적으로 꼭 해야하느냐 명령어가 쭉있으면 명령어 하나를 다 끝내고 나서 그 다음 명령어를 실행해야 하느냐 아니면 명령어가 하나 시작되고 걔가 아직 완료되지 않았는데 바로 뒷명령어를 시작시킬 수 있느냐 그런측면에서 살펴볼 수 있다. 그것을 pipelining 기법이라고 하는데 현재 대부분은 마이크로 프로세스에서 성능을 위해서 이런 방법을 쓰고 있다. 파이플라이닝 스테이지가 굉장히 세밀하게 나눠진것을 슈퍼 파이프라이닝 이라고 하고 때로는 한번에 명령어 한개 이상을 시작시키는 그런 기법을 우리가 슈퍼scalar = multiple instruction, 보통이게 우리가 scalar라고 하면 보통이게 어떤 integer 연산을 하는것을 scalar instruction이라고 하는데 이런것들이 한번에 굉장히 많이 시작된다. 동시에 out of order 라는 말이있는데 이것은 순서와 상관없이 순서를 바꿔서 order를 바꿔서 우리가 c 프로그램에서 명령어들을 순차적으로 쓰는데 a=b+c d=b+d 이것을 컴파일 해서 돌리면 프로그래머가 명시한 명령어들을 보고 꼭 그대로 돌리지는 않는다. 물론 거기서 중요한 전제는 프로그램의 정확성을 해치지 않는 범위 내에서 순서를 바꿔도 무방한건 바꾼다. 예를들면 ppt 참고  a=b+c, d=b+d 이런식으로 쓴단 말이야 그런데 이 문장에 이순서대로 실행될 필요가 있냐? 실제로? 우리가 프로그램을 적다가 보니까 순서를 정해서 써줘야 하니까 쓴것이지 사실은 이 둘사이에는 누가 먼저 실행되도 프로그램 로직에는 전혀 상관이없다. 프로그램의 기분에 따라 바꿀 수있는 부분 이기 때문에 결국 이것이 뭐냐면 이런 명령어들이 순서를 뒤바꿀수있는 명령어 이것은 일차적으로 컴파일러가 컴파일 하는 단계에서 순서를 바꿔야 하는 상황은 바꾼다. 컴파일러가 이따가도 보겠지만 프로그램을 이렇게 했는데 프로그램 정확성 하고 상관없는 문장 순서다. 그러면 바꾼다. 그리고 두번째로는 마이크로프로세스가 명령어를 하나씩 하나씩 수행하면서 아 이순서대로 하는것보다 바꾸는게 성능을 향상시킬 수 있겠다 하면 바꾼다. 또.
그래서 그런면에서 슈퍼 스칼라, 또는 vliw 해서 아예 컴파일러가 하나의 명령어를 한명령어가 32bit인데 예를들면 128bit 한워드를 4워드 에다가 여러개의 명령어를 한꺼번에 코딩을 해서 넣는다. 그리고 이 명령어가 한번에 마이크로 프로세스 에 의해서 동작되도록 하는 아키텍쳐도 있고 그다음에 멀티스레딩(동시에 여러개의 실행의 흐름을 처리하는 그런 개념) 멀티스레딩을 지원한다던지 멀티스레딩은 프로그래머가 로직으로 만든 스레드인데 반해서 하이퍼 스레딩은 프로그래머 가 만든것이 아니라 cpu 아키텍쳐가 스레드를 형성한것이다. 이런 다양한 형태로 프로세스개선을 시도하고 있다. 

## Sequential vs Pipelined Processing
이 그림을 먼저 보면 먼저 잠깐 이해해보면
위에는 우리가 전통을 해오던 순차적인 명령어 실행을 보여주고 있는 예이고 아래쪽은 지금 얘기하고 있는 파이플라이닝을 지금 예로 보여주고 있다. 왜냐하면 세탁하느 예로 들었지만 명령어의 실행순서라고 봐도 된다. 자 어떤 차이가 있는지 그다음에 이렇게 동작하려면 어떻게 해야하는지 한번 보도록 하자. 여기 a,b,c,d는 사람이라고 생각해도 되고, a 라는 사람이 와서 자기 세탁물을 세탁하고 건조하고 뭐 이렇게 해서 수납할때까지 이만큼의 시간이 필요하다. 그다음에 이게 끝나면 b라는 사람이 와서 반복하고 순차적으로 한다. 우리가 이제까지 봐왔던 명령어가 순차적으로 실행될 경우 그런 상황으로 볼 수 있다. 가만보면, 만약에 이 각각의 관계 세부 단계 가영향을 받지 않고 독립적으로 움직일수있다면 이렇게 할필요가 있는가 이렇게 하면 어떤가 a라는 사람이 세탁을 시작을 하고 세탁기를 쓰고 그다음에 꺼내서 건조기를 쓰기 시작하면 그때 b라는 사람은 바로 세탁기를 써도 된다. 그리고 마찬가지로 그다음에 다음단계 건조기를 썼을테니까 그다음 사람이 건조기를 써도 되고 이와 같은 각각이 독립적으로 동작할 수 있는 그런 기계들을 갖고 있다면 그런 상황이라면 이와 같이 하나의 작업이 다끝나기 전에 두번째 작업을 시작할 수 있다가 파이플라이닝의 핵심 개념이다. 토탈 타임을 보면 6시부터 시작해서 14시에 끝났다. 8시간 걸렸다. 아래껏은 3시간 30분 걸렸다. 한 슬랏이 30분이다. 총 3시간 30분 걸렸다.
핵심, 현재 카운트 instruction이 완료되기 전에 next instruction을 count 시킨다.(직전의 명령어를 셀수있겠다 이런의미인듯.) 이게 파이플 이고 이렇게 함으로써 얻는 효과가 머냐, 쓰로풋을 향상시킨다.(단위시간당 처리량을 의미한다.)
아까도 얘기했지만, 4개의 작업하는데 8시간이 걸렸는데 지금의 4개 작업하는데 3시간 30분이걸렸다. 그러면 1시간에 얼마나 일을 했는가 따져보면 훨씬 커졌다. 반면에, instruction latency라는 측면에서 볼때 지연시간은 하나의 명령어를 실행시키는데 토탈 타임 
거기는 여러가지가 있지만 instruction 이 시작했을때부터 컴플릿 할때까지 시간을 latency라고 한다. latency는 한 명령어가 시작 되서 끝날때까지 걸리는 시간은 동일하다. 파이플라이닝은 
그런데 그럼에도 불구하고 쓰루풋이 향상되는 이유는 앞선 시간들이 뒷따르는 시간에 의해서 상당부분감춰지기 때문이다 왜냐하면 그 시간이 고스란히 실행시간에 나타나지 않고 뒤따르는 시간이 뒤에 명령어를 실행하면서 상당부분을 상쇄하기 때문에 나타나는 효과가 파이플라인 이다. 이와같은 멀티사이클하고 유사한데 다른것은 하나의 명령어가 시작되면 그 다음에 뒤따라서 다음 명령어가 시작되도록 허용한다. 그게 파이플라인 아키텍쳐다. 대신 이 파이플라인 아키텍쳐가 5가지 단계로 구성되있으면 ++뭐든 명령어가 5단계 단계를 따라서 똑같이 움직여야 한다.++
얘를들면 지금 우리, 이게 자동차의 생산라인 하고 비슷한데 자동차가 차체 만들고 여기서 내장하고 그다음에 타이어 붙이고 마감하고 이런식으로 간다하면 차가 시작되면 내가 차체를 하고 내장하는쪽으로 옮겨주면 그 상태로 가는데 어떤 차는 이중에서 어떤 작업을 할 필요가 없을 수 있다. 소용차같은 경우는 고급 내장을 안해도 되는데 결국이 파이플라인 시스템은 동일하게 사용한다면 똑같이 그단계는 거쳤다가 그 시간만큼 거기서 기다렸다가 다음에 넘겨줘야 한다. 결국여기서 마찬가지다. 로드 같은 경우는 모든 단계에서 다 일을해 스토어는 패치, 디코드, 익스큐션 메모리 쓰지 메모리 쓰는걸로 사실은 끝나는데 하지만, 여기서 끝난다고 해서 모 그다음에 일을 안하는것이 아니고 write back step 까지 가서 그냥 기다리는 일을 해야 한다. 똑같이 ++r-type도 마찬가지다. 패치, 디코드, exectuion하고 r-type은 메모리 access를 하지 않는다. 하지만 메모리 access 안한다고 해서 중간에 건너뛰고 바로 여기다가 write-back할수는 없는것이다.++(각 단계에 맞는 위치가 존재하는듯 싶다.) 이것은 이미 정해져있는 스케쥴에 따라서 진행을 해야하기 때문에 이와같은 고정된 파이플 라이닝을 준수해야하기때문에 이와같이 낭비되는 시간도 있지만 결국은 전체적으로 상당부분의 시간이 뒤따르는 명령어의 실행시간과 겹쳐져서 결국 드러나는 시간은 훨씬 짧게 나타난다.
++싱글 사이클, 멀티 사이클, 파이플라인 잘 비교할수있어야 한다.(시험)++
자 그러면 지금 파이플라이닝 state가 5개로 되어있다. 이것을 우리가 5 stage, 파이플라인 아키텍 방금 봤던것처럼 instruction fetch부터 해서 write back 까지 근데 명령어 전체 개수, 처리해야할 명령어의 개수가N개야 그러면 toal clock 사이클의 클락으로 저 n개의 명령어를 처리하는데 드는 total clock은 몇 clock인가? n+4 다. 
우리가 앞에 9페이지 그림을 봐보면,
## Why Pipeline? For Performance!
자 한명령어가 쭉 실행되는 시간을 같다고 볼 수 있지만 일단 명령어가 쭉 들어가서 파이플라인 stage에 거의 다 차면 4cycle 까지 가면 파이플라인 stage를 다 채운것이다. 그다음에 바로 명령어가 바로 끝난다. 그러고 나서 바로 다음 cycle의 그다음의 명령어가 끝나고 나오고 한 cycle 지나면 계속해서 다음 잇다르는 명령이 완료되서 나오도록 되어있다. 처음 요시간만 기다리면 그다음부터는 한 clock마다 계속해서 명령어 하나씩이 나오게 된다. 그러니까 파이플라이닝을 채우는시간 그다음에 그다음부터는 한 clock마다 명령어 하나씩이 완료되기 때문에 ++파이플라이닝 을 채우는시간 5stage 에서 마지막 하나를 제외하고 파이플라이닝을 다 채우는시간은 4 clock이다. 그리고 그다음부터는 매사이클마다 명령어가 한개씩 실행되서 나오기 때문에 토탈 클락은 n+4 클락이다. 이것을 일반화시키면 예를 들어서 이게 5 stage가 아니가 k -stage다 어떻게 할꺼냐 (k-1)+n clock이 걸린다 라고 말할 수 있겠다. 자 그러면, 우리가 앞에서 봤던 그 데이터 패스를 파이플라인 데이터 패스로 계산하기 위해서 어떻게 이것을 고쳐야 하는가?
오히려 우리가 처음봤던 싱글 사이클 데이터 패스에 더 가깝다. 전체적인 어떤것이 싱글 사이클 데이터패스에는 중간중간 add가 나타났다. 멀티사이클에서는 이게 없어졌다. 그렇다. 멀티사이클에서는 이런 add가 중간에 alu 하나가 이런 add가 필요한 연산에서 이 alu를 계속해서 반복사용했다. 그게 멀티사이클의 장점이기도 한다. 한 장치가 서로 다른 물론, 사이클 겹치지 않아야 겠지만 겹치지 않는다면 재사용될수있다. 다른목적으로 
어쨋든 파이플라이닝에서는 그렇게 되지 않고 파이플라이닝 에서는 여기서부터 시작되서 여기로 흘러가는 흐름이기 때문에 저 뒤에있는 alu를 여기서 미리 재활용할 수 없다. 그대신에 여기서는 어떤 구조가 필요하냐면, 
## MIPS Pipeline Datapath Modifications
상상을 해보자! 파이플라인이 다 찼다. 파이플라인이 다 찼는데 그때 여기에서 하는 작업하고 여기에서 하는 작업 하고는 같은 명령어를 하는게 아니다. 바꿔 말하면 각 단계에서는 다른 명령어에 다른 단계를 수행하고 있는것 아까 세탁물로 따지면 여기서는 서로 다른 사람들의 해당하는 작업들을 한다. 여기는 d라는 사람에 세탁을 하는것이고 여기는 c라는 사람에 건조를 하는것이고 여기는 b라는 사람에 수납을 하는것이다. 이런식이 되는것이다. 그래서 그러면 뭐가 필요하냐? 여기서 했던 a라는 사람에 초기작업결과를 그다음 작업들에게 계속 넘겨주기 위해서는 그 계산 결과를 여기다가 저장하는  레지스터 필요하다. 일종에 이것을 우리가 ++ state register++ 라고 한다. 여기다 이름을 붙이는데 state register가 단계와 단계 사이에 다 필요하다. 다음 슬라이드 보면 이것을 요 state가 요 state, 이 state register는 여기서 출력되는 모든 값들을 저장할 수 있는 정보들의 공간이다. 여기는 instruction fetch와 instruction decode 사이에 있는 state register란 말이고 얘는 instruction decode과 execution 사이에있는 state register 라는것이고 애는 execution과 memory stage 사이에 있는 register이고 애는 memory stage와 write back 사이에 있는 state register이다. 길이가 조금씩 다르다. 어떤것은 비교적 명령어하고 여기에 뭐를 저장할까 pc+4를 계산한 결과 이런거 여기는 여기서 나온 register 값들 하고 요기서 immediate 나온 값을 32bit로 확장한 immed 값 같은 것들을 저장한다. 그러면, 여기서 instruction fetch를 해서 instruction에 대한 정보를 넣으면 그다음 stage에서는 여기서 읽어서 instruction decode를 한다. 여기서 읽어서 instruction을 decode를 하니까 애는 자유로워 진다. 얘는 또 다음 명령어의 instruction을 바로 가져올수있다. 얘의 역할은 ++ 이 전 뒤따르는 이 다음 명령어의 작업과 내작업간을 분리시켜주는 역할을 한다. 이 state register가 ++ 자 그다음에 또하나가 있다. 지금 여기 단계에 가면 우리가 명령어 해석해서 이 각각의 장치에 전달해야될 제어신호들을 여기서 결정할수가 있다. 제어신호들을 결정할 수 있는데

## MIPS Pipeline Control Path Modifications
중요한것은 뭐냐면 이때 해석한 이 제어신호라는것은 이 제어신호는 누구를 위한 제어신호냐면 이 단계에 명령어를 위한 제어신호다. 이 명령어가 그다음에 가면 결국 얘가 그때만들어냈던 제어신호들을 계속해서 가지고 가면서 끝까지 처리해줘야 한다. 그래서 요 제어신호들도 따라온다. 여기다가 썼다가 여기서 또 제어신호 기록된것중에서 일부 가져다 쓰고 그다음에 또 그것을 카피해서 가져가면서 각각의 stage에서 내 명령어, 명령어가 가는것이고 내가 지금 명령어 하나이다. 그래서 여기와가지고 아 나를 처리하는데 이런 제어신호가 필요해 그래서 해석해냈음 그래서 여기 가가지고 내가 아까 이런 제어신호 필요했지 거기서 쉬고(쓰고..?) 그다음에 여기와서 내 제어신호에 이런것들이 있지 그래서 여기에서 구성된 제어신호를 쭉 가져가면서 계속해서 여기에 해당하는 장치에다가 전달하면서 가야된다. 그래서 제어신호를 위한 저장공간이 필요하다. 그런데, 보면 이 제어신호를 위한 저장공간은 요 부분은 우리가 단계로 볼때 fetch, decode 까지는 별도의 제어신호가 필요가없다. 이것은 fetch와 decode에서 필요한 제어신호는 명령어마다 다르지 않고 모든 명령어에 공통적이다. 이것은 명령어하고 상관없이 여기에 들어가는 제어신호는 공통적으로 전달해낼 수 있고 명령어마다 달라지는 제어신호는 execution 단계, 3번단계에서부터 명령어가 달라진다. 그래서 여기다 제어신호를 넣는데 사실은 이 제어 신호는 요 위의 제어신호는 뭐냐면 execution 단계의 제어신호이고 그다음에 여기에 제어신호가 memory access 단계 제어신호이고 여기가 write back 단계의 제어신호다. 요렇게 만들어놓고 그담에 여기에는 무슨단계지, execution 단계지 이 execution 단계를 처리하기 위한 제어신호는 어느 part냐면, 이중에서 execution 단계제어신호가 여기를 control 하는데 쓰인다. 그렇게 해서 여기서 저 execution 단계에 제어신호를 썼으면 써가지고 여기에 필요한 연산을 했다. 그다음에 단계로 가는데는 요 값까지 같이 가져갈 필요가 있냐없냐 없다. 왜냐하면 이신호는 여기서 이미 써서 뒤에서 쓸필요가 없다. 이값은 여기서 쓰고 버리고 나머지만 가져간다. 우리는 mem, wb만 가져간다. 마찬가지다. 여기가 메모리 access 단계다. 여기에서는 memory access 단계에 필요한 신호를 여기다 쓰고 버리고 남은 다음 단계 wb신호만 가지고 다음 단계로간다. 여기서 control signal이 있고 밑에 data register 가 있다. state register 있고

## MIPS Pipeline Control Path Modifications
여기서 지금 이렇게 되면 아까 말했던 것처럼 instruction이 쭉 채워지면서 instruction 파이플라인이 다 차면 그다음부터 매사이클마다 명령어가 하나씩 완료되서 나온다. 그래서 결국은 파이플라이닝이 이상적으로 다차면 처음에 요 latency + 모든 명령어는 한 사이클마다 이렇게 끝나서 나오기 때문에 마치 현상적으로 보면 모든 명령어의 cpi가 1인것처럼 보인다. 그렇다. cpi가 한 사이클 마다 명령어가 끝나고 나오니까 물론 요앞에 요값이 앞에 더해져야 한다. 각각의 명령어의 cpi + (instruction당 cycle 수 + 한번 명령어를 다 수행하는 걸리는 시간=lateny+ 각 명령어마다 cpi)
하지만, 우리가 명령어가 이렇게 10 개면은 앞에 4라는 값이 의미가 크지만, 우리가 처리하는 명령어가 수십만개 수백만개 이렇게 될때에는 앞에 4라는 값은 미미한 값이다. 저기서 (k-1)+n이라고 할때 저 n값이 수십만, 수백만, 수천만이 되면은 앞에 있는 k-1은 생각안해도 되는 버려도 되는 값이다. 무시할만한 값이다. 
## Why Pipeline? For Performance
파이플라이닝을 할때 몇가지 장애 요소가 있다. 이것을 파이플라인 해저드 

## Can Pipelining Get Us Into Trouble?
파이플라인 장애요소라고도 한다. 크게 3개의 장애요소가 있다. 
1. 구조적인장애
이것은 어느 한순간에 보면 파이플라이닝 지나가는데 보면 한순간에 한 시점에 몇개의 명령어가 동시에 실행되고 있는 셈인가? 지금 stage가 5개라면 5개의 서로 다른 명령어가 동시에 실행되고 있는 셈이다. 그렇다. 그러면 그때에 서로 다른 명령어가 만약에 access하는 자원이 같은곳을 access한다면 예를들면 메모리 a라는 명령어와 뒤따르는 c라는 명령어가 같은 메모리에 자원을 access 한다던지 같은 register에 access한다던지 그러면 충돌이 일어난다. 그렇다. 그런것을 스트럭쳐 해저드 라고한다. 서로 다른 명령어가 같은 자원에 접근하는경우 이것은 하드웨어적으로 해결하면 비교적 쉽다. 
2. 데이터 해저드, 값이 준비되기전에 그 값을 사용할려고 하는경우 우리가 이제 뒤에 read after write 해저드 라는것을 볼텐데 우리가 아까는 프로그래머가 그냥 임의로 나열한것을 순서 의미가 없을때 바꿀 수 있었다. 그런데 이런것은 바꿀수없다. 예를들어 a=b+c, d=a+c 이둘은 순서를 바꾸면 안된다. 왜냐하면, 여기에있는 a값의 결과가 들어가고 나서 그 다음 문장에서 그값을 가져다가 쓴다는 게 핵심이다. 여기서 값을 쓰고 여기서 값을 읽는관계가 순서가 지켜져야 한다. 그래야 이 프로그램이 정확한것이다. 그렇다. 이것을 뭐라하냐면 read after write 다. wrtie가 있은 다음에 read 가 일어나야하는 상황으로 본다. 파이플라이닝을 하면 어떤일이 일어나느냐 파이플라이닝은 앞의 명령어도 파이플라이닝에 들어가서 막 a를 계산하는과정에 있는데 뒤따르는 명령어가 파이플라이닝을 따라 들어가면서 여기서 아직 완료되지 않은 이값을 뒤따르는 명령어가 일찍 읽어갈려고 시도하는 그런 일이 발생할 수 있다. 앞에서 이값이 완전히 준비가 안됬는데 뒤따르는 명령어가 a값을 읽어갈려고 시도할때 이것을 우리가 데이터 해저드 라고 한다. 또하나 
3. 컨트롤 해저드, 우리말로는 제어 프로그램 제어, 또는 프로그램에 분기제어, 분기제어 해저드 라고한다. 자! 파이플라이닝에서 계속해서 들어가는 명령어들은 어떤 명령어가 계속 해서 들어갈까 파이플라이닝에 들어가는 명령어는 어떤 명령어가 들어갈까 메모리 instruction이 쭉있는데 메모리상에 그럼 무조건 그 바로 뒤따라있는 메모리상에 바로 뒤따라있는 명령어가 파이플라이닝에 쭉 들어간다. 그런데 이게 언제 문제가 되냐면, 분기할때 문제가 된다. 우리가 프로그램을 메모리에 있는 순서대로차례로 실행만 한다면 파이플라이닝이 문제가 되지 않는데 가끔, branch가 나타나면 브랜치는 어떤 조건이 만족하면 전혀 다른 주소로 점프한다. 물론 만족하지 않으면 그다음 명령어지만 그렇다. 그런데 바로 다음 명령어로 브랜치해서 분기해야하는데 이미 뒤에서 브랜치 다음의 명령어들이 내차례인가 하고 파이플라이닝에 쭉 들어온경우 이런상황 이것을 컨트롤 해저드 라고 한다. 이런것도 일종에 우리가 해결해야할 문제다. 그래서, 우리가 파이플라이닝 컨트롤이라는건 데이터 패스 컨트롤 멀티사이클이나 싱글사이클 데이터 패스 컨트롤하고 또 다른 측면이 있는데 이와 같은 해저드 파이플라이닝 상에서 나타나는 어떤 장애요소를 찾아야 하고 탐지해서 그것을 적절하게 해결할 수 있는 action을 취해줘야 하는것이 파이플라이닝에 중요한 역할 중에 하나다. 그안에서 control에 

## A Single Memory Would Be a Structural Hazard
이런게 이제, 스트럭쳐 해저드의 대표적인 예이다. 명령어가 이렇게 진행되고 있다.
이순간에 보면 load 도 메모리를 access한다. 왜? 여기서 데이터를 읽어야 한다. 
inst3 에서도 메모리 access한다. 이게 무슨 step 인데? instruction fetch인데 
다 메모리에 있다. 동시에 얘도 메모리 access하고 얘도 메모리 access하면 같은시간에 그래서 충돌이 난다. 이런경우는 하드웨어로 추가해서 넣으면 해결이 된다. 명령어를 읽어오는 메모리하고 instruction을 읽어오는 메모리를 분리시켜버리자. 그러면 같은 메모리를 충돌할리가 없다.!
이런경우라든지 조금더 기술적으로 레지스터같은경우 여기서 요시간을 보면 시간이 흘러가는것이다. (한번 흘러간 시간은 되돌릴순없다.) 기억해야한다. clock cycle 0 -> clock cycle 1 -> 2..이런식으로 시간은 쭉 흘러가는데 여기서도 지금 레지스터에서 충돌이 난다. 이 첫번째 명령어가 여기서 register에 쓴다. wb을 하지. 뒤따르는 명령어가 여기서 register에서 값을 읽어. 요순간에는 두개의 명령어가 레지스터에 접근하는것이다. 얘는 쓰고 얘는 읽는것이다. 이것은 한편으로는 다행이다. 둘다 쓸려고하면 해결이 안된다. 얘는 쓰고 얘는 읽는다. 이런것을 보통 어떻게 해결하냐면 한 클락 사이클은 전반부 후반부로 나눠진다. 클락 사이클이 up, down 이렇게 되는데 그래서 전반부에 write를 하게 하고 후반부에 read하게 하도록 하게 해서 요것을 해결했다. 

## How About Register File Access?
그래서 저 빨간부분이 write다. 녹색부분이 read다. clock cycle은 이렇게 다운 업 다운 업으로 edge가 나타난다. clock cycle이 down이 되는 지점에서 값을 읽도록 clock cycle이 up되는 지점에서 반대다.
clock cycle이 down되는 지점에서 값을 읽어내도록 하고 clock cycle이 up되는 지점에서 값을 쓰도록 한다. 그렇게하면 요 stage에서 충돌이 일어나도 wrtie& read가 서로 비켜갈수가 있다. 데이터 해저드, 

## Register Usage Can Cause Data Hazards
이런것이다. 첫번째 명령어는 addr , 레지스터 1번에 쓴다. 뒷따르는 명령어들을 보면 그값들을 읽는것이다. 얘도 읽는 명령어다. 지금 여기에 빨간색으로 되어있는게 서로 충돌관계에있는, 해저드 관계에 나타나는 현상들을 빨간색으로 표현하고 있고 녹색은 해저드 관계로부터 벗어나있는 안전한 상태를 녹색으로 표시했다. 왜그러냐면, 왜 문제가 될까?
요기에 계산을 해서 그값이 요기에 1번 register 에 완전히 쓰이는 시간은 언제야? 여기에서 완전히 쓰인다. (5단계를 의미하는듯..)
그렇다. 시간으로 따지면 0, 1, 2, 3, 4
clock cycle 4에서 완전히 쓰인다.
자 그런데, 뒤따르는 명령어에서 1번 레지스터를 읽는것이다. 읽는건 어느단계에서 읽냐? 여기에서 읽는다. 쓰이는 결과는 두 클락 뒤에서 값이 쓰이는데 읽는건 훨씬 먼저 읽는다. 여기서 읽었다면 읽는것을 허용했다면 프로그램의 결과는 부정확하다. 왜냐하면, 이때의 읽은 달러 1은 앞에서만든 달러 1이 아니고 그 전에 있던 달러1의 값을 읽어 가도록 하는것이다. 그렇다. 그래서 이렇게 되는것이다. 

여기서 write가 되야하는 값이 여기서 읽혀지는데 시간은 거슬러 갈수없다. 여기서 만든것을 두클락전으로 되돌릴수는 없는것이다. 타임머신도 아니고. 마찬가지다. 여기서 만들어졌는데 그 뒤뒤 명령어도 마찬가지로 여기서 그값을 읽고있는데 한 클락 전에 되돌릴 수 없다. 다만, 그 뒤에오는 명령어들은 같은 사이클이 겹치더라도 write & read의 관계이기때문에 값을 정상적으로 가질 수 있고 그 뒤는 말할것도 없다. 문제가 없다.
이런것이다. 이런것이 data 해저드 라고 한다. 그리고 앞에서 앞에 슬라이드 read after write 해저드라고 한다. write 뒤에 read가 있는데 그게 이게 wrtie data가 다 완료가 안됬는데 값을 읽을려고 하는 시도. read after write 해저드 라고 한다. (read before write 해저드가 아닌가..) ppt에서는 raw 해저드라고 소개되어 있음.
어떻게 해결하냐? load 도 마찬가지다. load 

## Load-use Data Hazards
load 해서 데이터에 넣는다. 그렇다. 그뒤에 레지스터 값들을 가지고 온다. 마찬가지다. 여기도 달러1 값이 레지스터에 들어가는것은 여기다. 마찬가지로 뒤따르는것들은 훨씬 앞서서 값을 읽어가려고해 그렇다. 이걸 우리가 load-use Data Hazards 라고 한다. 일종에 이것도 raw 해저드 하고 비슷하다. 

## Solutions to Data Hazard
이것을 해결하는 solution이 몇가지가 있는데 
가장 심플한 solution은 파이플라인에 뒤따르는 부분들을 잠시 멈추게 하는것이다. 따라오지 말고 너는 한 clock 쉬어! 아니면 두 clock 쉬어! 이렇게 쉬었다가 와 바로바로 뒤따라오지 말고 쉬었다가 와 이렇게 된다. 저만치 
뒤따라오면 안되 
한 두걸음 뒤에서 와 
그것을 stalling(freezing) the pipeline 이라고 한다. 예를들면 이것이다. 
아까 뒤따르는 명령어가 여기서 시작했지, 하지마 가져오지마 한번 안가져오면 계속해서 그 slot을 stall, bubble 이라고 하는데 이런게 들어오면 계속해서 파이플라인에 계속해서 차 들어올것이다.
그다음에 명령어를 읽어올려고 했는데 안돼, 그다음에도 읽어오면 안돼 한번 더 쉬어 그리고 나서 두클락 쉬고나서 명령어가 들어와두 대! 이렇게 하는것을 stalling freezing 이라고 한다. 그러면 아까 이 관계에 있었던 그 현상이 두 클락 미뤄지니까 문제없다. 두클락 늦게 들어오면 이렇게 하면 문제는 ++ 두클락이 미뤄지면 결국에는 파이플라인의 효과가 이만큼 낮아진다. 파이플라인은 쭉쭉 차곡차곡 채워졌을때 파이플라인이 극대화 되는데 ++ 이런현상들이 많아져서 파이플라인에 stall이 많이 들어와있다. 그러면, 성능은 저하가 된다. 그래서 이것을 무식하게 stalling 할수는 없고 중간에 우리가 조금더 개선할 수있는 다른 logic 을 개선해 넣는데 그것을 우리가 internal forwading 내부전달, 또는 compuler scheduling 컴파일러가 지능적으로 명령어의 순서를 바꾸는 이런기법들을 이용해서 저와같은 문제점들을 성능저하 요소들을 조금 개선 하고 있다. 