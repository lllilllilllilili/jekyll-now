---
post : layout
title : 컴퓨터구조(기)5
---

## 온라인 퀴즈 6



(ㄱ)은 write back에서 나오는 ??? 담고있는데

write back은 결과를 레지스터에 넣음

레지스터에 넣는거니까 레지스터 어디?? 여기 regwrite 신호를 1로 할지 0으로 할지 결정하는 신호가 여기에 있을것이다.

그다음에 (ㄴ) 은 여기서나옴 이것은 뭐냐 메모리에서 나온 값이든지 계산의 결과든지 이게 register로 들어가는 값임 레지스터 결국 이게 어디로 가냐면 쭉해서 write data로 들어감 

그다음에 (ㄷ)은 여기서나오는 신호인데 이게 뭐냐? 뭐가 이쪽으로 계속 들어오고 있지?

여기에서 계산결과를 써야될 writeregister number 임

그거를 여기다가 그냥 그값을 여기다가 집어넣으면 안되는게 계속해서 뒤에서 명령어들이 들어오면서 여기를 새롭게 자기 번호로 업데이트해버림 그래서 결국은 여기서 write 를 해야될 것은 자기가 계속 가지고 가야됨

그러니까 wrtie register number를 계속해서 가지고 가서 그것을 어디로? (4)번으로 

그런다음에 (ㄹ)

이게 브랜치 명령어이고 두값이 같으면 그러면 어디 pc를 pc+4를 선택해서 넣을지 브랜치 타켓 어드레스를 선택해서 넣을지 그것을 제어 하는신호임 이게 여기에 (1)번임

그다음에 문제가 

프로그램 에서 클락 사이클 1에서 첫명령어의 패치를 시작한다고 가정한다.

클락 사이클 5에서 신호 A의 값은 

이거임 클락 사이클 5에서 

클락 사이클 5면, 5단계 고 

클락 사이클 5가 로드 명령어 

첫명령어가 Write back 되는

클락 사이클 거기서 뭐라하고 있냐면 

5에서 신호A의 값 

여기의 값 결국은 클락 사이클 5가 로드 명령어 write back 이니까 여기에서 방금 여기서 나온 값 메모리나온 값이 저쪽 레지스터 가도록 선택을 해야함

그렇다. A의 값은 뭘 선택을 해줘야하냐면 (1)번을 선택해야함 

그다음에 클락 사이클 (6)에서 (ㄷ)의 값 

(6)이면 이미 로드는 끝나고 나갔고 

(ㄷ)은 로드 다음 명령어가 무슨 명령어냐? 지금 명령어상으로 sub임 sub의 결과가 어디로 들어가냐? 11번 레지스터로 들어가도록 되어있음

11번 레지스터, 결과 레지스터 번호를 11번 , 11번 , 11번 가지고 오고 있는것임

(ㄷ)의 값은 11임

그다음 클락 사이클 (3)에서 (ㄷ)의 값 

(3)이면 여기가 fetch decode execution load가 execution 된 단계임 

거기서 (D)의 값 구해라

(D)의 값을 구해라 

(D)가 어딨어, 이거네 

Load가 execution 될때 여기할때 (D)의 값

지금 이거 어떻게 되냐? 이게 요게 저기 

요게 rt, rd 이렇게 됨

요게 rt, 요게 rd 그런데 여기서 지금 요 load 명령어가 execution 될떄 load의 목적지는 rt야 rd야? rt임 

rt rd 둘중에서 어떤게 write register number로 선택되어야 하냐면 

rt가 선택되어야 하니까 

destination을 0번을 선택해야함



로드 명령어가 execution된 단계가 여기임

그다음에 

프로그램이 1 이 완료되는데 걸리는 시간은 몇 사이클인가

프로그램 1 그게 없음 stall이 없음 stall 없으면 명령어의 개수 + 전체가 5stage이니까 5stage에서 1을 뺀 4 clock + 명령어의개수 그게 토탈 사이클임 

그게 9사이클임

그렇다.



그다음에 

(여기서중요)만약에 파이프라인 데이터패스에 포워딩 기능이 없다면 프로그램 1을 수행하는데 몇 클락이 걸릴까? 가정은 레지스터는 한 사이클 라이징 엣지 에서 write 폴링 엣지에서 read가 가능하다. 

반반 쓴다 얘기임

포워딩 기능이 없다함

포워딩 기능이 없으면 서로 데이터 해저드 가 발생했을 때 어떤 방법밖에 없냐? stall 방법 밖에 없음 

어디와 어디사이에 stall 이 발생하나? 일단 1,2 번 명령어 사이에 데이터 해저드 있음 

그러면 얘와 얘 사이에 적어도 몇사이클 stall 이냐? 2사이클 포워딩이 없으면 

그다음에 얘와 얘 사이에 있다. 얘와 얘사이에 2사이클 stall 필요함

그렇다. 그다음에 얘와 얘사이에 2cycle stall이 필요함

여기서 이렇게 2cycle 벌어지면 2cycle 벌어지면 그 뒤로는 밀리니까 걔하고는 상관이 없다. 그러면 둘둘둘 6사이클 늘어남 원래 정상적으로는 9사이클 끝나야 하는데 2cycle 2cycle 2cycle 중간에 stall 이 들어가서 15cycle이 됬다.



그다음에 만약에 포워딩 기능이 있다면 alu 결과가 메모리 읽기 결과를 alu 입력으로 전달할 수 있다면 몇클락이 걸릴까?

포워딩이 있다 alu에서 나온 결과 또는 메모리에서 읽은 결과를 alu에 input으로 돌려넣을 수 있다 그러면 일반적으로 stall 없이 다 해결할 수 있다. 다만, 뭐는 안되냐? load 의 경우에는 메모리에서 읽혀져야 하기 때문에 load에서 메모리에서 읽혀져야 하기때문에 한 stall은 불가피하다. 그러면



이 그림상에서보면 다른 건 다 괜찬은데 얘들관계만 한 stall이 필요함

그러면 원래 9개인데 하나의 stall이들어가니까 10 cycle만에 프로그램이 끝나도록 하고 있다.(lw가 하나 더 들어가는거임, 포워딩이 있다고 했으니까 프로그램은 정상적으로 돌아가고)



잘기억해두자

파이플라이닝 아주 단순한 에다.



## The Grand Example

데이터 해저드가 없음

lw $10, 20($1)

sub $11, $2, $3

and $12, $4, $5

or $13, $6, $7

add $14, $8, $9



하나씩 가는 예를 봄

첫번째 load 명령어 fetch함 

fetch 해서 가져오면 instruction이 여기에 저장되어

여기에는 state register 라고 했음

fetch 그다음에 하나더가면 이제 load 명령어가 decode가 이루어짐 

그러면서 뒤에 바로뒤에있는 명령어가 fetch 가 자연스럽게 일어남

이때 load 명령어를 control 해서 해석해가지고 거기에 필요한 모든 제어신호를 다 해냄

지금 어떤 제어신호들이 필요할까 한번 보자

execution에서 필요한 제어신호들은 뭘까? 

execution에서 어떤 제어를 해야하나? 이거한번 보고 그다음에 memory access에서 어떤 제어를 해야하나 그거를 보자 

그림이 좀 희미하지만 execution에서 해야할 일은 alu op 제어를 해야함 그다음에 또 뭐해야하나? 거기 이름이 alu source를 제어해야함 그아래쪽에 

그다음에 하나더 뭐냐면 execution에서 제어해야하는거 regdst를 제어해야함 

하나하나씩 찾아보셈



그다음에 그러면 그 거기에 지금 여기보면 여기 4bit 가 나오고 있는데 4bit를 execution 단계에서 차례대로 0001 차례로 부여하는걸로 이 bit값을 이해하면됨

자 그다음에 어 메모리 access 단계에서는 뭐뭐가 필요하냐면 메모리 access 단계에서는 멤write 멤read 두값을 어떻게 할꺼냐 하나는 또 뭐냐 하나는 이게 branch 명령이냐 아니냐 그걸 지그 ㅁ여기 3신호가 나오도록 되어있다. 



write back에서는 하나는 아까 봤던것처럼 regwrite 신호가 나와야 하고 하나는 뭐가 나와야해? 하나는 memtoReg 하나는 저쪽에 regdst 여기에 레지스터에 쓸수있게 할것인가 이것을 제어하고 하나는 메모리 에서 나온값을 레지스터 보낼것인가 alu에서 나온값을 레지스터로 보낼것인가를 결정하는 신호다.



그럼 무슨얘기냐면, 어차피 load명령어가 얘들의 다 질나것임 지날때 그때 로드 명령어가 정상적으로 실행되기 위해서 필요한 그 제어파트들이 있음 그값을 여기서 미리다 계산하는거임 

여기서 그리고 그다음단계에서는 exectuion 단계에서 정의된 값만 일단 써서 execution을 해 그리고 그다음 단계로와 그다음 단계는 메모리 access단계임 그러면 메모리 access단계 

그 로드 명령어의 메모리 access 단계 정의된 값을 가지고 메모리 access해 그리고 그다음 단계에서는 그 load 명령어의 wrtie back에서 정의된 이미 여기서 정의했지(아마도 control을의미하는듯) 

여기서 정의했던 것을 얘들이 가지고 감

메모리 엑서스도 여기서 정의된 값을 쭉 가지고 감 

그대신에 그단계에서 쓴 값은 그다음 단계로 가지고 갈 필요가 없으니까 버리고 간다.



가령, 짐을 3개 메고 가다가 맨 위에것을 가지고 이렇게 여기서 작업하고 여기서 버리고 두개만 메고 그 다음 단계만 가고 이렇게함

그러면 우리가 여기서 나와야할 값을 어떻게 결정할 수 있느냐? 이명령어가 이단계 이단계에서 이 명령어가 정상적으로 돌려면 어떤 신호가 나와야 되나? 그거를 따져보면됨(중요)



그래서 그 다음 맞아요?? 맞음



물론 맨위에 11은 어차피 여기서 write back에가서 load가 쓸 명령어긴 하지만 11 이 저 11 나와야 load가 나와야 잘 동작하나 한번 확인해보면됨 

여기서 11이될꺼아니야 그러면 여기서 1이면 메모리에서 나온값이 선택될것이고 

그다음에 위에 1은 여기서 1이 들어가니까 레지스터에 write가 될것이고 

확인해보자 (확인완료 이상없음)



자, 그래서 여기에 디코드 단계에서는 신호가 나와있는 상태임

그다음으로 사이클이 바뀌면 여기에 있던값이 여기 레지스터에 찰칵하고 들어감 그다음에 어떻게 되냐 이렇게 됨 



이떄 이값은 load 명령에 필요한 제어신호들이고 자

이때 control에서 나오는 이값은 뭐냐면 바로 뒤에오는 저 sub 명령어 을 처리하기 위해서 필요한 신호들이 지금 해석이되서 나오고 있음

sub 명령어



그러면 execution 단계에서는 x에 해당하는 신호선을 가지고 execution이 일어남

x 신호가지고 load가 잘 동작하나 x신호의 0001이 나오고 있는데 맨위에 0은 reg dst 여기에 오는값인데 이게 중요한게 지금 이 load에 destination은 10번이지 

load 의 결과가 적혀져 있는 register number는 10번임

10번이라는 값은 여기 명령어의 일부로 포함되서 지금 쭉 오고있음 근데 여기에서 얘기했지만 이게 지금 rt 이고 그렇지 rd값이고 

rt, rd값이 오고있음 load 명령어는 rt값이 레지스터 번호임 write 번호임 

rt에 해당되는 값이 이쪽으로 register write number 로 전달되도록 여기서 선택을 해줌 

그러니까 regdst가 0번을 선택하니까 10번이 선택되서 write register number로 계속 저장이되서 전달이됨



계속 왜그런지 확인해야함 그다음에 00은 사실은 외울필요는 없지만 의미상으로는 뭔가

00이 aluoperation에 00이 들어가면 의미상으로 뭐냐? add임 왜? 주소값 구하라는 더하기 연산을 하라는 add임 00이 



미리 말하지만 여기지금 여기는 10이 나오는데 1100인데(이전명령어값) alu operation 에 해당하는것은 10임 그렇다 뒤따르는 10은 뭐냐? op dependent임 그거는 operation에 따라서 function code에 따라서 달라진다. 그 의미임 

그다음에 여기 0 00 1은 뭐지?

1은 뭐지 여기를 선택함 

뭐야? 여기 지금 하위 16비트 가 들어가는 sign extension을 해가지고 여기에 값이 들어올꺼 아니야 그치 그값이 load 주소에 offset에 해당되는 값임



그 값이 여기에 alu에 한 소스로 들어가도록 할려면 1번을 선택해야함 



자 뒤 명령어 sub 명령어의 제어신호가 저렇게 나왔고 다음 한사이클 이 진행되면 

어떻게 되냐, load는 하나 더갔고 load는 자기신호를 가지고 앞으로 하나더 진행했고 뒤따르던 sub은 자기가 여기서 control 신호를 가지고 여기에 딱 들어와가지고 execution을 해달라 

그다음에 뒤따르는 and는 여기서이제 deconding을 해가지고  여기에 and에 해당되는 신호가 준비되서 나오고 있음

이게 아직 여기에 들어가지 않았음 클락 사이클이 바껴야 여기에 찰칵하고 들어감



그 신호가 맞나, 2분줄게 확인해서 봐바!

이 예만 소화해도 파이플라인에 60% 이상은 충분히 소화해낸거임 

이시간 끝난 뒤에도 이 예를 반복하면 좋을거 같음



여기 헷갈리면 뭐야 여기가 rt, rd  이렇게 심볼을 적어놓자 

rs는 여기에 바로 들어감 

클락 사이클 5면 load가 비로소 완료되는 단계 임

그래서 자기가 load는 자기 결과가 써야될 기록되어야할 wrtie register 가 10번이라고 저장을 해서 계속 왔음 근데 여기서는 11번이라고 나와 

11번은 sub명령어의 destination이 11이기떄문에 11을 갖고 감

그리고 여기서는 뭐하는거냐 and 명령어의 destination이 어디가되야하나? 그거를 지금 판단하고 있음 

12번이 선택이 되도록 regdst가 1번으로 들어가야함 

그다음에 이제 하나 지나가면 load는 파이프라인에서 나가고 그다음에 이제 여기는 명령어가 없음

그러니까 아무것도 없는 블랭크 = 노 오퍼레이션이 이렇게 들어간다 아무것도 없으니까

아우일도 안한다.



하지만 앞의 명령어들이 진행되어야 하기때문에 사이클은 진행되어야함 이렇게

다음에 여기에 이재 9번임

9번 사이클 이면 끝남

맨 마지막 명령어가 끝나는 단계고 그뒤는 다 비어있음

질문!



# Computer Architecture

이것은 어 데이터해저드, 컨트롤해저드, 이런것들은 이제 파이프라이닝 컨트롤 을 통해서 해결을 해야하는데 그걸 해결하기 위해서 추가되는 logic

살펴볼려함

데이터 해저드에 다시 한번 보자.

클락 사이클이 지나가면서 실제 결과는 여기서 만들어지는데 이게 필요한상황이 앞선 상황에서 필요하기때문에 시간을 거슬러서 보내주지 못하니까 방법은 얘를 아예 미루던지 뒤로 아니면 이 결과가 사실은 alu에서 나오니까 

alu 나온 결과값을 그 다음 여기에 인풋으로 넣어주던지 그것을 포워딩이라고 함 

이게 포워딩을 위한 회로임



## Forwarding Logic

뭐가? 여기 포워딩을 판단하는 로직이 들어가있고

일단 각자 상상을 해보자

어떻게 해서 이런 상황이 만들어질까



이게 저기 흑백으로 프린트한 사람은 색깔이 안보이겠지만

녹색은 머고

빨간색은 먼가

같은 레지스터 넘버가 중복하게 들어가는데

같은 값을 하나를 중복해서 전개를 했는데

이해를 돕기 위해서 rt 두개를 반복해서 쓴거임 

똑같은 rt 값임 

어떤 상황이냐면

지금 우리가 해저드 발생하는건 앞선 명령어의 write 

그러니까 그 destination register number하고 

뒤따르는 명령어의 소스하고 

소스는 둘임 rs일수록 일고 rt일수도있음

소스는

어느 것, 하고 그렇게 같은 번호를 쓰면 해저드가 발생함

해저드 발생하는건데 우리가이제 포워딩을 하는데

포워딩이 두가지 케이스가 있음 어디서

하나는 어디서 어디로 포워딩 하느거냐면 

exectuion 단계에서 나온 결과를 바로 뒤로 보내주는 경우가 있고

하나는 memory access 단계 에서 나온 결과를 뒤로 보내주는경우가 있음

예를들면 바로 뒤따라옴 명령어가 

바로 뒤따라오면 execution 단계에서 나온 결과를 그냥 바로 돌려보내주면 되는데 

하나 건너서 뒤따라와 

그럴 수있음 해저드 관계에 있는데 바로뒤가 아니고 하나 건너 뒤야 그러면 

그래도 여전히 해저드 관계에 있음 두 사이클 이내에 들어오는 명령어 사이에 

레지스터 넘버가 겹치면 그건 해저드 관계에 있음

바로뒤가 아니고 하나 건너서 뒤따라 오면 

실제로 그 하나건너 뒤따라오는 명령어는 decode가 여기에 있고  그다음에 

뭐야, 앞에 앞에서 지금 여기를 access 하고 있지 여기를 처리하고 있을거라고 

두관계가 그러면 

어떻게 여기에서 나온 결과를 여기에 

얘가 원하는 레지스터에 인풋으로 집어넣어줘야함

그래서 두가지 케이스가 있었음

포워딩이



앞에 한번 볼까!!! 

포워딩 



예를들면 지금 앞에 add 명령어가 있고

5번에다가 쓴다고 하자.

그다음에 여기무슨 sub 명령어가 있는데 얘는 

얘는 얘하고 dependency가 없음



add $5, ...

sub .... $5

or $10, $5, $7



그뒤에 다시 or 명령어가 있는데 몇번에다 쓰는지 모르겠는데

예를 들면 10번에다가 쓰는데 5번 하나 되있고 7번 되있고

5번이 나타남 여기에 5번이 나타남

하나 건너 있지만 

하나 중간에 명령어가 들어있지만

이명령어와 이명령어는 해저드 관계에 있음

해저드 관계에 있음

만약에 여기에 지금 얘가 5번 읽는다고 합시다. 

얘하고 얘도 해저드 관계가 있음 

근데 좀 상황이 다름 어떻게 되냐면 

얘와 얘는 포워딩을 하는데 언제 포워딩을 해줄 수 있느냐, 얘가 execution 단계를 지나면 결과가 나오지 

그렇다. 그러면 그떄 이값을 전달해줄 수 있음 

근데 그떄 얘는 exectuion 단계 얘는 무슨단계? 얘는 decode 단계있고

얘는 무슨단계에 있어 instruction fetch 단계에 있음

근데 값이 실제로 필요한 단계는 어떤 단계에서 그값이 전달이 되어야 하냐? 

execution단계에서 전달이 되어야 함

얘가 줄수있어도 그 얘는 얘한테 값은 줄 수있자만 그땐 오히려 얘가 받을 준비가 안되어있음 

얘가 execution 단계에 들어가야지만이 받을준비가 되는데 

얘가 exectuion 단계에 들어갈려면 몇사이클 더 뒤로 가야하나?

fetch -> decode -> execution 두사이클 뒤에 가야지 그렇다.

두사이클 뒤에 가야함 그래야 얘가 execution 단계에 있는거 아니야 

그러면 얘는 어떤 단계에 가있냐면 메모리access 단계에서 그것을 끝낸 결과로 나옴

메모리 access에서 나온 값이 여기로 들어감 (멤단계에서) - 녹색인듯?

<핵심>

포워딩이 바로 exectuion 이 끝나고 나서 포워딩이 될수도 있고 

그다음에 하나더 가서멤단계에서 하나건너 뒤따라오는 놈한테 전달할 수도 있고 

두가지 예로 포워딩이 발생할 수 있기때문에

우리가 회로에서 그 두가지를 다 고려를 해줘야함



그래서 이게 그러임



## Forwarding Logic 본격

자, 어 

이게 뭐 선이 막왔다갔다함

자 이거는 뭐냐면 

instruction fetch -> decode 단계에서 지금 rs, rt, rd 번호를 쭉 해석해서 갖고 나오고 있다. 그 번호하고 여기서 지금 막execution 을 진행했는데 그때 execution/mem 단계에 레지스터 rd 라는거는 목적지 레지스터 임 값이 쓰일 그 번호하고 

여기서 나온 rs나 rt 둘중 하나하고 겹치면 해저드 관계가 발생함(중요)

그러면은 어떻게 여기서 그 두값을 보고 아!

해저드 관계가 발생했구나 그러면은 여기 들어간 각각의 값을 여기 나와있는 이미 준비된값으로 전달해줘야지 그렇게 하고 여기서 전달하는 회로를 이안에 가지고 있는게 포워딩임 

그러면 어떻게 되 

예를들면 rs하고 rd하고 겹친다 그러면 어떻게 rs가 들어가야하는곳에 rd 값을 보내주면되지

또는 rt하고 rd하고 겹친다 그러면 여기에서 나온값을 rt로 보내주면 됨 

일단 그러면은 로직은 머냐면

이것임 

여기에 x 해저드 라는게 뭐냐면 바로 한 칸 



## Forwarding Conditions

바로 EX해저드 라는게 뭐냐면 바로 한칸 뒤에 따라오는 명령어와에 해저드 관계를 말하고 있음

그래서 보면은

if(EX/MEM.RegWrite and )

EX/MEM 이 뭐냐면 지금 단계와 단계사이에 status register가 있다고 했음 

그거에 이름을 이렇게 붙임 

execution 단계와 mem 단계 사이에 있는 register 거기에 regwrite , register rd number 이런것들이 다 기록되어있음 

그래서 exe/mem 단계 regwrite 그러니까 앞선 명령어가 지금 register 쓰는 명령어이고 그 앞선 명령어가 지금 레지스터에 rd가 0이 아니면 이 무슨말이냐? 0에다가 쓸수있어 없어? 0번 레지스터는 항상 컨시턴트 0이라고 했으니까 쓸수없음 이건 체크하는거임 

그리고 그레지스터 넘버가 뭐하고 같으면 저 앞쪽에 바로앞에 뒤따라오는거지(ID/EX) 그명령어에 ID/EX.RegisterRs 하고 같으면 그럼 뭘 넣어야대? 여기서 나온 rd값을 rs로 돌려넣어줘야대 

그러니까 포워드 A에다가 10을 집어넣어라 포워드 A는 

포워드 A는 여기지금 먹스가 만들어져있는데 이거 먹스에다가 지금 신호선을 넣는데 추가되는 신호선임 

포워드 A, 밑에는 포워드 B 임

원래는 여기에 ALUsrc 라는 이름으로 있었는데 지금 포워딩이 들어가면서 먹스가 확장되면서 먹스이름이 제어선 이름이 바꼇음 포워드 A, 포워드 B로 바뀜 

그러면 지금 여기서 쉽게 얘기하면 

앞선 명령어의 rd하고 뒷따르는 명령어의 rs하고 만약에 쫑나면 겹치면 rs대신에 앞선명령어의 지금 결과 rd 결과 그거를 돌려 넣어줄 수있도록 제어신호를 포워드A를 10으로 선택을 해줘라

포워드 A가 10으로 선택되면 여기 선택됨

그렇다.

여기 선택되면 녹색값은 어디서 오는건지 잘보셈

녹색값은 어디서 오는거야 여기서 계산 결과가 오는거네 

이 계산 결과가 여기로 들어감 그렇다.

계산 결과가 방금 이 앞선 명령어의 연산결과 인건고 그게 레지스터에 지금 담길것지 rd에 



그다음에 만약에 앞선 명령어 역시 Register writer가 있겠고 레지스터넘버는 0이 아니고 

그 레지스터 rd 하고 앞선 명령어의 레지스터 번호하고 뒤따르는 명령어에 rt레지스터넘버하고 같으면 이번에는 포워드 B를 제어하는데 포워드 B에다 10을 넣어라 

포워드 B여기 있고 10을 넣어라 하고 있다.

그렇다. 여기지 

그럼 역시 마찬가지로 여기서 나온 계산 결과를 여기다가 아래쪽에 인풋으로 넣는다. 그렇다 원래는 rs rt 가 들어가야 하는 자린데 rs rt 레지스터 넘버 대신에 레지스터 값 대신에 여기에 나온 결과를 넣는것이다. 그치



그다음에 



##### MEM hazard 는 머야 

멤 해저드는 이명령어 하고 바로 뒤가 아니고 하나 더 뒤에서 이 간격으로 지금 뒤따라오는경우 그러면 이게 어떻게 되냐면 얘가 이렇게 가고 얘가 필요할떄 이렇게되지 

내손을 봐 앞선 명령어는 여기가 있어 그리고 필요하면 여기 와있고 하나 건너서 이럴때에서 해저드 관계에 있을 수있음 

그렇지 그럴때에는 어떻게 하라고?

이건 여러분이 지금 1분정도 보고 해석해보자 따라가봐 어떻게 하라고 했는지 

지금 이 맴 해저드는 어떤 선을 설명하고 있는거냐?

빨간선을 설명하고 있다.

똑같음

지금 맴 단계를 수행하고 있는데 맴단계에서 지금 레지스터 번호는 맴Write/back (wb) state register에 담겨있고 거기에 지금 수행하고 있는 명령어가 레지스터 쓰는 명령어이고 그때 그 쓰는 레지스터 넘버가 rd가 0이 아니고 그다음에 그 번호하고 앞에 앞에 있는 ID/EX 그 뒤에 뒤에서 따라오면서 수행되고 있는 명령어에 레지스터에 rs 하고 쫑이 나면 

데이터 해저드 관게에 있으니까 걔를 위해서 

지금 여기서 가지고 있는 값을 걔한테 포워드 (전달해줌) 그게 여기서 

방금 어디에 어떤걸 선택하는거지 포워드A 

자기가 여기서 write 해야 되는 값이 결국은 저쪽으로 해서 레지스터 write도 되겠지만 그전에 얘한테도 돌려주는것임(???) 만약에 rt하고 쫑이나면 포워드 B가 01을 선택하도록 해서 이값이 alu로 들어가는

그래서 이미 모든 값은 전달 경로가 만들어져있고 얘와 얘가 그 벨리유 컨트롤을 해가지고 어떤 값이 들어가도록 해야될지를 결정하는것임 이미(???) 포워딩 유닛을 말하는건가??

그러면 여기에 지금 00은 뭐냐 

00은 여기에 로직에 다 안나와있지만 포워드 A 포워드 B가 만일에 포워드 데이터해저드 관계가 아니면 포워드 A와 포워드 B가 각각 얼마를 출력해야 하냐면 00을 출력해야 함

00 입력하도록 해서 정상적으로 레지스터 에서 읽은 값이 ALU로 전달되도록 포워드가 아니고 그렇게 설계되어있음



그다음에 그러면 



## Forwarding Example



sub $2, $1, $3

and $4, $2, $5

or $4, $4, $2

add $9, $4, $2

지금 여기 load가없으니까 포워딩이 있으면 

포워딩이 제공한다면 stall은 없음

얘와 얘 

사실은 얘와 얘도 데이터 해저드 관계에 있는데 포워딩 에 의해서 해결이됨

얘와 얘는 해저드 관계에 있냐 없냐?사실은 해저드 관계에 있지 않다.

이게 데이터로는 종속성이 있지만 두사이클 너머에 있는 놈드은 뭐야

두사이클 너머에 있으면 이값이 레지스터 들어간 뒤에 얘가 읽는다고 

그러면 얘는 문제가 없음

전혀 문제가없음 해저드 관계에 있지 않아.

한번 따라가보자



## Forwarding Example

특히 여기를 잘봐 여기가 어떻게 되는지 여기 어떤 값이 들어오는지

여기에는 지금 번호가 들어옴 레지스터 번호들이 들어옴

따라가보자

언제 해저드 디텍트가 일어나나 어느 사이클에서 해저드 디텍션이 가능한가 

저 포워딩 유닛에서 해저드 디텍션이 언제 가능해

여기서는 모름

하나더 지나가봐야함

하나더 지나가니까 앞의 명령어의 id 2번인데

뒤따르는 명령어의 rs가 지금 2번임 

그래서 서로 해저드 관계가 나타났구나 그러면 여기서 지금 나온값을 rs로 넣어줘야하니까 여기 포워딩 유닛 A가 10을 여기다 써줘야댐

그다음에 하나 더 지나갔어 역시 얘와 얘 해저드 디텍터임

4번 쓰죠 그럼 4번 읽죠 서로

and $4 4번 쓰는거고

or $4, $4, $2 4번 읽는거고 

rs죠 마찬가지임 역시 4번이고 여기 4번 목적지 4번이 나타나지만 이거는 해저드 하고 상관이 없음 

이거는 무슨 해저드야? mem 해저드임 ex해저드가 아니고 왜? 

여기에 지금 이단계에서 4번이 나타났는데 하나하나 뒤에서 add가 4번을 읽는거잔아 지금 

그래서 여기서지금 나온 값을 어떻게 이값을 여기다가 전달해주고 있는거임

지금 여기에 4번과 여기에 요 4번이 지금 일치하는것을 확인해서 이번에는 포워딩 유닛이 여기에서 뭐를 선택하도록 해줘야되냐면 0001 

가운데 들어오는 지금 여기 회색으로 되어있는 선이 요값인데 01을 선택해줘야함

그런데 여기 또 포워딩이 또 나타나나 앞에 or는 그렇지 이명령어 두개로 엮여있음

이명령어는 4번

쏘리 이게지금 얘 4번 보다 더 최근에 그 바로 앞에 있는 or명령어 4번에 엮어있네 그러면 앞에 and에 4번이아니라 or에 4번이다

이거 만약에 or 명령어에 요기 4번이 안나타났다면은 얘와 얘 관계에 의해서 해결이 되는데 or명령어에 4번이 나타나니까 얘가 바로 얘를 해결해줄 수 있는거잖아 

그렇다.

EX 해저드임 (근데 자세히보면 sub도 or에 걸려있는데 EX해저드인가?? 이건 질문을 좀 해야겠다)

얘의 4번과 여기 나타나는 rs의 4번이 일치한다 방금전에 했던것과 똑같음



++

근데 지금 이제 내가 헷갈렸던 것 처럼 이 해저드 관계가 얘 입장에서 볼때는 바로 앞에 놈에 명령어하고도 해저드 관게에 있었고 얘는 앞에 앞에 놈하고도 해저드 관게에 있었음 

그런데 바로 앞에 명령어에 그 해저드 관계에 있으면 얘는 무시해도 됨 왜냐하면 논리적으로 따지면 얘의 결과는 바로 앞에서 주는 명령어가 제대로 제공하면 되는거니까 무시해도댐

우리가 회로 포워딩 유닛안에서는 두개를 다 따진다. ex 해저드를 체크하고 그다음에 mem 해저드를 체크함 누가 우선순위가 높냐면 ex 해저드가 우선순위가 높음 

ex에 의해서 해저드가 해결되면 그러면 mem 해저드까지 체크할 필요가 없는것이고 만약에ex해저드에 의해서 체크가 안되면 그다음에 mem 해저드를 체크하는것이고 두가지를 같이보고 

++(모르겠다.)



++

이놈은 해저드 관계에 있는데 포워딩 이 된다고 하더라도 한사이클은 필요함 로드일때 

왜냐하면 로드에 이 값은 메모리 access 후에 available 해지기 때문에 

++



이것은 로드 명령어가 사용되는 경우, 로드 use 일떄 해저드 디텍션임

일단, 이걸 할려면 로드 명령어가 있으면 한사이클은 stall을 해야함

그래서 뭘해야 하냐면 현재 사용하는 instruction이 id stage에서 decode가 되는데 그때에 어떤명령어인지 체크해라

그다음 역시 마찬가지로 alu operand

id stage에서 여기에 rs , rt가 주어질것이고 그러면 load use일때는

현재 id/ex 단계에 메모리 read고 이게 load 란 말임

이게 load 명령어란 말임 다른 말로 하면 명령어가 load이고 

여기에 rt, rt 여기엔 로드 결과가 들어갈 레지스터임

if/id는 바로앞임 지금 막읽어온 패치한 명령어에 rs와 rt랑 같으면 

바로 뒤따르면 어떻게 해야해? 걔를 한 사이클 쉬고와 미뤄야해

그것을 stall이라고함 stall을 시켜야함 stall을 넣단 얘기는 다른 말로 bubble이라고 표현하기도하고 no-operation 아까 우리 아무것도 연산이 안들어왔을때 control에서 뭐가들어오냐면 control이 0000 0000 이 들어오면 아무일도 안하는것임

그게 bubble임



## How to Stall the pipeline

그래서 파이플라인을 stall하게 되는경우는 id/ex 단계에 있는 모든 control value 을 다 뭘로? 0으로 만든다.

EX MEM WB 다 0으로 만들면 no-operation 아무일도 안한다.

걔들이 지나갈때는 말하지면

컨베이너 벨트고 생산라인이면 여기에 물건이 담겨져서 들어가면 일을 할거아니야 그러면 아무것도 안넣어 그럼 빈 상자가 가면 그 stage에서는 어 그냥 빈사장 받아서 한 cycle 쉬고 다음 빈상자 넘김 빈상자가 bubble임 stall임



그렇게 하고 다음 명령어 읽어오는것도 멈춰야해 

그러니까 프로그램 카운터가 그 if/id를 업데이트하는것을 미리 방지해야해 업데이트하지않도록 한번더

현재 사용하는 insturction을 한번더 decode해야댐 

한거지만 또한번 decode해 

그자리에 한번더 instruction fetch도 똑같은 명령어 한번더 

근데 이게 우리가 뭐 읽어온것을 또 읽어올 필요는 없어 그렇기 떄문에 

이거는 내부회로적으로 그냥 메모리 access안하게 할수도있는데 우리가 

그냥 개념적으로는 읽어온것을 한번더 읽어온다고 해서 아무 정확성에 문제될것은 없음

그래서 한번더 fetch한다

그렇게 해서 한 cycle stall을 하면 

mem 단계에서 이 lw 명령어의 데이터가 읽혀져 나올것이고 그러면 그게 어디야

그 뒤따르는 명령어의 execution 단계로 포워딩이 됨 

이 그림을 보면 이해를해보자

여기서  



## Data Hazzard Requiring a Stall

여기서 이게 지금 stall 몇개 들어간거냐? 한개들어간거임

여기 여기 나타났다고 stall이 두개 들어간게 아님 

stall이 하나만 들어간 효과가 이 명령어에 의해서도 이 명령어에 의해서도 

그 stall의 효과가 나타남

여기는 stall 이 들어가서 뭐가 한번더 반복됬어 

여기는 decode가 반복됬고 

그다음에 얘는 fetch가 반복됨 

stall이 몇개를 들어갔는지는 결과적으로 뭐에 영향을 줘 프로그램 전체 실행시간이 stall의개수만큼 증가한다. 

1stall 들어갔으니까 프로그램 전체의 실행시간이 하나 증가하면됨

원래 실행되는거 

원래는 9사이클 에 끝나야 되는데 stall이 하나들어갔기떄문에 10cycle에 끝남

그래서 얘가 여기서 한번쉬면서 decode한번더 얘는 방금전에 fetch해왔는데 한번더 fetch 

그러면 당연히 얘 뒤따르는 놈들은 얘들이 미루어지면 당연히 뒤에 있는 놈들은 자연스럽게 밀리게 되어있음  

fetch 나가니까?

그래서 여기서 나온값이 여기로 

그리고 여기서 이미 register에 들어간 값은 자연스럽게 register로 ($4, $2잘봐야댐)



## stall logic

이게 그러면 이제 load 명령어의 경우에 한 stall하게 만드는 stall logic임

여기에다가 해저드라고 되어있는데 load use라고써줘!

로드 명령어가 사용됬을때

아까 앞에서 했던 그 로직을 생각을 해보자

뭐야 이거 

앞에 decode한 명령어가 memRead 명령어이고 

그 명령어에 rt하고 이 뒤따라온 fetch한 명령어의 rs rt하고 겹치면 

그러면 stall을 함

stall을 한다는것은 결국은 뭘하냐? 프로그램 카운터 업데이트 못하게 해야하니까 여기에 pc wrtie 를 disable시켜야함 

그러면 여기가 업데이트를하지 않게 이전값이 그대로 있을것 아니냐

그다음에 여기에 있는 그 instruction fetch에서 decode를 가지고 왔지 (ppt참고)

이거 그대로 유지시키게끔

그대로

그다음에 여기서 보면 뒤로 보내는것은 일이 없는 bubble을 하나 보내야 하니까 여기 control에다가 다 0으로넣어서 0을집어넣서 뒤로는 한 cycle 만큼 버블이 들어가도록 

이렇게 하는게 해저드 컨트롤 unite임 



## stall example 이어서

지금 여기에 1번, 1번레지스터

그다음에 

여기서 지금 decode가 일어난거고 아직 decode 결정은 안됬음 

근데 ?? 갖고

따라서 갔더니 앞선 명령어 ID/EX MemRead 가 있고 그다음에 뒷따라오는 명령어에 rs, rt 둘중에서 rs 번호하고 그다음 뭘봐야해? 여기 지금 요게 어딨어 ?

rt가어디로 들어가지? rt가 들어가는 자리가 지금 여기 있음 

숨어있는데 여기 rt번호임 

rt 번호가 이렇게 되어가지고, 여기로 지금 가고 있음

그래서 load명령어의 rt가 여기서 나와서 rt로 들어가고 rt하고 뒤따르는명령어의 rs하고 번호가 지금 같은거야 

이뒤에 stall 시켜야함 그렇다

뒤에 stall 시켜야하니까 여기 pc 증가하지 않도록 하고 

그다음에 여기있는 명령어 다시 여기다가 쓰도록하고 (ppt참고)

그리고 중요한것은 여기다 0이 출력되도록 하고 그러면 어떤 관계에 있냐고 하면

load 명령어 사이에 bubble이 들어갈것고 뒤에하고 건너뛰게 

자그러면 여기서질문

그러면 여기 and 명령어에 저 2번값 은 포워딩 유닛에 의해서 해결되나?

포워딩 유닛에 해결됨

그렇다 포워닝 유닛에 어떤 로직에 의해서 해결되냐? ex해저드임

ex 해저드에 의해서 해결이된다고 생각함 

ex해저드는 여기서 값이 available 해야할거 아냐 

근데 load는 지금 이걸 지나야 값이 available 해짐 

그렇다. 그러니까 어디에 mem 해저드에서 load가 write back 단계에 왔을때 뒤따르는 명령어가 여기 실행단계(execution 단계)에 왔을때 여기에 데이터 읽은것이 들어가도록 포워딩유닛에 멤 해저드에 의해서 뒤에 값이 처리되도록 

그러면 지금 우리가 지금 다시 정리하면 포워딩을 하면 stall없이 대부분 해결된다.

하지만, load 명령어는 불가피하게 한 cycle의 stall 이필요하다 그걸 해결하기 위해서 여기에서 

여기에서 execution 결과를 돌리거나 또는 메모리 accesss를 돌려주기 위한 포워딩 유닛이 있으면된다. 그러면 모든 종류의 포워딩이 다 해결이 됨 

한가지 추가적으로 필요한건 load 명령어는 한사이클 불가피하게 뒤에 명령어를 지연시켜줘야 하기 떄문에 그것을 버블 발생시키는 로직이 여기 하나 필요하다.

버블 발생시킬때 하는일은 뒤로는 뭘 보내? 컨트롤을 0을 보내

no-operation 

그리고 앞쪽으로는 앞에서 했던일을 한번더하도록해

명령어 fetch도 한번더 하도록 하고 instruction도 같은 instruction이 한번더 decode하도록 그러니까 이거의 변화가 없는것임 

pc와 요 fetch의 변화가 없음 

그래서 여기 그 write신호는 이게 enable되야 새로운 값이 update되는데 이걸 disable 상태로 해두면 이안에 내용이 변해? 안변해? 안변함

???이벼 안에 내용이 아까값 그대로 유지함 

그런 보존하는거임 

해볼 수 있겠지

꼼꼼하게 해본사람들이 시험 잘볼것임

(시험문제임)

