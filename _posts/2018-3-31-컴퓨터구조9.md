---
post : layout
title : 컴퓨터구조9
---
## Pseudo Instructions
어셈블리 언어를 어셈블러가 기계어로 변경하므로써, 편의성을 제공한다.

실제 하드웨어에서는 구현되어 있지 않지만, 어셈블리 언어로 사용가능한 명령어를 Pseudo Instructions 라고 한다.

#### Pseudo instruction examples
move $s1, $s2 # add $s1, $zero, $s2
blt $s1, $s2, label # slt $at, $s1, $s2 / bne $at, $zero, label
abs $s1, $s2 ($s1에 $s2의 절댓값을 담는다.) add $s1, $zero, $s1 /slt $at, $s2, $zero /beq $at, $zero, L #$2가 0보다 작으면 L로 이동하고 그렇지 않으면 다음 명령어 라인을 수행한다. 
sub $s1, $zero, $s1 #0-$s1= -$s1($s1은 음수이므로 양수가된다.)
L:

여기서는 abs 명령어가 함수4~5개의 명령어로 구성됨을 보여준다.

## MIPS Addressing Modes(1)
##### Operand in instruction itself
###### Imeediate addressing(I-format)
op/rs/rt/immediate
##### Operand in register
###### Register addressing - 레지스터에 값이 담겨있다.(R-format)
op/rs/rt/rd(레지스터 넘버에 값이 담겨있다.)/-/funct
레지스터 넘버로 레지스터들의 레지스터를 찾아간다.
##### Operand in Memory
###### Base addressing
op/rs/rt/Address-여기서는 rs랑 Address랑 합쳐서 실제 메모리 주소를 표현할 수 있다.

## MIPS Addressing Modes(2)
###### Instruction im memory
PC-relative addressing(branch)
PC로부터 얼만큼 떨어져 있는지 확인한다.(Word offset으로)
op/ rs/ rt/ Address
PC
Address + PC = word in Memory

Pseudo-direct addressing(jump)
op/ Address 
4bits PC
4bits + Address = Word in Memory
2의 28승이 250M인거같고, 여기서 PC의 상위 4bit를 이용하면 4GByte가 되는듯하다. (확장되서 쓸 수 있다.)

Q. 궁금증 
1. 표현을 byte offset으로 표현한다. 
Maybe, address completely word-address
pc byte-address가 표현되지 않을까?

2. jump i-format에서 op/ Address 나눠지는데 끝에 붙은 00이 의미하는것, byte로 표현할경우 4씩 증가해서 00이 표현이 안되니까 쓰이지 않아서 낭비가 되잖아 그러니까 word로 표현하면 개수로 표현하면되니까 훨씬 더 줄일 수 있다.
점프 명령어의 26비트 필드도 워드 주소이다. 바이트 주소로는 28비트에 해당한다.

3. 256MB-1(0부터 표현하면 ) 하지만, 중요한점은 2의 28승이 256MB라는사실이고 이 JUMP Instruction format은  PC의 4bit를 가져와서 4Gbyte까지 쓸 수 있다는점.

## MIPS Addressing Modes(3)
op/rs
rs에 레지스터 번호가 담겨 있어서 레지스터로 분기주소를 향해 이동한다.
위에있는건 $beq $s1, $zero, L #위에 있는 Pseudo - direct addressing 이고
아래있는것은 L FirstAddressing #이게 아래에있는 jump register, 그 주소로 이동해라

짚고 넘어갈것
##### MIPS 주소지정 방식 요약
1. 수치(Immediate) 주소 지정: 피연산자는 명령어 내에 있는 상수
2. 레지스터 주소지정 : 피연산자는 레지스터이다.(R-format)
3. 베이스 또는 변위 주소지정 : 메모리 주소는 레지스터와 명령어 내의 상수를 더해서 구한다.
4. PC상대주소지정:PC값과 명령어 내 상수의 합을 더해서 주소를 구한다. ex)beq $s1, $s2 L
5. 의사적집 주소 지정: 명령어 내의 26Bit를 더해서 pc의 상위 비트들과 연접하여 접프 주소를 구한다.
*하나의 연산이 둘 이상의 주소지정 방식을 사용할 수있다.

## Procedure 지원
Procedure은 function의 의미이다. 하지만 c언어에서의 function과는 다르다. Program Language의 단위 모듈이다.
큰 단위 Procedure에서 작은 단위 Procedure로 이동되는것이고 이것을 모듈화 시키는것을 의미한다.
알고리즘의 Divide & Conquere로 생각하면 좋다.
구현하기 쉽고, 재활용이 쉽다.

c언어의 계통으로 보면
부르는쪽을 caller, 피 호출자를 callee 라고한다.
c언어에서 함수를 불렀을때 branch 되고 (조건: 인자, 인자개수, 자료형, 정의함수 받는 Input 개수 일치 그에 따른 자료형일치 가 되어야 한다.)
피 호출자 함수에서 return 되는 value와 담기는 value는 일치해야 한다. (기본적인 c함수의 동작방법을 생각하면 편하다.)
이전에 Branch와 달리 이런식으로 동작되는 Branch는 원래 자리로 다시 돌아와야 하는데 이러한 연결관계를 도와주는 명령어가 jar이다.

## Procedure 지원 명령어들
#### MIPS procedure call instruction
jal(jump and link) ProcedureAddress
jump 0x02(opcode) #jump는 가버리면 끝이지만
jal 0x03(opcode) #jal은 갔다가 돌아온다.

jal은 Instruction format이 J format이고
opcde 0x03 나머지 26bit 이다.

PC+4로 jal 다음 명령어의 주소를 $ra에 자동으로 저장해준다.
$ra는 레지스터의 마지막 레지스터이며 PC+4를 자동으로 명시하지 않아도 어셈블러가 해준다.
ra의 의미는 return address이고, 돌아올 위치의 다음 명령어의 링크를 갖게된다.
돌아올때는 jr을 쓴다.
jr $ra(돌아올 주소) 
jr은 jump read register 이다.
Instruction format은 R format이다.

## 6 Steps for Procedure
Procedure을 호출시에 Caller가 Calle를 부를 때 어떤 일이 발생하는지 살펴본다.
1. 전달인자를 저장하는데 보통 레지스터에 쓴다 숫자가 4개 이상을 넘을시 다른 메모리인 stack에 담는다. $a0~$a3으로 담게 되고
2. Caller는 calle로 분기한다. jal을 통해서
3. Calle는 Caller을 위해서 우선 저장공간을 확보해야하는데 그게 stack이다.
4. 주어진 일을 수행하고
5. 그 결과값을 $v0 - $v1담고 (return value가 담김)
6. Callee가 Caller 쪽으로 돌아간다.
돌아가는 주소가 담기는것은 $ra이고 jr $ra를 통해서 돌아가게 된다.

## Stack Allocation
프로그램은 총 4개의 요소로 구성되어 있다.
코드, 데이터, Heap, Stack
(Heap은 동적메모리 할당 버퍼이고 Stack은 함수호출을 지원한다.)
프로그램은 메인에서 시작하는데, 첫번째 그림에서 Main함수를 위한 메모리 공간이 잡히고 메인에서 새로운 함수를 호출하면 새로운 함수 호출 공간이 새롭게 확보 되어야 하는데,
1. Saved argument registers(if any)
전달인자를 저장시 $a0, $a1, $a2, $a3 이상으로 더 필요하면 이 공간에다 적는다.
2. Saved return address
레지스터 ra에 return address 있는데 ra말고 필요할시 이 공간에 기록하기도 한다.
3. Saved saved registers(if any)
subfunction으로 왔는데 main에사 사용하고 있던 레지스터가 존재하고 그 값을 넘겨줄때 subfunction에서 사용할 값이므로 저장해준다.
4. Local arrays and structures(if any)
함수 sunfunction에 int a, b, c가 들어오면 지역변수로 공간을 확보할 stack에 만들어진다.

이러한 공간이 확보가 되면 subfunction이 실행될 것이다.
이러한 subfunction을 위한 공간을 stackframe이라고 한다.
subfunction이 끝나면 사라진다.(한 프레임이 실행되는 동안 있고 다 끝나면 사라진다.)

Heap은 낮은데서 높은곳으로 만들어지고,
Stack은 높은곳에서 낮은곳으로 만들어진다.
Heap하고 Stack이 붙어있는데 자라다가 경계를 만나면 os가 프로세를 중지하거나 혹은 stackframe이 자라다가 밑으로 자리를 잡으면 스택이 자란다 라고 하고(혹은 줄어든다.) 아래로 stackframe이 쌓인다.
재귀함수처럼 함수를 연속적으로 호출하게되면 stackframe이 쌓이게 된다. 아래로 다시 값이 최종적으로 호출되면 원래 호출했던 곳으로 돌아와야 하는데 못 돌아올 경우에 stack over flow가 된다. (ex) 피보나치 수열)
$sp를 stackpointer
$fp를 framepointer 라고 한다. $fp가 stackframe의 바닥이다.

궁금증
메모리에 저장되어 있지만 조절은 옆에 $fp, $sp가 한다.
