---
post : layout
title : 컴구(기)11
---
## 컴구11
컴구11

## 
만약에 어떤 캐시가 있는데 캐시에 그 캐시
캐시 용량이 256 kbyte고 한블락이 4개의 워드(=16byte)
캐쉬용량이 우리가 캐시 capacity라고 하는데 256 kbyte
그다음에 한 블락 사이즈는 4 words 니까 = 16bytes 
자프로세스에서 지금 어드레스가 나왔는데 어드레스 가 헥사로 12345678 이라고 나왔다.
이 주소가 무슨 주소인지를 알아야지 이게 바이트 주소냐 워드 주소냐 
바이트 주소야, 바이트어드레스야 
##### Q1. 자그러면 첫번째 질문 이 바이트가 소속된 블락어드레스는 몇번인가?
우리 블락 어드레스 라고 하기도 하고 다른말로 넘버라고 하기도하는데 
블락어드레스 한번 구해봐요 블락 어드레스
어떻게 하는건지
0x1234567
만약에 이게 퀴즈문제로 나왔으면 풀었을까 못풀었을까 생각해보면서 당연히 풀었지
//바이트단위로 봐야되
어떻게 이 바이트주소, 바이트 주소를 한 블락 에 해당되는 바이트수로 워드주소는 한 블락에 해당되는 워드의수로 바이트주소는 한블락에 해당되는 바이트의 수로 나눠준다. 당연하지 그렇지
같은 단위로 
한 블락에 16바이트가 들어가니까 이거를 16으로 나누는데 나눌 필요없이 오른쪽에 몇비트를 떼버리면되? 4비트를 떼버리면되지 
16진수에서 2진수 4비트를 떼버리는거니까, 16진수에서는 몇자리를 떼는거야 1자리를 뗀다 그럼 뭐야 블락 어드레스는 1234567 이다.
그러면 
##### Q2. 이블락에 속하는 바이트들의 시작주소와 끝주소는?
1234567 이지 
//0x1234560 ~ 0x123456F 까지다.
선도 바이트 마지막 바이트 어떻게 하면되
시작 바이트는 이 블락 넘버에 끝에다가 뭘붙이면되 0을 붙이면된다 
마지막 바이트는 저기에다가 뭘 붙여야대 F를 붙여야되 
이진수로 하면은 0000 을 붙이는것이고 마지막 바이트는 1111을 붙이는것이니까

이게 지금 한 블락이 열여섯바이트니까 0000 1111을 붙이는거야, 한블락이 8바이트면 뭘 붙여야되 000 ~ 111 을 붙인데 한블락이 4바이트면, 한워드면 00 ~ 11 이렇게 붙인다.
너무 당연한것이다.

##### Q3. 이 캐쉬가 제공하는 캐시블락의 개수
캐시블락이 먼지 아지? 캐시도 그 용량이 블락 블락 별로 구성되잔아 그렇지
그러면 그런 블락이 몇개냐 
그런 블락이 
용량이 얼마라고 했어 256kilo byte 한블락은 몇바이트 16바이트 
256 kb/ 16바이트 
16kb = k= 1024 = 16*1024=16384bits
16 kilo 개

##### Q4. 이 블락이 캐시에 들어가는 캐시 인덱스 
캐시 인덱스, 글씨는 이거 잘쓰느데
캐시 인덱스는 블락넘버를 뭘로 나눠죠 블락의개수 캐시블락의개수
지금 여기서 지금 하나 전제 묻지 않은게 있다 이게 무슨 맵핑이라는거 알려줘야지, 무슨 맵핑? 다이렉트 맵드 캐시에서 이 블락이 몇번 인덱스에 들어가겠느냐 이 블락넘버를 전체 제공한 블락의개수로 나눈 몫이야 나머지야 나머지다 나머지에 해당하는 번호에 들어간다.
블락넘버는 0x1234567 이었고 나누기 16384 인데 사실은 16384는 2의 14승이다. 
2의 14승으로 나눈 요게 이게 되면 안되지 !
mode 2의 14승 나눈 나머지
그러면 저 1234567에 해당하는 저 주소를 오른 쪽 몇비트값을 취하면 나머지야 14자리 , 14비트 그렇지
근데 좀 까다롭네 그렇지
2진수하나는 4자리니까 적어도 오른쪽에 3자리는 날라갈것이고 3자리는 취할것이고 거기에 지금 걸려있는 4에서 몇비트를 빼내야되? 2비트 그렇지
그러면 요 4가 지금 얼마야 0100 이지 거기서 요 2비트 빼네고 그다음에 여기에 567 요렇게 해가지고 요게 몇비트야? 14비트가 되는거지 그렇지 14비트.
그러면 사실은 헥사로 따지면 그냥 567 이네 왜냐하면 이게 앞에 선두가 0이니까 비트 00하고 뒤에 헥사로 567 인거 아니야
567 헥사 567 번지에 그 캐시블락이 들어간다 헥사 567번지에
256 곱하기 5하면 얼마야 이거 16진수 10진수로 환원하는건 알겟지 
이거는 256 곱하기 5해야되고 이거는 16곱하기 6해야되고 그다음에 7더하기 이렇게 하면 103이고 이거 얼마지 십진수로 합해서 1383 이다.
==16384 개 중에서 1383번 인덱스에 저블락이 들어간다.==
또 뭘물어볼까 
##### Q5. 해당블락이 해당 메모리 블락이 와가지고 해당 캐시인덱스에 적재됬을때 데이터 와 함꼐 또 뭐가 또 기록이 되야대 태그 ! 태그정도 그럼 아까 0X123 하고 끝에 비트로 뭐가 붙어? 01 이 붙지 그렇지 태그!
앞에는 지금 16진수고 뒤에 두비트는 이진수야 따라 하나로 통일해야겠지 그렇지
이거를 뭐 굳이 2진수로하면은 어떻게되 2진수로하면 
0001 0010 0011 01 
이렇게 그렇지 몇비트야 저게 14비트다. 지금 32비트 주소중에서 아래 4비트는 한 블락안에서의 바이트 오프셋을 나타내게 되있고 그다음에 14비트는 뭐야 그 블락에 들어갈 캐시 인덱스를 나타내게 되있고 그다음에 나머지 14비트는 걔의 고유한 값 태그정보를 나타낸다. 그러니까 32비트가 
저걸 만약에 16진수로 표현하라 그러면 이렇게 바꿔놓고 다시 오른쪽부터 4자리씩 해야된다.
이렇게 하고 1이라고 붙이면 안된다(시험문제임)
완전히 다른수야

#####  Q6. 지금 이 캐시는 용량이 256 킬로바이트 라고 했잔아 그렇지 근데 그거는 실제 순수하게 데이터가 저장되는 공간만 용량을 우리가 표시한다고 그랬지 근데 내부적으로 뭐가 필요해 태그가 필요하고 또 밸러드 비트가 필요하다 그게 토탈 이 캐시를 구현하는데 필요한 메모리야! 그러면 이 캐시를 구현하는데 필요한 토탈메모리는 몇 비트인가

토탈 비트, 계산해봐
일단 데이터 용량은 얘기해주고 있잔아 256 킬로 바이트라고 그렇지 그러니까 그것을 비트로 하라그러면 거기다 8곱해서 비트로 환산하면된다. 256 * 8 
근데 뭐가 필요해 지금 태그하고 비트가 차지하는 부분이 필요한데 일단 
밸러드 비트는 한비트고 태그는 지금 몇개 필요해? 14비트 
비트한비트, 밸러드 한비트 그다음에 태그 이건 밸러드 비트 이건 태그 한 캐시블락당 요게 추가적으로 필요하다 15비트가 그런데 이런 블락이 몇개야 이런블락이 16k 개 잔아 우리가 kilo는 1024를 대신해서 쓰는거니까 16kilo 
그러면 뭐야 킬로는 그냥 놔두고 16*15 240 kilo bit지 이게 지금 bit로 나온 숫자잔아 240 킬로 비트야 이게 
이게 밸러드와 태그 부분
그다음에 실제 데이터는 256 킬로바이트라고 했으니까 이거는 256 * 8 킬로비트지 
그렇지 256 * 8 하면 얼마야 2048 킬로비트 임 그래서 일단은
2288k bits 가 된다.
이거 연습해야되 
연습많이해(시험문제다)
그다음에 

## 
이것 무슨 캐시라고 했지 셋 어소셔티브 캐시
다이렉트 맵트 캐시의 단점이 뭐라그랬어
같은 캐시인덱스로 사상되는 그런 블락이 너무 많다. 그래서 그러글 완화시켜주기위해서 어떻게 고 인덱스 자리에 한개의 블락이 아니고 두개 네개 여러개의 블락들을 구비하자.
그래서 거기에서 비어있는 자리에 가거나 그중에서 가장 안쓰는 놈을 하나 교체하면서 들어오게하자 그게 셋어소셔티브 캐시에 의도다. 아이디어가
따라서 우리가이제 어 다이렉트 맵트 캐시하고 거의 같은데 어 지금 이 문제에서는 거꾸로 물어보고있다. 저 주소는 무슨 주소야 저기 바이트 주소야 워드주소야 0부터 31까지 풀로나와있어 저건 바이트주소다. 자 지금 여기에서 데이터부분에서 32비트가 나오네 그러면 한블락이 32비트란 얘기다. 32비트는 바이트로는 4바이트 그렇지 워드로는 한워드고 그러니까 무슨얘기야 여기서는 이게 지금 여기에 들어가있는게 한개의 블락사이즈야 한개의 블락.
한 블락이 32비트 
자 그런데 원래는 여기 어 따라서 지금 32비트니까 4바이트지 4바이트니까 바이트주소를 오른쪽 2비트를 뗴버리면 이게 뭐야 이게 블락주소야 그렇지 4바이트 가 한블락이라고 했으니까 2비트를 뗴버린다 그렇지 그런데 원래 다이렉트 맵트 캐시에서는 블락넘버를 제공하는 이 엔트리의 수로 나눈 나머지 그부분을 캐시 인덱스 라고 했지 걔가 들어갈 자리에다가 
그런데 여기도 비슷한데 이때는 캐시 인덱스라고 안하고 셋 인덱스 라고한다 셋인덱스 또는 셋넘버 왜냐하면 요게 한 개를 지칭하는게 아니고 한줄 한 셋트 한셋트 별로 지금 관리가 되는거야 그래서 이게 세트0 세트1 한세트에는 몇개 가지 자리가? 4자리가 들어가있다. 
한세트에 4자리 가 들어가는건 몇 웨이? 4way다. 갈수있는 자리가 4자린 얘기야 포웨이
자 그래서 지금 이거 보면 그런 세트가 몇세트 있어? 0~256 세트있잔아 0부터 255까지 그렇지 그러면 이 블락넘버를 보고 얘가 들어갈 세트 넘버를 찾아야겠지.
세트 넘버를 찾으려면 세트의 개수로 나눈 나머지를 보는거야 256으로 나눈 나머지 
256으로 나누니까 2의 8승이잔아 

오른쪽에 8비트를 보면대 
그럼 8비트를 보면 걔가 들어갈 뭐가 나와? 세트가 나온다. 
그렇지 그러면 다이렉트맵트 캐시는 거기가면 걔가 들어갈 자리가 한자리였기때문에 고민하지않고 그냥 그자리 바로들어가면되는데 
셋 어쇼티브는 지금 그 셋트에 여러 자리가 있는거야 
들어갈수있는 자리가 만약에 얘네들이 다 비어있으면 그냥 처음만나는 자리에다가 집어넣으면된다. 그다음에 비어있는 처음 자리에다가 들어가면되 
무슨얘긴지 알겟지
들어갈수있는 자리가

자그러면 아까 그문제를 내가 아까 풀었던 문제를 256kb 캐시가 한 개의 블락이 4워드로 구성되어있고 그다음에 4-way야 자그러면 똑같이 4-way로 구성이 됬을떄 주소가 헥사로 12345678 이라고 나온 데이터 그게 바이트 데이터일떄 그 블락은 볓번 세트에 들어갈까 
256kb 가 한블락이 4word고 4-way set associative로 구성될때 헥사 12345678이 속하는 블락은 셋트 몇번에들어갈까?
12345678이 속해이쓴 블락은 아까하고 똑같아 0x12345670 ~ 0x1234567F 까지 한블락으로 블락사이즈가 똑같으니까 문제는 캐쉬가 좀 다르게 구성되어있단 말이야 
캐시가 아까는 이렇게 일렬로 이렇게 구성되어있는 다이렉트 맵트 캐시였다가면 지금은 4WAY로 이렇게 세트로 구성이 되어있는거야 그러면

지금 이거는 한 블락이 4바이트인경우 지금 예로 든것이고 지금 내가 묻는거는 조금 다르다 아까 거기로 돌아가면 헥사12345678에서 16바이트가 한 블락이니까 여기에 블락넘버이고 
뭐를 알아야되? 이 캐시가 제공하는 세트의 개수를 알아야되
캐시 가 제공하는 세트의 수 
캐시가 제공하는 세트의 개수가 몇세트에요? 몇세트야? 
아까 용량이 얼마라고 그랬어? 246KB 잔아 근데 한 블락은 블락당 몇바이트야 16바이트지 그러면 256을 16으로 나누면 얼마야 16kb 였잔아 그렇지 
그냥 다이렉트 맵트로 하면 16k개 16384개가 쭉 그냥 일렬로 늘어서는데 
지금 이거는 셋 어쇼티브는 그렇게 안하고 한 세트에 그것을 4개씩 4개씩 해서 세트로 짝을 짓겟다 이말임 그러면 이게 어떻게되
세트의 개수는 256 킬로바이트 나누기 16바이트 나누기 얼마 세트의사이즈 (이거 중요하다)
셋사이즈 = 셋 어소서티비티 넘버로 나누어 져야 그게 256 kb 나누기 16바이트 이렇게하면 이게 뭐야 저렇게 하면 캐시 블락의 개수가 나오는데 그거를 뭘로 나눠져 4로 나눈다 이거를 (associativity number) 만약에 
8-way 셋쇼셔티비티로 하겠다 그러면은 한 세트가 8자리가 들어가니까 이거를 8로 나눠줘야 한다 4개씩 한세트야 그러면 얼마야 저게 4096 4k야 
이게 요 숫자로 
숫자하고 킬로하고 이렇게 잘 연관 해서 알아둬요 어떨떄는 k로 환산하는게 계산할때 더 효율일수도 있으니까 
4096
우리가 왜 이게 세트의 수가 4096인지 아는게 중요해 그 세트의 수를 알아야 저 블락 넘버를 세트의 수로 나눈 나머지가 4k는 2의 12승 
2의 12승이야 이게 그렇게 
그러면 저기에서 0x1234567에서 2의 12승으로 나눈나머지가 쟤가 들어갈 세트야
오른쪽의 12비트인데 헥사로 얼마야 헥사로 어 이게 헥사 한자리가 이진수 4비트니까 3자리지 딱 끊어지게 
헥사 567 이다. 아까 도 결과가 같게 나오는거같지만 같은게아니다 아까 다이렉트 맵트 캐시는 앞에 뭐가 붙은 셈이야 00 이진수 00 이 붙은셈인데 어쩃든 결과적으로는 어 같은 값이 나오는게 맞지만 저 567 세트야 
무슨 얘기냐면 아까 그림으로 돌아가면 그림으로 돌아가면 여기이런 숫자들 무시하고 다 무시하고 헥사 로 567번 에 해당되는 위치로 일단 배정을 받는다. 그다음에 그안에서 들어갈수있는 자리는 몇자리 4자리가 있고 4자리중에서 비어있는 첫자리에 들어가는것이다.
그거는 뭐 자유롭게 그러니까 최대 네놈이 거의 비슷한 시기에 같은 곳에 오더라도 상대방 을 쫓아내는 일이 없지 이 다이렉트 맵트 , 셋 어쇼티브 캐시는 
자그런데 이렇게 하면 충돌은 완화 할수있는데 비용이 든다. 비용이 뭐가 더 들어 딱 봤을때 비용이 비용이 데이터 블락은 더 드는게 아니야 데이터 블락은 지금 이걸 일렬로 세웠느냐 아니면 네개가 한세트씩 했느냐 에 차이지 데이터블락은 용얄이 늘어난 부분이 없다
뭐가 늘어나 그런데
어 비교기들이 있지 비교계들은 여기서 나온값들을 동시에 비교할려고 비교해놨잔아 
그다음에 또 뭐가 들어가
보면 어 여기지금 밸러드와 태그 가 다이렉트 맵트 캐시에서는 한블락에 한곳에서만 들어가는거잔아 근데 지금 이거는 어 넘버 오브 웨잇 
웨이 가 많으면 많을수록 거기에 비례해서 밸러드 태그가 다 구비되야 한다
그렇지 그러면 방금 그 아까 예제에서 해서 세트의 수가 얼마나 나왔다고 세트, 전체 토탈 세트의수가 4k개 나왔지 4096개 그러면 태그와 밸러드 비트는 4번이 나오잔아 그렇지
이게 
그런데 또 태그 사이즈도 다르지 태그가 어떻게 되 아까는 14비트 가 태그였는데 지금 이렇게 하면 몇비트가 태그야 16비트가 태그임
태그가 더 늘어난다 그래서 태그가 16비트가 될것이고 아까 예제로 그대로하면 그리고 밸러드 비트가 1비트, 그래서 1+어 16이되고 그렇지 그런게 한세트마다 몇곳에 있어 4곳에 있으니까 곱하기 4를 해줘야지 한세트를 위해서 필요한 밸러드 태그 공간이다. 
그런데 그런게 몇세트 있어 세트가? 
4k 개 있으니까 4096을 곱해줘야 한다. 그러니까 (1+16)*4*4096 그게 여기에 해당되는 요 태그& 밸러드 를 위한 공간이야 그다음에 데이터 공간은 똑같이 256 kbyte 지 그게 토탈인데 다이렉트 맵트 캐시보다 이와같은 부과적인 공간도 조금 더 늘어나고 셋 오셔티브 캐시이렇게하면 그다음에 태그를 매칭을 하기 위해서 태그정보를 거기에서 자기가 원하는 태그하고 일치하는지 비교하는 비교기 어 컴펄레이터 로직도 그 어쇼셔티비티 수만큼 필요하고

이와같은 부과적인 부과회로가 필요하다.
자그런데 왔는데 여기에 배정받아서 왔어, 그런데 봤더니 여기에 들어가야되는데 다 인밸러드야 어 떙큐지 아무대나 들어가면되 순서대로 처음빈자리 
두번째 같은 자리에 다른 블락이 왔어 얘는 차있지만 얘들이 다 비어있어 ok 그럼 다음 빈자리에 들어가면되 마찬가지로 여기 들어가면 되고 여기에 들어가면되

자그런데 한참돌다가 어떤 놈이 왔어 그래서 봤더니 여기에 tag를 다 비교해서 봤더니 자기가 원하는 태그가 아니야 무슨얘기야 다 엄한놈들이 지금 올라와서 캐시에 올라와있다는거야 그러면 어떻게 새로 들어온 블락이 어딘가는 들어가야되는데 이중에서 누군가는 쫓아내야 될거아니야 그치 쫓아내 어떻게 쫓아내 그냥 처음 이자리를 쫓아내?
그것도 방법일수 있찌 그냥 무조건 그냥 이자리에 들어간놈만 운이 나쁘네 계속 쫓겨 날거아니야 그래서 우리가 상식 적으로 생각하면 어떤 놈을 쫓아내면 좋냐 쫓겨날만한 애를 쫓아내면 좋다 무슨말이냐면 앞으로 한동안 안쓸놈이 쫓겨나면 제일 좋은거아니야
그렇지 앞으로 한동안 안쓸녀석 
어 그렇지 만약에 쫓아냈는데 바로뒤에 프로세스가 그데이터를 엑세스 할려고 그래 최악이다. 방금쫓아냈는데 그데이터를 도로 불러들여야해 캐시로 가장 안쓸놈을 쫓아내야 되는건데 어느 상황에서 프로세스가 앞으로 가장 안쓸놈을 알수있어 없어? 그건 모르는거다 그건 점치는거와 똑같다 어떤 블락이 지금 프로그램에 명령어에 따라서 지금 계속 실행되는건데 프로그래머 가 어떤 의도를 가지고 이 후에 어떤 명령어를 가졌는지를 하나하나 실행을 해봐야 아는거지 지금 이순간에는 알수가 없어.

그래서 그러면 앞으로에 걔의 형태는 모르지만 뭘보면 알아 걔가 과거에 어떻게 해왔는지를 보면 싹수를 알수있다. 그렇지 그래서 필요한것이다 잘해야되
그래서 비교적 과거에 걔가 많이 엑세스했던 놈은 앞으로도 많이 엑세스할 가능성이 높다 
그러면 뭐에 근거한거야 프로그램은 뭘 갖고 있어 프로그램은 로켈러티 를 갖고있기 때문에 그래서 누구를 쫓아내냐면 이중에서 recently used라고하면 최근에 쓴놈이다. 그렇지
most recently used 그러면 가장 최근에 쓴놈이다. 가장 최근에 쓴놈은 쫓아내면 안되는거고 그 반대로 most 의 반대 least 
least 가장 오랫동안 사용안한 놈을 쫓아내느것이다 이중에서 그게 가장 합리적인 방법이다. 그럴려면 뭐가 필요해 여기에 사실
뭐가 필요할까 시간 정보가 필요하다 그래야 서로 비교할꺼아니야 4개중에서 누가 가장 오랫동안 안쓰였는가를 볼려면 걔를 참조했던 시간정보를 어딘가에 기록을 해놔야지 선후 관계를 우리가 알수있잔아 그래서 그래서 
여기지금 밸러드와 태그비트외에 접근 시간
우리가 엑세스타이 는 읽어오는데 걸리는 시간이 아니고 엑세스한 클락, 엑세스 클락 그 시간정보를 여기다가 제공하고 각각에 그걸 기점으로 해서 우리가 least recently used 블락을 쫓아내는 희생시키는 방법을 쓰는데 이걸 LRU 알고리즘 이라고 한다 
줄여서 
이뒤에 48~54까지 요 예제를 좀 따라서 가볼것 알겟죠 
화요일날은 하여간 캐시에 관련해서 종합적인 퀴즈를 볼테니까 연습을 할것 문제 어떻게 나오는지 그렇지 어 ! 뭐 다음 다음 주 시험이야 어차피 공부해야되 알았지

## 질문
만약에 그거를 한블락이 한 캐시 블락이 4-WAY 가아니고 아주 극단적으로 16-WAY 다 그러면 16개 블락이 들어갈수있잔아 상대적으로 뭐가 주냐면 세트의 개수가 준다. 그렇지 한세트에 16개의 블락이 들어가니까 전체 블락 을 16개씩 세트로 묶는거잔아
그러니까 세트의 수가 준다. 그러니까 아까 4096 이었으면 1024로 줄지 
그러다 보니까 어 우리가 어 걔가 들어가야 할 위치는 걔의 블락 주소를 세트의 수로 나눈 나머지 부분이 걔가 들어갈 위치거든 
그러니까 4096으로 나눌때는 오른쪽을 12비트를 봤지만 1024로 나눌때는 오른쪽을 10비트만 보면되지 그런관계가 있다.