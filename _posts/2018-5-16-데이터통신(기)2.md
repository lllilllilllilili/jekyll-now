---
post : layout
title : 데이터통신(기)2
---
## 앞선내용
기말고사는 난이도가 올라감 
디지털 신호를
아날로그 신호
마지막 부분이 ask + psk 합쳐서 qam 방식을 소개함
그림을 통해서 원점과의 거리와 x좌표와의 각도로 구별이되면서 거리를 amplitude 각도는 페이스와 관련됨
평면상에서 서로 구별되는 각각의 위치가 곧 구별되는 신호, element가 됨
16개라고 하면 하나의 신호 엘리먼트가 4비트를 내포하고 있다. 이것을 16-qam
4개있는 경우 4-qam

이렇게 구현할 수 있는다. aplitude 어떻게 활용하느냐에 따라 다양한 그래프가 보인다.
저 포인트 들이 어떻게 생기냐면 sin, cos 합칠때 앞에 계수를 어떤거 쓰느냐에 따라 페이스 
수행을 해줌
원리가 그렇다.

## 아날로그 신호변조
아날로그 시그널에 얹어서 보냄 
아날로그 신호를 아날로그 시그널로바꿀려고 하냐? 왜?
밴드패스 가 우리한테 주어졌기 때문임
기본적인 소스는 자기 대역이 있는데 그 대역에 해당하는 밴드위스가 채널이 주어진게 아니라 다른 채널이 주어졌으면 그 아날로그 시그널을 그 대역폭으로 옮겨야 함
나에게 주어진 밴드 패스 채널로 옮기기 위해서 아날로그 모듈레이션이 필요하다.
여기도 역시
amplitude modulation, 프리퀀시 모듈레이션, 페이스 모듈레이션 3가지
디지털 신호를 아날로그 캐리어 시그널에 얹어서 보낼때 방식 3가지가 그대로 아날로그 신호변조할때도 적용이됨
앰플리튜드, 프리퀀시, 페이스에 내가 이 보내고자 하는 아날로그 신호를 반송파의 특성들에 얹어서 보냄 3가지

여기서는 이름을 디지털 신호를 보낼때는 쉬프트 킹이라는 표현을 했는데 이제는 모듈레이션씀
구별을 함

진폭변조는 amplitude modulation 내용은 같음
내가 보내고자 하는 시그널이 있는데 나한테 주어진 대역폭이 이런 대역폭이 있다 그러면 결국 중간에 케리어 프리퀀시가 이 fc라는 값을 갖는 어떤 캐리어 시그널을 만들어서 캐리얼 시그널에 이 아날로그 시그널에 실어서 보내야하는데 amplitude 에 실어서 보내는 모양은 딱 이런 모양이 됨

이 케리어 시그널의 진폭이 내가 보내고자 하는 아날로그 시그널에 amplitude 값에 의해서 오르락 내리락 함
그렇게해서 만들어진 시그널이 모듈레이티드 시그널임
케리어 시그널이 있고 이것을 명확히 해보면
케리어 시그널이 있고 케리어 시그널을 변조시키는 시그널이 내가 보내고자 하는 메시지의 시그널임
이것을 모듈레이팅 시그널이라함
두개가 합성이 되서 변조된 시그널이 모듈레이티드 시그널임
모듈레이티드 시그널이 전송이됨
모듈레이티드 시그널의 피크포인트 쫓아가면 내가 보내고자 하는 메시지가 담겨져 있음

구성하는 방법은 오실레이터 이용
캐리어 시그널 생성 보내고자 하는 시그널의 멀티플라이 해서 만듬
이 시그널의 대역폭이 어떻게 나오느냐 얘기를 하는데 통신쪽에 가서 하는 부분이 필요함
간단하게 개념만 말하면 모듈레이팅 시그널 (내가 보내고자하는 시그널) 프리퀀시 도메인에서 보면 밴드위쓰가 B인 시그널이 나옴
시간 도메인에서 주어진 m(t) 푸리에 트랜스폼을 통해서 M(f)라고 하는 프리퀀시 도메인의 함수로 
이런 모양이 나오는데 바로 이 원점을 기준으로 - 프리퀀시 성분을 갖는 이런 그림도 나옴
이것은 푸리에 트랜스폼을 공식을 적용하다 보면 그냥 생성되는 가상의 부분임
푸리에 트랜스폼을 해보면 계층형 함수가 나옴
이 시그널의 대역폭은 이것이다 말을함 
밴스 위스가 b인 원래의 시그널이 m 시그널이 이렇게 푸리에 트랜스폼이 되다보면은 이 그 캐리어 모듈레이션 하다보면은 바로 우리가 지금 f(c)라고 하는 캐리어 프리퀀시 이놈 
캐리어 시그널에 모듈레이션 하면은 그만큼 쉬프트 된다고 했음
그래서 이놈이 그대로 오른쪽으로 fc만큼 쉬프트 되면은 이런 모양이됨
이렇게됨 
-도 따라옴

그래서 밴드위스가 결국 2b가 됨 (마이너스도 따라오기때문에 2배가됨)
b는 원래 아날로그 시그널의 대역폭을 애기했는데 amplitude moduation을 하면 2b가 된다. 
마이너스도 따라오다 보니까 
그래서 통신쪽에 보면은 더블 사이즈 밴드라고 
더블 사이즈 밴드 통신임 괜히 이쪽시그널(-)는 필요없는데 양쪽을 다 통신하는 구지 필요없지만 같이 실어서 보냄 넓은 대역폭에 실어서 보내면 이거에 개선된게 싱글 사이드 밴드임
잘라버림 이걸 구지 따라올필요없이 애는 필요없음 ( - 쪽인거같음)
대역폭을 요만큼만 필터를 적용시키면 애만 취함 사실 이속에 정보가 다 들어있기때문에 (오른쪽 부분) 얘는 필요도 없는부분(마이너스)
싱글 사이드 밴드 통신을 한다는것은 반만 쪼개 놓고 보냄 통신쪽에서 나옴
언급이 없음

이부분은 왜 두배가 됬는지 대역폭이 왜 두배가 되는지를 이해하기 위해서 이부분 설명함

일반적으로 우리의 음성이 5khz에 대역폭을 갖는다고 하면 여기가 5khz란 말임 
그런데 am 방송국에 할당된 대역폭은 10khz 그거에 2배정도를 준다. 
방송국간에 사이에 간격에 여유를 두고 5khz만 필요하지만 10khz, am 방송국마다 할당해준다 
각 방송국마다 자기에 할당 된 대역폭에 해당하는 케리어 프리퀀시를 생성해서 거기에 모듈레이션해서 am방식으로보냄

## fm
미부분은 주파수변조는 개념적으로 보면은 캐리어시그널이 있는데 주파수를 변조시킨다 캐리어시그널이 
내가 보내고자하는 아날로그 시그널의 진폭값이 맞춰서 얘를 주파수를 변조시키는데 진폭값이 키면 주파수값이 빨리 바뀌게 만들고 값이 작으면 천천히 바뀌게 만듬
이게 주파수 변조임
주파수를 살펴보면 내가 보내고자 하는 시그널의 정보가 들어있다.

fm도 같은 흐름으로 설명함
뒤에도 있지만 
우리가 시그널이 모듈레이티드된 시그널에 모양이 amplitude쪽은 우리 지금 관심이 없고 cos 쎼타 t라고 하자. 모듈레이티드 된것임 다시말해서 내가 모듈레이션 하고자 하는 것과 cos 함수가 결합이 된것임 
이게 페이스 모듈레이션 또는 프리퀀시 모듈레이션 된 이후의 모듈레이티드 된 시그널을 표현할때 이와같이 표현하는데 이속에 (pm, fm)

amplitude modulation은 이 속에 내가 보내고자하는 정보가 있는것지만

프리퀀시 모듈레이션/페이스 모듈레이션은 이속에 들어있음 이거 크게 보면 cos뭐다 이건 앵글임 각도임 cos 각도를 표현하는 변수임

페이스/프리퀀시 모듈레이션은 이 앵글속에 들어있기 떄문에 정보가 크게 묶어서 앵글모듈레이션이라고 부름
프리퀀시 모듈레이션과 페이스 모듈레이션은 다 두개묶어서 앵글모듈레이션이라고 함 
여기에 작용을 했으면 앰플리튜드 모듈레이션 
크게는 앰플리튜드 모듈레이션/ 앵글모듈레이션 두개가 있는데
앵글 모듈레이션 들어가며보면 프리퀀시 모듈레이션과 페이스 모듈레이션이 있음

이게 앵글임
코사인 앵글이, 코사인 함수가 
이런 형태로 계속 간다. 프리퀀시라는게 이 속에 어떤 모양으로 들어있냐면 
얘가 지금 한 주기, 여기서 여기까지 한주기 2pi, 여기도 2pi
프리퀀시가 가령 10이다. 10이다 라는 얘긴느 초당 2pi를 10번 지나간다 말임
요속을 들여다 보면 이 모양이 2pi를 프리퀀시 만큼 이 표현이 갖는 의미를 보자

쎼타 티를 보여하는데 앵글이라는게 시간당 fc라는 2pi를 지나감 
이시그널의 주파수가 fc라고 하면 
하나의 주파수가 한번 거쳐갈떄 2pi만큼 가니까 2pi fc만큼 앵글이 표현이됨
여기에 더하기 뭔가 face가 있음 제로에서 시작하는게 아니라 페이스가 있음
이 앵글을 페이스모듈레이션은 이부분이 페이스야, 이 전체가 앵글을 의미하는데 각은 몇도냐 요부분은 페이스 설명하는 부분

//페이스 모듈레이션은 이 페이스속에 n개가 들어있음
페이스를 대신 m(t)가 이 속에 있다. 거기에 어떤 계수 kp라고 하는 kpm(t)
앵글의 모양이 이렇게 구성될때 페이스 모듈레이션
앵글속의 페이스 파트속에 m(t)가 들어있음
이런 모양새가 됨

반면에 프리퀀시 모듈레이션은 앵글이 변하는 속도 각속도임
프리퀀시가 여기 들어있음 앵글을 미분을 하면 각속도가 나옴
앵글값을 계속 회전을 하면 한 회전을 할때 2pi인데 초당 몇번을 하느냐 이런식으로 주파수가 2pi를 계속 회전하는 것으로 보여주는데
프리퀀시라는건 앵글이 변하는 속도가 프리퀀시임

이렇게 나옴 미분하면 쎼타t를 미분하면 2pifc 그속에 프리퀀시의 성분이 들어있음
각도를 미분하면 각속도가 나옴 각속도라는게 프리퀀시임
2pi를 초당 몇번을 격어 가느냐 프리퀀시 정리임
쎼타 t를 미분을 하면 d쎼타t/dt 
2pifc 이속에 내가 m(t), 이게 주파수 성분인데 캐리어시그널에 비해서 
지금 생성된 주파수에 내가 이속에 m(t)를 넣겠다 이말이다.
이 앵글을 미분을 성분속에다 m(t)를 집어넣음 이게 프리퀀시 모듈레이션 이게 주파수임
이 앵글을 미분한 값이 주파수임(결과적으로..)
주파수속에 m(t)를 집어넣으니까 fm이 됨 
앵글 자체의 페이스를 나타내는 부분에 m(t)를 집어넣음 pm임
fm과 pm은이런관계를 갖음 이것을 쎼타t로 표현하면 
fm을 쎼타t로 표현하면 적분을 해야함 

이런 모양이 나옴
m(t)가 어디에 들어있느냐? 적분식속에 들어감
이것을 적분을해야 쎼타(t)를 구함 쎼타(t)를 표현하면 2pifct 뒤에부분은 그대로 적분하면 kf상수 나오고 m(t)가 적분이 되는 형태로 표현이됨
그모양은 ppt참고
쎄타(t) 라는 함수의 모양을 들여다보면
fm/pm 어떤차이를 보이는지 볼 수 있음
pm은 말그대로 m(t)가 위상, 페이스자리에 그대로 들어와
자기모양대로 들어와있는데
fm은 앵글의 페이스성분쪽에가서 보면 m(t)가 적분된 형태로 들어감
이런 차이가 fm과 pm의 차이임
그것을 나타내는 식이 ppt에 있음 
pm은 위상 자기자체 자기모양 그대로 들어가있는 반면에
fm은 이렇게 적분된 형태로 들어감
fm은 앵글을 미분한성분이 fm이기 때문에 거기에 m(t)를 집어넣으면 그것을 다시 앵글로 얻어내
얻어내면 적분할수밖에 업다. 그래서 적분된 속에 m(t)가 들어있으면 fm이다. 그런형태다.

## fm vs pm(2)
앵글을 미분하면 프리퀀시 성분이 됨
순간적인 프리퀀시인데 미분해보면 여기나옴
fm은 미분한 값이 프리퀀시고
그속에 그대로 온전하게 들어있음
페이스 모듈레이션 미분을 하면 이렇게 됨 오메가c가 2fc임
오메가c +
이것을 미분을 하면 2fc나오고 결국 여기는 미분한 값이 되어버림
프리퀀시로 바꿔보면 이게 앵글이고 
이걸 미분해서 프리퀀시로 얻어보면 pm의 경우는 얘가 미분된 이런 형태임
이 차이가 있음
요차이에서 중요한 포인트를 얻어내야함

fm의 경우 캐리어 시그널에 이만큼 m(t)만큼의 주파수 성분을 더함 m(t) 만큼의 주파수 가 더해져서 감 fc+m(t)만큼 pm은 캐리어 시그널의 주파수 더하기 + 내가 보내고자 하는 시그널의 미분 성분이 더해짐 
이게 다름 

m(t) 값자체가 프리퀀시에 더해지는게 아니라 m(t)의 미분이 더해짐
이그림을 다시 보자 

## 아날로그 신호 변조[계속] 그림만
fm의 경우를 보면
fm은 이 내가 보내고자 하는 시그널 자체값의 크기가 이 주파수를 변화시키는 역할을 함 이값이 크면 이 시그널 주파수 굉장히 큰 부분에서 굉장히 빠르게 변화시키고
값이 작은 부분에서는 천천히 변화시키는 역할을 하는게 fm임
pm은 이 값에 크기가 문제가 아니라 값의미분치가 주파수에 변화를 줌
값의 미분
pm의 경우에는 주파수는 값의, 내가 보내고자 하는 시그널에 미분값이 이 주파수 값을 변화시키는 역할을 함 그래서 같은 내가 보내고자 하는 m(t)란 시그널을 pm을 통해서 캐리어 시그널에 얹혀 보내면 이런 모양이 나오는데
아까 fm과 다르다.

## 위상변조

이 시그널을 보면 이 값에 미분치가 큰 부분은 요 부분임
미분이라는게 시그널의 변하는 정도를 말함 
이 시그널은 이 부분에 대해서 거의 변하는게 없음
매그니튜드는 크지만 미분치는 제로임
여기가 미분치가 큼 
미분값이 m(t)가 많이 변하는 부분에서는 모듈레이티드 시그널은 주파수가 높고 이런 부분은 미분치가 0에 가깝기 때문에 주파수 성분이 낮음 
미분 변하는 부분이 큰 부분 주파수 늘어남??
그 차이임

모듈레이티드 된 시그널을 보면 m(t)의 크기에 의해서 주파수가 변하느냐? m(t)에 미분값에 의해서 주파수값이 변하느냐 이게 바로 fm과 pm의 차이 
두개를 묶어서 말함
두개를 묶어서 앵글 모듈레이션 중에 pm과 fm을 앵글가지고 설명함

그러면 이제 대역폭도 여기서 볼 수 있음

## fm과 pm의 대역폭
fm으로 모듈레이티드 된 시그널에 대역폭을 보면 
m(t)가 대역폭에 큰 역할을 함
m(t)의 가장 큰 이값일때 전체 대역폭이 제일 크고
m(t)의 가장 작은 값일때 이 대역폭의 아래값이 나옴
모듈레이티드된 시그널의 대역폭을 보면 fc 주변에 어떤 대역폭을 가지고 있느냐 이 포인트와 이포인트가 각각 결정하는 것은 이 포인트는 fc값이 제일 클때 이값이 제일 크니까 주파수 성분이
이 주파수 성분이 가장 작게 되는 부분은 m(t)에 최소값이다. 
m(t) 최소값이 나왔을때가 주파수 성분이 얘가 됨
max m(t)가 있을때 이런게 나오고 minimum m(t)성분이 나왔을때 이값이 나오고 (그림이 있음)
fm과 모듈레이티드 된 시그널의 주파수 대역은 m(t)가 좌우함
주파수 크기를 말함

정확히 m(t)가지고 표현한다기 보단 정확히 들어가보면 주파수의 fm의 모듈레이티드된 주파수대역폭을 보면 이와같이 되어있는데 2b 곱하기 ??? 유도된 과정을 들여다 볼 필요없음

우리는 단지 이 대역폭을 나타내는 이 식 속에 내가 지금 보내고자 하는 m(t)라고 시그널의 맥시멈 성분이 여기 들어있다 라는것을 인식해야함
모듈레이티드된 시그널에 대역폭에 지대한 영향을 미치는게 바로 내가 보내고자 시그널의 맥시멈값임
맥시멈값, 미니멈값 이런 값들이 이 대역폭에 지대한 영향을 미침
그런 값들이 여기에 들어있느냐 이 베타 라는 변수속에 들어가있고 이부분이 베타라는 부분이 여기 들어가있음 

전체 대역폭에 영향을 미치는건 바로 m(p)라는게 있음 k는 상수 
대게 이 값이 베타가 4정도 된다고 봄 적정한 값이 
4면은 여기가 5가 되고 10배가 된다. 밴드위스가 10배 원래 아날로그 시그널 m(t)가 가지고 있던 대역폭의 10배 정도 대역폭 필요하는게 fm이다.

똑같이 

## 아날로그 신호 변조[계속]
실제 fm 방송국에는 이것에 10배 되는 150kHz 필요함
나라는 200kHz주면 할당된 캐리어 프리퀀시를 이용해서 거기에 모듈레이션 해서 보냄
fm 방식으로 보냄
대역폭이 더 넓기떄문에 
am에서는 5khz 대역폭 을 써서 ???신호 만들었는데 여기서는 15khz 만들어놓고 소스를 200khz 대역폭을 보내니까 fm 방송이 훨씬 음질이 좋음

fm은 어떻게 구현하느냐 
fm은 이 주파수속에 m(t)가 들어간다는데 어떻게함?
이 장비가 하나 있어야함
볼티지 컨트롤 오실레이션 얘는 들어오는 신호 여기에 cos 함수가 발진이 되면 이 속에서 자체 생성이 되고 있는데 그 cos 캐리어 시그널의 프리퀀시가 인풋으로 들어오는 시그널의 매그니튜드 값에 의해서 이 주파수가 조절이 되는 장치임 
이게 바로 fm임
내가 보내고자하는 시그널의 값이 크면 주파수가 빠르게 작으면 주파수가 작게

vco가 요 m(t)를 인풋으로 받아서 자체 생성된 케리어 시그널의 주파수를 얘의 매그니튜드에 의해서 조절을 함 
fm 모듈레이티드된 시그널을 만들어냄 

밀접한 관계는 어떻게 구현되느냐?
m(t)의 크기에 의해서 주파수가 조절되는게 아니라, m(t)의 변화률 미분치에 의해서 조절이 됨
그래서 vco에 인풋으로 집어넣을때 m(t)를 그대로 집어넣는게 아니라 얘의 미분 값을 집어넣음
미분값을
미분기가 여기에 하나있음
내가 보내고자 하는 m(t) 시그널을 미분해서 미분된값을 vco의 인풋값으로 집어넣으면 미분된값이 크면 주파수 커지고 미분된값이 작으면 주파수작아지는 형태로 모듈레이션한게 페이스 모듈레이션임


그래서 미분기가 있고 없고가 fm과 pm의 차이임
아울러 페이스 모듈레이션에 의해서 만들어진 시그, 모듈레이티드 시그널의 대역폭은 fm과 비슷한 모양임 
2(1+베타)B 

주파수속에 주파수 대역을 나타내는 뭐가 또 영향을 미쳤냐? 
FM에서는 이 모듈레이팅 시그널의 크기가 영향을 미쳤는데 페이스 모듈레이션에서는 이 시그널의 미분값이 대역폭에 영향을 미침
미분값이 frequency에 들어가기 때문에 
이속에 들어나지 않은 B라고 하는 변수 속에 분명히 이 m(t)성분이 여기에 반영이 되어있어야함
베타속에 미분값이 들어가있음

m(t)가 자주바뀌면 미분값ㅇ ㅣ클테고 대역폭 커짐
모듈레이티드 된 시그널

베타 모양은 책에 안나옴 미분치가 어떻게 반영되기 위해서는 베타 부분봐야함
시그널의 미분값이 주파수 영역 pm 시그널의 절대적인 크기 대역폭에 영향을 미치는게 fm
구별을 함

5장 끝

## 6장
밴드위스를 좀 효율적으로 쓰자
멀티플렉싱 방법과 효율적 반대인 spreading 방식 이 있음
두가지 밴드위쓰 방법
멀티플렉싱(다중화) spreading(확산)

다중화 여러개 하나로 묶어서 보냄
확산 더 넓혀서 보냄

## 용어
bandwidth utilization : 나한테 주어진 밴드위쓰를 현명하게 사용하는 방식 말함
효율은 멀티플렉싱에 의해서 내가 얻어낼수 있음
멀티플렉싱말고 스프레딩은 효율보다는 
어떤 침해를 방어하기 위해서 spreading 씀
두가지가 상반되는 개념

spreading 효율이 떨어지지만 privacy 보안 위해서 어쩔 수 없이 사용

## 멀티플렉싱
두개의 디바이스 사이에 데이터를 주고받을 수 있는 미디엄이 그 디바이스 필요에 비해서 훨씬 더 큰 밴드위쓰를 내가 가지고 있다고 하면
내가 누군가 통신을 하고자 하는데 전화통화를 부산에 누군가와 전화 통화를 하고자 하는 사이에 주어진 대역폭이 대역폭이 엄청클텐데 남들과 share 하면 더 효과적이지 않냐?

공유될 수 있음 멀티플렉싱 개념은 어떤 기술인데 동시에 여러개의 시그널이 하나의 링크를 동시에 사용해서 전송하는 방식을 멀티플렉싱 방식임

## 종류
멀티플렉싱방식으로 주파수 멀티플렉싱
주파수 분할
파장 분할
동기시분할
통계시분할

멀티플렉싱 그림으로 보셈
통신을 위한 메디엄이 엄청 큼 여러명이 공유해서 쓰면 좋겟다!
공유하는 방식을 말함
보내는 쪽을 멀티플렉서 받는 쪽 디멀티플렉서임
링크 하나에 
라인 여러개일텐데 
여러 개 링크로 들어오는 데이터를 링크 하나로 내보내기 위해서 집약시키는 장치 멀티플렉서
하나의 링크를 여러개의 링크로 나누는 디멀티플렉서

채널의 개념
n유저가 하나의 링크를 사용한다면 각각의 유저별로 할당된 몫이 채널이라고 함
링크는 하나지만 채널은 n개가 있음
용어설명
다중화 범주에 멀티플렉싱 3개
타임 디비전은 2개가있음

## 다중화

## 주파수 분할 다중화
빨간글씨로 프리퀀시 디비전 멀티플렉싱
주파수 나누는 개념의 멀티플렉싱
파장을 다른 파장을 이용해서 같은 미디어 공유하는 방식이 아날로그 방식
타인 디비전 멀티플렉싱은 디지털방식이다.

주파수 나눠서 보내는건 
fm이나 am이나 프리퀀시
서로 대역폭을 이용해서 동시에 공유함
실제 유선이라 할지라도 유저별로 서로 다른 채널에 대역폭 할당 하는방식
fdm은 

## fdm 처리 과정
동일한 대역을 필요로 하는 소스라고  할지라도 서로 캐리어 프리퀀시가 서로 다르면 서로 다른쪽에 시그널을 옮겨놓게됨
그래서, 모듈레이션된 시그널이 이렇다하면 얘들은 서로 다른 대역폭에 자리를 잡고있기때문에 서로 간격없이 더해져서 통신을 할 수 있음 얘들은 다합하면 이런 모양이 되겠지만 이속에서 다시 받은쪽에서는 내가 취하고 자 하는 그주파수 대역폭에 맞춰서 튜닝을 하면 그놈만 뽑아낼 수 있다. 
모듈레이션 수행됨

필터라는게 내가 지금 채널을 맞췄다. 특정한 용도의 대역폭이 어디에있느냐 자기에 맞는 대역폭을 취했다 라는게 필터로 표현이됨
필터로 표현이 되면 그 시그널을 잡아내서 다시 디모듈레이션을함
디모듈레이션 과정을 보여주는데 m(t)를 모듈레이션 하는 과정은 m(t)와 cos 오메가ct 캐리어시그널을 곱한거였고 이게 모듈레이션 하는 과정이었고
디모듈레이션하는것은 내가 지금 받았는데 coswct를 받았는데 다시 coswct를 한번 더 적용시키면 삼각함수에 의해서 1/2(m(t) + cos 2 wct) 저번에 한거임
디모듈레이션 하는것은 얘를 m(t)를 끄집어 내면댐
cos 한번 더 곱한것에는 m(t)만 떨어져 나가져 있다 이와같이 
처음에 보낸 시그널을 cos 함수 두번 적용한뒤에 디모듈레이션 하면 끄집어 낼 수 있다.

요부분에서 이작업을 함 

예제6.1은 살펴봐라
똑같이 3명의 가입자가 링크 하나를 같이 쓸려고함
당연히 fdm을 쓰면 서로 다른 대역폭을 활용해야함
대역폭이 4khz라고 하는 똑같은 대역폭을 갖지만 모듈레이션할때 서로 다른 자리에 가도록 케리어 프리퀀시를 서로 다른것을 쓰면 이런 모양에 다른 자리에 시그널들이 가있다.

더하면 이런 모양이 됨 
프리퀀시 개념에서 살펴본 그림임 서로 다른 대역에 가서 다시 밴드패스 필터를 통하면 각자 자기자리에 있는놈만 끄집어 냄 

cos 함수 곱해서 디모듈레이션 하게 되면 다시 원래의 시그널이 복구된다.

## 예제 6.2
이그림은 
타임 도메인에서 살펴본다.
타임 도메인은 전송되는 시그널은 복잡한 모양인데 
이것을 프리퀀시에서 살펴보면 이모양이됨
프리퀀시 도메인에서는 명확히 3개의 시그널이 서로 다른 채널을 통해서 날라가고 있는 모습을 개념적으로 보여줌
주파수 평면에서 시스템에서 해석하는게 용이한 케이스를 보여줌
똑같은 그림인데 앞은 타임도메인
이것은 프리퀀시 도메인에서 보여줌

100khz 5개를 보내는데 100khz 만 할당받으면 곤란하고 사이에 10khz정도의 간격을 허용해야 된다. 5개의 100khz 보낼때 10khz 간격을 유지할려면 540khz가 필요하다.

간섭이 없어야함
겹치는 부분을 방지하기 위해서 대역폭 을 띄어서 하게끔 멀티플렉싱 이와같이 하면 정확히 할 수 있음 간섭을 일으킬 수 없음

## 6.3
4개의 채널이 있음
1Mbps
채널이 1MHz로(밴드위스가) 4개의 1Mbps 를 4Mbps를 소화해내봐야함
4개의 디지털 채널이 있고 1Mbps짜리 
채널을 fdm한단 얘기는 4개로 나눠줌
소스를 1Mhz를 4개로 나누면 하나당 250khz 대역폭밖에 없음
대역폭은 250khz인데 각각의 소스는 1mbps다.
신호 엘리먼트가 하나가 4개의 비트를 운반해줘야함
bit rate 는 1M인데 250khz밖에 소스밖에 없음 각각의 소스가
한 시그널 엘리먼트가 4bit를 소화할려면 qam 적용한다면 16qam이라는 모듈레이션 방식을 써서 디지털 데이터를 아날로그 바꿔야 하는데 16qam의 방식의 모듈레이터를 미리 적용해야함
한 hz가 4bit를 의미의 정보를 가져야 하기때문에 r=4가 되어야 함 
16qam 모듈레이션 방식을 써서 회로도 그려보면,
이런 모양으로 멀티플렉싱 해야함
1m 짜리 들어오면 16qam 방식으로 (ask+pask) 아날로그 신호로 바꿈 
케리얼 시그널에 집어넣음 아날로그 신호를 각각 대역을 달리하는 250khz 대역폭에 집어넣서 멀티플렉싱함 
qam을 적용하는 사례가 하나 나옴 

16qam이 왜 필요한지 설명
한 hz가 4bit를 의미의 정보를 가져야 하기때문에 r=4가 되어야 함 
16qam 모듈레이션 방식을 써서 회로도 그려보면,
이런 모양으로 멀티플렉싱 해야함

## 주파수 분할 다중화
멀티플렉싱한것을 또다시 이놈을 여러개 묶어서 멀티플렉싱 가능
그때마다 한 링크마다 용량이 증가한다.
4khz 
48 khz * 5 = ? * 10 2.5mhz
하나의 링크가 감당하는 대역폭이 커지는 방향으로 감
케이블 재질이 좋아져야함
서울에서 부산까지 일일이 전화를 연결해야하는데 동네에서 묶고 동네를 묶어서 구 단위 전화국 묶고 구단위 전화국에서 서부 동부 다시 큰 단위로 묶고 
혜와동 시외전화기 전체를 다묶어서 부산까지 한줄만 감
몇천개임
3600 개의 보이스 채널을 한줄로 3600개의 채널을 수용할 수 있는 한줄을 부산까지 끌고간다. 이게바로 멀티플렉싱의 효율임

예제는 보고

## 파형 분할 다중화
광케이블에서는 빛으로 보내는데 시그널을 빛으로 보내는데 빛의 여러가지 파장을 묶어서 보냄
파장이라는게 주기하고 비슷함
파장이 긴놈이 있고 짧은놈이있고 더 긴놈이 있고 이놈들의 
이놈들의 색깔이 다름
파장이 서로 다른 정보들을 하나로 묶어도 갈데 섞여보이지만 프리즘을 에로 들면
각도 달라하면 하나로 묶어서 프리즘을 통하면 각자 자기가 나가는 각도가 다름
프리징을 가지고 멀티플렉싱 디 멀티플렉싱 생성할 수 있음

파장 분할

역시 아날로그 멀티플렉싱이고 광전송에 활용되는 방식임

## 시분할 방식
동일한 라인을 주파수로 나눈게 아니라 시간을 나눠서 쓴것임 시간을 1/4씩 씀
그것을 계속 반복함
이게 하나의 프레임이 됨
프레임에 첫번째 채널 내가 쓰고 
시간에 비효율적인 모습을 보이지만 사람이 쓰기엔 비효율적이지 않다.
채널이 작은 간격임
동시에 쓰는것같은 생각을 할 수 있음.

tdm은 디지털멀티플렉싱인데 여러개의 저속도의 소스를 고속의 라인에 각 채널에 집어넣어서 보내는 방식임
시분할 얘기가 긴데 

이와같이 3개의 소스가 있다고 하자.
파란,노란,빨간
이 길이가 중요함 이 t라는 시간동안 이만큼의 양 이 멀티플렉서를 통해서 멀리 전송되는 동안에 소요되는 시간은 역시 t만큼 소요가 되야함 이만큼의 데이터가 전송이될때 t만큼의 시간을 써서 전송해 줬으면 나는 누구랑 공유했건 아무 상관없다.
내가 들여다 보내는 만큼 여기서 이만큼을 보내주면은 내가 남하고 share해도 아무런 피해가 없으니까 개의치않는다.
마찬가지로 모든 유저들이 
이만큼의 양을 멀티플렉서는 3명을 동시에 수용해줄려면 
이만큼의 양을 t/3동안 처리해줄 수 있어야 이 라인이 얘들을 만족시켜줌
하나의 프레임 이 형성되는데 프레임속에 파란색 이만큼 처리해주는 시간이 t/3 
이 노란색도 t/3 전체가 t가 됨
t 동안에 파란색 입장에서 이만큼이 처리가 됨 채널속에서
두번째론 여기로 처리되고 세번째는 여기서 처리됨
띄엄띄엄 날라가는것처럼 보이지만 얘입장에서 얘가 이만큼 생성되는동안에 처리되는것이고
이시간동안에 처리되는것이고 나는 간격을 못느낌 단위가 하나하나가 다 t이기 때문에
이게 가능할려면 이 라인이 3배가 빨라야 함
이만큼을 처리하는 시간이 이 링크에 비해서 이링크가 3배가 빠르면 같은 양을 처리하는데 1/3시간만 든다.
이 링크는 각각의 링크의 3배속도를 가지고 있어야함
10명을 수용할려면 10배 빠른 링크가 있어야함(왜냐하면, 멀티플렉싱 되기전에는 따로 가니까 n*T만큼 걸리고 이게 모여서 쭉 나열되면은 그 배의 속도에 맞게끔 T가 유지되어야 함)

각각의 t/10만큼 소요됨
이거 하나하나를 프레임이라고함

링크는 n개의 소스를 수용하려면 n배만큼 빨라야한다.
이걸 처리하는시간은 1/n만큼 필요하다. 처리하는시간 말하면

## 6.5
이걸 응용하면 여러문제가 나옴

그림에서, 데이터 rate이 각각의 채널이 1kbps임 
초당 1000bit가 들어옴 그런데 한 비트씩 멀티플렉서 된다. 
이 양이 얼마큼씩을 프레임을 나누는데 각각에 유저에게 할당된 채널속에 얼만큼씩 가지고 와서 프레임을 만드느냐
여기서 한비트 한비트 가지고 온다고 하자
이게 경우에 따라서 1byte씩 넣어서 프레임 형성할수도 있고
이문제에서는 1bit씩 가지고 와서 프레임을 만들자
만드는 경우임
어떤 소요시간을 물어봄
각 input slot(slot은 프레임에 넣을 대상이 되는 요 한덩어리에 시간이 얼마나 되느냐)
input에서 이 시간이 얼만큼이냐 1 bit라고 하면 
1bit씩 넣기로했으니까 한단위가 한비트임
한비트가 차지하는 시간은 이 라인이 1kbps라고 했음 초당 1000개
하나는 차지하는 것은 1msec 됨

이프레임에서 차지하는 시간은 얼마나 되야하나? 1/3msec 가 되어야함
여기도 1/3 1/3msec 토탈 1msec가  되어야함
이 1msec 에 한비트 처리되는게 여기서 보면 1msec 에 한비트 처리
전혀 지체될게 없다. 
그렇다면 각 채널에 시간은 소스에서는 1msec 인데 프레임에서

링크에서는 하나의 채널 길이는 1/3msec 여야 하고 프레임의 길이는 1msec가 됨
물어보는게 이 example임
input의 각 slot의 길이, output의 각 slot의 길이 그리고 frame의 길이
각각
1msec, 1/3 msec 다시 1msec 이렇게 됨
(교수님 input의 각 slot의 길이는 멀티플렉싱 되기전에 하나의 링크로 들어가는 부분인가요?)

이런질문들이 많음

응용문제가 계속나옴
이렇게
4개의 1Mbps 소스가 있음
이것을 프레임 한 bit씩 가지고옴
시각적으로 보여짐
1Mbps 4개로 묶어서 한 프레임으로 묶는데 맨 앞에 있는걸 묶어서 두번째꺼 묶어서 한프레임
각각의 input에서 1bit 듀레이션 output 링크에서의 1bit 듀레이션 얘의 비에서 1/4
아웃풋 빗 레잇은 
아웃풋 링크의 빗 레잇은 (bit rate) 1msec 가 필요함 얘는 1/4msec
한비트가 1/4msec 얘의 속도는 한 비트당 1/4msec니까 그것의 역수는 4Mbps 합 (계속 역수로 생각할까?? ....)
프레임의 속도는? 몇프레임퍼세크냐?
프레임은 초당 1Mbps 4개를 수용하는 이 프레임은 초당 몇개씩 처리가 되어야하나? output에서 프레임 하나당 1bit씩 처리되야 하는 속도가 그대로 여기서 유지되어야한다.
1bit는 초당 100만개가 처리되어야함(들어가는 라인인거같은데..?) 1bit가 처리되는 프레임도 초당 100만개가 처리되어야함
그래야 프레임 초당 100만개 처리
bps로바꾸면 프레임당 4bit니까 400만 bps가 됨 

## 시분할 다중화
채널에 집어넣는 구현하는 방식을 소개하는 장임
어떻게 집어넣냐
뱅글뱅글 돌아가는 스위치가 하나 있어서 1/3 시간동안 얘한테 열어주고 1/3 시간동안 얘한테 열어주고 1/3시간동안 얘한테 열어주면 한프레임을 채움
그걸 뱅글뱅글 돌면서 프레임마다 한바퀴를 돈다.
얘와 정확히 싱크가 맞아야 되는 것이 디멀티플렉싱쪽에서 정확히 얘 시간동안만 열려서 일로가야하고 얘 시간동안만 열려서 일로 가야하고 이렇다. 
1/3 씩 돌아가면 얘도 1/3씩 각각의 채널에 열려져있어야 하는 식으로 싱크가 맞아야 가능함
그래서 이것을 싱크로나이즈 타임디비전 멀티플렉싱 이라고함

동기식 타임디비전 멀티플렉싱

## 6.8
4개의 채널이 이걸 
4개의 채널이 또 멀티플렉싱
각각이 100 byte per sec 씩 들어옴
100 byte 씩 들어옴
프레임을 묶는데 각ㄱ 채널별로 각 소스별로 1byte씩 묶어서 프레임을 만드는 사례
여기서 1byte 프레임이 4byte이 하나의 프레임으로 만듬
들어오는쪽이 초당 100 byte 들어오면 각 소스입장에서 1byte 
프레임이 처리되는 속도는 초당 100개 그래야 서로 초당 한 바이트가 처리됨
초당 한바이트가 들어오고 있는데 초당한바이트가 나가게 됨
프레임이 초당 100개가 나가야댐
100개 프레임 이니까 100 프레임 per sec
프레임하나당 4byte = 32bit 
100프레임 * 32 bit 가 초당 날라가니까 3200 bps가 라인이 
이 라인이 3200 bps임 
프레임 듀레이션 = 프레임이 하나 차지하는 시간은 1/100 초 임
이런 디테일한 시간 값들을 물어보는 문제임

## 다른형태 문제
100kbps 짜리 4개가 있는데 프레임을 만드는데 각 소스로부터 2비트씩만 가지고 온다.
8비트 짜리 프레임을 만들면 또 이 물어봄 
프레임이 초당 몇개가 처리되어야 하느냐? 100 kbps 처리되어야함(땡인듯) bps를 물어보는건가?
프레임 하나 처리되어 봤자 각 소스는 2비트 밖에 처리가 안됨 
각 소스가 2비트를 생성해내는 동안에 프레임 하나가 날라가야댐 
그러면 각각 2비트 처리되는 시간은 초당 100kbps 니까 2비트면 한 비트가 1/100,000 걸리니까
2bit면 1/50000
1/50000초만에 프레임 하나가 
일초에 5만개의 프레임이 처리되어야 함 


그렇게 알고나면 1/50000 p sec 인데 각 프레임당 8비트니까 곱하면 이 아웃풋 링크의 스피드가 나옴 400kbps임 
당연히 아웃풋의 스피드는 얘들의 합임 400kbps임
책에 예제가 있으니 풀어보셈 간단하니까 (중요)

## 시분할 다중화
한 비트 멀티플렉싱에 단점 
단점은 채널이 있어서 각각 자기자리가 있어서 좋은데 이렇게 보낼게 없는 경우는 비어서 보냄
계속 보낼 데이터가 있으면 좋은데 두번째는 빈 상태임
그자리는 계속 비어서 감 시간 낭비가 많음
저런 문제를 개선하는데 뒤에 나옴

제목 잘 보셈
시분할 다중화가 저런 틈새가 생길 수밖에 없다.

## 데이터율 관리
예제가 스피드가 다 똑같았는데 다르면 어떻할꺼임? 인풋 스피드가 다르면 멀티플렉싱을 어떻게 할거냐? 쉬운 케이스만 
다른놈만 40이고 혼자만 20이면 애당초 두개를 묶어서 40을 만든다음에 동일하게 40을 만들어서 보냄

다단계의 다중화

하나가 50이고 나머지가 25다 그러면 이 50짜리를 두개로 나눠서 디 멀티플렉싱 25로 두개로 만든다음에 25kbps 5개를 묶어서 보냄
애는 채널을 2개 받음

숫자가 애매한 경우는
둘은 50이고 하나는 46이다 그러면 얘를 억지로 더미 데이터를 넣어서 50kbps 만들어서 보냄
쓸대없는 데이터를 채움

## 시분할 다중화
프레임과 프레임 사이에 이제 동기화 보내는 쪽에서 열심히 프레임 만들어서 보내고 받는쪽에서 프레임을 받아서 디멀티플렉싱을 해야 하는데 혹시 동기가 안맞을것을 대비해서 동기화를 
동기가 안맞으면 엉뚱한 채널을 뽑아내게 되어이음
동기를 맞추기 위해서 여기가 프레임에 시작이다 정보를 프레임마다 하나씩 주는게 현실적이다
프레임 동기화를 위해서 각유저부터 채널 채워넣는것만 보여줬지만 이제는 프레임 별로 한 비트씩만 추가하는 모습을 현실에서 이렇게함
동기화를 위한 패턴이됨
10101.. 이런식으로 반복, 반복되는 식으로 이 데이터가 들어가 있어서 
바로 요놈들을 체크하면서 받은 쪽에서는 프레임에 시작이다. 
라는것을 알고 이때부터 이 동기화를 놓치지 마라 이거임
한비트씩 추가됨
한비트씩 추가되니까 그러면 이제 아까 반복됬던 문제가 약간 변형됨
한비트 추가되는식으로 되다보면 

## 6.10
4개의 소스가 있는데 각각 250byte per sec 짜리 4개 소스가 있음
근데, 추가시키는데 각각의 소스로부터 1byte씩 가지고 오고 하나의 싱크로나이즈 비트를 추가한다 이거다. 한 프레임 사이즈는 4개 소스니까 각각의 소스로부터 한바이트씩 가지고 오면 4바이트가 되고 더하기 한비트 짜리 동기를 맞추기위한 한비트짜리 추가됨
그러면 한프레임에 사이즈는 33 bit가 됨(32bit +1)
그런상황에서 소스에 데이터 rate는 250 캐릭터 퍼 세크면 곱하기 8 해서 2kbps가 나옴
소스에 bps 이렇게 됨 소스에서는 각 바이트가 차지하는 시간은 초당 250 byte니까 1/250byte 임 소스에서는 차지하고 있음 
프레임 레잇은 프레임은 초당 250 byte?????

몇개의 프레임이 처리되어야 하나 초당 250개
한 프레임은 각 소스별로 한 byte밖에 처리를 안해주는데 각 소스는 초당 250개를 캐릭터를 생성함 프레임이 이 속도를 전혀 지체를 시키지 않고 다 처리할려면 한 프레임이 1byte 밖에 처리를 못하니까 소스별로 프레임도 초당 250개가 날라가야한다. 초당 250개 (1byte가 중요)
(이거중요)

스스로 해야함
프레임당 
프레임 레잇은 250프레임 펄 sec가 되어야 함 
한프레임에 소스별로 1byte 밖에 처리를 못해주니까 
프레임에 걸리는 시간은 1/250초 임 프레임이 1/250초임
구해본 값들이 

한 프레임이 1bit 싱크 더하기 4byte 해서 프레임당 
4개의 소스로부터 1바이트씩 가지고 오고 싱크 bit 하나 추가를 하면 33 비트가 됨 
이게 펄 프레임임 
근데 프레임은 250프레임 펄 세크로 처리가 되어야 해 왜냐하면 각 소스로부터 한 바이트 씩밖에 안가져오니까 소스는 250 바이트를 계속 생성해 내니까 250 프레임이 처리가 되줘야함

프레임당 차지하는 시간은 1/250초임 (1초를 기준으로 봐야함)
이래야 1초에 250개가 날라감
각 프레임에 몇비트냐 33비트임 그러면 output link의 스피드를 맨 마지막에 물어봄 링크의 스피드는 링크는 초당 250개의 프레임을 처리해야하는데 프레임별로 33비트니까 곱하기를 하면 아웃풋 링크의 스피드가 나온다. 250개의 프레임을 초당 처리해야 하고 각 프레임별로 33비트니까 곱하기를 하면 얼마가 나오냐면 아웃풋은 33*250 하면 되겠지 뭐

지금 프레임당 33 비트임 그런데 아웃풋 링크의 처리되는 스피드는 초당 세크당 250 프레임이 처리되어야함 곱하면 33*250 단위는 bit per frame * fram per sec 
bit per sec가됨
초당 bps 가 됨 

단위를 확인해봄

fdm도다중화, 멀티플렉싱을 대위적으로 채워나갔듯이 tdm도 다중화를 해나가고 있음
이게 24 채널을 묶어서 보이스 채널 하나를 ds0라고 디지털 시그널 0
이걸또 여러개묶어서 ds1 ,2 ..

ds라는 이름은 서비스 이름
통신망회사에서는 규격에서 부르는 이름이 있음
T-1 라인 보이스 채널 24개를 멀티플렉싱 라인이 T-1 라인
T-2 라인은 T-1라인을 4개로 묶어낸게 T-2라인(96개)
T-3 라인은 7개로 묶어서 672 보이스 채널이 나옴
이걸 8개 다음 T-4라인
이 규격들은 전세계 공통임

멀티플렉싱된 라인들을 갖고 서로 네트워크가 어떻게 구성되는지를 표현을 함
T-1 라인이 몇 메가 bps인지 살펴보는게 중요함
24개의 보이스 채널로 묶으면 1.544 Mbps 나온다.

음성은 4khz 대역을 쓴다고함
디지털화 하려면 4khz 시그널을 샘플링하면 나이키스트 법칙에 의해서 8khz로 샘플링하고 
8kh로 샘플링을 하고 곱하기 샘플한값을 8비트로 퀀타이제이션을 하면 
8*8=64kbps가 나옴 
보이스 채널 하나가 64kbps다.
64kbps를 24 채널을 쓰면은 1.544가 나오나? 1536이 나옴
T-1 라인이 보이스 채널 24개를 묶은거라고했는데 단순히 64kbps를 24개로 묶으면 저것보다 작은값이 나옴
1.544 나오게 하냐면 24개가 있으면 tdm 을 묶음 
각 소스별로 프레임을 형성하는데 1byte씩 프레임을 형성하고 거기에 한비트 싱크를 추가한것이다. 각 소스별로 샘플 하나가 8bit니까 샘플 하나하나 해서 24개의 유저로부터 한 바이트씩 가져오고 싱크 한비트를 붙여야함 
각 유저당 이 샘플을 몇번을 하냐면 초당 8천번을 해야함 한 샘플만 프레임이 한 유저 입장에서 한 샘플만 처리하니까 프레임이 전체 초당 8천개가 처리됨

프레임 별로 사이즈 보면 8bit * 24 +1 = 193 bit가 초당 8천번 반복되어야 하니까 * 8000하면 1.544 Mbps 숫자가 나옴  (나이키스트 샘플링 8천)
T-1 라인 규격은 1.544 Mbps 의미하는 라인이다. 퀄리티가 형성
T-1 라인은 24개의 보이스 채널을 묶으면 1.544Mbps 
그중에 싱크를 위한 1bit 씩 프레임별로 추가되기 때문에 단순히 이런 계산하고는 다름

유럽에서는 30채널로 묶어서 E-1으로 씀
한번 해보셈 위에예를 적응해서 한번해보자.




=======
---
post : layout
title : 데이터통신(기)2
---
## 앞선내용
기말고사는 난이도가 올라감 
디지털 신호를
아날로그 신호
마지막 부분이 ask + psk 합쳐서 qam 방식을 소개함
그림을 통해서 원점과의 거리와 x좌표와의 각도로 구별이되면서 거리를 amplitude 각도는 페이스와 관련됨
평면상에서 서로 구별되는 각각의 위치가 곧 구별되는 신호, element가 됨
16개라고 하면 하나의 신호 엘리먼트가 4비트를 내포하고 있다. 이것을 16-qam
4개있는 경우 4-qam

이렇게 구현할 수 있는다. aplitude 어떻게 활용하느냐에 따라 다양한 그래프가 보인다.
저 포인트 들이 어떻게 생기냐면 sin, cos 합칠때 앞에 계수를 어떤거 쓰느냐에 따라 페이스 
수행을 해줌
원리가 그렇다.

## 아날로그 신호변조
아날로그 시그널에 얹어서 보냄 
아날로그 신호를 아날로그 시그널로바꿀려고 하냐? 왜?
밴드패스 가 우리한테 주어졌기 때문임
기본적인 소스는 자기 대역이 있는데 그 대역에 해당하는 밴드위스가 채널이 주어진게 아니라 다른 채널이 주어졌으면 그 아날로그 시그널을 그 대역폭으로 옮겨야 함
나에게 주어진 밴드 패스 채널로 옮기기 위해서 아날로그 모듈레이션이 필요하다.
여기도 역시
amplitude modulation, 프리퀀시 모듈레이션, 페이스 모듈레이션 3가지
디지털 신호를 아날로그 캐리어 시그널에 얹어서 보낼때 방식 3가지가 그대로 아날로그 신호변조할때도 적용이됨
앰플리튜드, 프리퀀시, 페이스에 내가 이 보내고자 하는 아날로그 신호를 반송파의 특성들에 얹어서 보냄 3가지

여기서는 이름을 디지털 신호를 보낼때는 쉬프트 킹이라는 표현을 했는데 이제는 모듈레이션씀
구별을 함

진폭변조는 amplitude modulation 내용은 같음
내가 보내고자 하는 시그널이 있는데 나한테 주어진 대역폭이 이런 대역폭이 있다 그러면 결국 중간에 케리어 프리퀀시가 이 fc라는 값을 갖는 어떤 캐리어 시그널을 만들어서 캐리얼 시그널에 이 아날로그 시그널에 실어서 보내야하는데 amplitude 에 실어서 보내는 모양은 딱 이런 모양이 됨

이 케리어 시그널의 진폭이 내가 보내고자 하는 아날로그 시그널에 amplitude 값에 의해서 오르락 내리락 함
그렇게해서 만들어진 시그널이 모듈레이티드 시그널임
케리어 시그널이 있고 이것을 명확히 해보면
케리어 시그널이 있고 케리어 시그널을 변조시키는 시그널이 내가 보내고자 하는 메시지의 시그널임
이것을 모듈레이팅 시그널이라함
두개가 합성이 되서 변조된 시그널이 모듈레이티드 시그널임
모듈레이티드 시그널이 전송이됨
모듈레이티드 시그널의 피크포인트 쫓아가면 내가 보내고자 하는 메시지가 담겨져 있음

구성하는 방법은 오실레이터 이용
캐리어 시그널 생성 보내고자 하는 시그널의 멀티플라이 해서 만듬
이 시그널의 대역폭이 어떻게 나오느냐 얘기를 하는데 통신쪽에 가서 하는 부분이 필요함
간단하게 개념만 말하면 모듈레이팅 시그널 (내가 보내고자하는 시그널) 프리퀀시 도메인에서 보면 밴드위쓰가 B인 시그널이 나옴
시간 도메인에서 주어진 m(t) 푸리에 트랜스폼을 통해서 M(f)라고 하는 프리퀀시 도메인의 함수로 
이런 모양이 나오는데 바로 이 원점을 기준으로 - 프리퀀시 성분을 갖는 이런 그림도 나옴
이것은 푸리에 트랜스폼을 공식을 적용하다 보면 그냥 생성되는 가상의 부분임
푸리에 트랜스폼을 해보면 계층형 함수가 나옴
이 시그널의 대역폭은 이것이다 말을함 
밴스 위스가 b인 원래의 시그널이 m 시그널이 이렇게 푸리에 트랜스폼이 되다보면은 이 그 캐리어 모듈레이션 하다보면은 바로 우리가 지금 f(c)라고 하는 캐리어 프리퀀시 이놈 
캐리어 시그널에 모듈레이션 하면은 그만큼 쉬프트 된다고 했음
그래서 이놈이 그대로 오른쪽으로 fc만큼 쉬프트 되면은 이런 모양이됨
이렇게됨 
-도 따라옴

그래서 밴드위스가 결국 2b가 됨 (마이너스도 따라오기때문에 2배가됨)
b는 원래 아날로그 시그널의 대역폭을 애기했는데 amplitude moduation을 하면 2b가 된다. 
마이너스도 따라오다 보니까 
그래서 통신쪽에 보면은 더블 사이즈 밴드라고 
더블 사이즈 밴드 통신임 괜히 이쪽시그널(-)는 필요없는데 양쪽을 다 통신하는 구지 필요없지만 같이 실어서 보냄 넓은 대역폭에 실어서 보내면 이거에 개선된게 싱글 사이드 밴드임
잘라버림 이걸 구지 따라올필요없이 애는 필요없음 ( - 쪽인거같음)
대역폭을 요만큼만 필터를 적용시키면 애만 취함 사실 이속에 정보가 다 들어있기때문에 (오른쪽 부분) 얘는 필요도 없는부분(마이너스)
싱글 사이드 밴드 통신을 한다는것은 반만 쪼개 놓고 보냄 통신쪽에서 나옴
언급이 없음

이부분은 왜 두배가 됬는지 대역폭이 왜 두배가 되는지를 이해하기 위해서 이부분 설명함

일반적으로 우리의 음성이 5khz에 대역폭을 갖는다고 하면 여기가 5khz란 말임 
그런데 am 방송국에 할당된 대역폭은 10khz 그거에 2배정도를 준다. 
방송국간에 사이에 간격에 여유를 두고 5khz만 필요하지만 10khz, am 방송국마다 할당해준다 
각 방송국마다 자기에 할당 된 대역폭에 해당하는 케리어 프리퀀시를 생성해서 거기에 모듈레이션해서 am방식으로보냄

## fm
미부분은 주파수변조는 개념적으로 보면은 캐리어시그널이 있는데 주파수를 변조시킨다 캐리어시그널이 
내가 보내고자하는 아날로그 시그널의 진폭값이 맞춰서 얘를 주파수를 변조시키는데 진폭값이 키면 주파수값이 빨리 바뀌게 만들고 값이 작으면 천천히 바뀌게 만듬
이게 주파수 변조임
주파수를 살펴보면 내가 보내고자 하는 시그널의 정보가 들어있다.

fm도 같은 흐름으로 설명함
뒤에도 있지만 
우리가 시그널이 모듈레이티드된 시그널에 모양이 amplitude쪽은 우리 지금 관심이 없고 cos 쎼타 t라고 하자. 모듈레이티드 된것임 다시말해서 내가 모듈레이션 하고자 하는 것과 cos 함수가 결합이 된것임 
이게 페이스 모듈레이션 또는 프리퀀시 모듈레이션 된 이후의 모듈레이티드 된 시그널을 표현할때 이와같이 표현하는데 이속에 (pm, fm)

amplitude modulation은 이 속에 내가 보내고자하는 정보가 있는것지만

프리퀀시 모듈레이션/페이스 모듈레이션은 이속에 들어있음 이거 크게 보면 cos뭐다 이건 앵글임 각도임 cos 각도를 표현하는 변수임

페이스/프리퀀시 모듈레이션은 이 앵글속에 들어있기 떄문에 정보가 크게 묶어서 앵글모듈레이션이라고 부름
프리퀀시 모듈레이션과 페이스 모듈레이션은 다 두개묶어서 앵글모듈레이션이라고 함 
여기에 작용을 했으면 앰플리튜드 모듈레이션 
크게는 앰플리튜드 모듈레이션/ 앵글모듈레이션 두개가 있는데
앵글 모듈레이션 들어가며보면 프리퀀시 모듈레이션과 페이스 모듈레이션이 있음

이게 앵글임
코사인 앵글이, 코사인 함수가 
이런 형태로 계속 간다. 프리퀀시라는게 이 속에 어떤 모양으로 들어있냐면 
얘가 지금 한 주기, 여기서 여기까지 한주기 2pi, 여기도 2pi
프리퀀시가 가령 10이다. 10이다 라는 얘긴느 초당 2pi를 10번 지나간다 말임
요속을 들여다 보면 이 모양이 2pi를 프리퀀시 만큼 이 표현이 갖는 의미를 보자

쎼타 티를 보여하는데 앵글이라는게 시간당 fc라는 2pi를 지나감 
이시그널의 주파수가 fc라고 하면 
하나의 주파수가 한번 거쳐갈떄 2pi만큼 가니까 2pi fc만큼 앵글이 표현이됨
여기에 더하기 뭔가 face가 있음 제로에서 시작하는게 아니라 페이스가 있음
이 앵글을 페이스모듈레이션은 이부분이 페이스야, 이 전체가 앵글을 의미하는데 각은 몇도냐 요부분은 페이스 설명하는 부분

//페이스 모듈레이션은 이 페이스속에 n개가 들어있음
페이스를 대신 m(t)가 이 속에 있다. 거기에 어떤 계수 kp라고 하는 kpm(t)
앵글의 모양이 이렇게 구성될때 페이스 모듈레이션
앵글속의 페이스 파트속에 m(t)가 들어있음
이런 모양새가 됨

반면에 프리퀀시 모듈레이션은 앵글이 변하는 속도 각속도임
프리퀀시가 여기 들어있음 앵글을 미분을 하면 각속도가 나옴
앵글값을 계속 회전을 하면 한 회전을 할때 2pi인데 초당 몇번을 하느냐 이런식으로 주파수가 2pi를 계속 회전하는 것으로 보여주는데
프리퀀시라는건 앵글이 변하는 속도가 프리퀀시임

이렇게 나옴 미분하면 쎼타t를 미분하면 2pifc 그속에 프리퀀시의 성분이 들어있음
각도를 미분하면 각속도가 나옴 각속도라는게 프리퀀시임
2pi를 초당 몇번을 격어 가느냐 프리퀀시 정리임
쎼타 t를 미분을 하면 d쎼타t/dt 
2pifc 이속에 내가 m(t), 이게 주파수 성분인데 캐리어시그널에 비해서 
지금 생성된 주파수에 내가 이속에 m(t)를 넣겠다 이말이다.
이 앵글을 미분을 성분속에다 m(t)를 집어넣음 이게 프리퀀시 모듈레이션 이게 주파수임
이 앵글을 미분한 값이 주파수임(결과적으로..)
주파수속에 m(t)를 집어넣으니까 fm이 됨 
앵글 자체의 페이스를 나타내는 부분에 m(t)를 집어넣음 pm임
fm과 pm은이런관계를 갖음 이것을 쎼타t로 표현하면 
fm을 쎼타t로 표현하면 적분을 해야함 

이런 모양이 나옴
m(t)가 어디에 들어있느냐? 적분식속에 들어감
이것을 적분을해야 쎼타(t)를 구함 쎼타(t)를 표현하면 2pifct 뒤에부분은 그대로 적분하면 kf상수 나오고 m(t)가 적분이 되는 형태로 표현이됨
그모양은 ppt참고
쎄타(t) 라는 함수의 모양을 들여다보면
fm/pm 어떤차이를 보이는지 볼 수 있음
pm은 말그대로 m(t)가 위상, 페이스자리에 그대로 들어와
자기모양대로 들어와있는데
fm은 앵글의 페이스성분쪽에가서 보면 m(t)가 적분된 형태로 들어감
이런 차이가 fm과 pm의 차이임
그것을 나타내는 식이 ppt에 있음 
pm은 위상 자기자체 자기모양 그대로 들어가있는 반면에
fm은 이렇게 적분된 형태로 들어감
fm은 앵글을 미분한성분이 fm이기 때문에 거기에 m(t)를 집어넣으면 그것을 다시 앵글로 얻어내
얻어내면 적분할수밖에 업다. 그래서 적분된 속에 m(t)가 들어있으면 fm이다. 그런형태다.

## fm vs pm(2)
앵글을 미분하면 프리퀀시 성분이 됨
순간적인 프리퀀시인데 미분해보면 여기나옴
fm은 미분한 값이 프리퀀시고
그속에 그대로 온전하게 들어있음
페이스 모듈레이션 미분을 하면 이렇게 됨 오메가c가 2fc임
오메가c +
이것을 미분을 하면 2fc나오고 결국 여기는 미분한 값이 되어버림
프리퀀시로 바꿔보면 이게 앵글이고 
이걸 미분해서 프리퀀시로 얻어보면 pm의 경우는 얘가 미분된 이런 형태임
이 차이가 있음
요차이에서 중요한 포인트를 얻어내야함

fm의 경우 캐리어 시그널에 이만큼 m(t)만큼의 주파수 성분을 더함 m(t) 만큼의 주파수 가 더해져서 감 fc+m(t)만큼 pm은 캐리어 시그널의 주파수 더하기 + 내가 보내고자 하는 시그널의 미분 성분이 더해짐 
이게 다름 

m(t) 값자체가 프리퀀시에 더해지는게 아니라 m(t)의 미분이 더해짐
이그림을 다시 보자 

## 아날로그 신호 변조[계속] 그림만
fm의 경우를 보면
fm은 이 내가 보내고자 하는 시그널 자체값의 크기가 이 주파수를 변화시키는 역할을 함 이값이 크면 이 시그널 주파수 굉장히 큰 부분에서 굉장히 빠르게 변화시키고
값이 작은 부분에서는 천천히 변화시키는 역할을 하는게 fm임
pm은 이 값에 크기가 문제가 아니라 값의미분치가 주파수에 변화를 줌
값의 미분
pm의 경우에는 주파수는 값의, 내가 보내고자 하는 시그널에 미분값이 이 주파수 값을 변화시키는 역할을 함 그래서 같은 내가 보내고자 하는 m(t)란 시그널을 pm을 통해서 캐리어 시그널에 얹혀 보내면 이런 모양이 나오는데
아까 fm과 다르다.

## 위상변조

이 시그널을 보면 이 값에 미분치가 큰 부분은 요 부분임
미분이라는게 시그널의 변하는 정도를 말함 
이 시그널은 이 부분에 대해서 거의 변하는게 없음
매그니튜드는 크지만 미분치는 제로임
여기가 미분치가 큼 
미분값이 m(t)가 많이 변하는 부분에서는 모듈레이티드 시그널은 주파수가 높고 이런 부분은 미분치가 0에 가깝기 때문에 주파수 성분이 낮음 
미분 변하는 부분이 큰 부분 주파수 늘어남??
그 차이임

모듈레이티드 된 시그널을 보면 m(t)의 크기에 의해서 주파수가 변하느냐? m(t)에 미분값에 의해서 주파수값이 변하느냐 이게 바로 fm과 pm의 차이 
두개를 묶어서 말함
두개를 묶어서 앵글 모듈레이션 중에 pm과 fm을 앵글가지고 설명함

그러면 이제 대역폭도 여기서 볼 수 있음

## fm과 pm의 대역폭
fm으로 모듈레이티드 된 시그널에 대역폭을 보면 
m(t)가 대역폭에 큰 역할을 함
m(t)의 가장 큰 이값일때 전체 대역폭이 제일 크고
m(t)의 가장 작은 값일때 이 대역폭의 아래값이 나옴
모듈레이티드된 시그널의 대역폭을 보면 fc 주변에 어떤 대역폭을 가지고 있느냐 이 포인트와 이포인트가 각각 결정하는 것은 이 포인트는 fc값이 제일 클때 이값이 제일 크니까 주파수 성분이
이 주파수 성분이 가장 작게 되는 부분은 m(t)에 최소값이다. 
m(t) 최소값이 나왔을때가 주파수 성분이 얘가 됨
max m(t)가 있을때 이런게 나오고 minimum m(t)성분이 나왔을때 이값이 나오고 (그림이 있음)
fm과 모듈레이티드 된 시그널의 주파수 대역은 m(t)가 좌우함
주파수 크기를 말함

정확히 m(t)가지고 표현한다기 보단 정확히 들어가보면 주파수의 fm의 모듈레이티드된 주파수대역폭을 보면 이와같이 되어있는데 2b 곱하기 ??? 유도된 과정을 들여다 볼 필요없음

우리는 단지 이 대역폭을 나타내는 이 식 속에 내가 지금 보내고자 하는 m(t)라고 시그널의 맥시멈 성분이 여기 들어있다 라는것을 인식해야함
모듈레이티드된 시그널에 대역폭에 지대한 영향을 미치는게 바로 내가 보내고자 시그널의 맥시멈값임
맥시멈값, 미니멈값 이런 값들이 이 대역폭에 지대한 영향을 미침
그런 값들이 여기에 들어있느냐 이 베타 라는 변수속에 들어가있고 이부분이 베타라는 부분이 여기 들어가있음 

전체 대역폭에 영향을 미치는건 바로 m(p)라는게 있음 k는 상수 
대게 이 값이 베타가 4정도 된다고 봄 적정한 값이 
4면은 여기가 5가 되고 10배가 된다. 밴드위스가 10배 원래 아날로그 시그널 m(t)가 가지고 있던 대역폭의 10배 정도 대역폭 필요하는게 fm이다.

똑같이 

## 아날로그 신호 변조[계속]
실제 fm 방송국에는 이것에 10배 되는 150kHz 필요함
나라는 200kHz주면 할당된 캐리어 프리퀀시를 이용해서 거기에 모듈레이션 해서 보냄
fm 방식으로 보냄
대역폭이 더 넓기떄문에 
am에서는 5khz 대역폭 을 써서 ???신호 만들었는데 여기서는 15khz 만들어놓고 소스를 200khz 대역폭을 보내니까 fm 방송이 훨씬 음질이 좋음

fm은 어떻게 구현하느냐 
fm은 이 주파수속에 m(t)가 들어간다는데 어떻게함?
이 장비가 하나 있어야함
볼티지 컨트롤 오실레이션 얘는 들어오는 신호 여기에 cos 함수가 발진이 되면 이 속에서 자체 생성이 되고 있는데 그 cos 캐리어 시그널의 프리퀀시가 인풋으로 들어오는 시그널의 매그니튜드 값에 의해서 이 주파수가 조절이 되는 장치임 
이게 바로 fm임
내가 보내고자하는 시그널의 값이 크면 주파수가 빠르게 작으면 주파수가 작게

vco가 요 m(t)를 인풋으로 받아서 자체 생성된 케리어 시그널의 주파수를 얘의 매그니튜드에 의해서 조절을 함 
fm 모듈레이티드된 시그널을 만들어냄 

밀접한 관계는 어떻게 구현되느냐?
m(t)의 크기에 의해서 주파수가 조절되는게 아니라, m(t)의 변화률 미분치에 의해서 조절이 됨
그래서 vco에 인풋으로 집어넣을때 m(t)를 그대로 집어넣는게 아니라 얘의 미분 값을 집어넣음
미분값을
미분기가 여기에 하나있음
내가 보내고자 하는 m(t) 시그널을 미분해서 미분된값을 vco의 인풋값으로 집어넣으면 미분된값이 크면 주파수 커지고 미분된값이 작으면 주파수작아지는 형태로 모듈레이션한게 페이스 모듈레이션임


그래서 미분기가 있고 없고가 fm과 pm의 차이임
아울러 페이스 모듈레이션에 의해서 만들어진 시그, 모듈레이티드 시그널의 대역폭은 fm과 비슷한 모양임 
2(1+베타)B 

주파수속에 주파수 대역을 나타내는 뭐가 또 영향을 미쳤냐? 
FM에서는 이 모듈레이팅 시그널의 크기가 영향을 미쳤는데 페이스 모듈레이션에서는 이 시그널의 미분값이 대역폭에 영향을 미침
미분값이 frequency에 들어가기 때문에 
이속에 들어나지 않은 B라고 하는 변수 속에 분명히 이 m(t)성분이 여기에 반영이 되어있어야함
베타속에 미분값이 들어가있음

m(t)가 자주바뀌면 미분값ㅇ ㅣ클테고 대역폭 커짐
모듈레이티드 된 시그널

베타 모양은 책에 안나옴 미분치가 어떻게 반영되기 위해서는 베타 부분봐야함
시그널의 미분값이 주파수 영역 pm 시그널의 절대적인 크기 대역폭에 영향을 미치는게 fm
구별을 함

5장 끝

## 6장
밴드위스를 좀 효율적으로 쓰자
멀티플렉싱 방법과 효율적 반대인 spreading 방식 이 있음
두가지 밴드위쓰 방법
멀티플렉싱(다중화) spreading(확산)

다중화 여러개 하나로 묶어서 보냄
확산 더 넓혀서 보냄

## 용어
bandwidth utilization : 나한테 주어진 밴드위쓰를 현명하게 사용하는 방식 말함
효율은 멀티플렉싱에 의해서 내가 얻어낼수 있음
멀티플렉싱말고 스프레딩은 효율보다는 
어떤 침해를 방어하기 위해서 spreading 씀
두가지가 상반되는 개념

spreading 효율이 떨어지지만 privacy 보안 위해서 어쩔 수 없이 사용

## 멀티플렉싱
두개의 디바이스 사이에 데이터를 주고받을 수 있는 미디엄이 그 디바이스 필요에 비해서 훨씬 더 큰 밴드위쓰를 내가 가지고 있다고 하면
내가 누군가 통신을 하고자 하는데 전화통화를 부산에 누군가와 전화 통화를 하고자 하는 사이에 주어진 대역폭이 대역폭이 엄청클텐데 남들과 share 하면 더 효과적이지 않냐?

공유될 수 있음 멀티플렉싱 개념은 어떤 기술인데 동시에 여러개의 시그널이 하나의 링크를 동시에 사용해서 전송하는 방식을 멀티플렉싱 방식임

## 종류
멀티플렉싱방식으로 주파수 멀티플렉싱
주파수 분할
파장 분할
동기시분할
통계시분할

멀티플렉싱 그림으로 보셈
통신을 위한 메디엄이 엄청 큼 여러명이 공유해서 쓰면 좋겟다!
공유하는 방식을 말함
보내는 쪽을 멀티플렉서 받는 쪽 디멀티플렉서임
링크 하나에 
라인 여러개일텐데 
여러 개 링크로 들어오는 데이터를 링크 하나로 내보내기 위해서 집약시키는 장치 멀티플렉서
하나의 링크를 여러개의 링크로 나누는 디멀티플렉서

채널의 개념
n유저가 하나의 링크를 사용한다면 각각의 유저별로 할당된 몫이 채널이라고 함
링크는 하나지만 채널은 n개가 있음
용어설명
다중화 범주에 멀티플렉싱 3개
타임 디비전은 2개가있음

## 다중화

## 주파수 분할 다중화
빨간글씨로 프리퀀시 디비전 멀티플렉싱
주파수 나누는 개념의 멀티플렉싱
파장을 다른 파장을 이용해서 같은 미디어 공유하는 방식이 아날로그 방식
타인 디비전 멀티플렉싱은 디지털방식이다.

주파수 나눠서 보내는건 
fm이나 am이나 프리퀀시
서로 대역폭을 이용해서 동시에 공유함
실제 유선이라 할지라도 유저별로 서로 다른 채널에 대역폭 할당 하는방식
fdm은 

## fdm 처리 과정
동일한 대역을 필요로 하는 소스라고  할지라도 서로 캐리어 프리퀀시가 서로 다르면 서로 다른쪽에 시그널을 옮겨놓게됨
그래서, 모듈레이션된 시그널이 이렇다하면 얘들은 서로 다른 대역폭에 자리를 잡고있기때문에 서로 간격없이 더해져서 통신을 할 수 있음 얘들은 다합하면 이런 모양이 되겠지만 이속에서 다시 받은쪽에서는 내가 취하고 자 하는 그주파수 대역폭에 맞춰서 튜닝을 하면 그놈만 뽑아낼 수 있다. 
모듈레이션 수행됨

필터라는게 내가 지금 채널을 맞췄다. 특정한 용도의 대역폭이 어디에있느냐 자기에 맞는 대역폭을 취했다 라는게 필터로 표현이됨
필터로 표현이 되면 그 시그널을 잡아내서 다시 디모듈레이션을함
디모듈레이션 과정을 보여주는데 m(t)를 모듈레이션 하는 과정은 m(t)와 cos 오메가ct 캐리어시그널을 곱한거였고 이게 모듈레이션 하는 과정이었고
디모듈레이션하는것은 내가 지금 받았는데 coswct를 받았는데 다시 coswct를 한번 더 적용시키면 삼각함수에 의해서 1/2(m(t) + cos 2 wct) 저번에 한거임
디모듈레이션 하는것은 얘를 m(t)를 끄집어 내면댐
cos 한번 더 곱한것에는 m(t)만 떨어져 나가져 있다 이와같이 
처음에 보낸 시그널을 cos 함수 두번 적용한뒤에 디모듈레이션 하면 끄집어 낼 수 있다.

요부분에서 이작업을 함 

예제6.1은 살펴봐라
똑같이 3명의 가입자가 링크 하나를 같이 쓸려고함
당연히 fdm을 쓰면 서로 다른 대역폭을 활용해야함
대역폭이 4khz라고 하는 똑같은 대역폭을 갖지만 모듈레이션할때 서로 다른 자리에 가도록 케리어 프리퀀시를 서로 다른것을 쓰면 이런 모양에 다른 자리에 시그널들이 가있다.

더하면 이런 모양이 됨 
프리퀀시 개념에서 살펴본 그림임 서로 다른 대역에 가서 다시 밴드패스 필터를 통하면 각자 자기자리에 있는놈만 끄집어 냄 

cos 함수 곱해서 디모듈레이션 하게 되면 다시 원래의 시그널이 복구된다.

## 예제 6.2
이그림은 
타임 도메인에서 살펴본다.
타임 도메인은 전송되는 시그널은 복잡한 모양인데 
이것을 프리퀀시에서 살펴보면 이모양이됨
프리퀀시 도메인에서는 명확히 3개의 시그널이 서로 다른 채널을 통해서 날라가고 있는 모습을 개념적으로 보여줌
주파수 평면에서 시스템에서 해석하는게 용이한 케이스를 보여줌
똑같은 그림인데 앞은 타임도메인
이것은 프리퀀시 도메인에서 보여줌

100khz 5개를 보내는데 100khz 만 할당받으면 곤란하고 사이에 10khz정도의 간격을 허용해야 된다. 5개의 100khz 보낼때 10khz 간격을 유지할려면 540khz가 필요하다.

간섭이 없어야함
겹치는 부분을 방지하기 위해서 대역폭 을 띄어서 하게끔 멀티플렉싱 이와같이 하면 정확히 할 수 있음 간섭을 일으킬 수 없음

## 6.3
4개의 채널이 있음
1Mbps
채널이 1MHz로(밴드위스가) 4개의 1Mbps 를 4Mbps를 소화해내봐야함
4개의 디지털 채널이 있고 1Mbps짜리 
채널을 fdm한단 얘기는 4개로 나눠줌
소스를 1Mhz를 4개로 나누면 하나당 250khz 대역폭밖에 없음
대역폭은 250khz인데 각각의 소스는 1mbps다.
신호 엘리먼트가 하나가 4개의 비트를 운반해줘야함
bit rate 는 1M인데 250khz밖에 소스밖에 없음 각각의 소스가
한 시그널 엘리먼트가 4bit를 소화할려면 qam 적용한다면 16qam이라는 모듈레이션 방식을 써서 디지털 데이터를 아날로그 바꿔야 하는데 16qam의 방식의 모듈레이터를 미리 적용해야함
한 hz가 4bit를 의미의 정보를 가져야 하기때문에 r=4가 되어야 함 
16qam 모듈레이션 방식을 써서 회로도 그려보면,
이런 모양으로 멀티플렉싱 해야함
1m 짜리 들어오면 16qam 방식으로 (ask+pask) 아날로그 신호로 바꿈 
케리얼 시그널에 집어넣음 아날로그 신호를 각각 대역을 달리하는 250khz 대역폭에 집어넣서 멀티플렉싱함 
qam을 적용하는 사례가 하나 나옴 

16qam이 왜 필요한지 설명
한 hz가 4bit를 의미의 정보를 가져야 하기때문에 r=4가 되어야 함 
16qam 모듈레이션 방식을 써서 회로도 그려보면,
이런 모양으로 멀티플렉싱 해야함

## 주파수 분할 다중화
멀티플렉싱한것을 또다시 이놈을 여러개 묶어서 멀티플렉싱 가능
그때마다 한 링크마다 용량이 증가한다.
4khz 
48 khz * 5 = ? * 10 2.5mhz
하나의 링크가 감당하는 대역폭이 커지는 방향으로 감
케이블 재질이 좋아져야함
서울에서 부산까지 일일이 전화를 연결해야하는데 동네에서 묶고 동네를 묶어서 구 단위 전화국 묶고 구단위 전화국에서 서부 동부 다시 큰 단위로 묶고 
혜와동 시외전화기 전체를 다묶어서 부산까지 한줄만 감
몇천개임
3600 개의 보이스 채널을 한줄로 3600개의 채널을 수용할 수 있는 한줄을 부산까지 끌고간다. 이게바로 멀티플렉싱의 효율임

예제는 보고

## 파형 분할 다중화
광케이블에서는 빛으로 보내는데 시그널을 빛으로 보내는데 빛의 여러가지 파장을 묶어서 보냄
파장이라는게 주기하고 비슷함
파장이 긴놈이 있고 짧은놈이있고 더 긴놈이 있고 이놈들의 
이놈들의 색깔이 다름
파장이 서로 다른 정보들을 하나로 묶어도 갈데 섞여보이지만 프리즘을 에로 들면
각도 달라하면 하나로 묶어서 프리즘을 통하면 각자 자기가 나가는 각도가 다름
프리징을 가지고 멀티플렉싱 디 멀티플렉싱 생성할 수 있음

파장 분할

역시 아날로그 멀티플렉싱이고 광전송에 활용되는 방식임

## 시분할 방식
동일한 라인을 주파수로 나눈게 아니라 시간을 나눠서 쓴것임 시간을 1/4씩 씀
그것을 계속 반복함
이게 하나의 프레임이 됨
프레임에 첫번째 채널 내가 쓰고 
시간에 비효율적인 모습을 보이지만 사람이 쓰기엔 비효율적이지 않다.
채널이 작은 간격임
동시에 쓰는것같은 생각을 할 수 있음.

tdm은 디지털멀티플렉싱인데 여러개의 저속도의 소스를 고속의 라인에 각 채널에 집어넣어서 보내는 방식임
시분할 얘기가 긴데 

이와같이 3개의 소스가 있다고 하자.
파란,노란,빨간
이 길이가 중요함 이 t라는 시간동안 이만큼의 양 이 멀티플렉서를 통해서 멀리 전송되는 동안에 소요되는 시간은 역시 t만큼 소요가 되야함 이만큼의 데이터가 전송이될때 t만큼의 시간을 써서 전송해 줬으면 나는 누구랑 공유했건 아무 상관없다.
내가 들여다 보내는 만큼 여기서 이만큼을 보내주면은 내가 남하고 share해도 아무런 피해가 없으니까 개의치않는다.
마찬가지로 모든 유저들이 
이만큼의 양을 멀티플렉서는 3명을 동시에 수용해줄려면 
이만큼의 양을 t/3동안 처리해줄 수 있어야 이 라인이 얘들을 만족시켜줌
하나의 프레임 이 형성되는데 프레임속에 파란색 이만큼 처리해주는 시간이 t/3 
이 노란색도 t/3 전체가 t가 됨
t 동안에 파란색 입장에서 이만큼이 처리가 됨 채널속에서
두번째론 여기로 처리되고 세번째는 여기서 처리됨
띄엄띄엄 날라가는것처럼 보이지만 얘입장에서 얘가 이만큼 생성되는동안에 처리되는것이고
이시간동안에 처리되는것이고 나는 간격을 못느낌 단위가 하나하나가 다 t이기 때문에
이게 가능할려면 이 라인이 3배가 빨라야 함
이만큼을 처리하는 시간이 이 링크에 비해서 이링크가 3배가 빠르면 같은 양을 처리하는데 1/3시간만 든다.
이 링크는 각각의 링크의 3배속도를 가지고 있어야함
10명을 수용할려면 10배 빠른 링크가 있어야함(왜냐하면, 멀티플렉싱 되기전에는 따로 가니까 n*T만큼 걸리고 이게 모여서 쭉 나열되면은 그 배의 속도에 맞게끔 T가 유지되어야 함)

각각의 t/10만큼 소요됨
이거 하나하나를 프레임이라고함

링크는 n개의 소스를 수용하려면 n배만큼 빨라야한다.
이걸 처리하는시간은 1/n만큼 필요하다. 처리하는시간 말하면

## 6.5
이걸 응용하면 여러문제가 나옴

그림에서, 데이터 rate이 각각의 채널이 1kbps임 
초당 1000bit가 들어옴 그런데 한 비트씩 멀티플렉서 된다. 
이 양이 얼마큼씩을 프레임을 나누는데 각각에 유저에게 할당된 채널속에 얼만큼씩 가지고 와서 프레임을 만드느냐
여기서 한비트 한비트 가지고 온다고 하자
이게 경우에 따라서 1byte씩 넣어서 프레임 형성할수도 있고
이문제에서는 1bit씩 가지고 와서 프레임을 만들자
만드는 경우임
어떤 소요시간을 물어봄
각 input slot(slot은 프레임에 넣을 대상이 되는 요 한덩어리에 시간이 얼마나 되느냐)
input에서 이 시간이 얼만큼이냐 1 bit라고 하면 
1bit씩 넣기로했으니까 한단위가 한비트임
한비트가 차지하는 시간은 이 라인이 1kbps라고 했음 초당 1000개
하나는 차지하는 것은 1msec 됨

이프레임에서 차지하는 시간은 얼마나 되야하나? 1/3msec 가 되어야함
여기도 1/3 1/3msec 토탈 1msec가  되어야함
이 1msec 에 한비트 처리되는게 여기서 보면 1msec 에 한비트 처리
전혀 지체될게 없다. 
그렇다면 각 채널에 시간은 소스에서는 1msec 인데 프레임에서

링크에서는 하나의 채널 길이는 1/3msec 여야 하고 프레임의 길이는 1msec가 됨
물어보는게 이 example임
input의 각 slot의 길이, output의 각 slot의 길이 그리고 frame의 길이
각각
1msec, 1/3 msec 다시 1msec 이렇게 됨
(교수님 input의 각 slot의 길이는 멀티플렉싱 되기전에 하나의 링크로 들어가는 부분인가요?)

이런질문들이 많음

응용문제가 계속나옴
이렇게
4개의 1Mbps 소스가 있음
이것을 프레임 한 bit씩 가지고옴
시각적으로 보여짐
1Mbps 4개로 묶어서 한 프레임으로 묶는데 맨 앞에 있는걸 묶어서 두번째꺼 묶어서 한프레임
각각의 input에서 1bit 듀레이션 output 링크에서의 1bit 듀레이션 얘의 비에서 1/4
아웃풋 빗 레잇은 
아웃풋 링크의 빗 레잇은 (bit rate) 1msec 가 필요함 얘는 1/4msec
한비트가 1/4msec 얘의 속도는 한 비트당 1/4msec니까 그것의 역수는 4Mbps 합 (계속 역수로 생각할까?? ....)
프레임의 속도는? 몇프레임퍼세크냐?
프레임은 초당 1Mbps 4개를 수용하는 이 프레임은 초당 몇개씩 처리가 되어야하나? output에서 프레임 하나당 1bit씩 처리되야 하는 속도가 그대로 여기서 유지되어야한다.
1bit는 초당 100만개가 처리되어야함(들어가는 라인인거같은데..?) 1bit가 처리되는 프레임도 초당 100만개가 처리되어야함
그래야 프레임 초당 100만개 처리
bps로바꾸면 프레임당 4bit니까 400만 bps가 됨 

## 시분할 다중화
채널에 집어넣는 구현하는 방식을 소개하는 장임
어떻게 집어넣냐
뱅글뱅글 돌아가는 스위치가 하나 있어서 1/3 시간동안 얘한테 열어주고 1/3 시간동안 얘한테 열어주고 1/3시간동안 얘한테 열어주면 한프레임을 채움
그걸 뱅글뱅글 돌면서 프레임마다 한바퀴를 돈다.
얘와 정확히 싱크가 맞아야 되는 것이 디멀티플렉싱쪽에서 정확히 얘 시간동안만 열려서 일로가야하고 얘 시간동안만 열려서 일로 가야하고 이렇다. 
1/3 씩 돌아가면 얘도 1/3씩 각각의 채널에 열려져있어야 하는 식으로 싱크가 맞아야 가능함
그래서 이것을 싱크로나이즈 타임디비전 멀티플렉싱 이라고함

동기식 타임디비전 멀티플렉싱

## 6.8
4개의 채널이 이걸 
4개의 채널이 또 멀티플렉싱
각각이 100 byte per sec 씩 들어옴
100 byte 씩 들어옴
프레임을 묶는데 각ㄱ 채널별로 각 소스별로 1byte씩 묶어서 프레임을 만드는 사례
여기서 1byte 프레임이 4byte이 하나의 프레임으로 만듬
들어오는쪽이 초당 100 byte 들어오면 각 소스입장에서 1byte 
프레임이 처리되는 속도는 초당 100개 그래야 서로 초당 한 바이트가 처리됨
초당 한바이트가 들어오고 있는데 초당한바이트가 나가게 됨
프레임이 초당 100개가 나가야댐
100개 프레임 이니까 100 프레임 per sec
프레임하나당 4byte = 32bit 
100프레임 * 32 bit 가 초당 날라가니까 3200 bps가 라인이 
이 라인이 3200 bps임 
프레임 듀레이션 = 프레임이 하나 차지하는 시간은 1/100 초 임
이런 디테일한 시간 값들을 물어보는 문제임

## 다른형태 문제
100kbps 짜리 4개가 있는데 프레임을 만드는데 각 소스로부터 2비트씩만 가지고 온다.
8비트 짜리 프레임을 만들면 또 이 물어봄 
프레임이 초당 몇개가 처리되어야 하느냐? 100 kbps 처리되어야함(땡인듯) bps를 물어보는건가?
프레임 하나 처리되어 봤자 각 소스는 2비트 밖에 처리가 안됨 
각 소스가 2비트를 생성해내는 동안에 프레임 하나가 날라가야댐 
그러면 각각 2비트 처리되는 시간은 초당 100kbps 니까 2비트면 한 비트가 1/100,000 걸리니까
2bit면 1/50000
1/50000초만에 프레임 하나가 
일초에 5만개의 프레임이 처리되어야 함 


그렇게 알고나면 1/50000 p sec 인데 각 프레임당 8비트니까 곱하면 이 아웃풋 링크의 스피드가 나옴 400kbps임 
당연히 아웃풋의 스피드는 얘들의 합임 400kbps임
책에 예제가 있으니 풀어보셈 간단하니까 (중요)

## 시분할 다중화
한 비트 멀티플렉싱에 단점 
단점은 채널이 있어서 각각 자기자리가 있어서 좋은데 이렇게 보낼게 없는 경우는 비어서 보냄
계속 보낼 데이터가 있으면 좋은데 두번째는 빈 상태임
그자리는 계속 비어서 감 시간 낭비가 많음
저런 문제를 개선하는데 뒤에 나옴

제목 잘 보셈
시분할 다중화가 저런 틈새가 생길 수밖에 없다.

## 데이터율 관리
예제가 스피드가 다 똑같았는데 다르면 어떻할꺼임? 인풋 스피드가 다르면 멀티플렉싱을 어떻게 할거냐? 쉬운 케이스만 
다른놈만 40이고 혼자만 20이면 애당초 두개를 묶어서 40을 만든다음에 동일하게 40을 만들어서 보냄

다단계의 다중화

하나가 50이고 나머지가 25다 그러면 이 50짜리를 두개로 나눠서 디 멀티플렉싱 25로 두개로 만든다음에 25kbps 5개를 묶어서 보냄
애는 채널을 2개 받음

숫자가 애매한 경우는
둘은 50이고 하나는 46이다 그러면 얘를 억지로 더미 데이터를 넣어서 50kbps 만들어서 보냄
쓸대없는 데이터를 채움

## 시분할 다중화
프레임과 프레임 사이에 이제 동기화 보내는 쪽에서 열심히 프레임 만들어서 보내고 받는쪽에서 프레임을 받아서 디멀티플렉싱을 해야 하는데 혹시 동기가 안맞을것을 대비해서 동기화를 
동기가 안맞으면 엉뚱한 채널을 뽑아내게 되어이음
동기를 맞추기 위해서 여기가 프레임에 시작이다 정보를 프레임마다 하나씩 주는게 현실적이다
프레임 동기화를 위해서 각유저부터 채널 채워넣는것만 보여줬지만 이제는 프레임 별로 한 비트씩만 추가하는 모습을 현실에서 이렇게함
동기화를 위한 패턴이됨
10101.. 이런식으로 반복, 반복되는 식으로 이 데이터가 들어가 있어서 
바로 요놈들을 체크하면서 받은 쪽에서는 프레임에 시작이다. 
라는것을 알고 이때부터 이 동기화를 놓치지 마라 이거임
한비트씩 추가됨
한비트씩 추가되니까 그러면 이제 아까 반복됬던 문제가 약간 변형됨
한비트 추가되는식으로 되다보면 

## 6.10
4개의 소스가 있는데 각각 250byte per sec 짜리 4개 소스가 있음
근데, 추가시키는데 각각의 소스로부터 1byte씩 가지고 오고 하나의 싱크로나이즈 비트를 추가한다 이거다. 한 프레임 사이즈는 4개 소스니까 각각의 소스로부터 한바이트씩 가지고 오면 4바이트가 되고 더하기 한비트 짜리 동기를 맞추기위한 한비트짜리 추가됨
그러면 한프레임에 사이즈는 33 bit가 됨(32bit +1)
그런상황에서 소스에 데이터 rate는 250 캐릭터 퍼 세크면 곱하기 8 해서 2kbps가 나옴
소스에 bps 이렇게 됨 소스에서는 각 바이트가 차지하는 시간은 초당 250 byte니까 1/250byte 임 소스에서는 차지하고 있음 
프레임 레잇은 프레임은 초당 250 byte?????

몇개의 프레임이 처리되어야 하나 초당 250개
한 프레임은 각 소스별로 한 byte밖에 처리를 안해주는데 각 소스는 초당 250개를 캐릭터를 생성함 프레임이 이 속도를 전혀 지체를 시키지 않고 다 처리할려면 한 프레임이 1byte 밖에 처리를 못하니까 소스별로 프레임도 초당 250개가 날라가야한다. 초당 250개 (1byte가 중요)
(이거중요)

스스로 해야함
프레임당 
프레임 레잇은 250프레임 펄 sec가 되어야 함 
한프레임에 소스별로 1byte 밖에 처리를 못해주니까 
프레임에 걸리는 시간은 1/250초 임 프레임이 1/250초임
구해본 값들이 

한 프레임이 1bit 싱크 더하기 4byte 해서 프레임당 
4개의 소스로부터 1바이트씩 가지고 오고 싱크 bit 하나 추가를 하면 33 비트가 됨 
이게 펄 프레임임 
근데 프레임은 250프레임 펄 세크로 처리가 되어야 해 왜냐하면 각 소스로부터 한 바이트 씩밖에 안가져오니까 소스는 250 바이트를 계속 생성해 내니까 250 프레임이 처리가 되줘야함

프레임당 차지하는 시간은 1/250초임 (1초를 기준으로 봐야함)
이래야 1초에 250개가 날라감
각 프레임에 몇비트냐 33비트임 그러면 output link의 스피드를 맨 마지막에 물어봄 링크의 스피드는 링크는 초당 250개의 프레임을 처리해야하는데 프레임별로 33비트니까 곱하기를 하면 아웃풋 링크의 스피드가 나온다. 250개의 프레임을 초당 처리해야 하고 각 프레임별로 33비트니까 곱하기를 하면 얼마가 나오냐면 아웃풋은 33*250 하면 되겠지 뭐

지금 프레임당 33 비트임 그런데 아웃풋 링크의 처리되는 스피드는 초당 세크당 250 프레임이 처리되어야함 곱하면 33*250 단위는 bit per frame * fram per sec 
bit per sec가됨
초당 bps 가 됨 

단위를 확인해봄

fdm도다중화, 멀티플렉싱을 대위적으로 채워나갔듯이 tdm도 다중화를 해나가고 있음
이게 24 채널을 묶어서 보이스 채널 하나를 ds0라고 디지털 시그널 0
이걸또 여러개묶어서 ds1 ,2 ..

ds라는 이름은 서비스 이름
통신망회사에서는 규격에서 부르는 이름이 있음
T-1 라인 보이스 채널 24개를 멀티플렉싱 라인이 T-1 라인
T-2 라인은 T-1라인을 4개로 묶어낸게 T-2라인(96개)
T-3 라인은 7개로 묶어서 672 보이스 채널이 나옴
이걸 8개 다음 T-4라인
이 규격들은 전세계 공통임

멀티플렉싱된 라인들을 갖고 서로 네트워크가 어떻게 구성되는지를 표현을 함
T-1 라인이 몇 메가 bps인지 살펴보는게 중요함
24개의 보이스 채널로 묶으면 1.544 Mbps 나온다.

음성은 4khz 대역을 쓴다고함
디지털화 하려면 4khz 시그널을 샘플링하면 나이키스트 법칙에 의해서 8khz로 샘플링하고 
8kh로 샘플링을 하고 곱하기 샘플한값을 8비트로 퀀타이제이션을 하면 
8*8=64kbps가 나옴 
보이스 채널 하나가 64kbps다.
64kbps를 24 채널을 쓰면은 1.544가 나오나? 1536이 나옴
T-1 라인이 보이스 채널 24개를 묶은거라고했는데 단순히 64kbps를 24개로 묶으면 저것보다 작은값이 나옴
1.544 나오게 하냐면 24개가 있으면 tdm 을 묶음 
각 소스별로 프레임을 형성하는데 1byte씩 프레임을 형성하고 거기에 한비트 싱크를 추가한것이다. 각 소스별로 샘플 하나가 8bit니까 샘플 하나하나 해서 24개의 유저로부터 한 바이트씩 가져오고 싱크 한비트를 붙여야함 
각 유저당 이 샘플을 몇번을 하냐면 초당 8천번을 해야함 한 샘플만 프레임이 한 유저 입장에서 한 샘플만 처리하니까 프레임이 전체 초당 8천개가 처리됨

프레임 별로 사이즈 보면 8bit * 24 +1 = 193 bit가 초당 8천번 반복되어야 하니까 * 8000하면 1.544 Mbps 숫자가 나옴  (나이키스트 샘플링 8천)
T-1 라인 규격은 1.544 Mbps 의미하는 라인이다. 퀄리티가 형성
T-1 라인은 24개의 보이스 채널을 묶으면 1.544Mbps 
그중에 싱크를 위한 1bit 씩 프레임별로 추가되기 때문에 단순히 이런 계산하고는 다름

유럽에서는 30채널로 묶어서 E-1으로 씀
한번 해보셈 위에예를 적응해서 한번해보자.




>>>>>>> 8d334e4eff8cbd578d7c93991ebfca0d87a0ffe7
