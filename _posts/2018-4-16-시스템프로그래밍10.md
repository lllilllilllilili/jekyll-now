---
post : layout
title 시스템프로그래밍10
---
## 시스템프로그래밍10
시스템프로그래밍10

## Open Files
flag 파일의 모드
이번에 하는 file 디스크립터 I/O는 이전에는 file standard I/O library를 했었다. 이건 I/O가 아니라 커널에서 직접제공하는 I/O를 파일 디스크립터 I/O라고 한다. 커널 API가 된다.

access permission은 파일을 오픈하는데 없으면 만들라는 옵션일수있다. 만들라하면 모드중에 read / write 할 수 있고 신호를 줄수있다.

## Access Modes(flags)
O_EXCL은 파일이 이미 존재하는데 새로 만들려고 하면 error을 return 한다.
O_TRUNC 
O_SYNC 디스크 I/O를 줄이기 위해서 커널이 page cache를 쓰는데 디스크 write하더라도 메모리의 버퍼에 캐시에 남아있게된다. sync 옵션을 주면 write시 직접 디스크까지 가라는말. 디스크 I/O 많아지는 단점이 생긴다.

## mode: access permission at creation
실행시 유저 id 설정

파일의 set user id offset이라는것은 다음 학기 os 마지막시간에 파일의 고어 관련된 것이기때문에 지금은 설명할 수없다.
앞에 3개는 그냥 넘어감

밑에 있는거 몇개가 되었던지 간에 결국은 owner가 read/write execute 권한을 주는 옵션들이다. OR로 주면된다.
owner read / write  주고 싶으면 해당되는것을 각각 or해서 파일을 만들때만 해당한다.
aceess permission은 이미 존재하는 파일에 주는게아니라 없는 파일에서 생성할때 해당한다.

## File Close

## Open Example(1)
File * 를 주는것은 파일 오픈시 standard I/O Library 에서 썻던것이다  파일 디스크립터는 커널의 파일 api를 직접쓰는것이다. 
파일 open하면 커널 api를 주는것이고 standard I/O Library는 open대신에 fopen을 사용했다. 

프로그램 이름외에 아규먼트가 하나가 더 들어와야한다. 파일 이름이 하나 들어올것이다. 

여기서 open했단것은 커널의 api를 써서 파일 디스크립터 I/O로 오픈했다는것이고 아규멘트벡터1이 파일의 이름, O_RDWR는 read 모드와 write모드로 오픈해라 말이고 or O_CREATE는 만일에 파일이 없으면 만들어달라 라는 말이다. 파일이있으면 O_TRUNC 파일을 다 클린업 한뒤 거기다가 오픈해달라는 말이다. 뒤에있는것은 파일을 만들적에 대비해서 S_IRUSER|S_IWUSR은 owner가 read를 할 수 있고 write를 할 수 있다. 그런 모드로 파일을 만들어달라. 뒤에 알규먼트 or들은 파일을 만들때만 해당한다. (mode시에 open의 형식을 보면 잘 나타나있음)
(뒤가 creation 붙어있음)

왜냐하면, creation option이 들어갔으니까!
파일이있으면 그대로 read write로 open하고 파일이 없으면 파일을 만들고 만일에 파일이 존재하면, 다 날려버리고 새로해라. 
open시 fdo를 하는데 몇번이 return이 되냐!
3번이 return이 되냐(0,1,2 이미 있음)
그게 파일 디스크립터다.

fdo 파일을 오픈하고 fdopen한다는것은 재오픈한다는 말이다. fpo는 standard I/O library에서 쓰는것이다. 파일 디스크립터로 오픈한것을 내가 standard I/O library를 써서 access를 하고 싶다면 다시 오픈해도 된다. 말이다.
fdo를 써도 되고 standard I/O library에 fread나 fwrite쓸려면 안에 fdo 써서 커널 api로 오픈한것을 재오픈할수가 있다. r+는 read 또는 write를 하겠다.
커널 api와 standard I/O library를 왔다갔다 할수있다. 

fpintf는 standard I/O library 다. 그래서 fpo를 쓰고 있다. ++좋은예제는아니다.++

## File creation
access permission, 아까랑 같다. open할때도 만들수있었는데 직접만들어라 이말이다. 만드는것이니까 ++파일의 이름을 주고++ mode는 유저는 읽을수있다 쓸수있다. 그륩은 읽을수있다 쓸수있다.준다.

## Seeking
lseek가 현재 r/w offset을 원하는 위치로 바꾸고 그위치에서 파일을 접근할수있도록 한다.
standard I/O library에서 랜덤 access하는것을 fssek 였는데
커널이 제공하는것은 lseek다. 디스크립터만 다르고 offset은 파일의 r/w offset을 어디로 옮겨라 할때 그 offset이 된다. 

seek_set : 파일의 처음 기준으로부터 offset만큼가라
seek_cur : 현재 r/w offset위치에서 offset만큼 가라 
seek_end : 파일의 끝에서부터 offset만큼 가라는 말이다.

파일의 끝에서 offset만큼 간다는것이 의미가 있나? 의미가 이상하다. 나중에 쓰는 example이 나올것이다. 일반적으로 seek set을 쓴다 말이다.

## creat, lseek Example((1)
유저는 owner을 의미한다.
owner가 읽을수있고, owner가 쓸수있고 같은그륩에 있는사람이 읽을수있고, 그륩도 아니고 아무것도 아닌사람이 읽을수있다 라는 말이다. 그러면 file의 access permission이 생기는것은 
rw-(owner)r--(group을 위한 access permission) r--(전혀 관계없는 프로세스를 위한 access permission이다.)
프로그램을 짜면 파일만들어서 error 체크 안한다.
create하고 넘어간다. 모든 프로그램은 return value가 있으므로 혹시라도 error가 생겼는지를 꼭 체크해서 왜 error가 생겼는지 찍어주는 프로그램을 잘 짜는 방법이다. 
++return value가 -1 이하가 생기면 에러가 생긴거니까..항상 체크를 해야한다.++
write는 buf1, test1data를 받았다가 만든 파일에쓰는데 10자를 써라.(10자가 maximum이다.)
10자는 maximum이고 string을 써라했으니까 null이 나올떄까지 쓴다.

lseek 는 파일에 test1data를 썻는데, 그럼 r/w offset이 이동했을것이다.
그거를 lseek해서 몇번쨰 자리로 옮기란 말인가
6번째 자리로 옮긴다. 
test1(여기에 r/w offset을 위치) data
했는데 lseek를 성공적으로 할테지만 -1이라는것은 에러가 생겼다 를 의미
그러고 나서 test2 데이터를 쓰니까 
test1 r/w offset이 이동한데서부터 test2 data를 쓰니까 결과는 test1test2data가 결과로 나올것이다. 
## File Reading
읽기 위한 바이트 수를 지정해준다.
이것도 역시 size_t 가 return value인데 size_t는 integer라서 내가 n byte가 100 byte를 버퍼에다가 읽으라고 했는데 읽다보면 eof에 걸릴때가 있다. 그러면 실제로 50 byte만 읽었다 하면 실제 읽은 byte의 개수를 return 해준다.
nbyte 는 읽어들인 데이터의 크기(몇바이트를 실제로 읽었는지) 
-1은 읽다가 에러가 생긴경우, error가 생기거나 eof가 걸린것
eof가 걸리면 0이나온다. 0이면 eof이고 -1이면 error가 발생

## File Writing
버퍼에다 쓰는것이다. 
write를 10byte가 맥시멈이냐! 그게 캐릭터니까 null에서 끝난다고했는데 캐릭터인지 사실 모른다. 무조건 메모리에 10바이트를 쓴다. 아까 질문한것.
캐릭터가 들어갈수도 있고 인테져가 들어갈수도있으니까 

## File Copy
a.out의 소스파일을 읽어온다음에 destination 파일을 하나줘서 파일을 복사하는 example이다. 
캐릭터 버퍼를 1024 짜리 하나를 잡았다.
아규먼트가 3개가 들어오지 않으면 에러다.
왜냐하면 프로그램 이름과 인풋 파일 아웃풋 파일 3개가 들어와야지 되니까

인풋파일을 오픈합니다 첫번째 아규먼트 벡터1은 읽는파일일 테니까 O_RDONLY 로 한다. 읽는파일이니까 
-1 은 오픈하다가 에러가 발생하니까 에러 메시지 출력해준다. 그리고 프로그램 끝내버린다.

두번째 파일을 open을 해야하는데 만일에 카피를 할려하는데 파일이 있을수도 있으니까 없으면 create를 하고 있으면 다 잘라버리고(TRUNC) 새로쓰겠다.
그리고 WRITE 모드로 오픈한다. 만일에 새로 만드는거면 만든사람은 읽을수있고 쓸수있다.

READ를 한다. Input 파일에서 버퍼에다가 버퍼의 크기는 1024 byte다. 맥시멈 1024 바이트를 읽어라 읽었으면 읽은게 버퍼로 들어오면 그것을 아웃풋 파일에다가 버퍼에있는것을 쓴다. 
1024 바이트를 읽으라했지만 중간에 eof가 뜨면 못 읽을수도 있으니까 그때는 읽은 바이트의 개수가 리턴된다. 
buf에 1024가 들어오면 된다. 1024 바이트 쓰다가 맨 마지막에 가면 500바이트가 남았다. 그러면 n에 500이 return이 될것이고 읽은것만큼 write한다. 그리고 loop은 또 올라가서 읽을려고 하면 eof에 걸리니까 읽을것이 없으니까 0이 리턴된다.
0이 리턴되면 프로그램이 끝난다.
until not eof 까지 loop을 도는것이다.

마지막으로 close(fd), close(fdo)를 한다.

## Copying file descriptors
file descriptors copy하는데, 
전에 shell 얘기할때 pipe 할때나왔다.
dup은 파일 디스크립터를 오픈한것인데 이미, 오픈한것을 하나 복사한다.
어디에 복사하냐, pcb안에는 open file table이 있다 0,1,2,3번이 있다. 각각이 파일디스크립터고 0번쨰가 std input 1번이 std output 2번이 std error 이다. 내가 open하면 fd라고 하자. 
새로 오픈해서 dup은 카피하라는 말인데 위에서 내려오다가 제일 처음에 나오는 빈칸에다 복사를 해라 이경우에는 3번쨰에 복사가 되지만 만일에 내가 0번째를 close하면 위로0번에 복사가 된다. 내려오다가 첫번째 빈칸에 복사를 한다. pipe 다룰때 나왔었다. dup2는 fildes에 있는것을 fildes2에 카피해라 라는 말이다. 만일에 3인데 2주면 3번에 있는것을 2번에 갔다가 넣어라. 지정을 해서 카피한다.

++dup2는 지정을 해서 카피하는것이고 위의 dup은 위에서 내려오다가 처음으로 빈칸이 오면, 빈칸에 카피를 해라 라는 말이다++

## Kernel Data Structures for open-files 
강의시간에 다룬다.

## I/O Redirection(1)
$ a.out > output
모니터에 나가는게 너무 많아서 디스크에 받고 싶으면 위처럼 한다. output을 a.out을 보내는것이고 <하면 키보드 인풋대신에 디스크에서 받는것이다.
그것을 Input Output redirection 이라고 한다.

std_out 이라고 나왔는데, std_out은 구조체다. (stdard library 에서 나옴) std_out은 디스크립터로 1번이다. 
stdout_des 에는 1번이 리턴된다. 왜? stdout의 디스크립터를 물어보고 있으므로
stdout은 파일 포인터이고 stdout은 printf 할떄 stardard i/o library에서 쓰는것이고 우리가 쓸려고 하는것은 요 번호가 파일 디스크립터, stdout의 파일 디스크립터는 1번이다. 
stdout_des는 1이 리턴된다.
backup_des는 파일 디스크립터 테이블에 3개 밖에 없었는데 (std input, std output, std error)std_out을 dup해라 했으니까 1번을 카피하는데 위에서 내려오다 보니까 제일 처음 빈칸이 3번파일이다. 여기에 std_out이 들어간다(카피된다.)
3번이 리턴된다. backup_des에 

std_out을 바꿔치기 해서 다른 파일로 만들어버릴것이다. 프로그램이 끝나가면, 다시 std_out으로 돌려놔야 한다. 그래서 backup_des에 save를 해둔다. 3번에다가

test.txt를 open 하거나 있으면 다 날려버리고 오픈하고 없으면 만들어라. ofdes는 몇번이 리턴되냐? 4번 디스크립터 를 리턴할것이다. 파일이 4번에 생긴다. 4번이 test.txt다. 

그다음에 4번을 1번에 복사해라 stdout_des를 날리고 test.txt를 넣어라 라는 말이다.(카피를해라)
++
Hello world 1번은 콘솔로 나갔다.
Hello world 2번에서 stdout은 test.txt로 바꿨으니까 pinrtf를 해봤자, 1번으로 나갈거 test.txt 파일로 나간다. (중요)++
Input과 output을 바꿔버렸다.

할일을 다했으면 원상복귀를 해줘야 한다. backup_des에는 std_out이 있는데 다시 stdout_des로 넣어서 원상복귀한다.

++Hello world(3) 을 찍으면 console로 나간다. 모니터로++
++1번 3번은 콘솔로 나가고 2번은 디스크의 test.txt로 나간다.++
ofdes를 close 한다. test.txt를 담고있는 변수죠.