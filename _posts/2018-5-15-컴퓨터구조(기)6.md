---
post : layout
title : 컴퓨터구조(기)6
---
## 복습
지난시간에 해저드를 어떻게 디텍트하는가 
포워딩 유닛에서 
앞선 명령어 , 앞서가는 명령어에 rd 그러니까 destination register 번호하고 뒤따라는 명령어의 rs나 rt 하고 일치할때 해저드 관계가 발생하는데 그때 이제 원래는 write back이 단계가 되야 레지스터에 값이 들어가야 그값을 뒤에서 읽는게 절차적으로 가능하지만 순차적으로 명령어를 한개씩 수행하는경우에는
그렇게 처리가 되지만 명령어가 한개씩 처리가 되는게 아니고 조금 조금 조금 앞으로 전진하면서 실행하고 있기떄문에 뒤따르는 명령어가 그 레지스터값을 정상적으로 읽지 못함 그래서 해저드 관계가 발생함

그럴떄 우리가 어떻게 하는가 살펴봤음
그다음에 이건 뭐냐
이건 뭘얘기하는거져 
컨트롤 해저드?

브랜지 가 여기서 조건이 만약에 두개가 같으면 equal 이면 숫자로 써놨는데
숫자로 써놨는데 이게 사실은
라벨로 표현이 되는거지만 여기서는 그냥 
어 어차피 라벨은 뭘로 변환이 되? offset으로 변환이되
그 offset을 여기다 적어준거임

## Control (Branch) Hazard Example
이 offset의 의미는 byte 수? wrod수? wrod 의개수임
여기로부터 7개떨어진곳

36 sub $10, $4, $8
40 beq $1, $3, 7
44 and $12, $2, $5
48 or $13, $2, $6
52 add $14, $4, $2
56 slt $15, $6, $7
...
72 lw $4, 50($7)

그런데 여기서 기준으로 7개 떨어진곳이 아니고 
하나 다음 명령어 왜냐하면 pc라는건 항상 기본적으로 4씩 증가하도록 되어있기떄문에 
instruction fetch 단계에서 4씩 증가함 pc는 
여기서부터 여기를 기준으로 7워드니까 
7워드면 주소는 지금 다 byte 단위로 써있는거잖아 
40 / 44 ... 여기를 기준으로 7워드니까 
byte 면 7*4 = 28 어디야 
28byte 떨어진곳임
그러니까 44에다가 28을 더하면 72 임
72로 가는것이다. equal면 
equal 이 아니면 그다음 명령어를 수행하는것이고 

## Control(Branch) Hazard Example
겨울에는 너무 덥고 쪄죽는 그런경우가있음
그런거 어떻게 해결할까 서로 눈치보느라 말도 못함 어떤 어르신 되야 ! 
젊은 사람은 눈치만 보고 손 부채질 하면서그런데 
내린다고할때 버튼 누르듯이 그런것처럼 거기 자기가 생각할 수있는 버튼을 
그러면 어쩃든 누가 눌렀는지 몰라도 기사한테 갈꺼아냐 그렇게
앱으로 만들어보자

그냥 만약에 파이프라인으로 들어가면
여기 메모리에있는 명령어들이 차례로 차곡차곡 따라있기 떄문에 얘뜰이 내차례인가보다 하고 따라 들어감 따라 들어가는데 원래는 이게 어디서 결정이되냐면 이게 지금 그 두개가 같은 가 어디서 결정이 되지 ? 
여기를 나와야 결정이됨
여기서 그 두값이 들어가가지고 그게 같은가 하면 zero signal 이 나와서 1이면 같음
거기서 결정이됨 사실은 거기서 결정이 되니까 그 결정이 될때까지 그 사이에 이미 많은 부분들이 뒤따라들어와서 진행이 되고 있음
진행이 되고 이것들을 다 소거 시키고 그다음에 비로소 제대로 된 lw 명령어를 여기서부터 집어넣어야함 물론
equal 이 아니면 재수가 좋은거임
따라 들어왔던것들이 그냥 진행하면 되는거지만 equal이면 얘뜰이 다 
얘들을 살려두면 끝가지 가는건데 그러면 어떤 명령어
요 3개의 명령어가 실행이 되버리는거야 
이 3개의 명령어가 실행이 안되야 하는거지 
그렇다. 근데 얘들이 만약에 실행이 되면서 앞선 값을 만약에 바꾸는 결과를 나타낸다 그러면 치명적임 완전히 얘들은 우리가 그것들을 무효화 시킨다. imvalid 또는 널리파이 =0으로 만든다. 표현을 함
그렇게 해서 파이프라인에 들어왔던것을 쫙 소거시키고 그다음에 여기서부터 새사이클 새로운 명령어사이클을 여기다
그렇다보니까 몇사이클이 소비가 된거야 지금
3사이클 손해본거임
파이프라인에서 3사이클 만큼 
유익한 일을 못함
3사이클 동안 
그래서 지금 밉스에서는 그러면 이 뒤에 여기가서 판단이 되면 늦다. 
그래서 이것을 어떻ㄱ ㅔ했지 여기 디코드 단계에다가 뭐를 조금 회로를 추가해서 넣었음
디코드 단계에서 바로 디코드 단계에서는 레지스터 나온값을 값이 나오고 있으니까
그것을 여기서 두개 비교하는 회로를 추가하자 그래서 만든게 이런 형태임
여기에
어떤 회로가 추가됬어여 여기? 
여기에 두개 값 비교계 , 두개가 같은가 다른가 
비교기
그다음에 또 뭐가 추가됬어용 또?
여기서 요 부분이 추가됬음
원래는 요 저기 요게 branch target addr 였음 목적지 주소였는데
이것도 원래는 이뒤에서 계산했던 것임
근데 이것도 밑에 있는 16 bit , immediate를 shift left 2 해서 word 2 byte 
워드 표현이니까 4배해가지고 byte 표현을 한다음에 
그다음에 현재 pc, 가 오는 값하고 그 offset 하고 더하면 그게 뭐가되냐면 
그게 타겟 어드레스가 됨 이게 브랜치 어드레스가 됨
그래서 이게 같으면 같으면, 여기서 지금 이값이 이렇게 들어가는데 이 mux에 선택을 뭘하게 이값을 선택을하게 여기 번호를 붙여놓치 않았는데 번호가 이뒤에 붙어있던가 
그러면 이와같은 구조라면 적어도 브랜치가 선택될지 선택될지 않을지는 
디코드 단계에서 결정이되니까 적어도 한사이클만 손해를 보면 패치에서하면 제일 좋은데 
패치에서는 가져오자 마자 디코드를 못하니까 
일단 여기서 결정이 되니까 그 다음에는 제대로 된 instruction 을 가지고 오겠찌 
그러면 바로 뒤에 들어오는놈 
바로 뒤따라 들어오는 놈만 ??? 이대로 대입 시키면 되는거임
얘만 없애버리고 그다음엔 제대로 된 곳이 들어오도록 설계되어있음
여기에 지금 브랜치가 나타나고 
요예제가 어떻게 돌아가는지 보자

## Control(Branch) Hazard Example(3)
자 보자 
여기 지금 각각 들어가는 값임
처음에는 pc 는 지금 주소가 얼마라고 되어있었지 44 지금 
and 
지금 branch가 디코딩 단계에 있을때 
branch 가 디코딩 단계에 있을테니까 요기 가 이제 바로 branch 다음 명령어이고
branch 다음 명령어의 주소가 40임
그렇다.
그리고 걔가 수행할떄 44임 40이 아니라 
44가 나오고 그다음에 여기에 48이 들어가고 
그다음에 여기 지금 뭐야
$1, $3 레지스터 결과 
$1, $3 가 얼만지 모름 지금 그거에 결과에 컴플레이션이 일어나고 
그리고 44하고 여기에 offset이 7이었으니까 
7*4 = 28에 그 72라는 값이 선택이 되고 
$1, $3 결과에 의해서 여기서 72 를 선택할지 48을 선택할지가 여기 결정이 되지 여기서
그다음에 또하나 결정해야 하는게 있는데 또하나 결정해야하는게
만약에 만약에
지금 여기서 읽어온 일겅온 요 명령어가
뒤로 가서 안된다 하면 이 명령어를 어떻게 완전히 소거 시켜줘야함
그렇다 이명령어를 소거시키는 신호가 있는데 이게 이신호임 IF/FLUSH (PPT에 자세히보면있음)
그래서 여기 들어와있는 레지스터 를 완전히 CLEAR 시킴 그러면 뒤따라들어오는 게 날라가버림

계속 그다음에 정상적으로 72에 해당되는 동작이 실행된다.
Pipleline data path를 다시 정리하면
사실은 stall 이 없어야 하지만 불가피하게 stall이 발생하는 경우가 있고 stall이 전체적인 성능을 감쇠시킨다. 
하지만 경우에 따라서는 stall이 필요한경우도 있음
그래서 여러단계에서 이제 instruction 의 reordering, 여러단계에서 이제 명령어의 순서를 바꾸는 일들이 발생하는데
대표적으로 첫단계에서 컴파일러가 여러분들의 코드를 보고 순서를 바꿔도 결과에 영향을 주지 않는 범위내에서 순서를 바꾼다.
지난번에 그예를 봄
또하나는 우리도 개발자도 파이플라이닝에 대한 특성을 이해하고 개발을 할 필요가있다.
데이터들에대해서 그런것들을 얘기하고있음
이제 Exception 이라는 주제로 얘기를 하겠는데

## Exceptions - "Stuff Happens"
Exception은 뭔가 썸띵 해픈인데 
현재 우리가 어떤 프로그램을 정상적으로 진행하던 중에 정말로 extraordinary한 정상적인 흐름과 전혀 상관없는 사건이 발생하는것 우리가 그것은 exception이라고함
정상적으로 
여기 뭐라고 되있냐면 unexpected change 그러니까 전혀 예상하지 못했던 사건이 발생해가지고 그 사건을 처리하는 과정
그게 exception임
뭐, 컨트롤 해저드 도 exception에 하나 일 수도있는데 그것보다는 더 굉장히 그 예측불가능한것들 말함
exception에 한예를 보면 
지금 
add $1, $2, $1;
sw $3, 400($1);
add $5, $1, $2;
두개를 더해서 그값을 기반으로해서 400번지 offset에 있는 주소에다가 이값을 쓰고 그담에 그값과 이값을 더한다. 근데 이런것들이 여기 동그라미 쳐라 여기 
이게 메모리 address임 
근데 이떄 이 $1의 값이 적절한 메모리 의 addr를 가리키고 있으면 상관이 없는데
실수로 누군가가 $1의 음수값을 -100000 이란값을 집어넣었다든지 그러면 전혀엉뚱한곳에 address가 발생함
그러면 우리가 컴퓨터시스템에서는 특별히 적법한 address 가 아닌 전혀 다른곳에 붋법한 address를 access 하면 그걸 우리가 뭐라하냐면 segmentation fault , protection error 라고 해서 불법한 영역을 접근했다 알려줌
이런것들이 exception 한다 라고함
예외적인 경우
또, 뭐 뒤에 여기 지금 대표적으로 
한 예를 또 들면 여러분들 그 c 프로그램에서 이런것들을 많이하는데
뭐 a에다가 뭐 b/c 이런것을 많이함
만약에 나누는 분모 c가 0이 되면 원래 불능임 0으로 어떤 숫자를 나눌 수없음
0/0 부정이라고 해서 어떤 값으로 정의해도 상관없지만 어떤 상수를 0으로 나누는건 불능임
이런경우 이런경우
exception임
c가 0이면 
excpetion임 이런것을 divide by zero excpetion이라고함
왜 exception 이라고하느냐?
여기서 얘를 무시하고 다음으로 갈 수 가 없음
왜냐하면, 이 상황에 대한 어떤 처리를 해주고 가야댐
왜냐하면 프로그래머가 이상황을 의도한건지 의도하지 않은건지를 모르지만 정상적인 연산이 아님 그러면 적어도 사용자가에게 정상적인 연산이 아니라는 사실 정도는 알려줘야 그 사람이 그 프로그램을 멈추던지 뭔가 무시하고 가도 된다고하면 그대로 진행을 시키던지 그 사람의 판단에 맞기는거임 이건 프로그램이 해결할 수 있는 문제가 아님 이런 상황은 
자 그러면 excpetion이 어떤 종류가 있느냐 크게

## Two Types of Exceptions
Interrupts가 있는데
컴퓨터 시스템에 외부에서 들어오는 이벤트임
예를들면 네트워크 장치, 키보드 디스크 I/O 이런것들 이런게 
external 이라는건 cpu 입장에서 볼때 cpu 밖에서 들어오는 이벤트임
page fault , os 배울텐데 원하는 프로그램 코드나 원하는 데이터가 메모리에 없을때 발생하는 현상
system call - 우리 사용자 프로그램이 operating system에게 뭔가를 해달라고 요청할때 하는것을 시스템콜이라고함
이런것들이 인터럽트인데 특히 주의할것은 이 두가지 
두 부분은 그 마지막하고는 의미가 다른데 얘들은 하드웨어 인터럽트임
하드웨어가 거는거임
여기는 인터럽트라고 안하고 fault라고 씀
이거는 어떤 일이 진행되다가 결함이 발생 3번째 시스템콜은 소프트웨어 인터럽트임
소프트웨어에 의해서 발생하는 인터럽트임
근데 사실은 여러분들 요거를 이 시스템콜을 이렇게해서 아래쪽으로 내려줘
왜냐하면 시스템콜은 두가지의 특징을 가지고 있음 인터럽트 특징도 가지고 있고 트랩의 특징도 갖고 있음 두가지의 성질을 가지고 있음 
어쨋든 프로그램이 실행하는 그 상황에 비추어 볼때 어싱크로너스 하다고 볼 수 있음 어싱크로너스?
모라고 하냐 비동기 라고 함
프로그램이 발생하는 프로그램이 실행되는 그 시간 성과 인터럽트가 발생하는 시간성이 서로 연관이 전혀 없을때 
프로그램 실행 시간, 실행 순서와 인터럽트의 발생순서가 전혀 연관이 없을때 이것을 우리가 에이싱크로너스 이벤트라고함 다른 말로 얘기하면 저런 이벤트가 언제 발생할지 알수없음
우리가 전화가 알수없는것처럼 책을 읽고있는데 전화가 언제 올지 알수없음 그런것임
그게 어싱크로너스 이벤트임
자 이런것들은 어떻게 해결되느냐? 기본적으로 명령어와 명령어 사이에서 체크를함 
예를들면 앞에서 봤잔아 and load word or 이런 명령어들이 있지 그런 명령어 명령어 사이에 이런 인터럽트 가 발생했는지 체크를 하게 되어있음
바꿔 얘기하면 그러면
명령어 하나를 실행하는 과정중에는 인터럽트가 할수있다 없다? 명령어 하나는 인터럽트 방해받지 않고 그대로 진행되고 그 다음 명령어를 시작하기 바로 직전에 아 이사이에 뭔가 인터럽트가 들어온게 있나 체크를 하도록 그렇게 되어있음
그래서 인터럽트가 발생하면 어떻게 되냐? 
인터럽트 발생해 전에
인터럽트라는건 어떻게 이해하면되냐? 
프로그램이 실행된다라는건 우리가 개념적으로 모델링하냐면 내가 집에서 소설책을 읽고있어 이게 내가 cpu고 내가 소설책을 읽는 동작이 프로그램을 실행하는 동작임 
한장 한장 한장 한페이지 한줄 한줄
차례로 읽어가면서 인터럽트는 뭐냐면
그런중에 전화벨이 울림 저쪽에서 전화벨이 띠리링 하고 울림 그러면 내가 지금 프로그램 실행하는 동작이 방해받음 
전화를 받을려면 내가 읽는 이 동작을 멈춰야함 어떻게 멈춰? 거기에 북마크를 꽂아 두던지 어디까지 읽었는지 표시해두고 하던일을 멈추고 하던프로그램을 멈추고 저쪽에 가서 전화응대를 함
그게 인터럽트를 처리하는 과정임
전화를 하고 끊으면 그게 인터럽트 처리를 한거임
이것 역시도 내가 한거임
인터럽트 처리도 cpu 개입 되서 처리를 한거임
자 그래서 서비스를 마치고 나면 다시 와서 내가 아까 하던 소설책을 다시 읽어야함
내가 아까 어디 까지 읽었는지 마킹을 해놨으니까 그것을 찾아서 쭉 읽어감
결국 어떻게? 내가 하던일 유저프로그램을 잠시 서스 펜드, 일시정지했다가 인터럽트를 처리하고 다시 리줌 다시 재개 하도록 이렇게 하는게 인터럽트 처리 아주 개념적인 플로우임
그래서 뒤에 
이그림이 있는데 

## Exceptions
이그림이 있는데
명령어들임
인터럽트 처리하는것을 핸들러라고 함
익셉션 핸들러, 인터럽트 핸들러
핸들러 역시 명령어들의 집합임
그래서 여기 이렇게 오다가 이 명령어 와 이명령어 사이를 봤더니 어 쟤가 인터럽트를 보냈네 
그러면 그 인터럽트를 처리하는 로직으로 간다.
일종에 분기같이 가서 전화에 해당되는 인터럽트 서비스를 하고 다시 멈췄던 지점으로 돌아와서 그다음에 다시 실행을 재기 한다. 이것도 프로그램이고 이것도 프로그램의 일부임
하지만, 이것은 일반적인 유저 프로그램이고 이거는 대부분 시스템 os가 미리 등록해놓은 그런 구비한 레디 메이드 모듈임(핸들러말하는듯?)
하지만 다 메모리에 있다는거 

그에 반해서 트랩이라는것은
외부에서 들어오는 동작보다는 인터널 이벤트 다른 말로 명령어을 실행하는 과정중에서 발생하는 명령어를 실제로
아까 예를들면 디바이드 바이 제로 이건 명령어 하던 중에 이 명령령어 때문에 발생한거임
그런것임
어디서 갑자기 날라온게 아님 이런것들이 트랩임
또는 뭐 여기 오버 플로우 옆에다가 디바이드 바이 제로 써주셈
그다음에 언디파인드 instruction 명령어가 왔는데 돌릴려고 봤더니 opcode가 쌩 정의되지 않은것임 그럴 수 있음 왜냐하면 여러분들 이렇게 네트워크가 오는경우 네트워크에 그 노이즈나 그런것에 의해서 데이터가 깨질 수 있음 그러다보면 명령어도 이상하게 바뀔수도있고 하드웨어 멀펑션 뭐이렇게 아이오장치 라든지 이런데서 제대로 동작하지 않는거
그런거 때문에 발생함 
대게는 싱크로너스 함
싱크로너스는 걔가 일어나는 시점하고 프로그램이 실행되는 시점하고 관련성이 있음 그렇다.
이명령어 떄문에 일어난것임
그다음 명령어를 수행하다가 걔 그자리에서 개떄문에 발생한거임 명령어때문에
대부분 어떤 핸들러에 의해서 서비스가 되고 그렇게 되면 어떻게 되냐면 여기 문제가 있던 명령어를 대체해야되고 명령어 이대로는 실행을 못시킴 그리고 그것을 
메시지로 사용자에게 전달을 해주거나 아니면 그 동작을 시뮬레이션 해주는 다른 모듈이 돌아가도록 이게 그 핸들러 에 중요한 역할임 아니면 그 프로그램을 abort , 강제로 종료시키는 그런상황들이 발생한다.

우리가 각 단계에서 여러 exception들이 발생할 수 있는데 instructon fetch나 memory access stage에서는 메모리 access하니까 아까도 말했듯이 자기가 원하는 명령어나 데이터가 없으면 fault 가 발생한다고 함 여러분들 메모리에다가 다 올려놓고 실행을 하는거 아닌가? 그러면 자기가 원하는 명령어나 데이터가 없는 경우가 무슨 얘기지 ? 이런 궁금증을 잠깐 가질 수 있는데 현대 운영체제에서는 예를들면 프로그램 10메가 짜리 프로그램 이잔아
그러면 우리는 내가 만든 프로그램이 10메가 이면 


## Exceptions in Simple five-stage pipeline
우리가 지금 쉽게 생각하는건 메모리 10 메가 공간을 확보 한다음에 10메가 쭉 올려놓고 실행하는걸 단순한게 생각할 수있는데 그렇게 동작하지 않음 현대 운영체제는 
10메가 프로그램이면 아주 일부 뭐 500 k라든지 256 k 라든지 아주 일부만 올려놓고 돌아 실행을 하다가 걔를 벗어나는 순간이 있지 왜냐하면 자기프로그램 중에서 일부말고 다른 곳에서 접근 해야 하는 그런 순간 그런순간이 발생하면 그때 비로소 해당되는 파트들을 또 올리고 이것을 뭐라 하냐면 on-demand 로딩이라고함

필요하면 그때그떄 올리는 온 디멘드 로딩 또는 
온 디멘드 또는 아주 느릿느릿하게 느릿느릿 하게 그런것이 필요할떄 올린다고 해서 이런것을 게으른 로딩이다 라고 해서 레이지 로딩이다 라고 말함
그러다 보니까 프로그램이 돌다가 어 ! 이데이터 어디갔어 아직 안올라왔어 ? 
이런상황이 발생함
그런것을 우리가 페이지라는건 해당되는 instruction이나 data 가 들어가있는 기본단위를 우리가 페이지로 받았는데 그에 자기가 원하는 페이지 가 메모리에 안올라와있다. 결함이 발생했다. 
또는 misaligned memory access
여러분들 로드 워드 에 access하는 주소는 꼭 워드 바운더리 에서 access해야함
워드 바운더리는 주소가 4의배수임
0 4 8 12 
주소계산을 잘못했어 그래서 load word 했는데 3번지 에서부터 한워드를 읽어오라고 계산을 잘못함 그러면 역시 exception 발생함 
이렇게 메모리 access할수없다. 그래서 이게 misalinged memory 
그다음에 메모리 프로텍션
아까도 말한것처럼 자기가 사용하는 메모리 영역말고 남에 영역에 침범한다던지 그런게 발생할 수 있음 그게 어디서 instruction fetch나 memory access 때 이제 5stage 중에서 

instruction decode stage에서는 뭐가 발생할 수있어 
undefined / illegal 불법적인 opcode 그다음에 
execution 에서 발생할 수 있는 arithmetic은 
arithmetic exception 아까 말했던 것처럼 
오버플로우 디바이드 바이 제로 이런것들

write -back 단계에서는 특별한 exception 이 발생하지 않아 

그래서 이런 exception 이 거기서 발생하지 발생하면 그러면 그 다음 단계에서 이 exception에 대해서 처리를 하고 다시 실행을 재기 하도록 설계되어있음 


## What happens during an exception
excpeiton이 발생하면 어떻게 해야 하느냐, 크게 하드웨어적 파이플라인에서 해야될 일이있고 소프트웨어적으로 해야할일이 있음
소프트웨어적으로 해야할일은 아까 설명했던것을 잘생각하면댐
소프트웨어적으로 익셉션 이 발생했으니까 하던일을 멈추고 익셉션을 처리하는 코드로 가서 그 로직을 수행하고 그리고 다시 돌아오는것
그게 소프트웨어적으로 해야하는일임
파이플라이닝은 지금 익셉션이 발생했으니까 그 익셉션 발생한것을 계속 파이플라인에 진행시키면 안됨 그게 번져나가는거니까
그래서 일단은 offending instruction 이라는것은
exception을 발생시킨 instruction 을 offending instruction 이라고 함
걔를 일단 멈춤
그리고 일단 앞서나간 놈들 은 뭐 아무 죄가 없음 앞선 나간 명령어들을 진행을 시킴 쭉 가게 
그리고 얘 offending instruction 뒤따르는 놈들 잇지 뒤따라 들어온놈을 fflush 시킴
exception이 발생하면 얼마나 많은 손실이 있는지 대충 감이 잡힘
앞에 나간 놈들은 내보내고 그럼 자기로부터 뒤따르는 놈들은 다 싹 파이플라인에서 쫓아냄
그다음에 왜 exception이 발생했는지 exception원인을 확인하고 그것을 exception을 알리는 status register 에다가 그 excpetion의 종류를 setting 함
그다음에 중요한건데 어떤 명령어에서 exception이 발생했는지 그명령어의 주소를 잘 기록해둠 왜냐하면 그 주소에서 다시 시작해야함 그게 문제가 됬던 명령어니까 해결할 수 있는 내용을 
예를들면 아까 뭐 그 오버 플로우가 일어났다 던지 디바이드 바이 제로 명령어에서 일어났다 그러면 다시 유저에 의해서 데이터 를 다시 받던지 다시 손질해서 다시 실행을 제기	하면 그자리에서부터 실행을 해야 할 꺼 아냐 
이건 세이브 해놓고 그다음에 어디로 가냐면
prearranged address 미리 준비된 장소, 코드 로 점프해 이걸 뭐라하냐면 excpetion 핸들러 코드라고함 
exception을 처리하는 코드임
그럼 아까 뒤에 뭐 그런 그림이 나왔지만 우리가 이제 컴퓨터 시스템 메모리를 이렇게 큰 array로보면 대게 이제 그 일부를 멀로 쓰냐면 핸들러 들을 등록하는 장소 상위 번지를 (ppt 그림 참고 노트된거임)
여기에 핸들러들의 어드레스들이 쭉 들어오고있음
그리고 실제 핸들러들은 여기 실제 코드는 이렇게 되어있고 
이거는 이제 핸들러 코드들이고 
그다음에 유저프로그램은 여기서 돌고있음 
그래서 무슨 excpetion이 발생하면 그 excpetion의 종류에 따라서 여기 핸들러 어드레스를 참조함 그러면 arithmetic exception이 발생했다 그러면 arithmetic exception에 해당되는 핸들러 주소를 담고 았는 곳에 가 
그러면 얘가 arithmetic handler는 여기있어 이렇게해서 거기를 가리키고 있음
그래서 이렇게 해가지고 핸들러 코드로 가서 처리를 하고 다시 아까 자기가 save 해놨던 유저 코드로 돌아가도록 그렇게 되어있음 

소프트웨어 적으로는 얘하고 얘하고 서로 인터플레이를 하는데 얘는 하드웨어적으로 해놓고 그담에 여기서 여기에 핸들러 코드로 지금 분기하도록 되어있잔아 그러면 그다음부터는 os가 역할을 맡음 그러면 핸들러 코드입장에서는 아까 여기에 save 해놨지  왜 exception이 발생했는지 
여기에 register에 있잔아
그 exception에 해당되는 이유를 원인을 확인하고 그다음에 excpetion을 처리함 그명령어에 적절한
그다음에 다시 돌아가서 여기 save 한 address로돌아가서 정상적으로 실행을 재기하거나 아니면 이 프로그램은 회복 불능인거같으면 여기서 강제종료 시키는게 낫겟다 싶으면 그러면 그냥 프로그램을 abort 프로그램을 강제종료시키거나 os 입장에서 처리하도록 되어있다.

그래서 여기서 주의해야할것은 우리가 보통 프로그램 안에서 이 지점에서 이지점으로 간다고 할때는 브랜치 명령어를 쓴다든지 뭐 jar 명령어를 쓴다던지 해서 
임시적인 명령어를 써서 옮겨 다님
근데 여기서 여기로 가는건 이 코드 상에 그런 분기 명령이 따로 있지 않음
저기서 저기로 가는건 아까 말했는듯이 누가해? 하드웨어가해 
익셉션이 발생했을 떄 해당되는 익셉션 핸들러 지점으로 분기시켜주는건 소프트웨어가 하는게 아니고 cpu 하드웨어에 의해서 정의되는 그런 로직에 의해서 처리가 됨 
그러니까 여기에 나타나지 않아
중요한거 시스템 입장에서는 여기에 익셉션 발생시킨것을 offending instruction이라고하는데 그 address를 반듯이 잘 기록해야 놔야한다 왜냐하면 그지점으로 돌아와야하니까 
그다음에 뭐 다른 것들 
다른ㄱ ㅔ뭐가 있을까 어 여기서 지금 cpu가 있고 
내가 손이 cpu고 이프로그램을 수행하고 있었어 
그러면 cpu안에는 뭐가 있냐면 많은 레지스터들이 있음
그 register 들이 있는데 여기다가 계산값을 5개의 레지스터 에다가 값을 넣고있는데 이 cpu가 여기가서 얘를 계산하는거 아니야 
근데 얘들도 어차피 명령어들이니까 얘들도 레지스터를 쓸거임
그렇다. 그런데 얘들이 5개의 레지스터에다가 값을 써봐! 그러면 다시 여기로 와바 무슨일이 발생해? 아까 얘가 여기서 계산해 뒀던 값이 다 사라져 버림 그러니까 우리가 이게 지난번에 함수를 호출할 때에도 비슷한 상황을 말했는데 여기서 쟤한테 분기하기전에 여기 offending instruction에 address를 save 하는것도 중요하지만 현재 확보 하고 있는 레지스터 값있지 레지스터값도 어딘가에 save 하는것이 중요하다.현재 계산해논 레지스터값들

이렇게 하고 다시 익셉션 핸들링이 처리가 되면 다시 유저에게 컨트롤이 오고 그다음에 해당됬던 일을 다시 진행하도록 한다.
여기 3장의 슬라이드는 미리 보고 와라!!!
우리가 지금 화요일 은 공휴일임
