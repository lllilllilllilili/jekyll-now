---
post : layout
title : 시스템프로그래밍(기)7
---
## 복습
그래서 아무튼 목표는 프로그램을 잘짜는것이다.
랭기지를 잘한다 라고 되는건 아님 누차얘기하지만 나중에 
모든 과목을 다 들어서 맨 마지막에 화룡정점을 한다는게 캡스톤을 한다는거임
이것저것 배워서 랭기지로 배워서 수단이라는거지
자바 자체가 파이선 자체가 중요한건 아님 그 뒤에 숨어있는 컨셉이 중요함
사상이 있으면 영어, 아프리카어로 하든 상관없음
그것을 결국은 다 이용해서 뭔가를 만든다는 졸업 논문의 의미이다.
각각 분담해서 뭔가를 만드는게 중요함
여러사람이 2~3사람이 같이해서 큰걸 만드는게 좋다.
앞으로 취업을 해가지고 혼자짜는 프로그램이 없다.
콜라보레이션이 중요하다.
내 시절에는 
잘 짜는게 필요없다. 못짜는 사람을 가져다 토론해서 끌어올려야함
다른 회사로 가더라도 소프트웨어가 메인턴스가 됨
잘하는사람은 회의도 안하고 짜버림 딴 사람들은 하는 시늉만 하다가 끝..
그대신 짜는 사람이 그 회사에 없음 다른 회사로 가버림
그러면 그 소프트웨어가 업데이트를 꾸준히 해줘야 하는데 메인턴스가 없음
버전2가 늦게 나오는 나라가 한국임
버전1이 제일 늦게 나오는 나라는 미국임 그래서 소프트웨어를 잘하는거임
못하는 잘하는 사람 
그림을 그려서 서로 디스커션해서 결국 내가 얘기한것을 단사람이 어그리 해야지 넘어간다.
그림 그리는게 프로그램임
그렇게해서 1년있다 가보면 헤매던 애가 1년 지나면 성장해 있어
그대신에 버전2, 3 
그래서 예를 들어서 si 학교에 월급 주는 시스템, 학생관리 시스템 만들어주쇼
외주 받아서 주는 si 에서 처리함
규모가 커서 무슨일 하게 될지는 모르지만 맨날 프로포져, 시스템 어떻게 만들겠다 가서 
sk, kt, .. 붙어야됨 사업해서 입찰따내기 위해서 1000 페이지 적어놓고 감
계약을 따면 용약을 시킨다 조그만 회사에 용약을 시킨다.
그러니까 맨날 그것만 프로퍼졀 만 쓰던 사람이 나와서 일을 못함
그런데 더골치아픈건 외대에서 lg cns 외주 줬다 치자. 만드는건 1년동안 만들라고 했는데
처음 나간 스펙이 아님 요구사항이 바뀜 
계속 바뀌니까 누가 죽어나가냐 ? 그밑에 용역하는사람이 죽어나감 
소프트웨어는 하도급 구조가 되어있음 
차라리 스타트업 회사가서 
조그만 회사가면 자기가 배운것으로 일을 할수있음
거기서 실력쌓이면 큰 회사를 갈수있고
스타트업 회사 일잘하면 그 회사가 구글에다가 1000억에다 판다 비일 비재함
그런 소프트웨어 만드는거는 구글이나 마이크로 소프트나 페이스북이나 이런데 상대해서 
2~3명 모여서 
구글에서 사간다 회사를 
그게 1000억임
근데 한국에서는 그게 잘안됨
가서 뭐 만들라고 하면 발표하면 괜찬은건 지네들 개발(대기업)
지적 재산권 인정하지 않음
한국에서 잘나가던 
리눅스 회사가 4000개가 넘었는데
5년지나니까 하나가 남음
그 하나를 윈드리버라고 리얼 타임 os 만드는데서 삿음 
기술이 좋아서 산게 아니라 
얘네들이 리눅스 가지고 뭘하는데 
한국에서 커가면 한국에서 리눅스로 시작하면 자기네들 성장을못하니까 없애버릴려고 삼
그런 꿈을 가지고 소프트웨어를 하자.

## 네트워크 지난시간
그래서 지난시간에 네트워크
트랜스포트 상대로 프로그램을 짠다
tcp , udp
tcp 는 전화거는것
상대방하고 연결이 되야지 통신을 가능
전화가 교환기라고 했는데 전화기 교환기는 
근데 우리 네트워크는 패킷을 주고 받아서 중계하는것임
전용선 쓰는게 아님
중간에 라우터 라고 하면 모든 패킷을 다봄 겉에서 보기에는 전화하는것처럼 보이기 떄문에
전화는 서킷 스위칭 우리가 배운 네트워크는 패킷스위칭 전화하는것처럼 보인다고 해서 버츄얼 서킷 이라고함 
그게 tcp임

tcp는 전용회선 를 쓰는거처럼 보이기 떄문에 Reliable data transfer is guaranteed 가 된다.
만일에 내가 파일을 10만 바이트 보낸다고 한다면 여러토막으로 잘라서 보낼꺼 아니냐 
그러면 중간에 없어지는것도 생길 수있음 연속해서 저쪽과 end to end 커뮤니케이션을 하니까
카운트 같은것을 둬서 중간에 잘못되면 잘못된것을 알수있다.
tcp는 그래서 복구할 수 있기떄문에 위에 내용이 보장이된다.

그렇기 떄문에 이거는 서버한테는 프레셔가 크다.
무슨 말이냐면 브로드캐스팅은 그냥 혼자서 다 떄려버림 그런데 전화하는건 일일히 클라이언트가 100개면 서버가 일일히 100개의 커넥션을 가져야지 통신을 해야될거 아니냐 그러니까 
당연히 서버한테 프레셔가 커진다.

반면에 udp는 전보보내는 방식이다.
그래서 상대방 이 받거나 말거나 내가 우체국에서 보내버리면댐
마찬가지로 보내고 말기떄문에 이거는 한두개의 메시지를 그냥 뭔가를 알리는데 사용하는데 그 유용한 통신이 유저데이터그램프로토콜이고 그대신에 이것은 신뢰성은 없다.
중간에 가다가 없어져도 어떻게 할 방법이 없다.
모든 네트워크 프로그램은 한쪽에서는 기다리는 놈이 있어야 함
뭔가를 접속을 기다리는 놈이 있어야함
한쪽에서는 접속을 요청함
접속이 요청을해서 나중에 접속이 된다면 주고받을수있음
그렇지만 기다리는 놈을 = 서버
접속을 요구하는 놈 = 클라이언트
클라이언트 & 서버 모델이라고 했음

서버가 웹서버 이쪽이 브라우저(클라이언트)면 
이거는 웹 브라우저 모델이라고했음

그래서 아무튼 클라이언트 서버가 있어야댐
그래서 이제 서버에 형태를 보면

## Server Types
Repetitive server type
서버가 딱 하나 있는거임
하나 가 있어서 웹서버가 있는데 나한테 접속을 하면 내가 스레드 하나이기때문에 접속을 한놈 하나 서버시를 해주고 그게 끝나야지 다음 클라이언트한테 갈수가있음
one by one 이다 이거다
싱글서버임 그러니까 이거는 클라이언트가 많이 들어오면 
FIFO = First in First out 해서 
이렇게 하면 느림
(single-threaded server)

우리가 p_thread나 fork를 배우듯이 서버가 클라이언트 접속할때마다 또다른 서버를 만들어내서 붙여준다.
그래서 클라이언트가 1000명이 들어와있으면 서버도 똑같은게 1000개가 p_thread로 만들어지거나 
쓰레드로 만들어지거나 
아니면은 프로세스로 만들어지거나 
옛날에는 프로세스를 fork 했었는데 fork는 메모리를 많이차지함 그래서 요새는 thread로 하는게 보통이다.
thread는 별로 오버헤드가 없으니까 
그래서 이런것을 멀티쓰레드 서버라고 한다. 

Concurrent server type(위에 설명이 되어있음)
서버가 쓰레드를 1000개 까지 만들 수 있으면 1000명의 클라이언트를 한꺼번에 서비스를 할 수가있는거다.

## Programs/APIs of Each Layer
만일에 이제 
네트워크 프로토콜이 7층이면 7층에서 각 층에 소프트웨어 있으니까 5층에 있는 프로그램 짤려고하면 4층을 써야할것이고 4층도 마찬가지로 3층을 써야함
그러니까 각계층에 api가 필요함
api가 뭐가 있는가를 나타냄

어플리케이션은 꼭대기 - http //웹에서 쓰는 프로토콜, ftp //파일 주고받을떄 쓰는 프로토콜, email, rsh //버츄어 박스 리눅스 들어가면 shell 뜨는데 옛날에는 그렇게 pc가 없었으니까 서버로 들어가야됨 서버로 들어가서 sehll을 돌려야 하니까 원격 컴퓨터의 shell을 돌린다고 해서 리모트 쉘이라는 뜻임, RPC //이런거다. 우리가 클래스가 있으면 멤버 펑션을 다른 객체서 부르면 그 객체가 내기계에 있는게 아니라 어디에 있는거냐? 다른 머신의 객체에 멤버 펑션을 부르는게 remote 포리시절 콜이라는것이다.
리모트 펑션 콜이라는거임 다른 기계에 있는 펑션을 부른다 이거임

트랜스포트 - Socket(Berkley), Windosck, TLI
커널단에 있는것은 뭐냐면 트랜스포트 레이어 까지는 커널 단에 있다.
커널 속에 있다. 트랜스포트 레이어가 처음으로 4층으로 트랜스 포트 레이어를 이용해서 여러분이 네트워크 프로그램을 원하는대로 만들 수있는 레이어다.
그래서 이 트랜스포트 레이어 에서 제일많이쓰는것은 윈도우 시스템을 쓸때는 윈솤을 쓰고 그다음에 표준으로 쓰는것은 TLI라는게 있는데 이 표준이 나왔지만 실제로 제일 많이 쓰는것은 뭘쓰냐? 리눅스에서 버클리 소켓을 쓴다. 
대단해!

트랜스포트 레이어를 쓰면 여러분들이 중간에 중계가 되가지고 이게 미국에 있는 컴퓨터하고 얘기를 하는데 중국에 있는 컴퓨터를 거쳐서 가는지는 그런거 모름 네트워크에서 ip 레이어가 해결해준다. 네트워크 레이어 ip, 라우팅을해서 여기서부터는 누구하고 누구를 생각하면되냐 
저끝에 있는 미국에 있는 컴퓨터하고 대화 하는것만 생각하면 되기 때문에
end to end 커뮤니케이션을 제공한다 이거임 그게 뭐냐면 tcp나 udp를 쓰는것이다.
tcp나 udp 쓰기위한 api는 소켓이다. 소켓도 우리가 
파일을 쓸려고하면 파일을 오픈함
파일을 오픈해서 write하면 파일에 쓰는거고 read하면 파일에서 읽어오는것이다 개념이 똑같다.
소켓도 뭘 하나 오픈한것처럼 생각하면되냐 파일이 아니라 네트워크에 포트하나를 오픈한것이다 라고 생각하면됨
그래서 거기따가 쓰는게 있고 
읽는게 있음
쓰는것은 보내는거고 
읽는것은 받아오는것임
이름만 send 하고 receive로 바꼈을 뿐이지 
사실은 read &write 하고 똑같고 실제로 read&write를 써도된다.
소켓도 가상적인 파일, 네트워크 포트라는거를 가리키는 가상적인 파일에 어떤 오픈 인스턴스라고 생각하면됨
파일디스크립터임 
우리가 파일을 오픈하면 0,1,2 스탠다드 인풋 아웃풋 에러라고 했다.
그다음에 오픈하면 3번 부터생긴다 소켓 오픈하면 3번부터 생긴다.
똑같음 

파일을 하나 3번으로 오픈해서 소켓을 만들면 몇번이 되냐 4번이되고 파일처럼 취급해야한다 똑같이

소켓을 이용해서 tcp, udp를 이용한 프로그램을 짤수가 있다.

Device driver layer는 굉장히 많은데 커널안에 있는거라 구지 알필요는없다.
커널 만드는 사람이 고민해야한다.

## Socket Comm(end to end : TCP, UDP)
소켓 커뮤니케이션 end to end임
한국이다 미국이다 tcp나 udp를 쓴다
tcp는 커넥션 오리엔티드고 udp 커넥션없이 보내고 마는것이다.
받든지 말든지 
그런데 모든 네트워크는 이런게 연결이 되어있다.
보내는쪽에 그 기계에 주소가 ip어드레스임 ip 어드레스 고 포트가 이제 몇십만개가 있음
포트를 하나 를 선택을 함 
상대방도 그럼 뭐가 있겠지? ip 어드레스하고 포트(상대방이쓰는 포트)
그게 일단 물리적으로 연결이 되어야하고 
이거를 연결하는것도 똑같은 것을 여러개의 소켓이 쓸수가 있다.
그다음에 그 소켓을 만드는것은 또 뭐야 프로세스임 
프로세스가 소켓을 통해서 이렇게 이쪽 소켓 이쪽 소켓 이쪽 프로세스 이쪽 프로세스가
연결이 되는 형태가 end - to -end connection임 
이게 다 필요함

물론 이게 자기 기계 에 있는것일 수도있다.
그걸 부백이라고 하는데 꼭 다른기계가 아니라 자기 기계 안에있는 프로세스 한테도 네트워크를 통해서 보낼 수 가 있다.
어떤 커넥션이 성립이 된다고 하는건 이렇게 프로세스와 프로세스가 소켓을 각각 오픈하고 그 소켓을 여기 ip어드레스 하고 포트에다가 서로 바인딩 한다고 한다. 바인딩, 소켓을 
소켓을 바인딩 한다고 한다.
그게 무슨 말이냐면 내 핸드폰 스피커를 어느 여러개의 연결선이 있는데 하나 꼽았다
그게 소켓이다. ip하고 포트가 굉장히 여러개가 있는데 
거기에다가 소켓을 하나, 파일을 오픈하는것과 같다고 말했다.
파일을 오픈해서 요고하고 연결을 시켜버리는것을 바인딩 한다고 말한다.

그리고 그프로세스가 만든거고 
이게 연결이 되야지 end to end 가 연결이 되는것이다.

그래서 tcp 하고 udp를 비교를 해보면
바인딩이라고 하는게 있어야 한다.
이것도 바인딩이 있어야하는데 
아이피 어드레스 하고 포트넘버 자기 아이피 하고 자기의 포트넘버를 알아야 하고 자기가 쓸것을 
그것을 어디에다 소켓에다가 연결을 해야댐 
그다음에 내가 만일에 보내는 놈이라고 하면 상대방도 알아야댐 
그렇다. 그런데 그말은 어떻게 상대방 껏을 알게되는지는 프로토콜 안으로 들어가서 자세히 말한다.
아무튼 udp 일경우는 내가 보내는 상대의 주소를 알아야지 보낼수있다. 당연히 이것도 바인딩을 해야하는데 
여기서 보면 여기에다가 동그라미
tcp는 stream i/O임 - 고거하고 반대되는게
UDP 에는 message-based 라는 말이있다.

그게 가장 큰 차이임
stram i/o는 무슨뜻일까 나중에 나오지만 내가 tcp를 이용해서 저쪽에 있는 컴퓨터한테 10만 바이트 짜리를 보내는데 1000 바이트씩 여러개로 나눠서 보낸다고 하자
그러면 저쪽에서 받는쪽에서 1000 바이트씩 딱딱 받느냐 
그게 보장이 안된다. 1000 바이트를 보냈는데 10바이트가 먼저 도착할 수도 있음 그렇지만 뭐는 보장이되냐 그 10바이트 받은다음에 다음 10 바이트는 1000바이트의 다음것일 것이다 라는것은 보장이 된다.
그래서 꼭 보내느 사이즈하고 받는 사이즈가 같지않다 라는 말임 
그냥 쭉 스트림으로 쭉 흘러가기때문에 
나는 1000 바이트씩 보낸다 하더라도 쟤는 10바이트씩 받을 수가 있다.
그러나 순서는 바뀌지가 않는다. 그게 골치아프다.
1000 바이트 보내면 1000바이트씩 받으면 좋은데 그게 아니다 이거임
그래서 이거는 tcp 
파일 같은거 보낼떄 좋다. 큰파일 보낼떄
내가 1000 바이트를 보내면 저쪽에서 10바이트씩 받던 500 바이트씩 받던 중구난방으로 받는다 하더라도 쭉보낸게 쭉가잔아 그래서 그게 stream I/O임 
그런데 내가 천바이트씩 보내는거가 큰 의미가 있다고 생각해보자 1000바이트씩 잘라서 보내고 1000바이트가 다른 의미가 있다고 치면
저쪽에서 1000바이트씩 받아야 할것이다. 그럴떄는 거기다가 무슨 표시를 해서 이게 이 메시지 끝이라는걸 알게해야되 
그거는 TCP에서 해주는게 아니라 유저가 직접 알아서 해야하는 end-to-end protocl을 자기가 만들어야 한다 그위에서 stream이기때문에 

flow control 이라는것은 tcp가 무지하게 똑똑해
내가 보내잔아 그쪽에서 받는쪽에서 감당을 못해 받아가지고 디스크에 넣어야하는데 감당을 못하면 
야 조금 잇다가 보내 말을 보낼수있다.
그거를 뭐라고 하냐 flow control이라고 한다.
속도조절을 할수가 있다 받는쪽에 사정에 따라서 
받는쪽의 사정이나 우리왜 
도로에서 자동차가 막힌다 라고 하잔아
막히는것은 왜 막히냐 차가 많이 들어와서 막힘 그런데 이제 네트워크에서 서브네트워크라고 하는데 어떤 네트워크를 통해서 저쪽에있는 미국의 컴퓨터한테 보낼떄 
전체 세계 네트워크 망이 있을거 아냐 그걸 서브넷이라고 하는데 
거기에 전부다 패킷이니까 여러사람이 전세계에서보내면 패킷이 엄청나게 들어오겟죠
그러면 그게 이 라우터 저 라우터 거쳐가지고 가는데 라우터가 저장될게 많기떄문에 이게 꽉차 버려서 꼭 무슨현상? 교통 체증같은 현상이 빚어진다.
그래서 패킷이 10배가 막 증가를 해서 늘어나면 소통이 안된다.
마치 차가 막히는것처럼 그런현상이 네트워크에서 컨제스챤 이라고함
혼잡이라고 하는데 그럴때는 네트워크가 너무나 바쁠때 차가 막힐떄가 마찬가지로 그럴때는
tcp가 네트워크 에 집어넣지 않는다. 패킷을
바쁠때는 
그런것도 하고 
그리고 에러 컨트롤도 한다 중간에 하다가 하나가 사라졌으면 복구할 수있다.
그런거는 다 해주는거고 여러분이 알아야 하는거는 

tcp는 stream i/o다 천바이트를 보냈다고 해서 천바이트를 받긴 받는대 받는게 10바이트 단위로 받을수도있고 
도착하는게 그렇다 이거임 

반면에 udp는 메시지로 되어있음
전보보내느거니까 내가 천바이트 보내면 받는 놈도 천바이트를 한번에 받는다.
근데 책에는 이렇게 되어있는데 내가 udp를 해가지고 무지하게 많은 데이터를 굉장히 빠른속도로 보내보니까 
받는쪽에가서 메시지 하나씩 와야하는데 메시지가 보낸게 붙어가지고 온다
여러개 보낸게 붙어가지고 올때도 있다.
그거는 커널뻑으로 예상
일단 좌우지간 udp는 메시지 베이스이다.
메시지 하나 보내면 받는쪽에서 받았을때 그게 메시지 단위로 들어온다 라는게 보장이됨
그게 달라
tcp하고 udp는 

## Ports
그래서 udp 프로그램잉이 쉽냐 tcp가 쉽겠냐?
udp가 쉽다. udp는 메시지 단위로 전하고 뭐 전화를 걸지 않고 그냥 보내버리면 되고
쉽다.
flow control이 없고
error control도 한정이 되어있고 오버헤드는 적다. 
그러나 릴라이어블 하지 않다.
중간에 가다가 없어저도 복구할 방법이 없다.

시작.
자그러면 아까 네트워크 연결할려면 소켓을 만들어야하고그다음에 	자기기기의 아이피 주소가 있고
자기가쓰는 컴퓨터에 ip주소가 있고 포트는 그 컴퓨터에 굉장히 많은 몇십만개가 있단 말이야 그중에서 
하나를 골라서 내 소켓하고 어떻게..? 바인딩을 해야됨

얘도 이쪽에서도(반대)이것을 바인딩을 해놓고 이게 연결이 되어야한다.
그래서 포트에 관한 얘기다.

## Ports(2)
A network application process uses a port in the local host.
자기의 로컬 호스트에서 내가 통신을 할려고하면 일단 포트하나를 잡아야 한다
포트하나를 잡아야하는데 이프로세스가 만번이라는 포트를 쓴다고 해서 이 프로세스가 만번이라는 포트를 못쓰는것은 아니다.
그거는 아니다 여러사람이 같이 쓸수가 있다.
그래서 
So, (IP addr + port #) can designate the peer process of the remote host
포트넘버는 여기 0에서 부터 65535 포트가 이렇게 있는데 이거는 
0~1023 개 는 Well-known ports 라고 해서 이미 어떤 서비스들이 쓰는걸로 할당이 되어있음
그러니까 이걸 쓰면안된다.
무슨 말이냐면 여러분들이 ftp 라는것을 한다.
파일 트랜스포트 프로토콜 rftp 같은거 쓰는데 그래서 파일 트랜스퍼같은것을 하는것은
포트가 69번 부로 되어있다 라는거임
이미 지정이 되어있어서 무슨 말이냐면 내가 예를 들어서
내가 파일 트랜스퍼 서버라고 하자 
파일 서버임 내가 음원을 다운해주는 서버라고 치자
그러면 음원파일을 커넥트가 접속해서 받아야 한다. 음원파일 mp3를 
근데 그거를할때에는 저쪽에서 항상 내 서버 주소는 알꺼 아니냐 
도메인 네임이 예를들어서 소리바다다 그러면 주소는 알것이고 ip 주소니까 그다음에 
저쪽 클라이언트가 다운 받는 프로그램이 내 어느 포트 한테 요청을 해야하냐면 몇번 69번한테
요청하는게 유명한것은 지정이 되어있다 라는 말임

그래서 http가 쓰는거 그다음에 도메인 네임 서버가 url을 ip주소로 바꿔주는게 이것이고
도메인 네임 서버한테 내가 통신할떄 물어본다 얘가
물어봐서 ip가 뭔지 받아온다
그런거 하는경우는 23번 같은거가 이미 지정되어있다.
이게 0번에서부터 1023번 까지는 Well-known port라고 해서 어떤 유명한 서비스들한테 할당이 되어있다.

Registered ports(1024~49151) 까지는 이것은 레지스터 포트라고 하는데 이것은 다이나믹 포트가 그렇다.(Dynamic ports)
근데 여러분들은 다이나믹 포트란 얘기는 여러분들이 맘대로 숙제하면서 쓸수있는 포트다 이거임
저포트는 맘대로 쓸수가있고
요거는 등록은 되있기는 되어있는데 이것은 사용자가 어떤것을 개발해가지고 이 포트를 가져다 뭐 어떤 의미로 유명한것을 뭘로 써라는것을 지정하는게 iana 라는 기관이있다. 여기에다가 내가 등록은 할 수있다. 그러나 무튼 여기있는건 다 쓸수가 있다.
그런데 여러분들은 그냥 숙제같은거 한다그러면 45000 대 이상을 쓰면된다 이거임
편리하다.

## Connextion Oriented Comm. Sequence(TCP)
tcp를 사용하는것에 통신절차다.
양쪽에 peer에 클라이언트하고 서버가 어떻게 통신을 하느냐 라는건데
아까 얘기했듯이 서버는 보내기만 하거나 받기만 하는게 아니고
클라이언트와 서버는 보낼수도있고 받을수도있는데
서버는 처음 통신을 시작할때 기다리고 있는놈이고 클라이언트는 전화를 거는쪽을 클라이언트라고 한다.
이게 tcp 통신 절차다.
그래서 여기에있는 api라는게 나오잔아 
이건 아까도 얘기했듯이 머야 
버클리 유니벌시티에서 만든 소켓 api를 아직까지 쓰고 있다.
그래서 어떻게 하냐면 양쪽에 
소켓을 만듬 소켓을 만든다 라는 얘기는 아까도 얘기했듯이 뭐하는것과 같냐
파일을 오픈하는것과 같다. 파일디스크립터를 하나 받아오는것이다.
소켓 디스크립터
소켓을 하나 오픈하는것이다.
그다음에 바인드 한다고 했는데 바인드가 뭐라고했지? = 내가 이제 클라이언트 가 들어올텐데 그 기다릴 로컬포트 지정을 해야됨 로컬아이피 주소하고 (내기계아이피주소하고) 고거하고 뭘 붙여야 된다고?
소켓을 붙여야 한다 그게 바인드임 
바인드에서는 자기 자신의 주소, 아이피주소하고 자기가 기다릴 포트(서버니까) 기다려서 접수를 할 포트를 이제 갖다가 소켓을 꼽는다 라고 생각을 하면됨
바인드임
그다음에 이건 이제 이름을 잘못붙임
리슨이라는게 있는데 붙여놨으면 뭐에 접속을 기다려야 하지? 클라이언트가 뭐를 전화를 걸기를 기다려야 한다
전화거는것을 그거가 리슨처럼 들리는데 이 리슨은 그런뜻이 아님
그 내가 이렇게 서버가 기다리고 있을 클라이언트 들이 굉장히 여러명이 전화를 걸꺼 아니냐 
여러명이 걸면 전화를 받기위해서 큐가 생김 클라이언트에 큐가 생김
클라이언트 큐의 개수를 지정하는 시스템콜임

클라이언트의 대기큐의 길이를 지정하는 
그러니까 만일에 지금 내가 전화를 기다리고있는데 클라이언트가 5명이 접속 요구를해서 길이를 5으로 지정했다라고 하면 5명까지는 큐잉이되는데 6명 째 들어오면 그것은 그냥 리젝트가됨 거절이됨

자 큐의 길이를 정해놓고 나서 드디어 억셉트라는것을하는데 억셉트라는게 진짜로 기다리는거임 전화를 기다림 상대방에게서 전화가 오기를 기다리고 있음 억셉트임

자 그러면 서버는 요기까지만 설명을 하고 클라이언트로 가보자
클라이언트는 소켓을 역시 오픈해야되
이것은 클라이언트 소켓임 
그러면 클라이언트 에 아이피 주소하고 클라이언트의 포트가 있을거 아니야 클라이언트도 써야 하는 포트가 있을거 아니야 
그 포트하고 바인드를 해야한다
이것도
근데 바인드가 있어? 없어?
바인드가 없음
왜없는지는 여기가서 맘한다.

커넥트가 뭐냐
커넥트가 전화 거는거임 누구한테 억셉트를 해서 기다리고 있는 전화를 기다리고 있는 서버한테 전화를 거는행위가 커넥트이다.
근데 커넥트를 할떄에는 상대방한테 전화를 걸어야하니까 커넥트의 아규먼트가 뭘로 들어가겠냐 이쪽 서버에 아이피주소하고 포트번호가 들어가겠지 당연히 어디로 전화를 걸어라 하는거니까 
그러니까 여기서 커넥트의 상대방 아이피주소하고 상대방 포트넘버를 지정해줘야하는데 내 아이피주소하고 내 네포트는 어떻게 되냐?
그거는 내가 지정을해서 바인드를 할수도있지만 바인드를 안해도 커넥트에서 자동으로 해준다. 커넥트에서 로컬아이피주소하고 로컬 포트는 임의로 지정을 해서 커넥트에서 자동으로 바인드를 해준다. 
udp 에서도 그렇고 tcp 에도 그렇고 
항상 보내는쪽에 처음 보내는쪽은 바인드 를 안해도댐
커넥트에서 자동으로 바인드를 해준다.

어찌됫거나 클라이언트 에서는 상대방 전화번호가 IP주소하고 뭐가대 상대방에 서버의 포트넘버가 됨 그것을 가지고 전화를 걸어
걸면 이제 한국에있고 이게 미국에있는 컴퓨터면 이제 라우터를 통하고 통해가지고 뭐 중국 거쳐서 유럽거쳐서 가겠죠
가는데 보내는 내용이 뭐 싱크X 뭐 어쩌구 저쩌구 이런건데
이 싱크로나이즈 라는거는 아무튼 저 싱크로나이즈라고하지말고
sin 이라는데다가 이렇게써라 = call request packet
전화거는 메시지가 간다
내 전화좀 받아
우리 통화하자 
call request packet이 간다 이거다
그러면 여기서 ack라는건 항상 잘받았다 라는뜻임
잘받았다라는건데 이 ack는 tcp계층에서 쓰는 end to end 에크날리지를 애기한다
중간단계에 있는 노드한테 보내는게 아니라 저쪽 미국에 있는 컴퓨터한테 그래 나 전화를 딱 받는 행위를 말한다.
에크날리지 + sin 이 간다음에 그거를 뭐라하냐면 call accept packet 이라고 한다.
call request packet이 왔으니까 우리 좀 통화좀 합시다 라는 call request packet이 왔으니까 
답장을 해줘야한다. 답을 해주는데 답으로 가는게 call accept packet 이라고 한다. 그래 전화하자 통화하자 이런게 간다 이말이다
그러면 여기서말하는거 또 뭐냐 그래 알았어 대답을 한다. 이런단계를 거쳐서 드디어 누구하고 누가 연결이되는거냐? 서버하고 클라이언트의 양쪽 소켓이 연결이된다 이제
이놈은 이 소켓에다 쓰면되는거고 이놈은 이소켓을 찾아서 읽으면되는거다
이놈이 이 소켓에서 읽거나 이 소켓에다 쓸수도 있는것이다.

그래서 여기보면 얘가 보내고 싶으면 이쪽에서 send 하거나 얘가 뭘 하냐? receive를 할수도있고
이쪽에서 send 한거는 얘가 receive 할수있다. 그런데
이때 사용하는게 뭐냐면 write할때 우리가 파일 디스크파일 오픈해서 write 나 read할때 앞에 ft가 하나 붙는데 그거와 마찬가지로 여기도 소켓 ft가 붙는다.
그러니까 send가 사실은 뭐라고 했지?
send 가 write 라고 했고
receive가 read 다 이런얘기다 똑같은 말이다. 
(크로스)

통신을 막 하다가 끝나면 close 되면 이제 뭐냐hl
우리 끝내자 그래 알았어 
그래 빠이빠이 하는게 close가 된다
그런데 이렇게 close를 하더라도 저 포트가 프로그램을 또 금방 돌리면 
아직까지 사용중이라는 말이 나올떄가 있다.
그건 뭐냐면 내가 close를 하고 프로그램 금방 또 돌려
그런데 그게 진짜로 close가 될려고 하면 이게 왔다갔다 해야됨 
그래서 시간이 좀 걸릴떄가 있다 라는 애기임 
그래서 금방또 재사용 할경우에는 문제가 생길 수도있다.

## Connextionless Communication(UDP)
커뮤니케이션 타입에 대해서 얘기하는데 3가지 봐야된다.
심플렉스 뭔가요 - 단방향통신이다 예를들면 라디오라든가 관리실에서 방에다가 인터폰으로 떠드는거 내가 대답할수없으니까 단방향이다.
half duplex - 이거는 대표적인게 무전기나 오키도키 같은거, 둘이 동시에 얘기할수가없다 한쪽에서 얘기하면 오바하고 ??? 한다음에 내가 얘기하고 그럼 이쪽에서 절로갔다가 또 바껴가지고 저쪽에서 일로오는것을 번갈아 가면서하는거지 동시에 둘이 얘기할수가 없다.
무전기는 hlaf - duplex 라고한다
양방향 통신은 되는데 동시에는 안됨 번갈아가면서 해야 된다.
휴대폰은? 휴대폰은 full duplex 라고한다.
이거는 완전히 동시에 서로 양쪽에서 떠들수가있다.
full - duplex 양쪽에서 동시에 보내고 동시에 받을수가 있는게 풀 듀플렉스다.
당연히 전화거는건 풀 듀플렉스임
그렇다. 
여기서 하고 자 하는얘기는 우리 네트워크 커뮤니케이션에서는 센드에 리시브하는것은 다 뭐다? 풀 듀플렉스다 이거임 동시에 주고 받을 수가 있다.

그런데 요새는 또 전화기 앱중에 그런게있다. 옛날에는 공사장에서 공사하시는 인부가 100명이 공사장에서 일을 한다그러면 다 무전기를 차잔아 그래서 half duplex 하는게 편하단 말이지 
그거는 half duplex로 한사람이 얘기하면 모든 인부한테 다간다
그런데 무전기 들고다니고 뭐도 들고다녀야대? 휴대폰도 들고댜녀야하니까 귀찬다.
휴대폰, 무전기는 없애버리고 휴대폰으로 뭘 흉내를 내? 무전기 흉내를 내는것도 장사가 잘된다. 
그래서 전화기를 마치 뭐처럼 쓰는거냐 무전기처럼 쓰는것이다.

누차말하지만, 돈버는것은 프로그램 잘짜는게 아님 
프로그램 잘짜는사람 많음 돈벌려면 새로운 서비스를 만들어야댐 
창의적인 서비스를 만들어야함
이세상에 소프트웨어가 어딨는지 많이 아는사람들이 이기는세상이 왔다이거임
ai 을 할려고 하면 ai 공부해가지고 프로그램 짜는 시절은 지남
왓슨 플랫폼 , 텐서 플랫폼을 쓰면됨 간단하다
도구들을 잘쓰는사람들이 이기는 사람이다 도구를 잘쓰니까 ai 변호사나오고 
ai로 초등학생들 영어회화 가리킴 
자기가 음성인식해서 대답해서 그러는데 가맹점 만들어가지고 300개가 넘음
학원이 그것이 돈버는 세상임 
만드는데 시간이 얼마 안걸림
중요한거는 돈벌려면 새로운 서비스를 만들어야 한다. 프로그램은 컴퓨터공학과 졸업생한테 시킨다.
디바이스레벨 - 너무많음(윗단임)

그래서 전에도 얘기했지만 교육학에 대해서
앞에 앉아있는사람은 시키는 일을 잘하는사람들이고 근데 별볼일이 없고
미안하지만 가운데 앉아있는사람들이 제일 별볼일이 없고
저 뒤에서 딴짓하고 휴대폰보고 뭐 피어싱하고 뭐 다리꼬고 떨고앉아있는 사람중에서 
한사람이 만명을 먹여 살릴수있는게 100명중에서 한명이 나온다
프로그램은 못짜는데 항상 반항이 있어서 새로운 서비스를 생각한다

## Connextionless Communication(UDP)
그래서 send 하고 receive에 여기 밑에다 써라 full duplex 라고 
양방향 통신이 된다.
udp 
udp를 할때에는 Connectionless 이게뭐 전화같이 연결이안되도 그냥 상대방 주소만 알면 너 메시지 받으라 하고 그냥 보내버리고 만다 라는 뜻임 그래서 서버라는거는 여기서 처음에 사실은 기다리는놈이 됨
서버라는 뜻이 서버가 꼭 이렇게 안해도 되는데 클라이언트와 서버가 바껴도 된다는 뜻이다. udp 얘기하면은
좌우지간 먼저 보내는놈이 이제 클라이언트로 했다.
그리고 보면 역시 서버도 소켓을 오픈한다.
그다음에 바인드를 한다.
바인드를 한다라는건 아까 뭐라고 했냐 바인드는 소켓에다가 뭐 붙이는거냐? 
누구의 ip?, 자기자신의 ip 하고 자기자신이 쓸 포트를 지정해야댐 그걸 지정을 해서 
소켓에다가 붙이는게 바인드고 그다음에 아까 뭐 전화를 기다리는게 아까 여기서는 억셉트였잔아 
그런 행위도 필요없다 그냥 recevfrom을 하면 누구한테 올지 모른다 메시지가 recevfrom을 하고있는거다근데 누구한테 올지는 모르는거다 아무나 쏴바라 누구한테 내 ip하고 내 port 한테 쏴바라 이렇게 되는거다
그러면 보내는쪽은 소켓을 오픈하고 바인드 안해도 된다 이것도
보내는쪽에서는 
자동으로 해준다 sendto를 합시다. sendto가 화살표가 잘못됬는데 recevfrom 까지 가는것이다.
전화연결과정이 없음 sendto를 하면 recevfrom으로 메시지가 전달이 되서 얘가 recevfrom에서 기다리다 깨어난다.꺠어났을때 에는 뭐냐면 뭐가 메시지가 온거임 
근데 뭘 알아야하지? 누가 보냈는지를 알아야함 
그래서 아까 receive 하고 달리 receivefrom 이라는거는 누가 보냈는지 상대방의 ip주소하고 상대방의 port번호를 알려준다.
여기에서는 상대방이 누군지, 보낸놈이 누군지 알려준다.
그러니까 이런 클라이언트는 여러개가 있을 수 있는거다
아까 tcp는 이건 원투 원투 커넥션임
전화를 받아야 되니까 반듯이 원투 원투 커넥션이다.
그래서 udp 이거는 커넥션이 없으니까 클라이언트가 여러개 가 애도 sendto 하고 얘또 sendto 하고 그러면 나는 receivefrom에서 기다리다가 어떻게 되냐 메시지가 들어오면 깨어났는데 이놈이 보냈을 수도 있고 저놈이 보냈을 수도 있는거다 뭐만알면 내 아이피주소하고 내 포트번호만 알면 나는 받은거야
그대신에 receivefrm에서는 뭘 알려주냐면 누가 보냈는지 즉 보낸쪽의 ip주소하고 포트 번호가 들어온다 이거임

그러게 하고 나서 그놈주소를 이제 알았음 알았으니까 나도 또 sendto 할수있음 
상대방주소를 알았으니까 receivefrom 이쪽에 할수도있고 이거는 자기가 프로그램 짜기 나름이다.
내가 set??? 나는 receive 만 할껀지 아니면 send도 할껀지
이거는 여러분 마음이다.

프로그램을 짜다보면 여러가지 시스템을 만들다보면 제일 어려운게 p_thread 프로그램하고 네트워크 프로그램은 사실 맛만 살짝 보여주는건데 깊이 들어가면 굉장히어렵다.
그래서 다른점은 뭐냐면 연결과정이 없이 직접상대방 주소만 알면 sendto를 하고 그다음에 receivefrom을 하고 그것에서 알수가 있다 라는거 하고 연결과정이 없다.
연결과정은 아까 얘기했듯이 tcp 에서 억셉트하고 커넥트 (전화거는행위)가 없다 이런것이다.
이것도 역시 끝난다음에는 아까와 마찬가지로 빠졌는데 close close한다
소켓을 close 하면 네트워크 커넥션이 끊어진다.

## Socket Address Structure
아까 여기서도 나왔고 여기서도 나왔고 바인드가 있잖아
바인드는 뭐냐면 바인드는 나에 로컬 아이피주소하고 내가 쓰는 포트를 소켓에다 연결시키는거 아니야
소켓은 만들어 놓고 그러면 내가 쓰는 아이피주소하고 내가 쓰는 포트번호를 어디다가 struct에다가 저장하는 구조체가 있어야한다 그걸일단 만들어야지 이제 연결시킬수가 있으니까
그래서 그 구조체입니다. 그 구조체가 소켓 어드레스 struct 이다. 
소켓의 어드레스가 아니라 소켓 하고 연결할 뭐가 되는거냐 ip 번호하고 port 번호를 지정하는 그러한 구조체가 있다 이런얘기다 . 이거를 먼저 준비를 해야한다.

그런데 요새는 거의 인터넷으로 통일이 됬지만 예전에 네트워크가 처음 생겼을때에는 네트워크가 다 달랐음 
즉 제록스라는 회사에서 만든 네트워크에 아이피 주소하고 뭐 이런게 있잔아 아이피주소 체계도 다르고 제일 유명한 네트워크는 미 국방선에서 달프라고 있음 미국방선에서 펜타곤이 있잔아 저기 건물 팔각형인가하는 
거기서 만든 네트워크 프로토콜이 아니라 체계가 있었음 
엤날에는 전세계가 연결된게 아니라 미국방선에 연결이 됬다라든지 아니면 뭐냐한국에 뭐 무슨 어떤 그륩에서 사이트가 연결이된다든지 이런 개념이 네트워크임 
이제 그러다가 이 네트워크가 뭘로 발전을 하냐? 전체에 전세계에 있는 모든것을 통일해서 연결하는걸로 바뀜
그게 뭐냐 그게 인터넷임
인터넷이 뭐에 약자야 인터 네트워크 약자임 인터넷이
영어로 발음하면 이너넷 인터넷은 인터 네트워크!
무슨말이냐면 미국에도 여기저기 네트워크가 자기네들끼리 회사에서 쓰는 네트워크 국방선에서 쓰는 네트워크 한국에 사는 무슨 대학교에서 쓰는 네트워크 이런게 있었는데 옛날에는 그렇게 어떤 지역이나 단체기관에서 네트워크가 형성되어있었는데 
그런 네트워크를 또 네트워크로 연결한다고 해서 무슨 네트워크냐? 인터네트워크라고 했고 그것을 줄여서 인터넷이라고함 

그러니까 옛날에 기존 네트워크에서 쓰든 그런 주소체계하고 그다음에 인터넷을 쓰는 주소체계가 달라졌을 꺼 아니냐 만드는데가 다르니까 그래가지고 이 주소를 가져다 집어넣는방법이 네트워크를 뭘쓰냐에 따라서 다 다르다.

다르기때문에 여러가지가 있을수밖에 없다. ip주소하고 포트번호를 표현하는 방식이 여러개 가 잇을 수밖에 없어서 할수없이 이거는 레프레젠테티브 대표적인 스트럭쳐, 가상적인 스트럭쳐 실제로 쓰는게 아니고 
스트럭쳐 소켓 어드레스 라는거는 이 사실은 소켓의 어드레스가 아니라 뭘애기하는거냐
아이피주소체계하고 그다음에 포트번호를 가져다 어떻게 지정하느냐 하는 구조체인데 
여기에 보면 family라는게 나오잔아 family 가 바로 그거임 
인터넷에서 전체세계를 연결하는 인터넷 체제로 쓸꺼냐 아니면 국방선안에서만 쓰는 다른 아이피주소 체계를 쓸거냐 그런 거를 패밀리라고한다.

패밀리마다 뭐가 다 다르다는 거냐? 아이피주소를 표현방법이 다다르다 이런말임
그래서 이 다르니까 이 길이도 (length) 들쭉 날쭉하다.
그래서 이 길이를 여기에다 저장하고 있고 여기보면 array가 캐릭터 데이터가 14개가 있는데 
14 바이트에 들어가는 포맷이 뭐마다 다다르냐? 국방선 네트워크가 다르고 일본에 뭐가 다르다 이런말임
그렇기 떄문에 여기서 이것을 상세하게 쓰지 못하고 그냥 대표적인 구조체를 얼버무려 놓은것이 sockaddr 임 
실제로 여러분들이 쓰는거는 저게 아니고 뭘 써야되는거 인터넷 주소체계를 써야되는데 그게 바로 이거다.
여기에 _ 하고 in을 붙임 인터넷이란 얘기임
인터넷은 다시 한번 말하지만 뭐에 약자냐? 인터네트워크에 약자임

## Socket Address Structure of the Internet
그래서 여러분들이 쓸 인터넷에 네트워크체계는 여기에 address_struct에 길이가 들어간다
그러니까 무슨 말이냐면 어드레스가 ip주소가 ipv4에서는 몇 bit? 32bit이지만 만일에 ipv6를 쓰면 몇비트? 128 비트임 그러게 길이가 다다르다.
패밀리가 바로그거다
예를들어서 ipv4를 쓸거냐
ipv6를 쓸꺼냐 
아니면 제록스 네트워크 의 체계를 쓸꺼냐 
아니면 달파 네트워크의 체계를 쓸거냐 
그 패밀리를 나타낸다

내가 지금 방에서 프로그램 짜는데 고생하는ㄱ ㅔ뭐냐면 
실험실에서 하는것은 컴퓨터를 10대를 연결해서 분산컴퓨팅 하는것을 하고있는데 
실제 컴퓨터몇개 없으니까 컴퓨터 하나를 가지고 이컴퓨터 10개를 시뮬레이션 해야대
근데 통신프로그램에 룹백이라고 해서 밖으로 보내잔아 네트워크 통해서 보내면 그게 얼루드 들어오냐
자기자신한테도 들어와서 여러대인것처럼 흉내를 낼수가있다.
그얘기는 패밀리중에서 뭐가 있냐면 룹백도 있어
뭐냐면 네트워크 프로그램을 내가 테스팅 하고 싶은데 두대의 컴퓨터가 필요하다
그런데 두대의 컴퓨터 하는게 아니라
하나의 컴퓨터로 해서 프로세스를 서버하고 뭐를 만드냐? 클라이언 2개를 같은 기계에서 돌리면서 마치 네트워크에서 통신하는 프로토콜 을 전과정을 거치게 해야 테스트될꺼 아냐 그걸 룹백이라고 하는데 
그때 주는 주소체계가 또 다르다.
그게 패밀리다. 나중에 나올것이다.

여기에 보면 포트가 있음 그다음에 그다음에 struct in_addr sin_addr 가 32bit 아이피 어드레스임
32bit 아이피 어드레스인데 
struct in_addr 을 보면 이거는 뭐냐면 32bit ip주소가 unsigned long  unsigned integer로 들어가있다.
그리고 나서 이 인터넷은 아까 여기에서 이 14가 있었는데 길이가 남잔아 그래서 여기에 8bit는 0으로 채워지게 된다. 
저거를 할때는 항상 0으로 채워야한다. 그런데 바인드 같은거 할때는 이 주소 체계를 줘야하잔아 주소 체계를 줘야하는데 이걸 쓰기는 쓰는대 api가 아규먼트가 타입이 뭘로 되어있냐? 이걸로 되어있음 
그래서 이것은 캐스팅을 해야됨
만들어 놓고나서 그렇게쓴다.
api를 그렇게 디파인 했으니까
무슨 네트워크를 쓸지 모르니까 그렇게 정의는 해왔는데 
우리가 쓸꺼는 sockaddr_in 이다.
요거를 할려면 요거를 

## Socket Address Structure
그래서 아까 얘기했듯이 이안에 들어가있는 패밀리의 종류같은것을 보면 
AM_INET 이라고 하면 
AF_PF 라고 써도 되는데 
AF_INET이라고 하면 이게 인터넷 주소체계의미 Ipv4나 Ipv6를 쓰겠다 이말임 
AF_UNIX 라고 하면 아까 말했던것처럼 뭐라고! 한기계에서 룹백을 이용해서 여러기게를 흉내낼수가 있다.
그래서 같은 기계안에 서버하고 클라이언트가 네트워크 프로토콜을 이용해서 통신할 수 있는데 그 이터널하게 로컬 커뮤니케이션할 때 쓰는 게 마치 네트워크을 쓰는것처럼 그겍 AF_UNIX이다.

우리 한기계에서 프로세스 간에 통신을 할려고 그러면 많이 배움
메시지 큐도 배워고 파이프도 배웠음
소켓을 쓰는건데 한기계안에서 통신하는데
그런데 무슨차이가 있냐면 파이프는 그냥보내는거고 
소켓은 네트워크 프로토콜을 다 거쳐가지고 전달한다. 불필요한 핻동이지만 왜냐하면 디버깅을 해야 하기때문에
개발하는 단계에서
그렇게 쓰는게 AF_UNIX다.

AF_NS 라는것은 이거는 제록스는 다 알지? 복사기 만드는 회사임 얘네가 만든 네트워크 어드레스 체계임 
엤날에는 저런게 다 따로따로 있었음 
그래서 보면 소켓이라는것은

## Socket(2)
여기에 또 도메인이 들어간다
도메인이  아까 이거 sin_family하고 마찬가지 개념이다.
그래서 PF 로 되어있는데 AF로 해도댐
PF_INET : internet protocol 
PF_INET6 : IPv6 protocol 
PF_UNIX : 로컬 커뮤니케이션을 쓴다고 했음
PF_NS : XEROX 이런게 있음
PF_IMPLINK: 옛날에 1970년대 제일 유명한 컴퓨터 회사는 어디 ibm 이었음
그당시 컴퓨터 엄청 컸음 비쌋음, 근데 지금 pc보다 엄청 느릴것이다.
그런거 만드는게 ibm이 제일 유명했음
ibm에서 만든 네트워크임
이거는 아까랑 똑같다. 주소체계 는 뭘쓸것이냐 type이라는게있다.
type이라는것은 소켓 타입을 말한다.
소켓 타입을 얘기하는데 소켓 타입은 아까 얘기했듯이 소켓 데이터그램 하면은 이것은 udp로 쓰겠다 이것임 
udp 형 소켓임 
소켓 stream하면은 아까 tcp는 stream i/o라고 했음
그래서 여기는 tcp를쓰겠다.
프로토콜은 뭐냐면 tcp가 stream i/o를 하는 대표적인 프로토콜 이지만 
tcp가 있지만 내가 만일에 tcp보다  더 좋은 프로토콜을 만들수도있다.
그럼 그프로토콜을 쓸수도 있는것이다.
이제 일반적으로는 요 프로토콜에다 0이라고 주면 디폴트가 머냐 tcp가되는거고 요경우에는 udp가 되는거다.
근데 tcp 대신에 다른 프로토콜도 쓸 수 가 있다.
그러니까 요 프로토콜은 뭘로 하면되냐?  0으로 하면 이게 디폴트가 된다.
tcp 또는 udp가 된다. 따라서 이제 소켓 데이터 그램이라고하면 udp가 오고 이소켓은 이소켓을 stream으로 open하면 tcp가 된다 라는것임 
자이렇게해서 이게 뭐하는거야? 소켓을 하나 만드는거임
아까 뭐랑 똑같다고? 파일 오픈하는것과 똑같다 그래서 여기 리턴 밸리유가 인테져 인데 이게 소켓 아이디 인데 파일 디스크립터와 똑같다 아까 파일 디스크립터가 오픈 하면 3,4,5 부터 나가잔아 요것도 똑같이 파일이 이미 4번이 오픈되어있으면 소켓하면 5번이 리턴된다.
꼭 파일 디스크립터랑 똑같다.

소켓만드는데 실패하면 마이너스 1이 리턴이 된다.
여기보면 소켓 스트림도 있고 소켓 데이터그램도 있는데 소켓 raw라는거 는 주로 모할때 사용하냐면 전에도 얘기힜듯이 핑할떄 핑프로그램 짤 때 사용한다.

## bubd(2)
소켓을 만들었으면 아까 뭐해? 바인드 해야함 바인드는 누차말했듯이 만들어진 소켓에 나의 로칼 아이피주소하고 로칼 포트넘버를 가져다 붙임 이건 오픈한 소켓의 디스크립터임 소켓디스크립터, 파일디스크립터임 
그다음에 아까 얘기한 소켓 어드레스 구조체가 나온다. 실제로 우리가 이걸 쓰는게 아니라 뭘쓴다? 여기 뒤에 _in 용으로 쓴다. 여기에 뭘 채우는거냐? 길이하고 패밀리하는 AF_INT, 포트는 내가 쓸 포트, struct addr sin_addr 이거는 my 내기계에 ip주소를 집어넣어서 요구조체를 가지고 뭘 부르면 bind를 부르면 여기에 구조체 들어갔음 구조체를 가지고 부르면 이제 소켓하고 나의 포트 하고 ip주소가 연결이된다. 근데 요거가 소켓 어드레스_in 이었는데 요걸 부를때는 api가 이렇게 이렇게 디파인 됬으니까 뭘로 캐스팅해야되?
socketaddr 로 캐스팅해서 보내야된다.
요 addr length라는건  요 struct의 길이를 얘기한다.
바인드는 아까 서버쪽에서 바인드하고 클라이언트쪽에서 tcp를 쓸떄 전화를 거는것을 커넥트라고 함 
전화를 클라이언트가거는거임

## connect(2)
전화를 클라이언트가거는거임
그럴떄에는 자기가 소켓을 공유해서 쓸떄니까 오픈된게 있고
그다음에 커넥트하는놈은 바인드를 안해도 자동으로 바인딩을 해줌
바인딩은 얘는 할 필요가없고
여기에 address 구조체가 들어가는데 이게 내 주소에요 남의주소에요? 이제 전화거는거니까 남의주소가 들어감
즉 내가 클라이언트면 뭐에 어드레스가 들어가? 서버의 address가 들어감 서버의 ip주소하고 뭐가들어가? 이안에 포트번호가 들어감
그리고 요거는 요거에 길이임
그래서 커넥트를 한다고 하는것은 뭐냐면 이제 전화를 거는것이다
커넥트에 상대되는게 뭐지
아까 억셉트였음
아까 커넥트에 상대되는게 이쪽에서 tcp에서 억셉트하고 있어야댐
근데 얘가 느려가지고 억셉트 하고 있지 않으면 어떻게되냐?
에러가 리턴이된다.
먼저 뭘 돌려야하나? 항상 억셉트를 돌려놓고 나서 항상 클라이언트가 돌아가야한다.
커넥션이 실패하면 통화중이다 이런 정도로 생각하면됨
리턴밸리유는 이제 성공이면 0이고 에러이면 -1임

## listen(2)
그다음에 서버쪽에서는 소켓을 만든다음에 뭐한다?
리슨한다고 했음
리슨이라는것은 클라이언트가 접속대기를 하잔아
하나하나 얘기하고있으면 대기를 할텐데 그 큐의 길이를 가져다 지정을 해준다
이걸 5라고 하면은 5까지 밀려있을 수있다.
그러면 6번째 들어오는것은 어떻게되냐? 그냥거부해버린다.
이거는 이제 서버에 노드를 가져다 조정하기위해서이렇게만든다.
그다음에 억셉트라는게 실질적으로 뭐냐? 억셉트라는게 서버가 뭘기다리는거라고?
아까 전화를 기다리는게 억셉트임 그래서 
억셉트를 보자

## accept(2)
억셉트는 내가 오픈한
서버가 오픈한 소켓
그다음에 struct sockaddr *peer 라고 되어있음
자 이소켓에서는 바인드가 됬죠 이미 내 주소는 바인드가 아까됬음
무슨얘기냐면 아까 서버쪽에서보면 서버쪽에서보면 listen 하고 accecpt하기전에 내소켓은 내주소는 바인드를 했잔아 그렇다 
억셉트를 하면 여기서 커넥트하고 만나는거잖아
그러니까 억셉트해서 받는것은 뭘 받아야해?
상대방의 ip주소하고 상대방의 포트번호를 받아야된다
그래야지 전화가오면 여기 누가전화했는지 전화번호가 뜨잔아 그얘기다.
상대방이 그거가 리턴이 되어야하는데 그게 여기로 리턴된다. 여기서 억셉트를 하면 억셉트를 하면 요 struct addr에 포인트를 줬잔아 상대방 지금 연결이될 클라이언트의 주소 (ip주소하고 port번호하고 그 주소) 그 구조체길이가 리턴이된다.
그래서 여기보면 요것도 포인트로 되어있음
그런데 이제 중요한게 있음
중요한게 뭐냐면 억셉트해서 기다렸다. 그래서 상대방이 커넥트를했음 그런데 여기에 내가 억셉트를하는데 사용된 소켓이 요거잔아 오픈한 소켓이 그러면 일로연결이 된거잔아
그런데 이 클라이언트하고 접속이되서 억셉트해서 리턴이 되면 좀 접속이 됬는데
내가 클라이언트하고 뭘 보낸다고 치자 만일에
또는 받는다고 칠떄
이 소켓을 쓰면 되겠어 안되겠어
이 소켓을 쓸수가 없다.
왜? 요 소켓을 만들어서 바인드를 해가지고 억셉트를 할때 사용한 요 소켓은 내가 서버이기 때문에 계속 다른 클라이언트를 기다리고 있는 소켓이다 이거임
전화교환수가 쓰는, 호텔에 프론트에서 전화교환수가 쓰는 소켓이다.
그런데 억셉트를 하면 누구하고 접속이됬어? 클라이언트하고 어떻게? 접속이됬단말이야 그래서 억셉트가 리턴밸리유여기에보면 노말, 에러가 아닌경우에는 a new socket descriptor가 리턴이 된다.
새로운 소켓이 하나 자동으로 만들어진다.
자동으로 만들어지는데 이 새로운 소켓이 만들어져서 이걸 리턴밸리유로 리턴이 되는데 요
전화가 연결이된 클라이언트하고 통신할때는 뭘쓴다 이거임?
새로운 소켓을 쓴다 이거임

새로운 소켓은 접속된 클라이언트하고 통신을 하는데 send, receive하는데 쓰는거고 
이 소켓은 뭐하는데 쓰는거냐? 계속해서 단 클라이언트 기다려야 하잔아 단 클라이언트 에대해서 억셉트를 룹을 돌면서 해야하기떄문에 이소켓은 안쓰고 새로운 소켓을 하나 만들어준다. 

자 그러면 서버입장에서 억셉트가 됬다. 지금 서버입장에서 억셉트가 됬음
그러면 졸지에 소켓이 몇개가 생겼어? 2개가 생겼음
옛날 소켓하고 새소켓이 생겼음
근데 하나는 내가 계속해서 억셉트를 또해야대 다른 클라이언트때문에 또하나는 클라이언트하고 어떻게되? 통신을하는 소켓임
근데 서버하나가 어떻게 두가지를 한꺼번에 하냐?
그래서 그때 쓰레드를 만들거나 포크를 한다 이거임
새로운 소켓이 하나 생겼잔아 그다음에 옛날에는 fork를했음서버가
그래서fork를 해서 child process는 이 새소켓을 가지고 누구랑 대화를 하냐 클라이언트랑 대화를 하고 
parent process 는 계속해서 룹을 돌면서 뭘하냐? 또다른 클라이언트를 기다리기위해서 옛날 소켓가지고 억셉트를 하는 형태로 프로그램을 짜야된다.

## send(2) for TCP
그리고 일단 접속이 되면 서버는 클라이언트랑 아까 무튼 
full-duplex이기 떄문에 누구나 send를 할수있고 누구나 receive를 할수있따.
그래서 클라이언트가 자기소켓 그다음에 서버면 새로생긴 소켓 
그런것을 이용을해서 뭘 보내고자할떄는 메시지 버퍼에 있는것을 1000바이트면 1000바이트 만큼 이것을 보낼수가있음 send통해가지고 
이제는 뭐냐면 연결이 됬기때문에 send할떄 상대방 ip주소하고 포트번호가 필요가 없다. 일단 연결이됬기떄문에
udp는 뭐냐면 연결이 없기떄문에 내가 메시지를 만일에 쟤한테 3번 보내야 된다고 하면 sendto를 쓸꺼아니냐 send가 아니라 그떄는 3번 보낼떄마다 뭘지정을 해줘야되? 상대방의 ip하고 포트번호를 지정해줘야지 그게 udp임 그거는 연결이 안했으니까
근데 이거는 전화식연결이 됬기떄문에 이제는 나와 뭐냐면 소켓에 다 뭐든 정보가있음
뭐냐면 상대방의 주소하고 아이피는 알필요가 없음 그냥 소켓을 보내면된다.
그리고 이 소켓하고 접속이된 클라이언트한테간다.
그래서 파일에 write하는것과 같다.
파일을 open한 상태에서 
그래서 버퍼를 주고 바이트를 준다. 

이런거는 나도잘 안쓰는데 메시지 all이라고 하면 
MSG_OOB : 이 데이터는 굉장히 중요한 데이터이기때문에 기존 라우팅을 하지말 고 빨리 다른데이터가밀려있더라도
먼저보내라 라는뜻임
MSG_PEEK : 내가 send를 했다. 그럼 밑에있는 프로토콜이 가다가 천바이트를 send했으면 밑에있는 프로토콜이 받아가지고 또 어덯게해? 라우팅을 시작해서 건너건너 보내기 시작하겠다. pekk 이라는건 아직까지 보내지말라 그냥 라우터가 버퍼에 좀 쌓아놓고있어 왜? 내가 또 할테니까 그거 채워지면 나중에 보내라는 뜻임
MSG_DONTROUTE : 라우팅 하지 말라뜻인데 써보질 않음( 어떤 경우에쓰는 지 찾아보셈) 

## send(2) for TCP
send임
자그래서 이제 클라이언트가 됫든 뭐가 됫든 연결된 소켓에 대해서 send를 했다고 치자
1000 바이트를 센드를 했음
센드를 하면 이 센드를 하면 천	바이트라는것은 아까 얘기했다싶이
천 바이트라는건 그거를 뭐라고 한다고? 메시지라고 함
메시지, 그러면 밑에 프로토콜에 내려가면 그 천바이트가 길면은 패킷단위로 회를 친다고해서 
따로 따로 보내기 시작한다.
그러면 받는쪽에서는 열바이트 씩 잘라서 보냈으면 그걸 재조립해야한다.
근데 재조립을 잘안한다. tcp는 (?)
아까 무슨 i/o라고 했으니까?
stream i/o라고 그래서 10바이트가 전달될수도있음 
순서는 맞지만 
그래서 stream i/o라고 그랬다. 이런얘기임
그래서 여기보면 내가 여기 천 바이트를 보내달라고 헀더라도 이게 실제로는 500 바이트만 갔을수도있다.
그래서 여기 리턴되는 integer가 뭐냐? 실제로 보낸 데이터의 개수다.
바이트의 개수

간단한 프로그램을 짜는건 쉽다.
통상 어떤 한국에서 만든 소프트웨어, 네트워크가 포함되어있는 프로그램을 보면 잘못하는게 뭐냐면 에러가발생했을떄 처리를 못함
실제 목적 프로그램을 천줄을 짰다 그러면 300줄은 다 그런 에러 관리하는 코드가 들어가야하는데 그렇게 짜는사람이 없음
에러 처리가 골치아픈게 네트워크임 왜냐하면 나혼자 하는일이아님
저쪽이 끊어졌을때 재접속하는 프로토콜이 있어야하는데 내가 알아서 하고 서로 약속이있어야함
에러 관리 하는게 어렵다.
5 컴퓨터가 통신을 하는데 여기에 내가 하나가 있고 여기 4개가 있으면 그게 tcp 를 통신하려고 하면 
전부다 point to point 하려고하면 5 콤비네이션 2 라고 해야함 머리가아픔
5대가 똑같이 통신을 할려고하려면 내가 master역할을 해서 모두다 4슬레이브가 나한테 보낸다.
나하고만 연결한다. 내가 받은것을 모든 슬레이브한테 보내주도록 프로그램을 쓴다. tcp는
서로 연결하기가 지저분하니까 그렇게 프로그램을 짜면 무슨 문제가 있어? master가 죽으면 아무것도 안돌아감 master 죽을때 그걸 슬레이브가 알면 자기가 마스터 역할을 함 4명의 슬레이브가 눈치보기 시작 
abort를 할껀지

send를 했다. 1000바이트 보내달라고 했어 그래서 integer가 뭐가 리턴이 됬냐면 1000이 리턴이 됬다.치다 그러면 send에서 return이 된거야 1000바이트 보냈다 라고 밑에프로토콜에서 답장이 왔음
send에서 return 이되면 이 1000바이트가 미국에 있는 컴퓨터까지 간거냐 안간거냐?
안간것이다. 그게 아니고 밑에있는 프로토콜이 tcp 잔아 tcp 레이어에서 천 바이트 잘 접수했다. 이런 뜻이다.
접수 증 내주는거임
그때서부터 보내기는 tcp는 tcp대로 어떻게되냐 각 프로토콜에서 미국으로 보내기 시작한다. 
send에서 return 이 됬단 얘기는 프로토콜까지 천바이트가 전달이 됬다 라는 뜻이지 이게 end to end communication 저쪽에 미국에 있는 컴퓨터까지 잘 전달이 됬단 얘기가 절대로 아니다.
디스크에다 이거 쓰는거면 어떻게되냐?

디스크에다 쓴다음 리턴하는게아니라 페이지캐시에다 쓰잔아
디스크 까지 안감 마찬가지로 이것도 프로토콜 버퍼까지만 전달이된거다. 그떄서부터 프로토콜이 알아서 뭡니까 쪼개가지고 패킷단위로 쪼개서 회를 쳐서 전달 전달 해가지고 보내기 시작할것이다.

나한테 리턴이 된것은 밑에있는 프로토콜까지만 간것이다.

그러면서 Completion of send() successful return, send를 했는데 return이 성공적으로 왔다고 하더라도 This means that the data messager has been stored in the sender's protocol buffer successfully, send에 포로토콜에 버퍼에 저장이 됬다 이런뜻임
send 에 프로토콜에 버퍼는 왜필요한가? 프로토콜 버퍼는 왜 필요할까? 보내면 말면되지
이유는, 보냈어 옆의노드한테 보내야할거아냐 
보내야 되는데 보내는데 얘가 뭐야
오다가 잘못보냈다고 메시지가 오면은 다시 보내줘야한다. 그러니까 다시 받았다 라는 메시지가 올떄까지 이건 항상 keep해야한다.
그래서 프로토콜 버퍼가 있는것이다.
재전송하기 위해서 
잘받았다라는 메시지 가 와야지 , 버퍼에서 비로소 지워진다.
그러니까 네트워크에 무지하게 통신을하는 패킷들이 많이 돌아다니면 패킷을 가져다 다 저장하고 있어야하잔아
언제까지, ack받을때까지 
그러니까 네트워크가 복잡해지면 어떻게 되? 라우터의 뭐가 꽉차버리는거냐? 버퍼가 꽉차면 안돌아간다.
그걸 네트워크 컨제스쳔 이라고한다.

자동차막히는것과 똑같다.
예를들어서 1kbps 이더넷이 있다.
100M bps 이더넷이 있다. 100Mbps 이더넷을 쓰잔아 pc에 100메가 바이트 해가지고 거기다가 50 메가 바이트의 전송속도로 1초에 	 50메가 바이트 정도만 보내면
보내는 스피드가 100메가 바이트 정도 나온다. 
100 메가 바이트 이더넷이라고 했는데 1초에 100메가 바이트 씩 집어넣으면 10메가 바이트도 안나온다. 
쫓아가질 못한다. 
바로 저런것들
그래서 
The data stored in the protocol buffer will be removed when an ACK message is arrived from the receiver's protocol
상대방 보내는쪽에서 , 받는쪽에서 어떻게 되냐?
서로 인접노드에서 ack 잘받았다라는 메시지가 와야지 버퍼에서 제거가 된다.
그런데 ack 가 안온다.
ack 안온다. 그러면 즉, ack를 무한정 기다릴순없다. 그래서 예를들어서 1초동안 안에 ack가 와야한다.
그런데 	 뭐가 안왔어? ack가 안오것을 ack timeout이라고 한다.
이런것은 어떻게하는거? timeout을 어떻게해야져?
여러분들 얼람 배웠잔아
얼람 5초있으면 5초지나면 알려주는거
그런것으로 프로그램을 짠다.
ack timeout 이라는것은 정해진 기간안에 잘받았다라는 답장이안옴 
nack 는 네가티브 애그날러지 라는뜻임, 이거는 시간내에 오긴왔는데 받은쪽에서 데이터를 받아보니 이 데이터가 깨져있다 이런뜻임 쳌썸(checksum)이 안맞는다.
오다가 이것은 변조가 됬다 그래서 나 잘못받았어 라는 메시지를 보내고 뭐라고 하냐 받는쪽에서 그것을 nack 라고 한다.
nack가 오거나 시간이되도 뭐가 안오면? ack 가 안오면 버퍼에있는것을 어떻게? 재전송으 해야한다.
그거를 모든 프로토콜이 그런짓을 하는데 그것을 ARP 라고 한다. 
ARR 이라고 해야하는거아니야? ARP? 
ppt에 있음
그래서 마지막으로 그런 특성이 있고 따라서 send에서 return 됬다고해서 저쪽에서 도착한게 아니라 라는것을 알아야하고 tcp 의 send와 receive는 아까 얘끼했듯이 제일 골치아픈게 stream i/o다
그래서 메시지를 하나 보냈다고 하더라도 받는쪽에서는 이거 뭐야? 쪼개져서 올수도있고 receive를 하는데서 아니면 여러개가 오는게 어떻게 되냐? 붙어서 올 수도있다. 받는쪽에서
그래서 메시지를 짜르거나 붙이거나 하는것은 누구의 책임이야?
프로그램이 짜는 사람이 알아서 해야한다
tcp를 쓸떄에는 그게 머리 아프다.
