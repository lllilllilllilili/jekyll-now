---
post : layout
title : 컴퓨터구조13
---
## 컴퓨터구조13
컴퓨터구조13

## Load Instruction (I-format)Data flow
명령어별로 필요한 datapath를 살펴보고 있다.
특정한 명령어가 주어졌을때 pc부터 시작해서 datapath 상에 어떤 값들이 전달되는지, 각 제어신호는 어떤 값이 전달되는지 확인한다.


## Load Instruction(I-format) Control
자기번호 + 500 
zero register는 값을 바꿀 수 없음. 상수값을 갖는다.

rt가 쓰는용이라 write number 쪽으로 간다.
그러므로 첫번째 mux의 regdsc는 0이 주어져야 한다. 
control에서 regdsc로 0을 보내야 한다.
control에 어떤 제어값이 들어오는지 보는것도 중요하다. 
나올땐 레지스터에 지정된 위치에 포함된 값이 나올것이다. 
9번이 들어갔으니 509가 나온다.
전기적인 신호로 510이 둘다 나오지만 mux가 막는다.
하위비트 16bit가 32bit로 확장되서 들어간다.
음수가 나올수도 있으니까 sign 확장해야 한다. 
(레지스터때문에 확장하는것이고 음수가 나올수있어서 sign extension을 한다.)
32bit도 -1은 올 1이다.

alu에서는 effective address 계산, 메모리로 보낼  
control에서는 ALUSrc에다 1을 보내는데 그것을 확인하는것이 opcode로 판단한다. 10010 (decimal 35)

1744가 메모리의 address로 들어간다.
++data path 상에 동작은 전부다 구현된다. lw만 한다고 그 부분만 안되는게 아니라 다되는데 control이 통제하는 것이다.++

값은 가지만 제어선에 의해서 동작하지 않는다.
만약 memread가 1이되면 509가 들어가게 될것이다. 

특수한 명령어에 대해서만 이상한 발생시키는 경우도 있다.

++addr 1744에 들어있는 값이 나올것이다. 
메모리에 어떤값이 있는지는 이 ppt에서는 알수없음
시험에서는 값을 테이블로 줄것이다. 1744에 들어있는 값을 꺼내주면 될것이다.++

(register안) write data에 x가 들어간다.
write 해야할 번호는 이미 결정되어있다. 9번으로 9번의 x라는 값이 들어가도록 해줄려면 Regwrite가 1로 되야 한다.
## Store Instruction(I-format) Dataflow

## Store Instruction (I-format) Control
don't care는 0이든 1이든 상관없다.

## Branch Instruction (I-format)Dataflow
같으면 offset에 해당하는 label로 점프해라
offset을 pc+4에다가 더해서 분기주소를 target address만든다. pc의 주소가 beq의 주소라고 가정할때
pc+4라는 beq의 다음주소다. 
beq $s1, $s2, 1234
그 라벨까지 떨어진 거리, 중요한건 워드 offset이다. 1234 만큼 떨어졌다는것은 *4 만큼 떨어졌다는것을 의미

명령어에 표현된 그값 그대로가 먼저온다. 1234가 먼저온다.
그림 참고

노란값은 연산에 의해서 결정된다. control에 의해서 결정되지 않았다. 불안전하다. 지금 명령어가 무슨 명령어이고 branch 명령어이고 그결과가 equal이면... 
branch 명령어 라는 사실 자체가 표현되어 있지 않다.
앞에 보면 and 연산자 가 있고 branch 인지알리는 제어선이 있고 그다음에 zero에서 두개가 다 만족되면 branch 연산을 하게 되어있다. 따라서, 
control에서 branch 라는것을 알려줬고 그다음에 0의 결과가 만족이 되면 분기주소가 선택이 되도록 구성되어 있다. 0이 나왔기 때문에 204가 나온다. branch 조건이 만족하지 않는다.

branch 명령이 만족하지 않으면 그 다음에 명령어가 수행된다. 

MemtoReg 어떤 신호가 들어가든 상관없음. Regdsc도 상관없음
명령어의 동작에 영향을 주지 않는다. 

##  Branch Instruction(I-format) control
don't care 조건이 많으면 많을수록 조합회로를 간단하게 만들 수 있다. don't care가 많으면 많을수록 유리한 방향으로 축약해 갈 수 있다.

## Single-Cycle Control Signals Summary
ALU Operation 해야하는 연산이 결정된 것이다. ALUOP에는 연산이 결정이 안된다. opcode만 봐서는 알수 없다. function code도 같이본다.

op : dependent on operation(see functioncode)

## ALU control Design
ALU에 들어가는 실제 control line 을 정의하지 않았는데 어차피 그것은 정의하면된다. 몇비트해서
4비트로 해서 0000이면 and 연산지시, 0010 add연산지시 이렇게 정의를 할 수 있다.

정답은 아니지만 우리가 이렇게 정의한다. 

## Opcode and ALU control Input
ALUOp라는값은 ALUOp값은 control에서 온다. opcode를 보고 값을 준다. 그값을 보고 연산이 정의되서 오는경우는 고민없이 연산을 지시하는데 op dependent 신호다. 오면 function code를 보고 결정한다. 
각각의 명령어가 있는데, 이 테이블은 opcode값은 2비트 값으로 정의를 내린다.

10이라는것은 operation dependent, 00이라는값은 load나 store경우에 add하라는 의미로 

beq 01을 보내서 sub 하라는 의미로 바로, main control에서 보낸다.

10은 function code를 봐야한다. function code는 6비트인데 

ALU control이 지금 ALU line으로 들어간다. 4비트가 들어간다. 이값에 따라서 연산자가 하나 선택해서 나온다. (add나 이런거), ppt에 보면 자세하게 나와있음.

main에서 오는 2비트 값(ALUOp), function code6비트 값이다. 보고 ALU control을 결정한다. 

이것은 조합회로 이다. 왜 조합회로냐면 입력이 ALUOp 와 function code가 입력이다. 그거에 따라서 오른쪽에 있는 Output ALU control이 결정된다. 나머지 컬럼들은 힌트 주기위한 설명이다.


## Truth Table for the ALU control
입력에 대한 출력의 테이블이 나온다. 
조합회로다. and or 논리게이트의 조합으로 만들어 낼 수 있다. 만들때 4bit를 한꺼번에 같이 놓고 한다. 출력하나하나에 대해서 회로를 생각한다.(중요)
0 bit 1, 2, 3 bit 포지션을 넘버링 한다.
0 bit는 어떻게 구성이 되야할까 각각 bit별로 본다. 맨 상위의 bit는 올 0, 
4번째 1은 1이 3개인 경우,
alu op1 = 1 f3 =1이거나 또는 f1=1 이면 이값이 1이 된다. 나머지는 그런경우가 아니기 때문에 조건에 맞지 않으므로 0 이 나온다.  

## Implementation of ALU control
최상위 비트는 항상 0 
최하위 비트는 op1 = 1 이고 f0가 1이거나 f3가 1이면1을 내보내고, 이 케이스가 아니면 다 0을 내보낸다. 
ALU Control 4bit가 무엇을 보고 결정하는지 나와있다. 조합회로를 만들어야하는데 그 과정을 논리식을 확인하면서 맞는지 1이 나오는것을 확인해서 공부

