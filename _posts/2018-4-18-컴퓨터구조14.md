---
post : layout
title : 컴퓨터구조14
---
## 컴퓨터구조14
컴퓨터구조14

## 퀴즈해설
$s3 19번
rs 1번 으로 들어가는 번호 19번이 들어간다.
mux를 거쳐가서 write register 들어가는 번호 8번
200이 $t1으로 들어간다.
5는 레지스터값이 나온다.
(1) R-format
RegDst - 아래서 들어오는 값을 0이 되어야 한다.
MemtoReg 1이되어야 한다. 바로간다.

(2)lw
rt에서 들어가므로 1이 되어야 한다. MemtoReg는 0이되어야 한다. 다시 들어가야 하므로 
읽어야 하니까 MemRead가 1이 되어야 한다.
MemWrite가 0이 되어야 한다.
(3)sw
메모리에서 나오는값을 선택하는건 don't care 
MemRead 0이 되어야한다.
MemWrite는 1이 되어야 한다.
branch는 안나타있지만 control에서 나온다. branch 신호는 1이 나올땐 명령어가 branch일때 나오므로 sw에서는 0이 나온다.

## Opcode and ALU control Input
ALU OP는 contrl에서 opcode를 보고 alu쪽에 전달하는 신호다. 실제 00은 LW나 SW일때 주소값을 계산해야하니까 더하라는 operation

beq는 비교해야하니까 빼라
10이 나오면 opcode만 보고 판단하기 어려우므로 function code를 보자.
ALUop가 10일때 function code에따라서 보내준다. 
alu control은 정의한것이다. control을 구현하는데 control은 입력이 들어가면 출력이 바로나오는 조합회로이다.
입력은 왼쪽에 있는 컬럼이 입력이다. aluop의 2비트와 function field의 6비트가 들어가면 오른쪽에 alu control이 값들이 나오도록 되어 있다.


## Truth Table for the ALU control
한 칼럼씩 계산을 해야한다. function을
맨위의 비트는 항상 0가 나오도록 하면 되고
오른쪽의 비트는 두경우에 대해서 1이다. 0001 0111 (끝에1)
aluop1값이 1이 되어야 한다. 한칼럼에 1이 되는 function을 보자. f3가 1이고 f0가 1이면(aluop1은 1이라고 이미 언급)
면 0001, 0111 끝에 1이 생긴다. 같은식을 나머지에 적용해보면 모두 0으로 나타나는것을 볼 수 있다.
전형적으로 하는방법은 카르노 맵을 그린다던지, 테이블 기법을 써서 모든 민텀을 찾아낸다.

맨마지막줄을 살펴보면 aluop1을 1로하고 f3를 1로하고 f2가 0이므로 inverter 하고 f1이고 1이고 f0가 0이므로 inverter한다. 

맨마지막의 두번째도 0이면 inverter하고 1인 채로 다 곱하면 1이되게하는 민텀이된다.

두민텀을 합하는것이다. 그것을 sum of product 이라 한다.
두항만 같도록 디지털 로직을 만들면 0001, 0111에 끝에1만 나올수있도록 유도할 수 있다.

간략화하면 ALUop1(F1+F3) 하면 항이 나온다.

0000, 0001 에서 두개가 0이다. 근데 1이되는경우를 생각해보면 ALUop1=1 and f2하면 이경우에서만 1이나오고 나머지서는 다 0이 나온다. 우리가 실제 구하는값은 0이므로 그것에 invert를 한다. ALUop1 and F2를 invert 한다.

operation 2는 3군데서 1이 나온다. aluop0가 1일때 1이나오고있다. 현재 한경우이고 나머지는 don't care인데 don't care는 편의에 의해 취급하는거니까 0이라고 생각하면 된다. 하나는해결했고 나머지 2개의 공통점을 보면 aluop1 이 1이되어야 하고 f1이 1이된다. aluop1 and f1
aluop0 + aluop1*f1 이다. 논리적으로


## Implementation of ALU control
밑에있는것은 위에있는것을 gate logic으로 표현한것이다.
operation 0,1,2 일때만 값을 나타내고 있다.  
aluop는 main control에서 2bit가 오는것이다. 

## Branch Instruction (I-format) Dataflow(dataflow만 본다.)
방금 gate 블락이 어디에 들어가는 로직이냐면 alu control안에 들어가는 게이트이다. 
++aluop 2비트, function code 0번부터 5번(6비트가)오고 
그리고 alu control에서 오는 4비트가 alu로 제어하는 신호로 출력된다.++

control이 있는데(main control) 어떻게 만들것인가, 

## Control Unit Outputs
퀴즈에 봤던 내용정리
딱 명령어가 주어지면 10개 정도의 신호가 정해진다. 
opcode 6비트를 보면 R-format, lw, sw, beq를 알 수있다.
opcode 6비트를 보면 값이 정해진다.

## More Details on Control Signal Generation
r-format 은 opcode가 올 0 
load는 100011 
이렇게 될때 값이 1이 나온다.
이럴때 할 수 있는 방법은 
게이트로 1이 나왔다라는것은 여기에 opcode가 올 0가 됬다.
여기에 1이나왔다 라는것은 opcode 100011이었다. 라는것이다.
입력에서 들어오는 값을 다 1이 되도록 만들어서 and를 하는것이다. 그래서 그것에 출력이 1이 되었단것은 해당되는 opcode가 그 instruction이 나왔다 그말이다.

여러 제어신호들이 있는데 그게 1이 나왔을때 그게 필요한곳으로 연결시켜주면된다. 
r-format일경우 RegDst도 있고 RegWrite로도 가야하고 ALUOp1에도 1이되어야 한다.

load일경우 1이 나왔단것은 load 명령어가 나왔단 말이다. ALUsrc가 1이 나와야 하고 MemtoReg가 1이 되어야하고 Regwrite도 1이 되어야 한다. MemRead도 1이 되어야 한다.

각각의 1이 나왔을때 1이 되야 하는것으로 값이 계속 연결시켜주는것이다. 

or 로직은 1을 만드는 경우가 두개 이상 경우가 발생하면 둘중에 하나라도 1이 되면 1이 되도록 한다. 
굉장히 기계적이다. 위에는 and gate 아래는 단일 또는 orgate로 나타나있다.
++이회로가 main control안에 들어가는 회로다.++
alu control보다 더 체계화 되어 있다. 더 쉽게 구현할 수 있다.
++
single cycle data path는 데이터 패스가 pc로부터 instruction memory를 거쳐서 레지스터파일을 거쳐서 alu를 거쳐서 데이터 메모리 거쳐서 연결되고 pc 위에 값이 변경되는 adder가 있고 그 architecture를 생각해보고 각각 에 들어가는 제어선들이 있는데 제어선을 main control 만들어서 보내준다. alu control이 alu의 제어선으로 다른곳을 담당한다.
++

## Review: Handing Jump Operations
Jump 명령어는 j type이다. 26bit jump target addr 였는데 주의할건 타겟 어드레스는 단위가 워드 어드레스다. branch 주소도 그러하고 jump도 word 단위다. 메모리로 보낼때는 byte 단위로 바꾼다.
++
shift left 2 해서 28 byte 로 바꾸고 상위 4비트가 남는데 상위 4비트를 0으로 채우는것도 방법이지만, 0으로 채우면 128 MB로 메모리 공간이 제한되기 때문에 그래서 조금 PC가 움직임에 따라서 움직일수있는 범위를 가변적으로 조정하기 위해서 PC가 현재 설정되어 있는 addr의 상위 4비트를 가져다 이어붙인다. 수도 다이렉트 어드레싱을 쓴다. pc에서 나온 값중에 상위 4비트를 위에다 덧붙여서 32bit 점프 어드레스를 만든다. ++

## Adding the Jump Operation
윗부분이 수정되었다.
새롭게 나타나는 신호가 jump라는 신호다. 명령어가 jump이면 jump에 1을 내보낸다. 
jump가 나오면 주소가 나와서 26bit가 들어가고 shift를 거쳐서 28bit가 나오고 나오던 pc의 값중에 4bit를 이어붙여서 32bit 주소가 된다. 
pc+4가 나와서 다음주소를 가리키고 그 다음주소는 mux에 입력으로 들어가고 immediate 값과 shift 한뒤 들어가서 pc+4와 더하면 이게 branch target addr이다. 다음주소 또는 branch주소 뭔가 선택되서 나오면 걔하고 점프주소와 branch 주소와 갈림길에 선다. 

만약에 beg다. branch가 1이 나오고 zero가 1이 나올것이다.
branch target addr 을 선택한다.  그렇지 않으면 다음 명령어가 간다.

그리고 jump다 jump가 1이 나오니까 jump에서 나온값을 선택한다. 여러개가 다음 분기 주소가 될수있는데 그것들이 제어신호에 의해서 오직 하나만 선택되도록 게이트가 있는것이다.

## Main Control Unit

## Instruction Critical Paths
명령어가 통과하는 루트가 조금씩 다르다.
R-format 은 Instruction memory 통과하고 그다음에 register file을 통과하고 alu 통과하고 datamemory는 상관없다. 그다음에 마지막에 register writer에 값이 들어가는데

가정, 메모리 access하는데 instruction 메로리든 data 메모리든 메모리 access 하는데 4ns 만큼의 시간이 걸린다. 그리고 alu adder 여기를 통과하는데 2 ns
레지스터 파일 access 1ns 걸린다 가정하면 
r명령어의 경우 

lw가 Instruction memory를 거치는 이유는 instruction fetch 단계임. alu op하는 이유는 address 계산하기 위해서 데이터메모리 access 읽어낸 값을 레지스터에 다시 써준다. 총12

제일 짧은 명령어는 jump, branch 제일 긴명령어는 load

clock cycle을 가변적으로 조절할수 없기때문에 정해진 고정된 clock cycle을 움직이므로 load의 시간에 맞춰줘야 한다.
제일 긴 명령어가 지나가는 path를 critical path라고 한다. 가장 중요한 path이다. 
프로세스를 개선할떄 critical path를 개선해야한다.
++clock으로 따지면 12ns 면 몇 Ghz clock을 써야 할까?++
1/12는 0.083.. clock frequency 0.083Ghz = 83MHz
1Hz=1초에 cycle이 한번 나타나는것을 의미한다.

## Why Single-cycle Implementation Is Not Used
CPI = Cycles per instruction
cycle은 clock cycle의미 instruction 한개당 clock이 몇 clock 필요한가.
single-cycle은 모든 명령어가 한 clock에 처리되는구조다.
cpi=1 이다. 이런구조에서는 clock cycle이 cycle의 개수를 의미
cycle time (혹은 길이) 12ns(방금봤던거)
clock cycle time 12ns이었고 cpi는 1인 architecture보고 있다. 제일 긴것은 load에 의해서 결정된다.

clock을 이렇게 맞춰두니까 load맞춰두니까 규칙적으로 뜨는데 load는 clock cycle을 다쓰는것이다.
store 하더라도 이전에 끝나는데 clock이 load에 맞춰져있어서 시간이 낭비된다. jump가 시간이 제일 많이 낭비된다.

load가 아닌 명령어는 waste가 발생한다.

## Single Cycle Disadvantages & Advantages
Single cycle로 명령어를 돌리는것이 쉽게 구현가능하지만 좋은 방법은 아니다. cycle time 낭비되고, 안에 있는 resource들 adder 등이 중복되서 설치되어야 한다. 명령어가 실행되면서 하나의 adder가 두번 사용될 수 없다. adder가 다른 용도로 필요하다면 또 그 adder를 만들어야 한다.
resource 갖다놓으면 재활용되어야 좋다.
한 cycle에서 리소스가 한번씩만 사용되도록 설계되어있어서 자원이 활용도가 낮고 자원이 중복해서 설계되는 자원의 낭비도 발생한다.

## Performance Evaluation
걸리는 시간이 아래와 같다고 가정하고, 단위가 ps 이다. 메모리유닛이 200 ps, ALU가 100PS, 레지스터파일 50ps, Mux도 시간은 걸리지만 앞에있는거이비해 작은시간이라 무시할만한다.

명령어들 봤지만, 프로그램 분석시 그중 많이 나타나는게 lw 30% 나온다. 그다음에 많이 나오는것이 alu 명령이다. 쭉 뽑아보면 명령어가 나타나는 빈도가 있다.

## Answer2
lw 25% store 10% r-format 45% beq 15% j 5%
lw는 메모리 두번, alu 1번, register 2번 600ps 
제일 짧은것은 jump다 메모리 한번 200
다른것은 볼거없다. lw에 의해서 클락이 결정된다. 600ps clock cycle time, frquency는 1.67Ghz 

single cycle에 고정클락을 써야 하니까 600ps 사이클 타임이 흘러갈텐데 가정을 하는데 기술이 도입되서 명령어마다 cycle을다르게 줄수있다. 

600ps 400ps 고 각각 다르다. 가변적으로 클락 사이클을 줄 수 있다고 가정하면 시간이 지나서 평균적으로 명령어당 사용하는 클락 사이클 계산할 수 있다. 평균은 instruction이 어떻게 분포되어있느냐!
## Answer3
가변적으로 클락 조정할수있으면 한 프로그램이 끝나서 평균적으로 한 명령어당 수행되는 클락 사이클 타임은 
lw 는 600ps였는데 25% 만큼
sw는 550ps 였는데 10% 만큼, 이런것을 가중평균이라고 한다.
차지하고 있는 비중만큼 비율을 곱해서 평균을 낸다.
가중평균은 평균적으로 447.5ps(고정된 클락600ps였는데 ->평균적으로 447.5정도되면 충분히 돌릴수있다.)

## Answer1
성능지표가 어떤 프로그램 실행시켰을때 실행된 시간 execution time은 명령어가 몇개 수행됬냐, 한 명령어가 수행되는데 걸린 시간, cpi는 명령어 하나당 소요될 사이클의 개수 싱글 사이클은 항상 1이다.
클락 사이클 타임, 한 사이클당 소요될 사이클 타임

## Answer3
performance는 실행시간이 짧으면 좋다. 실행시간 길면 performace는 작은것이다. performance와 execution time은 반비례 관계이다. 

(variableclock을 사용한다고 했을떄의)performance/single cycle의 performance 
= executiontime은 역수관계
cpi는 1이니까 없음
600ps/447.15ps (평균 클락 사이클,위는 고정 클락 사이클)
variable clock 컴퓨터를 만들 수 있다면 성능이 single cycle의 1.34배 만큼 좋다. 성능이 34%만큼 향상된다.

## Problems with a Single-Cycle Implementation
명령어 당 clock cycle을 별도로 구현한 방법을 멀티 사이클 데이터 패스를 만들면 싱글 사이클의 단점을 많이 보완할수있다. 한 클락 사이클을 더 짧게 만들 수 있다. 한 클락 사이클을 150ps를 만들 수 있다. 빠르게 돌아가는 클락을 만들 수 있다. 그리고 클락을 각각의 명령에 따라서 개수를 다르게 준다. 

천천히 돌아가는 시스템에 몇등분으로 일을 나눠놓은것이다. 4등분 (명령어 수행자체가 1. 인스트럭션 패치 2. 인스트럭션 디코드 3.alu execution 4. data memory access 5. register write back) 5단계로 나눌수있는데 세분화 시킨다. 세분화된 동작이 아주 small 1 cycle에 돌아가게끔 
|-------------|
|---|---|---|---| 이런식으로..
멀티사이클로 수행이 되게끔 사이클을 아주 짧은 사이클로 만들고 lw 같은 경우는 5 cycle이 지나가야 한다. (짧은게) branch는 (1. fetch 2. decode 3. alu) 3cycle 로 끝
jump는 1cycle 
클락을 가변적으로 개수를 지정할수있다. 멀티사이클 데이터 패스라고 하고 instruction 당 clock cycle의 개수가 여러개가 되고 cpi는 명령어마다 다르다. lw는 5 cycle. beq 3 cycle jump 1cycle . 이런경우 cpi가 다르다.(cpi는 명령어당 사용되는 사이클 의 개수니까..)

시간을 늦춰서 10시에 시작하자. 시험장소는 추후공지