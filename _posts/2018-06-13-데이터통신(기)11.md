---
post : layout
title : 데이터통신11
---
## 데이터통신 11
dlc 서브레이어 에서 수행하는 프레이밍 언급했고 프레이밍중에 바이트 기반
비트 기반 두가지 프레이밍 소개를 했고 사실 소개하기 보단 간단한게 언급했다 그런데 
프레이밍 앞뒤에 붙이는 그플래그 와 동일 한 패턴이 내부에서 발생되는 경우를 대비해서 어떤 이 채워넣기 스터핑이라는게 채워넣기 어 바이트기반 프레임에서 바이트 스터핑을 했고 비트기반 에서 프레임잉에서는 비트스터핑을 했다.
그래서 이렇게 플래그와 동일한 패턴이 발생하는 거에 대한 오동작을 방지하는 그런장치들을 갖고 있다 라는거를 지난시간에 소개를 했다 그게 바로 스터핑 이다 채워넣기! 
당연히 받은곳에서는 언스터핑 을 재고하는 일을 해야되겠쬬 그건는 범위를 채우는 거니까 
자오늘 나머지 dlc에서 플로우와 에러 컨트롤에서 잠깐 살펴보고 hdl이라는 프로토콜을 좀 살펴보면서 11장 마무리짓는다

## Flow and Error Control
플로우컨트롤은 데이터를 주고받는 그 주체간에 데이터를 
수신쪽에서 데이터를 처리하는 스피드에 맞춰서 보내는쪽이 속도를 조절해주는 기능 이게 플로우 컨트롤 이라고했다.
플로우 컨트롤할얘기가 많은데 이 중요한 기능이고 조금있다 보겠지만 데이터링크레이어에서 아주 간단한 정도의 플로우 컨트롤만 수행하고 트랜스포트 레이어 , 레이어4에서는 굉장히 섬세한 복잡하고 섬세한 플로우 컨트롤 기능을 구현하고 있어요 그거는 트랜스포트 레이어 있는 다루지 않기 떄문에 아주 간단한 데이터링크에서 수행되는 아주 간단한 플로우 컨트롤 기능만 살펴보는것이다. 
에러컨트롤은 에러가 발견됬을때 어떻게 할것인가 이거임
우리가 에러 발견하는 방법은 10장에서 crc 방식을 통해서 에러를 디텍션할수있다고 얘기를 했다 에러가 디텍션이 됬을때 어떻게 할것인가 그게 에러 컨트롤인데 제일 좋은 방법은 버리는것이다. 내가 커렉션 할수없다면 에러가 발생한 패킷을 놓고 내가 할수있는 일ㅇ ㅣ없다 이에러가 아주 중요한 부분에 발생한건지 뭐내가 전혀 알방법이 없다 에러를 버리고 
버린다. 
어 또는 재전송을 요구한다 이런 것들이 에러 컨트롤이라고 얘끼할수있다. 
근데 이 에러컨트롤 과 플로우 컨트롤이 같이 묶여서 묶여서 이 구현이 될수도있다라는걸 이제 좀 후에 살펴볼 수 있다
여기보면 플로우컨트롤에 그 기본적인 개념을 보여주는 슬라이드다 이거는 보내는쪽과 받는쪽 보내면 이 플로우 컨트롤 에 위한 피드백 정보가 가는거죠 이 리시버가 지금 어떤 사태에 있는지를 알아야 내가 이 보내는 속도를 조절하는데 리시버 가 어떤상태인지 알수있는 방법은 리시버를 정보를 주는것밖에 없다. 그래서 플로우 컨트롤 을 위해서는 리시버쪽에서 플로우 컨트롤 위한 피드백 정보가 센더 쪽에가야된다  당연히 가야된다. 이 플로우 컨트롤을 위한 이 피드백 정보가 무엇일까? 어떤것이 있을까는 지금이 플로우 컨트롤이 보낸 메카니즘이 어떠내에 따라서 이플로우 컨트롤에 피드백 정보도 거기에 맞춰서 맞춤형 데이터가 돌아와야되는것이다

이 보내는 스타일 이 여러가지가 있다. 어 이거는 전체적인 개념만 보여줬죠 가령 아주 간단한 예를 보여주고있는데 가령 이런것이다 한 플로우 컨트롤 예다.
둘간에 두가지 경우가 발생할수있는데 이경우에는 어떤 버퍼를 갖고있다 리시버쪽이 버퍼를 갖고있다. 그래서 버퍼가 풀인경우와 버퍼가 비어있는경우 자 이 두경우애 간단한 그 버퍼사이즈가오로지 한슬라이스? 다ㅣ 얘기는 패킷 하나 전달할수있는 여유의 버퍼사이즈다 라고 인위적으로 한번 가정을 해보는거죠 굉장히 통신이 너무 간단한다 이말이다. 이 프레임 이버퍼가 차면 하나받았는데 이 하나 받은것을 처리하고 있지 못하고 있으면 보내면안된다 보내는쪽에서는 그래서 뭐 오로지 이게 비어있을때만 보내야되고 그래서 이런경우에 이 센더쪽에 리시버쪽에서는 버퍼가 찬 비어있다 안비어있다 이정도만 보여주면된다.
피드백 정보만 뭐이런 아주간단한 아주 심플한 케이스의 사례를 잠깐 설명한다.
뒤에 상세히 설명을 하죠 

또다른 주제가 이제 DLC 데이터 링크 와 링크 장치 와 장치사이에 한홉사이에도 연결을 통해서 데이터가 오가는데 그 연결기반이 될수있느냐 연결 , 비연결 기반이 될수있느냐 이런얘기를 하는거에요 우리가 마치 서킷 스위치 네트워크와 패킷 스위치 네트워크 할떄 연결고리 의  키드냐? 비연결 기반이냐 이런얘기를 했었다.
여러분 2개의 개념을 구별할 수있는 커렉션 오리엔티드와 커렉션 리스 방식에 어 통신 커렉션오리엔티드는 물리적으로 우리이제 서킷 스위치가 
서킷 스위치 네트워크 대표적인 옌데 물리적으로 아예 채널이 할당되어있는거지 두개 센더와 리시브 간에 하드웨어적으로 완전히 채널이 할당되어있는 그야말로 하드웨어적인 어 커넥션 오리엔티드 개념이 서킷 스위칭 개념이다.

그거에 반해서 버츄얼 서킷 스위칭 네트워크는 가상적인, 커넥션 오리엔티드다 하드웨어적으로 채널 을 아예 할당 하는게아니라 일단 받아두는데 너에게 줄 채널은 일단 예약을 해두는데 항상주는게 아니라 필요할때만 제공해준다 라는개념이 버츄얼 서킷 스위칭 네트워크 또다른 커넥션오리엔티드 기반인데 좀 소프트한 개념의 커넥션 이다.

커넥션리스는 아예 센더와 리시브간에 어떤 연결이라는 개념이 없는것이다 그냥 센더는 무조건 목적지 주소를 패킷에 넣어서 보내면 중간 중간 이 라우터는 그 주소를 보고 어느쪽으로 내보낼까 를 결정해서 계속 전달해가는 커렉션 리스개념에 통신이었다. 
그런데 이거는 우리 요 챕터 가 뭐냐면 데이터링크레이어 에서의 커넥션 개념을 얘기하고있다 내가 지금 방금 설명했던것은 END TO END 개념이죠 센더와 리시버 리시버사이에 이런 네트워크가 있는데 이 전체적으로 이 둘간의 커넥션 오리엔티드냐 커넥션 리스냐 이걸 얘기하는것이다 여기서 지금 얘기하는것은 요중간 스위치와 이웃한 스위치간에 요 커렉션 한링크 
요 한링크에서도 커렉션 오리엔티드 개념이냐 커렉션 리스개념이냐 이런얘기를 하는것이다 요 챕터가 데이터링크레이에서 데이터링크 레이어는 볼수있는게 여기서 여기까지 볼수있는게 아니라 바로 이웃한 노드와의 그 링크 하나만 보는것이다. 우린 그런 시각을 계속 이 링크 레이어 , 레이어개념에서 그런걸 항상 염두해 둬야 한다. 
여기에 얘기하는 커넥션개념이 바로 한 링크 한 홉에서의 이 곱 
별 중요하지 않은 얘낀데 지금 언급을 하고있다. 여기서는 당연히 하드웨어적으로는 얘와 얘사이에 연결이 되있는것이다. 저기서 얘기는 거기서 주고받는 프레임들이 서로 어 어떤 그 앞에 보낸것과 뒤에 보낸게 어떤 유기적인 관계를 갖느냐 아니면 만일 독립적인 프레임이냐 여기에따라서 여기도 소프트 기반에 소프트 에 의한 커넥션을 애끼하고 있다. 프레임 간에 연결이 있느냐 없느냐 이건 별 중요하지 않은내용이니까 넘어간다

책에서도 그냥 간단하게 걸고 넘어가고있다. 

자 이제 아까 잠깐 했던 프로우 컨트롤과 에러컨트롤이 플로우컨트롤과 에러컨트롤 같이 유기적으로 묶여서 이 데이터링크에서 어떻게 이루어지는지살펴보는절이에요 여기가
어 요부분이 요책에 바로 전버전에서는 굉장히 내용이 많았다 전통적으로는 
데이터링크레이어에서 플로우와 에러컨트롤을 위해서 4가지 방식이 있어왔다 전통적으로 그 4가지가 뭐냐면 아주 간단한 
스탑 앤 웨

## Data - link layer protocols 
아주 간단한 방법 
스탑 앤 웨이트 방법 , 고우백엔드 방법, 그리고 실렉티브 리핏이라고 하는 4가지 방법이 있었다 이게 각각 다 플로우 컨트롤과 에러컨트롤이 같이 묶여서 수행이되는 프로토콜들이다 4가지가 
이 전버전 
다다뤘었는데 지금은 안다룸
두 프로토콜은 앞에 두프로코콜은 데이터링크에서의 얘기이다. 이 두개의 심플과 스탑앤 웨이트 뭐 이 예 가장 간단한 방식들이다 
이 두가지 방식은 여전히 쓰이고 있는데 데이터링크레이어에서 뒤에 두경우는 여기 고백엔 과 실렉티브 리핏이라는것은 없어졌다 사라졌다.
데이터 링크 레이어 에서는 이 두가지 방법을 이제는 더이상 안쓴다 얘기에요 
이 두가지는 굉장히 디테일하고 이 아주그 효과도 좋고 뭐이런 할일도 많고 어 이런 두가지 방식에 따라 할애기가 많았었는데 이 11장을 얘기할떄 이부분은 뒤에 트랜스포트 레이어 tcp 레이어에서 엔드 투 엔드개념 이런거죠 이 tcp 레이어에서의 플로우 에러 컨트롤은 얘와 얘사이에 있는거죠 
트랜스포트는 이 내부는 상관없어 센더와 리시버 
사이에 받아서 에러가 있으면 너 다시 보내라 이거임
우리 데이터링크 레이어에서는 에러 컨트롤 하는데 받았더니 에러가 있더라, 얘한테 다시 보내라고 하는거야 얘한테 
데이터링크 레이어 오로지 한 홉간에만 얘기한느것이다 
트랜스포트 레이어는 end to end 개념에 
그래서 지금 이얘기가 나름대로 여러분들이 중요하게 생각해야되는데 이 기존에 데이터링크레이어 4가지 기능이 있었단얘기는 얘와 얘사이에 데이터 를 주고 받다가 에러가 발생하면 동원했던 방법이 4가지가 다있었단 얘기지 얘네 둘사이에 그런데 이렇게 링크 바이 링크로 일일히 다 하다 보니까 뭔가 비효율적이라고 생각이 드는거에요 그래서 아주 간단한 두가지만 얘네둘사이에 또 다른 훕과 훕사이에는 두가지 케이스만 복원을 시키고 엔드 투 엔트 개념 궁극적으로 소스에서 데스티네이션까지의 이 두관계에 서는 이 4가지를 다쓰는거다. 여전히 남겨두고 있어여 이 end와 end 개념에서는 
근데 훕과 훕사이에서는 좀 간단히 가자 이 두가지만 쓴다. 그렇게 여러분이 해석해야됨 고백엔 이나 설렉티브 리핏인 굉장히 엄격한 방식이다 또는 여기에 tcp를 쓰고있으면 tcp는 절대 에러를 허용안한다 이거임 여기서 주고받다 보면 여기서 아주 간단하게 에러 컨트롤이 이루어지다보면은 분명히 에러가 발생했는데도 불구하고 여기까지 에러가 수정이 안된상태로 올수가 있다 이거임 그러면 이제는 여기서 tcp가 트랜스포트 레이어가 얘들이 놓쳤을만한 거를 여기서는 다 걸러내야되 그래서 여기서는 고백엔 이냐 실렉티브 리핏같은 상세한 에러컨트롤 기능을 쓰는데 얘가 상세한것은 얘라 이거임 엔드 엔드 개념
트랜스포트 레이어는 프로세스간에 서로이 양쪽에서 수행되는 프로세스간에 컨트롤이다, 얘들은 아무상관이 없는것이다. 그래서 조금 오류가 발생했을때도 엔드 투 엔드 개념으로 다시 걸러내는기능을 천천히 하는거지 그래서 거기에서 수행하고 있기때문에 구지 한홉 지날때 마다 거기서 상세한 프로토콜은 빼자 라고해서 이 고백앤과 설렉티브 리핏은 사라졌다 이거임
근데 우리 이번학기에 배우는 데이터 링크 레이어만 배우잔아요 따라서 트랜스포트 레이어 에서 여전히 사용하고 있는 고백엔 이나 설렉티브 리핏 은 뒤로 미루고 네트워크 강의로 미루고 
두가지만 심플과 스탑 앤 웨이트만 본다 이거임
슬라이드 하나에 굉장히 중요한 얘기들이 써있다.
(시험문제)

저런 플로우 와 에러컨트롤 을 얘기를 할때 이런 
이 어떤 통신을 하고있는 주체들 간에 동작 노드가 있다 이거죠 그래서 보내는쪽 받는쪽 동작을 파이나잇 스테이트 머신 = 유한상태기계 뭐 이렇게 
파이널 스테이트 머신으로 표현 해
얘들이 센더입장 , 보내는 입장 받는입장 각각이 어떤 동작 , 모드들이 있느냐 그들간에 어떤식으로 트랜스퍼가 이루어지는 지를 보여주는게 파이널 스테이트 머신 그 기능을 설명하는것이다 센더 쪽과 리시버를 다 이런 모양으로 표현하고 기본적으로 이런 노테이션을 쓴다이거임 
스테이트 1 과 스테이트 2가 스테이트 들을 옮겨갈떄 그걸 발생시킨 이벤트를 위에 쓰고 다 밑에는 옮겨가면서 수행되는 액션들을 쓰는식으로 우리 표현을 하는거죠 뭐 이거 다른데서도 이런값을 쓰고 있곘죠 그래서 자체 스테이트를 볼드래고? 어떤 이벤트는 2는 이 스테이트를 계속 돌게하는 이벤트죠 액션은 무엇이 수행되면서 돌고 뭐 이런식으로 이벤트 와 액션 이 두가지를 스테이트 정의해 가는 과정에 이제 보여주죠 그래서 이 심플 
지금 우리가 살펴볼게 심플과 스탑앤 웨이트 두가지 컨트롤을 살펴본다. 심플 프로토콜은 말그대로 일방적으로 보내는것이다.

## Simple Protocol
보내는 쪽은 무조건 보내고 받는쪽은 오자마자 처리하고 말그대로 심플이다. 
여기 피드백 정보도 없다.
여기는 이거는 사실 가정이 있어야되 어떤가정이냐 애가 막강 한 파워가 있어서 오는 즉시 모든것을 처리할 수있는 능력이 있어야 하고 또다른 가정이 뭐가 있어야 되냐 가는 도중에 에러가 발생하지 말아야 된다.
에러가 발생한 경우에 대처하는 메카니즘 이 여기에 없다 에러가 발생이 되면 여기서 에러가 디텍션이 됬으면 피드백을 통해서 다시보내기 뭘해야하는데 피드백이 없다 심플 프로토콜 은 말그대로 그냥 보내는것이다 일방적으로 
전제가 두가지 라고 했다 리시버는 엄청난 파워가 있어서 이 들어오는 즉 시 처리할수있어야되 그래서 이 두가지를 파이널 스테이트 , 이 심플프로토콜에 센드와 리시버그 파이널 스테이트 머신을 그리면 이런 것이다. 스테이트 가 하나밖에 없어 오로지
서로 여러 동작이 필요없다 이 상위레이어 에서 네트워크 레이어 에서 자 어디로 데이터를 보내라라고 내려보내면 그냥 보내는거야 
프레임 을 만들어서 보내고 계속 이상태에 있는거져 보내는 쪽에 동작은 
받는쪽은 어 패킷이 하나 왔다 프레임 이 하나 도착했다 이벤트가 발생했죠 그러면 이거를 네트워크 상위 레이어 에 올려 볼려고 
헤더 띠어 내고 디캡슐레이션 해서 올려보내고 계속 그 상태에 머물러 있는것이다. 
여기도 에러가 있고 없고 지금, 에러가 없다는 가정이 됬긴 지금 이런 일 반복 파이널 심플 프로토콜은 보낸쪽이랑 받는쪽이랑 오로지 스테이트 하나로 계속 동작이 되는 이건 너무 이상적이고 사실 이런식으로 구현이 되면 굉장히 곤란한다 
왜냐하면 가정이 들어맞지 않을떄도 있지 리시브 가 그렇게 파워풀한 그런 그 능력이 분명히 보장되지 않고 더중요한건 전송중에 분명히 에러를 피할수가 업다 에러발생한것을 
절대 에러가 0다 에러가 발생할 확률할 0다 라는것을 아무도 보장을 못한다. 그러면 에러가 발생했을때 어떻게 하는거냐 에 대한 대책이 없다. 그래서 이거는 이상적인 프로토콜이다. 그래서 현실적인 게 바로 그다음에 제시하는 자이걸 이제 우리가 저런 심플 프로토콜을 했을때 이 시간개념을 넣어서 어 주고받는 과정을 보는데 너무 간단하죠 이와같이 보낸 쪽 받는쪽 
보내면 요 사선에 요 간격이바로 트랜스미션 아니 프로퍼 게이션 딜레이죠 
가령 처리하고 가면 처리하고 다이거에요 이게 심플 프로토콜이다. 
심플 프로토콜 은 아까 얘기한대로 너무 이상적이다. 현실적으로 보안된게 바로 스탑앤 웨이트 방식이다. 

## stop and wait
보내고 자이게 누구입장에서 스탑앤 웨이트 냐
보내는쪽이냐 받는쪽이냐
이게 보내는쪽에서 얘기다. 
보내고 나서 스탑 한다 이거임
하나만 보내고 스탑, 그리고 기다렸다 뭘 기다려
받은쪽에서부터 무슨 응답이 오기까지 
기다린다.
스탑 앤 웨이트 철저하게 이 굉장히 엄격한거죠 이거 사실 
간단하긴 하지만 엄격한데 굉장히 비효율적인 것이다
하나 보내고 스탑 멈추고 응답이 오기를 기다린다. 이거임
응답 속에는 바로 에러 컨트롤이 들어있다.
피드백 오는데 에러 컨트롤과 플로우 컨트롤이 다들어있어요 응답이 왔단 얘기는 리시브 쪽에서 처리했단 애기지 그러면 내가 다시 보낼수있잔아 이플로우 컨트롤 개념인거임  
리시버가 처리했으니까 아가 이제 너처리할 그다음 패킷 을 처리할 준비가 됫구나 에요 하고 보내주는 그런 개념이기떄문에 플로우 컨트롤이 여기서 구현이 되는거고 피드백 정보가 또 그 안에 갖을수있는건 너가 보낸게 에러가 있드라 없드라를 고 정보 속에 넣어줄수있죠 
그러면 에러가 있다 업다에 따라서 이 센더가 또 어떤 액션을 취할 수있으니까 에러 컨트롤도 되는것이다 그래서 스탑 앤 웨이트는 2가지가 다 구현이 되는거죠 플로우 와 에러컨트롤이 
다 구현이 되요 어차피 피드백 정보를 받아야 되는 방식에서는 이 두가지를 다 구현할 수있다 이거임 그래서 이게 두번째 프로토콜이 스탑 앤 웨이트인데 여기서는 플로우와 에러 컨트롤 이 다 ㄱ작동을한다 얘기임 

자이 아까 얘기했던 얘기가 있었는데 스탑앤 웨이트 말고 좀 복잡한
고백앤 설렉티브 리핏 이런게 있다고 그랬죠 이 데이터링크 레이어 에서는 안쓰는데 이말이 곧 그말이다 우리는 가장 기본적인 스탑 앤 웨이트 프로토콜을 여기서 언급을 하고 이것의 좀 복잡해진 버전은 23장 에서 얘끼한다
tcp에서 다시얘기하는게 고백엔이나 설렉티브 리핏 인데 그게 여기서 표현하기를 이 스탑앤웨이트 에 복잡해진 버전으로 얘끼하겟죠 
자이게 바로 무슨얘기냐면 고백엔 실렉티브 리핏이라고 하는 우리가 여기서 다루지 않은 두가지 방법은 사실 스탑앤 웨이트 기능을 기반으로 더 확장된 버전이다 전혀 엉뚱한 데서 나온게 아니라 스탑 앤 웨이트의 확장 된 버전 
한마디로 표현하면 너무간단하다

스탑 앤 웨이트 는 하나 보내고 응답기다리고 이거임
그럼 너무 멍청하다 너무 시간이 오래걸린다 하나보내고 응답하고 한 번 10개보낸다음에 10개는 응답없이 보낼수 있게 허용되는거죠 10개 보내고 거기에 대해서 응답을 기다리는것이다 10개중에 첫번쨰 두번쨰 대한 응답이 오면 또다시 거기에 맞춰서 2개 더 보내고 그러니까 계속 응답이 없는 상태에서 보낼수있는 패킷의 개수가 스탑 앤 웨이트 는 오로지 한개로만 구성이 되어있는데 그걸 일반적으로 n개로 넓혀 보자 이게바로 고백엔 , 고백엔 이 엔이 바로 그 n이다.

에크없이 응답없이 보낼수있는 사이즈를 n개로 늘린거라 이거임 고백엔
실렉티브 리핏도 마찬가지다. 사이즈를 키운거에요 응답이 없이 보낼수있는 패킷의 개수가 스탑 앤 웨이트는 한개일 뿐인고 고백엔 이나 실렉티브 리핏은 일반적으로 n개 라 이거죠 다 같은 골격이라 이거지 그래서 여기서 표현이 좀 복잡해진 버전 고백엔 이나 실렉티브 리핏은 스탑앤 웨이트의 복잡한 버전으로 제공한다.

질문. 너무 고지식한거다 고백앤도 안정적이다 나중에 보면 고백엔이나 실렉티브 리핏이 응답 없이 보낼수있는 개수를 한개 보다 많게 허용함으로써 불안정 하지 않느냐 그이유에 	철저하게 관리한다 그 응답 없이 n개에 대해서 하나하나 에 대해서 철저하게 관리를 한다. 그 바로 설렉티브 리핏이라는 4가지 방식중에 맨마지막에 언급한게 잇죠 설렉티브 리핏 
말그대로 선택적 반복이다. 그 n개중에 문제가 발생한놈 고 선택을 해서 얘를 다시 보내게 한다 이거임 그러니까 하나 하나 에 대해서 철저한 관리를 하죠

철저한 관리를 하고 복잡해졌지 그대신 그대신 복잡해졌지만 효율은 늘어난다 안정성에는 손해보는게 없다.
 
여기서 이 레이어 가 아래로 내려갈수록 좀 단순하게 구현된다. 이게 지금 설렉티브 리핏 기능을 보면 여기 잠깐 내가 지금 윈도우라고하는데 자 여기서 보내는쪽에서 쭈욱 패킷을 보냈는데10개를 보냈어 그럼 받은쪽에서 이 10개 각각에 대해서 에러를 10개 에 대해서 일일히 다 체크를 해야한다 그중에 5번이 에러다 에러, 5번에 대해서만 다시 보내라 이런식으로 한다 이거임
이게 설렉티브 리핏이에요 10개 보냈는데 그중에 5번 만 다시모내라 이런 기능들을 데이터 링크레이어 라고 하는 하드웨어 에 좀더 이 가까운 기능들인데 이 tcp는 소프트웨어적인거 
이런거느 소프트웨어적인 내용이잔아 
에러 체크해서 어느 특정한 하나만 다시 보내고 이걸 리핏해라 자이런 기능들이 low 밑에 있는 레이어에서는 조금 어울리지않는 기능이다 이거임 
그리고 얘와 얘사이에 아주 즉각적인 전송이 이루어지고 거기에 대해서 직각적으로 뭐 반응이 오기때문에 스탑앤 웨이트 는 비효윶적이라고 볼수 있지 몰라도 한링크안에서 프로토콜 볼떄는 뭐 괜찬다 이거임 한 홉에서는 스탑앤 웨이트에 만족하고 얘와 얘사이에는 복잡한 기능들 
그렇지만 복잡하다는것은 그만큼 안정화를 위해서 여러가지 장치를 구비했다 이거임 불안정한 쪽으로 가지 않아요 
효율을 높이는 쪽으로 간다 이게 23장인데 tcp 에 여기 들여다 보지 않는다. 
슬라이딩 윈도우라고 하는 개념을 배운다 이거임 슬라이딩 윈도우는 내가 패킷을 ack 응답없이 보낼수있는 사이즈가 하나밖에 없죠 그게 윈도우 사이즈가 1인거야 슬라이딩 윈도우 1 
자그러면 이 23장가면 슬라이딩 윈도우가 일반적으로 n n슬라이드 윈도우
n개는 보낼수있는거지 , 슬라이딩 윈도우에 의미는 응답없이 보낼수있는 패킷의 개수 그게 슬라이딩 윈도우의 사이즈임 
우린 1이끼때문에 여기서는 더이상 할얘기가 없다
요 챕터에서는 우리 여기서에서는 오로지 하나의 프레임, 한순간에 하나의 프레임 다시 말해서 윈도우 와 사이즈가 1이어야대 1인것만 명확한 얘기다.

다른거 보내기 전에 ack를 기다린다. 하나보내고 에크 기다리고 그다음꺼 보내고 
자 그리고 당연히 보낼떄 에러체크를 위해서 crc 정보를 집어넣어야 한다 각각의 프레임에 crc정보는 반드시집어넣는다. 
에러 컨트롤이 각각 들어가 있다 스탑앤 웨이트 흐름을 보여주면 이와같고 뭐 프레임 을 주고받을때 프레임 하나보내면 이번엔 이제 ack 라고 하는놈이 오겟죠 
ack 그래서 ack라는 메시지가 정의되어있고 가죠 그러면 거기에 대해서 제대로 받았다 라고 하는 ack 가온다.그러면 그다음 패킷이만 
그게 항상 crc 필드가 들어있다. crc 필드는 가장 널리쓰이는 에러 디텍션 방식이다.
자기필드가 딱 정해져있다. 
이거를 이런 파이널 스테이트 머신으로 표현하면 자 이 보내는쪽이 스테이트가 두가지가 된다. 스테이트가 두개가 있어야된다. 자여 기 레디는 보낼준비를 되있는것이다 그래서 상위레이러 로부터 패킷을 보내라 라는 이벤트가 발생하면 이런 액션을 취해야 되지 프레임을 만들고 다음 링크로 보낸다 라는거죠 근데 보낼때는 자기 스테이트 를 바꿔야되요 이제는 ack를 기다려야되는 스테이트로 바껴야된다. 계속보내면 안되잔아 스탑앤 웨이트는 그리고 블락킹이라고 하는 스테잉트 에 머물다가? 여기에 머물면서 이리로 다시 돌아가야 다음 패킷을 보낼수있는거야 그러면 일로 돌아갈수있는 조건은 제대로 된 ack를 받아야된다. 그래서 rec 
에러가 없는 ack를 받으면 그런 이벤트가 발생하면 state로 이리로 간다. 그래서 다음 패킷을 보낼준비를 하러가는거죠 

반면에 이제 보내고 나서 ack를 무한정 기다리느냐 타이머를 하나 설정하겠죠 스탑앤 웨이트는 타잉아웃이 이루어지면 무슨일을 할까 보냈는데 가다가 패킷이 업어져버렸다 그러면 무작정 기다리는게 아니라 타임을 하나 설치를 해두고있다고 타임아웃이 발생하면 다연히 재전송을 해야되는 재전송을 해야되고 여전히 재전송하고 나서도 이 state 에 머물러 있어야한다 이 패킷이 처리가 안됫잔아 ack가 와야지만 이리로 가는데 재전송하면 다시 이 state에 머물러야 한다 또는 ack를 받았는데 crc 체크해보니까 ack 메시지 속에 에러가 있다 라고 하는거임 그러면 이 메시지를 내가 ack라고 처리하면 안된다. 역시 ack를 버리고 기다린다 
기다리다 보면 타임아웃이 될거고 타임아웃 되면 재전송하고 그래서 역시 블락킹 스테이트 를 계속 머물러있어야한다.
그걸 우리가 이걸 가령 코딩을 한다 이 프로토콜을 코딩을 한다고 했을때 머릿속에 중요한게 이거다 스테이트간애 두개를 내가 정의를 해야되고 이 각각의 스테이트에서 무슨이벤트들이 발생하는지만 알아내면 코딩이 된다. 바로 이 블락킹이라는 스테이트해서 과연 어떤 이벤트들이 발생하까 3가지가 발생한다 

내가 ack를 기다리는 상태에서 타임 아웃이 발생할수있는거고 ackㄹ르 받았는데 에러가 발생한 놈이 올수있는거고 ack를 받았는데 에러가 전혀 없는경우
요 3가지 이벤트에 대해서 코딩을 한다. 이 요 스테이트 에서도  무슨 이벤트가 발생헀는지를 볼수있다. 여기서는 상위에리어 는 데이터를 보내라 이벤트하나 발생하는 경우가 있다.
코딩을 이프로토콜을 , 내 프로그램 할수있다.

보내는쪽에 받고 리시버 쪽에 어떤 스테이트가 있을까? 리시버 쪽은 여전히 스테이트 하나밖에 업다. 하나밖에 업다 뭐 내가 지금 항상 패킷 기다리는 상태야 얘는 하나 받았더니 에러가 없더라 그러면 뭐져 이 에러가 여깃죠 에러가 없는걸 받았다 그러면 이 디 캡슐레이션 세션에서 네트워크레이어로 올리고 또 다음 패킷을 기다린다 이방식 
하나 받았는데 에러가 발생했더라 아무것도 아니다 패킷 을 버리고 아무일도 안하는거지 

아무일도 안하면서어떻게 되? 센더는 타임아웃에 걸리는것이다 
센더쪽에 타임 아웃이라는 이 이벤트에 대한 처리루틴이 있기떄문에 리시버는 에러가 발생한 패킷 웠을떄 아무일 안해도 작동이 된다.타임아웃 이기때문에 센더쪽에는 

타임 작동이 되는거지 타임아웃이 있기때문에 센더 쪽에는 가령 여기에 타임 아웃 이 없으면 어떻게 해야되? 이경우에 타임 아웃이라는 이 모드 내가 이런 이벤트를 센더쪽에서 내가 구현을 안했다 라고 하면 리시버 입장에서 패킷을 에러가 발생헀다 리시버 입장에서 패킷을 받았는데 에러에러가 발생했다 라고 그러면
라고그러면 
무슨일을 해야되느냐
에크를 보냈는데 내네가티브 애크를 보내줘야한다

이거 아무일도 안하고 가만히 기다리면 얘는 이 블락킹 스테이트에서 빠져나올수가없다. .그렇죠 얘는  블락킹 스테이트에 빠져나가는 방법은 뭔가 ack 
에러가 발생하든 안하든 에크란 메시지가 와야 빠져날수있는데 타임 아웃이 없다면 얘가 지금 그거 에러가 왔다고 아무일도 안하고있으면 못바쪄 나가지 
빠져나갈수있는 방법을 제공해야된다. 그래서 에러가 발생했을때는 패킷을 버리고 가?느니란? 네가티브 에크를 보내준다 라는 액션이 하나 추가 되야 한다 근데 여기서는 네가티브 에크라는걸 안쓰고 타임아웃을 싼다. 한 프로토콜이 이 내가 선택할수있다 여러분이 
타임아웃을 쓴 스탑앤 웨이트냐 아니면 네가티브 에크란 메시지를 사용하는 스탑앤 웨이트냐 뭐이거에 따라서 내가 프로토콜을 구현하는 방법에 bk라는 ?? 측면에서 약간씩 변화가 있는것이다. 어쩃든 센더와 리시브 간에 절대 어느 한 무한 루프에 빠지는경우를 분명히 없도록 잘 유기적으로 이루어져야한다. 자 이경우에 
데이터 오고가는 이런 타임 다이어그램 방식으로 이 시간개념을 넣어서 보면은 이 시나리오를 스탑앤 웨이트에서 구현되는 어 데이터 주고받는 시나리오 사례들을 보는거에요 자 여기가 

## 사례
여기가 센더고 여기가 리시버죠 
프레임 하나 보내라고 네트워크 레이어 에서 보냈어요 그러면 데이터링크레이어 에서는 프레임을 만들어서 보내겠죠 보내고 받은쪽에서는 에러가 없더라 이거임 
그러면 네트워크 레이어로 올리고 에크를 보내줬잔아 그렇죠 여기는 아주 정상적으로 이루우진 스탑앤 웨이트 기관의 통신이에요 그다음에 시나리오를 보면 프레임을 보냈는데 가다가 중간에 없어져버렸다. 없어져 버릴수 있다 이거임 어떤 사례? 였는지 모르지만 그러면 리시버 입장에서 아무것도 안하고 있는거야 
계속 아무일도 일어날수가 없다. 결국 이 로스트를 벗어나는 방법은 타이머 타임아웃이 발생할수밖에 없다
그래서 타임 아웃이 발생해서 아까 그 센더 쪽에 타임아웃이 발생하면 이 재전송이었죠 재전송하면 이번에 제대로 전송이된다 이거임 요 두번째 시나이오는 잃어버린 패킷이 발생한 경우에 어떻게 스탑앤 웨이트가 작동이 되는가를 살펴보는것이다.

자그다음에 3번째 시나리오는 잃어버린 패킷이 다른 패킷에서만 발생한다는 보장이 없죠 ack가 없어질수도 있다. 자 가던 패킷이 없어지는 경우하고 ack가 오다가 없어지는 경우하고는 분명히 다르다 이거임 상황이 다르다. 이거를 ack가 없어진 거지 프레임은 제대로 갔는데 ack가 오다가 없어졌어 그러면 이 센더 입장에서는 이 경우나 프레임 이 가다가 없어지는 경우나 ack 가 오다가 없어지는 경우랑 똑같다 내가 뭔가를 보냈는데 타임 아웃이 걸릴때까지 아무것도 안하는거지 똑같다 이 역시 센더는 재전송이다.
이렇게 된다 근데 리시버입장은 다르다 리시버는 제대로 받아서 처리를 했는데 그래서 ACK를 보냈죠 제대로 갔으리라고 생각을 하는데 센더는 ACK가 안오는 바람에 재전송했죠 그러면 리시버는 재전송 패킷을 어떻게 알아먹느냐, 넥스트 패킷이라고 알아들을 수 밖에 없다 그렇죠 내가 아까 패킷 제대로 받아서 ACK까지 보냈는데 그다음에 패킷이 하나 오더라 아까 꺼와 구별할 방법이 없다 이게 뭐 새로운 패킷인지 재전송한건지 아무정보 가 리시버 쪽에 없죠 
리시버는 새로운 패킷이다. 아직 까지는 장치가 없기때문에 새로운, 넥스트 두번쨰 패킷이라고 생각해서 이 네트워크 레이어로 올리고 에크를 보낸다
자이경우는 어 문제가 발생한거죠 왜냐하면 중복된 패킷인데도 불구하고 리시버는 중복된 패킷을 구별못한다 이거임
그래서 지금까지 얘기는 스탑 앤 웨이트는 이런 문제가 있구나 라고 우리가 알수 있는거고 그럼 스탑 앤 웨이트를 고안 해야되겟죠 이문제를 고안해 낼수있는 방법
이문제를 고안해 낼수있는 방법 뭐죠 ? 
문제 어디서 발생했는지만 보면되잔아
여기서 ACK 제대로 받았다라는것을 응답을 해줘야된다. 
이 리시버 쪽에서는 문제가 왜 발생했느냐 이 애크가 가다가 없어저서 지금 재전송했는데도 불구하고 새로운것으로 안다 
그러면 에크가 가다가 없어졌다라는걸 알면은 아 얘가 재전송된거구나 라고해서 이거를 구할수가있다 왜냐하면 이미 처리한거니까 
내가 과연 ACK 가 제대로 갔었는지 어떻게 알수있을까 당연히 그거를 알려면 ACK를 받은 이 센더는 ACK 잘받았다 라고 하는 또다른 ACK를 보낸다 이거임
그렇죠 
자 그러면 이 여기서 재미난 일이있다. 
여기도 그런얘기를 할수있다.

지금 재미난 얘기가 나왔으니까
쉬는시간에 생각해보라고 재밌는 얘기를 준다.
이게 
전쟁 상황인데 자 이런 이런 상황인데 A라는 부대 A1 이게 A라는 부대는 두 부류로나눠져있고 여기에 B라고 하는 적이 A와 B는 적이다 서로 적이야 서로 적이야 
A와 B는 적인데 이상황에서 A라는 이부대가 
A라는 세력이 B라는 세력을 물리칠려고 한다 그런데 병력을 비교해보면은 A1 + A2는 B보다 크다 그런데 A1도 B 보다 작고 A2도 B보다 작다 이말은 각자 혼자 공격하면 진다 반드시 A1 A2가 동시에 공격해야 이긴다.
그런데 그러면 동시에 공격할려면 A와 A2 사이에 통신을 해야되진아 언제 몇칠 몇시에 공격하자 근데 그 통신하는 방법이 너무 애석하게 전령 보내는 방법밖에 없다 전령을 보내는데 전령이 가는길은 이 적진을 뚫고 간다 네트워크 바쁘면 에러가 발생할수있는 상황이다 가다가 잡힐수있는 상황 얘가 무슨 메시지를 보냈다고 해서 반드시 얘가 받았다는 보장이 없다 가다가 잡혔으면 끝나는거지 이런상황이다 과연 문제는 이게 다야 이상태에서 과연 A가 이길수있느냐 이문제다.
이상황에서 상황그게다 통신 주고 받는환경은 전령이 오고가면서 적진을 뚫고 가야되는 아주 불안정한 상태다. 그래서 정확히 몇월 몇일 몇시 몇분 몇초 공격하자 두개의 정보가 일치됬어야 이게 이루어져서 이길수있다 과연 A라는 부대 이길수있는지 10분동안 쉬는시간동안 생각해봐라 저친구의 얘기하고 그대로 적용할수있다 좋은 사례다 라는거임.

## 복습
결국 이런거죠 이 식하고 
이 똑같은식
계수가 지금 두개의 폴리노미얼이 있다.
차수가 같으면 나누어 떨어질려면 계수가 다 같아야댐
계수가 같을 확률이 1/2 임
얘가 가령 1이면 얘도 0 또는 1확률중 1/2
그런게 1/2이 몇개냐
그런데 그 crc 볼떄
살펴보면 어느게 이경우는 너무 명확하고 같고
이게 x의 0승 자리
둘다 1인 조건이 있어야 되는 케이스들이 그중에 하나있다 그중에는 이미 같기떄문에 
조건에서 하나 없어지고 또다른 조건 이미 이놈이 이미 같아야된다라는 
x의 r승이 양쪽에 다있다 
계수가 상황에 따라서 이미 어떤놈이 같다고 조건에 있는건지 상황에 그래서 계수가 
어느 경우가 이 계수가 있다고 전제가 있는 건지
어느 경우가 이 양쪽에 다 있다는 경운지 
어느 경우가 +1 이라는 맨 아래쪽 계수가 있다라는 전제했지 상황에 맞춰서 생각

## 문제
몇번 주고 받으면 될까 
이 전송이되다가 확률 75% 전송이된다. 25% 로 전송이안된다.
전쟁터는 100%는 가정한다.
확률 100%가 아니면 
자 시나리오 만들면
보내겠죠 6월 7일 14시 공격 보내겠지
a1 공격못함 이걸 받았다는걸 알아야 공격할거아니야 메시지 보낸상태에선 공격못해
a2는 받자마자 공격못함
받았다는걸 알리기 위해서 ack를 보낸다. 그러면은 어 a1은 어 a2가 받았다 라는게 확신이 되잔아 a1은 공격을 해야되 a2가 받았다라는 메시지 받았는데 a1 공격한다?
a2 입장이 되바요 a2가 공격을 할꺼라고 확신을 해야 공격을해
내가 ack를 보냈지, 근데 이 ack가 제대로 갈지 가다가 깨질지 어떻게 알아 이게 여기에 도달한다는 보장이 없다 또 이게 적진을 뚫고 야되기떄문에 
이걸 받았다는 보장이 없어서 공격을못함
그걸 알게 하기위해서 ack를 또보냄
이게 쓰리 웨이 핸드쉐이킹
내가 받았다라는게 확인됬으니까 a1이 공격하리라 생각해서 a2가 2시에 공격한다? 왜못해
a1입장에서는 이게 갔는지 안갔는지 어케알아 
이걸 받았다는걸 알려주기 위해 또 ack를 보내야줘
공격못해 a2는 여전히 얘를 받았다는것을 갈지 안갈지 어케알아 

a1과 a2는 ack만 주고받다가 굶어죽음
a가 이길수가 없어 공격을 하지못하고 ack만 주고받다가 끝남
통신에서의 불안정성떄문에 정말 엄격한 전쟁터같이 100% 아니면 액션 취하는거 불가 통신도 어려워진다
근데통신은 목숨거는 상황은 아님 메시지를 주고받는데 메시지 없어졌다해서 누가 죽고 이러는건 아님 
100%는 아니지만 중간에 끝난다 쓰리웨이 핸드쉐이킹으로 끝남 그리고 또다른 장치가 타이머를 둔다 이런식으로 해서 타이머장치 
이러다가 이제 오류가 발생하면 취할수있으니까 
이경우에 
계속 ack 주고받다가 다음일을 제대로못함 상대방의 확신을
이게 한마디로 내가 어떤 액션을 취하기 위한 취하는데 확실을 준 최종메시지
내가 액션을 갖게끔 한 최종메시지 요 메시지에 확신이 없기떄문에 이문제는 안풀림
이문제는 계속 a1이든 a2든 어디누군가 가 확신을 갖기 위한 그 마지막 메시지 자체가 보장이없다.
응답을 기다려야하는데 
타이머가 센더쪽에서 파이널 
얘는 여기에 있으면 아무 일도못한다 여기서 빠져나오지 못하면 센더일을 더이상못한다 어떻게 해서든 빠져나오는 방법을 만들어줘야되 
그 중에 하나가 타임아웃이다. 이상태에 일정한 시간이있었으면 그래 혹시 아까 보낸 메시지가 없어졋든 ack가 오든 없어졋든 분명히 일이 발생했구나 나 빨리 빨리빠져나가야 되니까 그다음 액션을 취하는데 다시한번더 보낸다 
=>용도 어떻게든 블락킹 상태를 빠져나오기위해서 어떤 시함을 만들어놓은거죠 

얘가 지금 받았다는 아무런 리액션이 없다 그럼 다시보내야지 에러컨트롤

재전송하면 스탑앤 웨이트를 손을 봐야된다. 
타이머 넣어서 재전송하는것을 얘는 구별을 못하기때문에 여기서 문제가 생긴다. 똑같은 패킷인데 구별이안된다. 리시버가 구별을 할수있게 하는것이 있다.하나 뭔가 고안해주면된다
정보하나 추가한다 
메시지에 번호를 주면된다. 
아까 보낸게 0번이었으면 여기도 똑같이 0번이 오면 버린다. 근데 새로운게 1번을 주면 새거다 이렇게 아까 와 구별할수있는 아이디 하나만 주면된다. 얘는 시퀀스 넘버 라는게 필요하다 시퀀스 넘버는 사이즈가 딱 한비트면 끝나요 이 스탑앤 웨이트는 이렇게 지금 문제가 된 패킷이 오로지 한개만 있을수있기떄문에 이게 아까 뭐 실렉티브 리핏 뭐이런거 n개를 몽땅 보낸다 그러면 n개 에대해서 일일히 다 구별할수잇게끔 시퀀스 넘버가 더 여러개가 있어야된다 적어도 n개를 구별할수있게끔 줘야한다 아까 10개를 보냈는데 5번이 에러가 발생했다 그러면 
5번이란 아이디를 보낼수있단 얘기는 패킷마다 넘버가 있다
여기 넘버 얘기안했었는데 스탑앤 웨이트에서도 당연히 패킷에 시퀀스 넘버를 주면되는데 다행스럽게 이 스탑앤 웨이트가 시퀀스 넘버가 한비트면 충분하다 0과 1
왜냐면 한번보내고 하나보내고 요게 처리되기 전에 다음껄 안보낸다 그래서 요놈과 다음것만 구별할수 있으면되요 이 스탑앤 웨이트는 
그 시퀀스 넘버가 두가지만 있으면된다 
0과 1이 

## Flow diagram for Example 11.4
저 문제를 해결하기위해서
시퀀스넘버 요구
이제는 스탑앤 웨이트
이게 완성품
프레임 0을 넣어서 보내면 이제 여기아까 
번호가 간다 
0번 보낸다
리시버는 0번을 받았으니까 1번을 기다린다 
ack번호  
0번을 제대로 받았으니까 다음1기다린다 0을 제대로받았다 의미
그다음 패킷 1보낸다
가다가 꺠졋다 재전송한다.
0번이 갔어요 ack
얘는 프레임 0다시보내는데 이미 0번은 제대로 처리했는데 0번이 또왔어 아 얘가 판단하기를 뭔가 문제 생겻구나 ack를 다시보내주면서 버린다. 
중복되는걸 알아 차릴수있다 간단한 장치로 
시퀀스 넘버라는 간단한 장치만 고안해서 그래서 이와같이 	시퀀스 넘버 까지 가지고있는게 스탑앤 웨이트다. 이거임
시퀀스 넘버는 한비트면 충분하다.
양방향 통신이라고 하면은 여기서 데이터 오고 여기서 데이터 올수있다.

보내줄 데이터 보내면서 그 필드 어딘가에 ack 정보도 넣어주면 너한테서 받을 정보 제대로 받았다 그리고 내가 너에게 새로 메시지 보낸다 두 메시지를 주고 받는 모양새가 된다. 메시지 위에다가 ack 정보 까지 넣어서 보내는 케이스인데 양방향 통신에서 그걸 
ack를 메시지를 내가 저쪽에 메시지 위에다가 얹혀서 보낸다 피드백킹

뭐 여기 
양방향 통신에서 ack메시지를 따로 보낼게 아니라 데이터 패킷을 보낼때 어느 필드에 ack 정보 까지 넣어서 보낸다
실제 tcp가 보면 그런 
여기도 피드백킹 하는것을 볼수있따

## hdlc프로토콜
hdlc는 비트 오리엔티드, 바이트 오리엔티드 봤는데
여기는 비트오리엔티드 프로토콜이고 포인트 투 포인트 1:1 통신 또는 멀티포인트에 다 쓰인다 이거임 
멀티 포인트 1!다 하나가 여러개 몫을 보낼때 또는 포인트 포인트 1:1
이런경우에 다 쓰는 프로토콜 
hdlc는 우리가 방금봤던 스탑 앤 웨이트 방법을 구현하고 있따 하나보내고 응답하고 이런식이다.
자 hdlc는 실제 실용적이기 보단 이론적이고 개념을 소개해는 내용을 많이 사용한다 
실질적이라기 보단 이념적이지만 개념적이지만
앞ㅇ로 배우게될 ppp나 이런 
여러가지 실질적인 프로토콜의 기초가 된다.
그래서 hdlc를 다룬다.

전체적인 설명을 잘보여주고있다.
hdlc 프로토콜의 전송모드는 2가지다 있다.

## Normal reponse mode
이거는 주와
얘가 마스터고 나머지는 종속된다.
그래서 항상 데이터는 잃어 버리고 
얘를 
1;1 일 경우 1!다 일경우
얘가 주고 얘는세컨더리
누군가가 주만이 하는 하나의 프라이머리 노드가 있고 나머지들은 그냥 거기에 명령을 받아서 수행을 하거나
뭘받아서 리스펀스 를 보내거나 이런걸 말하는 노말 리스판스 모드
그러니까 기계층
일종에 노말

## Asynchronous balanced mode
밸런스
양쪽이나 똑같은 지휘를 갖는다 보내기도
명령을 보내기도하고 양쪽이 다 똑같은 대등한 개념으로 주고받는다.
받는 형태의 전송모드
밸런스모드이다.

## 프레이밍
팩트들
이 11장에 팩트들
hdlc 전송모드 2가지를 봤고
hdlc에서 정의된 패킷의 모양
프레이밍의 모양 3가지로 나눠서 설명하고있다.
hdlc는 3가지가 있다. 프레임 3가지가 있다.
hdlc 가 제공하는 여러가지 기능들을 수행하다보니까 3가지 형태의 메시지가 정의되어있다.
i프레임
s프레임
u프레임

i는 말그대로 인포메이션 실제 데이터가 있을때 만들어지는 프레임, 이게 인포메이션 프레임
s프레임은 인포메이션이없음 이건 데이터 주고받는게아니라 관리자로서의 컨트롤을 위한 프레임
컨트롤을 위한 정보가 들어있음
u는 언넘버드 프레임 이것도 일종에 네트워크관리하는 밸리어 먼트 인포메이션
이 커넥션을 관리하고 자 하는 어떤 정보가 있다.
얘는 계주적 데이터고 얘는 매니지먼트용 정보들이다.
얘와 얘는 다른거죠 
이거를 바로 프레임이라고 한다.
이들 간에 그런 메시질르 구별짓기 위해서 프레임에다 공통적으로 플래그 양쪽에 있꼬 
어드레스 있고
어드레스 당연히 프레임 이 가야될곳을 얘끼하는거죠 
컨트롤 필드가 다있고 그리고 이렇게 좀 다르죠
이 프레임들간에 구별은 이 컨트롤 필드에서 들어난다. 
컨트롤 필드 모양이 무엇인가를 보면 얘가 i프레임이냐 s냐 누구냐를 알수있다.
그 뒤에 여기에 그 기준이 나온다 컨트롤 필드가
i와 s u 사이에 컨트롤 필드 모양이 다른데
요거를 봐야한다
컨트롤 필드가 8비트인데 맨앞에 0으로 시작하면 여기시지금 컨트롤필드가 요놈이 요 컨트롤 필드 딱 들어왔을때 요 첫 나오는 비트 정보가 0이면 인포메이션드 되면 10 이면 s프레임 11이면 u프레임 저 두비트를 가지고 구별한다. 
어 인포메이션 프레임이면 바로 요기에 3비트씩 있고 그리고 폴링 파이널 이라고 하는게 있는데 먼저 요 3비트씩은 센더쪽에서 받는 시퀀스 넘버 여기는 리시버 쪽에서 보내는 시퀀스 넘버 
가령 ack 넘버 일수도 있는거지
ack넘버
아까 ack 1 ack0 이렇게 온다고 했쬬
센더 쪽에 시퀀스 넘버 리시브쪽에서의 시퀀스 넘버 
그러면 이게 컨트롤필드고 그뒤에 인포메이션이 따라간다.
아이 프레임은

자 슈퍼 바이저 프레임은 10으로 시작하고  코드가 두비트가 있다,
코드가 2비트가 있다  슈퍼바이저 프레임에 기능을 4가지를 내가 줄수있다 요기 코드가 2비트 
0001 1011 을 갖고 4가지의 슈퍼바이징의 프레임이 만들어진다.

여기지금 ack 넘버가 따라올수도있고 뭐 그렇죠
ack넘버

언넘버드 프레임이거는 코드가 5비트 받아사용했다 
다시말해라 5비트면 32가지의 어떤 성사된 기능을 의미하는 메시지가 정의가 될수있다 u프레임은 32가지 기능까지 구현할수있다.
코드
먼저이 인포메이션 프레임 너무 간단하고 여기 그냥 보내는쪽에 시퀀스 넘버 받는쪽에 시퀀스 넘버
자 s프레임을 한번 살펴보다 s프레임에 2필드 2비트가 있는데 가령 얘는 무슨일 을 하는지 한번보면 2비트가 0001 1011 4가지죠 00이냐 리시버 랜이 말그대로 내가 리시버인데 받을준비가 됬다라는걸 상대방에게 알려준다. 그런 정보다 
그럼 뒤에 오면 n(r)필드는 ack만 보내는거죠 여기 00이면 리시버 랜이 즉 받은쪽에서 자 다음거 받을 준비가 됫다라는걸 알려주기위해서 00을 넣고 여기에 ack넘버, 내가 ack0을 받았다 ack1을 받았다 라는걸 여기다 넣어준다. ack넘버

그필드가 10 이면 리시버 낫 레디 준비가 안됬다
뭐이런얘기 들어가면 다있다.
01 이면 리젝트, 이거는 고백엔 이나 이런 이런 메카니즘이 사용될떄 고백엔 이나 실렉트 리핏은 과거엔 쓰였으나 지금은 안쓰임
쓰일때 정의된거임
가령 이런거임 내가 10개를 받기로 했음 슬라이딩 윈도우 사이즈가 ack없이 받을수있는개수는 스탑 앤 웨이트는 1개지만 고백앤 이나 이런거는 늘릴수있다. 그럼 동시에 주고받는데 이렇게 1 2 3 4 를 받는데 6이 왔는데 5가 오다가 없어졌따 그러면 그러면 6이 안왔는데 5가 안왔는데 6이 왔다 그러면 그 경우에 리젝트 한다 6을 고백엔 같은 이런 방식에서 하는거에요 이젠 안쓴다니까 무시해도 되겠다 그리고 11이 경우에는 실렉티브  리핏이라고 했을때의 또이런 비슷한일
이런 두가지 유저도 됩니다

자 u프레임은 언넘버는 프레임
5비트를 이용한다고했죠 컨트롤 필드에 5비트 이용한다고했는데 그중에 몇가지만 보였다
얘들을 보면 커넥션 매니지 먼트야 
가령 여기 조금더 이제 이게 사용될텐데 sabn 자 요게 뭐냐 11  100으로 그 코드 필드가 111 어디 얘기하는 경우 
11 100 요렇게 코드가 디비된 유프레임 의 경우에 의미가 뭐냐 sabm 셋 어싱크로너스 밸런스 모드, 이게 무슨말이냐
어싱크로너스 밸런스 모드는 우리가 대드는 입장에서 통신을 하자 그런 메시지다.
그런 의미를 갖는 매니지 먼트 메시지다.
다른 코드 보면 어떤 커넥션을 내가 지금 어떤식으로 열고 닫고 디스커넥션하고 이런 그 관리 정보를 주고받기위한 메시지들
유프레임

## Figure 11.8
자 이런거 예를 들고 끝내죠
이 hdlc 로 만들어진 프레임어 상세한 그 내용까지 봐가면서 각 메시지가 의미하는바를 보자 유저프레임인데 유프레임
a와 b사이에 커넥션을 이제 설정하기위해서먼저 유프레임을 보낸다 sabm
11 100 우리 아까 본거자 어싱크로너스 밸런스 모드로 우리가 커넥션을 하자 라고 요청을 한것이다 여기에 
그러면 얘가 당연히 응답을 보낸다 여기에 유프레임으로 ua 필드는 뭐야 ua 정보는 
표를봐야지

언넘버는 ack다. 요청을 받았으니까 어 그러자 라고하는게 바로 요정보다 ua정보 
유프레임으로 응답을 한다 이렇게 그러면 두 사이에 언 밸런스드 모드 커넥션이 만들어지고 주고 받자고 약속해지고 그다음에 인포메이션이 온거아니에요 아이프레임이 오고가고 그다음에 이걸 끊어야겠쬬 그래서 유프레임 디스커넥트 를 의미하는 또다른 코드 값을 가진 유프레임을 보내면 거기에 대해서 또 ack가 오면 서로 두줄간에 통신에 끝나는것이다 두링크간에 두 노드간에 한링크 를 사이에 둔 두노드간에 뭐 요런 간단 한 유프레임을 통해서 데이터에 대한 전송과 끊기 한다는것이다.

## Figure 11.9
또다른 케이스는 한번쭉 살펴보자
자 뭐이렇게 데이터를 이제 에러가 발생하고 나면 우리 아까 유프레임 끝났고 그 데이터 주고 받는 과정을 한번 살펴보자 2개를 보냈고 아이프레임에 여기 시퀀스 넘버, 아이프레임의 경우 시퀀스 넘버 
보내는 쪽에 시퀀스 넘버 따라서 얘 0번 보냈으면 2번째 보낼떄 1번이 간다 이렇게 그쵸
0번이 가고 1번이가고 그럼 얘가 이제 2개 갔구나 보낼게 있으면 보낼게있으면 아이프레임을 보내는데 
거기에 ack를 넘버를 피드백킹 하는 ack넘버를 0번 도 받았고 1번도 받았으니까 나는 2번을 기다린다는 식으로 여기 가는거죠 
그런데 아까 뭐 시퀀스 넘버 0과 1만 있다고했는데 
자 지금 이게 무슨얘기냐 2번도 있고 3번도 있고 뭐이 hdlc 여기서 시퀀스 넘버가 3비트를쓰고있죠 뭐 필요에 따라서 스탑앤 웨이트는 0과 1이면 되는데 여기 지금 이런식으로 이 시퀀스 넘버를 8개까지 가능하게 해놨다 000 부터 1 3비트씩 사용하고 있으니까 
이 01을 받았으니까 이제 2번을 기다린다음에 ACK 가면서 동시에 내가 A에게 보낼 데이터 I에게 정보를 보내고 있어 피드백킹을 한거죠 계속 가지
0번 1번 2번 이렇게 가죠
보내는 쪽에 시퀀스 넘버잔아 011 그렇지만 받는 내가 ACK넘버는 계속 아직 그사이에 더온게 없으니까 2가 가는거죠 
그럼 얘는 다 제대로 받으면 제대로 받았는데 보낼 데이터가 없어 그러면 ACK를 보내야 겠죠 그래서 이번에는 I프레임이 아니라 S프레임으로 리시버 렉이 다 잘받았고 내가 ACK는 012 까지 받았으니까 3번을 기다린다 라는 ACK넘버를 만들어서 보내주는 거죠 여기는 아무 문제없이 데이터가 잘 주고 받게 되는 그 상황을 보여준것이다. 여기는 에러가 발생했을때 어떻게 되는 가를 보여주는거죠 이렇게 여기에 인제 데이터를 하나 보내고 두번째 보내고 세번쨰 갔는데 두번째 가다가 깨졋다.
자 그러면 얘가 하는일 리젝트를 하는거죠 오놈이 2번이라는 놈이 2번이라는 놈은 내가 지금 받을수없다 얘가 그 1번이 안왔는데 2번을 받을수없다그러면서 나는 1번을 기다린다 라는 ACK넘버 1을 여기서 보내는거지 아주 디테일 들여다 봐야되
지금 요 시나리오 
요 왜 1이 있느냐 얘입장에서는 0번을 받을 다음에 내가 1 번을 기다리고 있는데 2번이왔다 이거에요 그래서 얘에 대해서 리젝트 를 하면서 나는  1번을 기다린다 라고 요정보를 ACK넘버를 집어넣는곳에 집어넣는다.
리젝트 일경우가 여기 ACK 넘버 라고 했죠 리젝트 S프레임 봐요 리젝트 ACK넘버라고했죠 그러면 리젝트가 스탑앤 웨이트 에도 쓰이네
이 정보를 받아서는 노드 B는 얘를 다시 보내줘야 한다 1번 그래서 1을 다시보내고 2를 또다시 보내고 왜 2는 여기서 보내긴 했지만 리젝트했잔아 그러니까 다시 보내줘야지
비로서 다 잘받았다 라는 리시버 의미로 3번을 이제 기다린다 라는거임 ACK가 들어오면 

이거 가다가 얘가 계속 보냈어 그럼 여기 오는 정보가 뭘까 0이 오겠죠 0이 오겟지 아니면 이게 가다가 다 꺠졌으면 아무일 도 안하지 
0이 꺠졌으면 2왔을떄 얘가 리젝트가 여기서 나간거지 1이 왔을떄 
이거 스탑앤 웨이트니까 
하튼 얘가 걔지고 얘만 제대로 갔다라고 하면 요순간에 요 리젝트 메시지가 가는데 1번을 갔을때 나는 0을 기다린다하는 요 리젝트0 이라는 ACK넘버를 갖고 필드 마다 갖는 정보의 의미 이거를 좀 약간 디테일 하게 준것이다.

질문 - 아이프레임이죠 내가 보낼 데이터도 있었던거야 그래서 그 걸 보내면서 여기다가 ACK넘버를 피드백킹 해서 보내는거지 
이게 스탑앤 웨이트인데 지금 내가 보기에도 스탑앤 웨이트는 하나 보냈으면 뭐가 와야 다음걸보내고 이랬죠 
그게 스탑앤 웨이트잔아 그게 지금 이렇게 처리되는게 나는 HDLC 더 봐야할텐데 이 받고 나서 액션이 없는데 또 계속 보내고 있잔아 
이게 허용이 된단 얘기죠 HDLC 에서 언제 이걸 보내느냐 프로토콜 규격을 들여다 본다.
3개가 연달아 온 사이에는 안보내다가 3개가 가니까 보냈잔아 뭐 어떤 액션을 취하는 룰이 있겠죠 그 프로토콜 규격을 들여다 봐야되 
한예지 HDLC라는 프로토콜에 서 에러가 없는 경우, 에러가 있는 경우에 특별한 케이스들을 보여주는것이다.


노드 A에서 B로 갈때 0보내고 1보내고 1을 보내는 놈은 B에서 A로 아닌지?? 이거맞나 ㅋ
보낼게 있어서 보낸다 여기도 얘한테 보낼게 있는게 있으니
그러면서 보내면서 ACK를 여기다 집어넣으면서 
얘를 받았기때문에 보낸게 아니라 얘도 얘한테 보낼게있는거지 A도 B한테 보낼수있는 지금 양방향 통신의 경우에요 무조건 서로 언밸런스드 아까 밸런스 모드죠 어싱크로너스 밸런스 모드 서로 동등한 입장
서로 주고받을수있는 그런식으로 이 커녁센 열었잔아 지금 여기에 언밸런스,아어.. 어싱크로너스 밸런스 모드 
요 상태 요부분에 깊게 들어온것이다 데이터 주고 받는 부분을 상세히 본게 이부분임

에러가 있는 경우 없는 경우 
나도 지금 여러분들에게 지금 제시안한게 스탑앤 웨이트 라고 하면서 이렇게 여러개 보낼수있느냐 ACK가 없는데 나도좀 HDLC 들여다 봐야한다 상세한 설명없이 이렇게 설명하고 있다 스탑앤 웨이트 구현하고 있다라는거임

에잉ㅇ 끝