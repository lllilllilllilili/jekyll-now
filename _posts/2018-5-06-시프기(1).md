---
post : layout
title : 시프기(1)
---
## 시프기(1)
시프기(1)

## Concurrent-Readers/ Exclusive-Writers Problem
writer's lock

reader's lock
read 할때는 write가 들어오면 안된다. read끼리는 화장실을 공유하는것이고 write를 막아주는 새로운 lock이 필요한것이다. 
그래서 lock이 두가지가 된다. 하나는 write할때 exclusive lock, 나혼자서 화장실을 쓴다. 다른 write도 못들어오고 다른 read도 못들어온다. 내가 쓰고 있는 중이니까!  
reading 할때는 shared lock이다. 화장실을 같이 쓴다. 읽기만 하는 놈끼리는 write는 막아줘야 한다. shared lock이다. 
그림을 참고하고, 새로운 형태의 mutual exclusion이 등장을 하게 된다. write lock은 우리가 예전에 배웠던 pthread mutex lock이랑 비슷하다. 혼자들어간것이니까! 
새로 나온것이 reader's lock이다. shared lock이라고 하는데 reader끼리는 받아준다. writer는 밖에서 기다려야한다. 이후에는 os시간에서 배울껀데 기아가 생긴다고한다. read가 3명이 들어가 있다. write가 10시에 도착을 했다. write는 못들어간다. write가 와서 한참 기다리고 있는데 read가 끝날때쯤해서 다른 reader가 자꾸 들어가는 거야 그러면 꼬리에 꼬리를 물고 read가 들어가면 write가 굶주리게 된다. 기아(starvation)이라고 한다.
불공평하다. 나중에 해결해야한다. 시프에서는 read/write lock을 쓰는 예제에 대해서만 말한다. 

## File/Record Lock
이것을 할때 사용하는것이 fcntl 이라는 함수이다. file control 의 약자다. 
struct flock *lock ....
record lock은는 파일에다 lock을 거는건데 file 이 만약에 10만 바이트다. 10만 바이트를 내가 한꺼번에 access 할 수있냐? 그렇지 않다. db면 홍길동의 record를 쓴다하면 파일의 일부분만 쓴다. 그것을 쓸대 그 부분에 대해서만 lock을 걸어야 한다. 그것을 record lock이라고 한다. 할일을할때 내 account만 lock을 걸어야 한다. 파일이 굉장히 큰데 일부분만 lock을 거는것을 record lock이라고 하고 file lock은 파일 전체에 대해서 다거는것이다.
우리가 여기서 말하고자 하는건 record lock을 의미한다. 
cmd 에 getlock이라는것은 지금 lock이 걸려있는지 뭐가 걸려있는지 물어보는것이다. setlock은 화장실에 들어갈려고 하는것이다. mutex lock하고 같은것이다. 그런데, lock이 이미 걸려있으면 error가 리턴된다.(화장실이 이미다 찼다.) 다찼으니까 다른데로 가봐라, 우리가 쓸껀 화장실이 차있으면, 기달려야 한다. lock을 걸려다 실패하면 w는 wait해라.(아마도 F_SETLKW) 언제까지 lock이 풀릴때까지 내가 lock을 획득할 수 있을때까지 기다려라 할때 쓰는것이 SETLKW 이다. cmd로 이것들을 쓰고자 한다. struct flock *lock은 lock의 종류를 넣는다. fcntl.h에 define 되어있는데 이것은 아까 lock의 종류가 몇가지 있었냐? reader's lock, writers lock, unlock 3가지를 define한다. 

## File lock
구조체를 보면 처음에 타입에는 reader's lock을 걸껀지 writer's lock을 걸껀지 아니면 lock을 푸는건지 화장실 나올때는 lock을 풀어야 한다. 그다음에 lock을 걸때 파일이 이렇게 있으면 
여기에 홍길동이란 record가 있다고 하면 여기서부터 여기까지 무엇을 걸어야 하나? lock을 걸어야 한다. 일부분만 걸기위해서 여기보면 start 
off_t l_start; 이게 start offset을 나타내는것이고 
off_t l_len; 이것은 길이를 나타낸다.
어디서부터 얼마나 lock을 걸어달라냐 이것인데 
start position을 잡을때 3가지 옵션이 있다. 
1. seek_set이 있는데 start를 100이라고 줬으면 파일의 시작부분부터 100바이트를 가서 lock을 걸어라 이말이다. 시작점을 기준으로 해서 
2. seek_cur는 파일이 있으면 현재의 read/write offset이 있는데 현재 위치의 offset에서부터 start만큼 가란 말이다. seek_set은 처음서부터 가라는 말이고, 
3. seek_end는 파일의 맨뒤에서부터 얼마만큼 가라 이런말이다. 

당연히 seek_set을 많이쓴다. 주어진 length만큼만 그부분에 대해서 lock을 일부분만 걸어달라 이말이다. 내가 여기다가 writer's lock을 걸면 그동안에는 아무도 못건들인다. reader's lock을 걸면 read는 들어오지만 write는 기다려야 한다. 그래서 lock의 종류를 배운것이고 
pid는 위에서 getlock, lock이 걸려있는지 안걸려있는지, pid는 이 lock을 누가 가지고 있는지 리턴된다. 화장실에 어떤 프로세스 가 들어가있는지 알려준다.

## Record Processing
파일이 struct record에 집합으로 구성되어있다고 치자. 가정하면, 하나의 레코드는 이름 주민등록번호 잔액 이게 100개니까 100개까지 있는 파일이라고 가정한다. 그런데 이게 100개까지 있으면 sizeof(struct) 하면 나오는 byte 수가 대충 28바이트 정도 될텐데 이것이 일정한다고 했냐, 안일정하냐고 했냐 일정하지 않다. cpu마다 달라서 반드시 그길이는 sizeof(struct record)로 물어봐야지 진짜 길이가 나온다. 이런게 쭉 몇개가 있냐면, 파일속에 100개가 있다. 가정은 계좌번호는 0번에서부터 99번까지 있다고 가정한다. 0번 계좌번호를 쓰는 사람은 제일 앞에 있는것이고 99번 쓰는 사람은 record의 맨뒤에 있는것이다. 그래서 계좌번호를 받으면 lseek을 통해서 쫓아가면 access를 할 수 있다. db로 하면 이렇게 하지 않는다. 우리는 계좌번호가 5번이 들어오면, 몇번째 위치로 가냐면 파일 레코드가 28바이트면 5*28만큼 가야된다. 실제 데이터베이스를 그걸 가지고 찾냐? 그렇게 하지 않는다. 홍길동이란 이름을 가지고 찾는다. 그건 db에서 하는 일이고 우리는 random access 한다. 그래서 가정하는것은 계좌번호 0번에서부터 99번까지 있고 쭉 일렬로 있다고 가정한다. record processing은 이렇게 한다. 파일을 가져다 open했고, 파일 포인터로 만들어서 이것을 재오픈했다. record_no를 0번에서부터 99번까지 있다고 했다. 그것을 record number로 받는다. 이것을 하면 enter키가 들어가서 getchar()를 집어넣는데 enter키를 날려버릴려고 
그래서 record number가 0에서부터 100보다 작아야 찾을 수 있는데 그래서 만약에 50번이 들어왔다 치면 50번째 레코드는 어디에 위치하고 있느냐 레코드번호 50 곱하기 sizeof(struct record) 가 28바이트면 50*28만큼 앞으로 가야지 50번째 record가 있다. 그위치가 position으로 계산이 된다.(pos)

레코드의 길이 * 레코드의 번호를 가지고 pos를 계산을 했다. 가는게 시험문제에서도 나왔다 싶이 fseek, seek, lseek 파일 포인터를 쓰니까 fseek를 써줬다. 만약에 그냥 시스템콜을 쓸려하면 lseek를 써야한다. 

fseek을 쓰고 그 position으로 날아간다. read/write offset을 옮긴다. 기준은 파일의 앞을 기준으로 한다. 그리고 읽는다. 얼마만큼 읽어야 하나면 current에 sizeof(struct record)만큼 읽어야 한다. 그것을 한개를 읽어라 의미이다. 

시험문제에 integer를 파일에 쓰라하면 몇 바이트씩 써야하나, 4byte씩 써야 하는데 4byte를 쓰는것보다 sizeof(int) 라고 써야한다. sizeof(record)만큼 하나를 읽는다. display_record(&current)라는것은 이안에 있는것을 이름하고 계좌번호하고 잔액을 display 해주는 루틴이라고 가정하자. 

그래서 이것을 update 할것이냐, 지금 조회한것이다.업데이트는 할것이냐 는 예금 하나 넣으실꺼에요? 찾을꺼에요? 물어본것이다. yes라고 치면 yes 인지 no인지 받았어. 받은게 yes면 if 하겠다. 그러면 record의 내용이 바뀐다. 다시 써야한다. 그러면
그래서, current에 새로운것을 받아온다. 새로운 balance를 받아오는것이라 루틴이라고 치자. 키보드에서 입력받아서 받아오면 홍길동이란 레코드를 무엇으로 계산해서 왔냐면, record_no * sizeof(struct record) 로 왔는데 (포지션만큼) fseek를 통해서 왔는데 날라와서 read를 했다. read로 했으니까 offset이 일로 갈것이다. write는 어디에다 해야하나? 다시 돌아와서 써야한다. 여기다 쓸려고 하면 그러니까 다시 fseek를 또하고 있다. 그래서 offset을 돌려놓고 나서 fseek를 통해서 돌려놓고 나면 그다음에 fwrite를해서 record를 쓰고 있다. 그런 loop을 돌고있는 example 이다. 

## Critical Section
이번에 pthread에도 나왔다 싶이, 이 프로그램이 하나만 돌아가면 괜찬은데 atm 머신이 여러개 있다. 동시에 똑같은 동작에 대해서 같이 access하게 되면 당연히 race_condition이 생겨서 mutual exclusion문제가 생긴다. 
그래서 processA가 read를읽어서 잔액을 읽어서 update balance를 하고 이것을 disk에다 save하는 3개의 동작으로 구분되는데 프로세스 b도 마찬가지고 이것이 얽혀서 일어나면 하나가 날라가버린다. 이전에 했던 내용이다. 그러니까 lock을 걸어야 한다. 여태까지는 mutex lock을 걸었는데 이제 배운것! reader's lock 하고 writer's lock을 배웠다. 조회만 하는 애는 read's lock을 걸어야 하고 예금 을 하거나 뭔가를 찾아가는 놈은 뭘써야 한다. 그것은 writer's lock을 거는것으로 바꿔야 한다. 그래서 record locking은 !

## Record locking
inquiry는 조회한다. 의미이다. 조회할땐 변하는게 없으니까 reader's lock을 건다. 그러나 예금 하거나 withdraw 하는것은 이것은 writer's lock을 건다. 이것보다 복잡한것은 송금할때는 인터넷에서 찾아서 저쪽에다 쓰는거니까 양쪽에다 다 lcok을 걸어야 한다. 할때 

## Example
그래서 예를 들어서 수도코드를 보면 이게 atm머신이다 하면 조회를 할때는 reader's lock을 걸고 이미 누가 write를 하고 있으면 그얘기는 block된다. 그러나 누가 read를 하고 있으면 그것은 read가 들어갈 수 가 있다. 
lock은 record 단위로 하지만, 만약에 lock이 요기만 걸려있어서 요곳만 lock이 걸린다해도 못들어간다. 당연히

deposit하고 withdraw은 writer's lock을 건다.나올때는 unlock을 한다. 

앞에서본것과 똑같은것이다.
records 100이고 만일에 계좌번호의 일련순으로 파일을 구성했다고 하면 record 안에는 id와 name과 balance 가 있고 record가 100개가 있다.
그래서 그게 account 파일에 있다고 가정을 하고 loop을 돌면서 account number을 받아들인다. account number는 0번에서부터 99번까지다. 그러면 똑같이 만일에 inquiry다. 그런데에는 record lock을 거는데 reader's lock을 건다. 그런다음에 pos를 해서 찾아가서 lseek를 해서 찾아가서 읽어서 display하고 다했으니까 unlock을 하면된다. 앞에서 lock을 걸때는 무슨함수를 사용한다고 했냐면 fcntl을 사용한다고 했다. 그게 사용하기 복잡해서 만든 루틴이다. 요런것이 있다고 가정하다. 나중에 설명한다. 

++record lock을 걸어주세요, 어느 record 번호하고 record의 길이를 주고 거기에 대해서 reader's lock을 걸어달라 ++

그다음에 deposit 할때에는 writer's lock을 건다. 그래서 record lock을 거는데 해당 record의 길이를 주고 writer's lock을 걸고 그다음에 그 record를 찾아가서 읽기를 하고 읽기를 하고 다시 써야하는데 그럼 다시 도도림질 해야한다. (돌아간다는 의미같다.) 그래서 다시 lseek를 하고 새로운 내용, account가 증가가 된 내용을 record를 다시 파일에다가 쓰고 다했으니까 파일을 unlock을 해서 풀어준다. 

그래서 아까 말한 record lock이란 함수를 어떻게 만들었냐 하면 이것은 결국 무엇을 골라야 하느냐 아까 얘기했듯이 file contorl이라는것을 불러야 한다. 복잡해서 이렇게 만들어 놓은건데 type이 reader's lock이냐 writer's lock이냐 unlock이냐에 따라서 type을 가져다 setting을 하고 file lock에 type을 setting을 하고 거는 위치는 파일의 처음을 기준으로 한다. start point는 record number * record length로 하면 될것이고 길이는 record의 length로한다. (길이) 그래서 이것을 가지고 fcntl을 부르면 파일의 이런 부분에 대해서 reader's lock이 걸리거나 writer's lock이 걸리거나 lock을 unlock한다라는 루틴이 된다. 

## POSIX Read-Write Locks
조금 전까지 한것은 뭐냐면 원래 전통적으로 리눅스나 유닉스에 있었던 시스템콜이고 posix에서 pthread를 위해서 reader's , writer's lock을 새로만들어줬다. 이것 역시 menual을 보면된다. 똑같은 의미이니까 pthread_read, wirte lock system에 readlock을 걸어달라는 의미이다. 요곳은 writer's lock을 걸어달라는 의미이고 
요곳은 reader's lock을 unlock하는것이고 writer's lock을 unlock하는것이다.
posix에서도 쓸수있다. 요것은 file에다 거는게 아니라 variable에 걸때도(mutex가 필요한이유, count variable을 공유하기때문에) count에 대해서 읽기만 하는애한테는 reader's lock을 걸고 count를 변화시키는 애는 writer's lock을 걸어야 한다. 그래야지 시스템이 read가 많이 돌아갈때는 performance가 동시에 돌아가니까 시스템이 빨라진다. 

