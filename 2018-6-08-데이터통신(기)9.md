---
post : layout
layout : 데이터통신(기)9
---
## 숙제
이부분, 제너레이터와 체커 
저런 방식으로 어 했을때 저런 표가 나올수있는 배경을 어 설명해라
배경 그래서 인터넷을 열심히 찾아서 해결책을 들고왔다. 
신드롬 비트에 따라서 신드롬 비트가 최대 0부터 7까지 나오는데 신드롬 표현되는 부분에 대해서 오류에 대해서 위치를 어떻게 아느냐가 이번시간에 과제다 그렇기 위해서는 저희가 처음에 신드롬 비트 체커 부분을 보면 s0 는 b2 b1 b0 q0 를 모두 모듈러 2 연산을 이용해서 s0 s1 s2를 모두 구하게 되는데 그 연산은 사실 모두 모든 비트들에 exclusive or 연산으로 가능하다고 제가 찾았고 이제 그 제가 그 인터넷에서 조사를 해온결과 q0 와 q1 그리고 q2를 구하기 위해서는 체커 부분에서 이제 b3 ~ b0 까지 있었고 그 뒤에 이제 3자리 비트 q2 q1 q0 있었는데 그 큐를 구하는 방법들이 이 밴다이어 그램을 통해서 나타낼 수가 있다. 어 이제 b0 b1 b2 b3 가 이제 원래 저희가 구해야하는 비트였기 떄문에 어 이 비트들을 모두 이제 이 밴다이어 그램내에서 모두 exclusive or 연산으로 혹은 모듈러 2 연산으로 해도 동일하게 나온다. 그렇게 해서 q0 의 경우에는  b0 b1 b2를 모두 exclusive or 연산을 한 결과값이고 q1에 경우에는 b1 b2 b3의  exclusive or랑 q2의 경우에는 b1 b2 b3 exclusive or 연산이 나온다.
그렇게 이제 데이터 이외에 패리티 비트 q들을 모두 구할수있게 되고 그이후에 신드롬비트는 이렇게 도형, 벤다이어그램에서 원끼리 원하나 둘 셋이 있는데 이 원끼리 원에 있는 원소들끼리에 모두 exclusive of 을 해야 된다. 그렇게 되면 s0는 b0 b1 b2 q0 이렇게 모두 체커에 나와있는 신드롬 식같이 모두 exclusive or을 하게 된다고 나와있다. 그렇게 해서 s0 s1 s2 이렇게 구하게 되면은 신드롬 비트에 대한것이 나오게 되고 이제 그다음으로 오류의 위치를 어떻게 구하느냐 인데 신드롬비트를 보게 되면 모두 겹치는 부분이 b1이 모두 겹치게 된다. 여기 이 밴다이어 그램에 보면은 b1이 모두 겹쳐있는 부분이다. 그전에 q0 q1 q2가 저희 책에 나와있는 q2 q1 q0 이렇게 나와있게 되는데 패리티 비트의 경우에는 모든 2의 좌승 형태에 부분에 오류를 검출할 수있따. q0는 2의 0 승 q1는 2의 1승인 2 q2는 2의 2승인 경우인 4 부분에 오류를 검출할 수 있게되고 그 이외에 어 이제 원래 데이터 부분들에 오류 부분을 구할려면 이제 b1 이 모두 겹치기 떄문에 제일 큰수라고 생각하면된다. 정확하게 설명을 완전하게 말씀드리기는 헷갈린다. 모든 경우에는 s0 s1 s2 에서 b1이 모두 겹치게 되므로 b1 의 부분은 제일 큰 수인 7 부분 에서 오유를 검출하게 된다. 그 후에 q0 와 q1 부분이 낮은 낮은 2의 오류부분을 검출하는거였기때문에 낮은 쪽을 검출할 수있다고 생각하면되고 그 둘이 겹치는 부분인 b2가 있따. 낮은 부분이기 떄문에 1 2 그이외에 제일 낮은 부분인 3 부분을 검출할 수있다고 일단은 제가 구했고 
위 쪽에서 검출할때 b0 부분이 s0 와 s2가 겹치는데 이부분은 q0 ??가 제일 높은데 여기서는 q0와 q2 부분이므로 두번쨰로 낮은 5부분에 오류를 검출할수있다. 라고 생각을 했고 b3의 경우에 는 s0과 s2가 겹치기 떄문에 이 부분을 검출할수있다고 제가 일단은 찾아 봤다. 
// 큰 원덩어리를 각각 s0 s1 s2라고 생각하면 겹치는 부분중에 제일 큰 부분에 대해서 오류를 검출할수있고(표를참조) 예외적으로 3개가 겹치는 부분중에 동시에 3개가 겹치는것을 오류로 검출할수가 있다.

## 쉽게 접근하자
자 사실 여기 어 마지막에 이은 
실제 우리가 이런 원리로 만들어 졌다는 게 중요한데
어 한번 보죠 이게 예들이 이 조합들이 S0 
s0 = b2+b1+b0+q1
이런식으로 s1 s2 
이런 누구들을 묶어서 저걸 만들었느냐 비밀이 그속에 있다. 
모듈러 2연산이라고 하면 지금 보내고자 하는 이 a 가 받았을때는 b다 에러가 발생했을 지도 모르니까 문자를 표현을 바꿨을 뿐이지 a가 b다. 
애당초 만들때 이거 어떻게 만들었냐 하면은 a에 이 3비트를 모듈러 2연산을 해서 나온값을 r값을 줬단 얘기는 이 속에 1이 짝수개 있으면 얘를 0로 주는것이고 홀수개 있으면 1을 준다.
지금 그런 연산이다.따라서 모두 더하면 
0이된다. 1의 개수 가 짝수가 되게 만드는 어 만드는셈이 된다. 얘는 
그렇죠 여기 3개가 들어있을때 1의 개수가 홀수면 여기 1 짝수면 0
그래서 이 4개를 더하면 결국 1의 개수가 짝수가 되게 만드는 그런것이다.
여기서 지금 다 더하고 있다. 더하고 있는 요 내용들이 요게 곧 얘를 다 더한거에 a0 a1 a2 더한게 r0 죠
그게 곧 표현이 바꿨지 r이 q로 바꼇지 
q0 b0 b1 b2 
얘들 4개합은 곧 얘들 4개합이다. 
그러면 가다가 가는사이에 에러가 발생하지 않았다 라고 하면 애당초 얘들 합이 어떤식으로 만들어 졌냐면 0이 되게 만들어진것이다 모듈러 2연산 
1의 개수가 짝수가 되게 얘가 만들어진거니까 모두 더하면 0이다. 
0이되면 이 에러가 없으니 얘들의 합이 0이 되서 여기 0이 나와야 되는것이고 
얘도 마찬가지다. 얘도 요 4개를 더한것이다. 보낼때 만들어진 요 4개 
두번째 요기 4개를 더한개 바로 s1이다. 
그래 이속에 에러가 없었으면 당연히 만들어지기를 0이 되게 만든것이기 떄문에 여기도 0이 나와야 된다. 여기도 마찬가지다. 여기도 이게 가는사이에 에러가 없었다면 0이 나와야 된다.
요 셋이 q0 q1 q2 그리고 b0~b7 까지 7비트 7비트가 이 속에 다들어있다. 요속에 
그래서 가는사이에 누군가가 에러가 발생했으면 어디선가 0이 아닌값이 하나 나오게 만들어준다. 
이게 만들어진 원리를 설명하면 뭐 이렇게 좀 수식을 써가면서 설명하면 물론 이런 부분은 
어 이게 아득한 얘기지만 이게 그 속에 숨어있는 도대체 의미가 뭔가를 찾아보면 훨씬더 쉬운 것을 쉽게 이 문제를 이해할 수있다는것을 알수있다.
자 방금 여기 생각해보자 q0에 가령 가다가 q0 여기 패리티 를 붙인 이놈이 에러가 발생했다. q0가 0인데 1이 되어버렸다. 그러면 받은쪽에서 기다라할떄 ?? q0가 있는 부분에 0이 아닌 1이 된다 이거임 그놈이 그 에러가 발생한 놈이 있는 줄에 있는 sum에서 0이 아닌 1이 나오게 되는것이다 가령 q0가 에러가 발생했다. 그러면 여기 당연히 여기 한비트만 에러 발생한거 일단 가정해야되 
q0는 여기 하나밖에 없다 이거지 
다른 곳에는 없다 이거임 따라서 여기만 1이고 나머지는 0 0 1 그러면 0 1 1 
0 0 1 이면 q0가 에러다 이렇게 찾아낼수있다. 001 q0 에러인것이다. 가령 111이다. 이 몽땅 세비트가 다 에러가 있다면 신드롬 이 111 그러면 에러가 발생한놈이 여기도 있고 여기도 있고 여기도 있단얘기지 그놈을 찾으란 말이다. 그게 바로 다 여기도 있고 여기도 있고 여기도 있는놈 찾아보면 b1 이다. b1이 여기 3군대 다있다. 그래서 b1이다.
이 원리가 이거다. 여기다 찾아봐라 110 이다. 가령 신드롬이 110 이다. 그럼 두번째와 세번째 있고 여기는 없어야 된다. 에러가 발생한게 그놈을 찾아내면 된다. 여긴 없는데 여기와 여긴 있는 놈 
뭐죠? b3 가 있다.
여긴 b3없죠. 
따라서 110 이면 b3 이다. 되는것이다.
이렇게 각각 그 
바로 이그림인데 이 그림 
이게 인제 만드는 원리 인데 이게 이 그림에 이런 것을 머릿속에 두고 만들어주는데 만들어진걸
이이 만들어지는 과정을 이해했지만 도대체 해석이 안되는 케이스고 난 거꾸로 생각하겠다. 이건 생각안하고 기본적으로 에러가 발생한 위치에 있는 놈 ,근데 에러가발생하지 않으면 없는것 이렇게 찾아내보면 바로 이표가 정확히 만들어진다 이거임
이 그 이런 좋은 아이디어를 그 들여다 보는게 재미있다. 전에 1학년떄 배운 패리티 
이 
ppt 참고 
이 첫번쨰 
10 개 쭉 나갈때 2의 몇승에 해당하는 자리에는 패리티를 놓고 나머지 자리에는 데이터를 계속 집어넣는식으로 패리티4 고 여기는 
 여기는 패리티 3이다. 여기는 데이터 5 데이터 10 가령 데이터 6비트를 보내는데 우리 1학년 때 배운 해밍코드에 의하면 패리티 비트를 이와같이 대체 해야 하기때문에 내가 6비트를 보내야될 상황이면 패리티를 4개를 집어넣어야 한다.  이 자리들에 
 4개를 집어넣고 보낸다. 4개를 집어넣고 보내
 이렇게 해서 보냈을때 에러가 체크하는 방법이 뭐냐면 여기도 신드롬 구하고 있죠 거기서도 에러 체크하는방법이 일일 히있었다 이거죠
 에러1 뭐 이렇게 자 어느놈들을 어 우리가 뭐 묶어 내느냐 이것을 구해서 어, 그 최종적으로 얘가 여기는 4비트니까 c4까지 가요 c4 c4는 뭐다 
이렇게 해서 이 신드롬이 이 해밍코드에 의한 신드롬이 이 4비트이다. 4비트가 c4, c3, c2, c1이 나타내는 값이 에러가 발생하는 위치가 된다. 저게 0000이면 에러가 없단 얘기고 이게 0이 아닌숫자가 나오면 가령 9가 나왔다. 9 라는게 1001 이죠 이 값이 1001 이 나오면 9번쨰 이놈이 에러가 발생했다. 이렇게 찾아내는 아이디어 가 있었다 이 1학년때 해밍코드 에서 우리가 배운내용이다. 이게 
이럴때도 과연 이게 어떻게 에러가 발생한 위치를 알려줄까 비밀은 바로 이속에 있다.
누구들을 썸을 했느냐 그거죠 누구들을 여기 이 조합을 누구들을 썸을 했을때 나오냐 이거임
가령 9는 1001 이죠 
자 에러가 요기에 발생하면 뭐 얘는 지금 어떻게 그떄 그 어... exclusive or죠 여기도 
여기도 아마 exclusive or일것이야 여기서도 이렇게 발생할 경우에 9라는걸 나타내는 방법 뭐 내가 그 여기에는 이 그 어 하튼 
명확히 생각이 안나는데 여기서도 이 해밍코드도 이 조합들이 다 다르죠 여기 이 조합 이 조합 이 조합이 다 다르다. 근데 그게 구지 외워서 할 필욘 없고 어 여기 바이너리 넘버에서 그 왜 00 4비트면은 0000~1111 갈떄 자 맨 아랫 자리가 어 이떄 뭐더라 어떻게 해야되죠 생각이 안나네 기억나는 사람이 있어요 해밍코드 1학년 떄 배운 해밍코드 
이 그 
이 조합속에 
생각이 안나는데 깊이 들어가지 맙시다.
원리가 그거다 이 조합속에는 어떤 위치가 나타날 수있는 어떤 조합들로 아이디어가 그거다 이거죠 
어떤 놈들을 여기 조합을 통해서 만들어 내느냐 라는거죠 그속에 비밀들이 있고 이것과는 살펴보면 어 이 재미있는 얘기가 이속에 있을 수있다는것이다.

지금 저 이책에서는 하여튼 해밍코드라고 부르는데 좀 스타일이 다르다. 여기서 보여주는 해밍코드는 바로 이런 지금 우리가 살펴본 그런 원리에 기반을 두고 있다.
이런 문제를 여러분들이 이렇게 인터넷에 찾아보면 사실 이런 인터넷 에 요즘엔 뭐 없는 내용이 없네 보니까 이런 내용들 까지 다있단 얘기란 말이야
어 소화를 해야되겠지 그런 내용을 찾았으면 잘 소화를 해야되는데 
어 잘 고민을 해봐야 한다. 이해안되면
너무 시간을 
지난번에 했듯이 이번 토요일날 캡스톤 발표가 있다 10시에 관심있는 사람 나와서 보셈
기존에 컴공과 

캡스톤 설계 60점 못받으면 그 다음 학기 60점을받은사람만 그다음 학기에 졸업논문을 써서 졸업을 할수있음 60점을 못받은 사람은 1년을 기다려야 한다. 캡스톤 설계에서 60점을 못넘으면 졸업할 자격이 안된다. 굉장히 심각한 과목이다. 그래서 캡스톤설계를 매학기연다. 2학기떄도 연다. 4-2 에도 캡스톤 과목을 열기로 했다. 1학기떄 과락한 사람이 1년을 기다려야 하니까 
다시 논문을 제출할 자격을 받을수있는기회를 준다. 미리미리 3-2 학기부터 기초설계 과목을 통해서 준비를 하는게 중요하다. 
학부 규정이다. 컴전학부 규정 
디정 출신이 많다. 남학생 디정과출신
그경우에는 기존의 방식도 있다. 이거 한번 물어봐야 겠다. 학부 규정은 위와 같이 정해져 있다.

## 
지난시간에 사이클링 리던던씨 체크라고 하는 에러 디텍션 방식에 대해서 기본적인 개념을 설명을 했다. 그런데 칠판이 너무 낮은자리에 내가 써갔고 뭐 안보이는 사람도 있었을것이고 근데 슬라이드 에 있는 내용이니까 잠깐 그 내용만 복습하고 이 사이클링 리던던씨 체크가 보여주는 능력을 한번 보도록 하자
이 슬라이드에 얘를 저번에 완벽하게 내가 들지를 않았는데 가령 이런것이다.

## 사이클링 리던던씨 체크
1 0 0 1 1 가령 내가 5비트를 보낼려고 하는데 디바이저가 디바이저가 그떄 얘기한 디바이저가 뭐 가령 3비트다 그러면 101 라고 하는 디바이저를 갖고 내가 저 5비트를 어 보내고자 한다. 그러면 이 리던던씨를 어떻게 붙일까 를 어이제 고민을 하는게 바로 센더쪽이다. 
리던던씨를 어떻게 붙일까 이 리던던씨를 붙이는 방법은 이거였죠 이거를 이놈이 이 로테이션이 여기서 지금 어 m이라고 하죠 
그러면은 얘가 지금 3비트면 2비트, 2의 n승 * m 두 자리를 만들어준다. 이 n 이 이 예에서는 2^2 * m이라고 하자 그러면 이 m 이라는 데이터를 왼쪽으로 쉬프트 두자리를 하고 오른쪽에 두자리를 빈자리르 만들어놓는다. 이 2비트를 쉬프트 시키고 추가시킨다. 오른쪽에 
이 자리에 무엇을 넣느냐 하면은 바로 m 이 값을 이 렇게 나눈 나눠서 나온 q와 이 r이라고하는 이 나머지가 나온다. 이거임 나머지는 당연히 얘보다 한자리 
얘 자리수 보다 작아야 된다. 가령 지난번에 봤듯이 101 을 101로 나누면 이건 나눠지는것이다 111이면 어떻게 되 이 비트가 111이면 자 나눗셈 한번 111 해보죠 101 
그러면 101 자 요기서 연산은 모듈러 2 연산 
이게 서로 이게 다른놈 1 0 이라고 하는 나머지가 나온다. 이렇게 된다. 
이렇게 된다. 그래서 요게 나머지고 이게
이게 나머지고 나머지를 여기다 집어넣는다. 
여기 r 0 1 r 1 을 집어넣어서 보낸다.
r 제로 일 알원을 집어넣어서 보낸다. 
얘가 곧 나머지다 이거죠 
나머지를 집어넣어서 보내면 보내면 이제 가는 어 이 나머지를 집어넣어서 보낸다 얘기는 
2의 2승 * M + R을 넣어서 보낸다. 나머지를 보낸다 얘기 
그러면 받은쪽에서는 이거를 또 다시 나눈다 그랬다. 나눴을때 바로 얘는 얘로 바로 이거죠 이거 
이거잔아 똑같죠 Q+R/G 이고 얘때문에 생긴놈이 R/G 자 이 모듈러 2연산을 해서 같은 놈을 더하면 없어진다 이거임 제로가 된다.
그래서 Q 나누어 떨어진다 이거임 
내가 보낸 그대로 보낸 그대로 전송이 되면 받는쪽에서 G로 나눴을떄 나머지가 없어야 된다. 가령 여기에 나머지 에러가 발생했다 라고 하자. 그럼 여기에 우리가 에러를 넣어죠 여기에
우리가 지금 이 여기에 아까 우리 01 이었나 가령 이런식으로 예를들어서 정확히 얘를 이걸로 나눈 나머지 를 여기다 집어넣어야하는데 지금 그건 정확하게 다짐?? 하죠 어차피 모듈러 2 연산을 한번 나눗셈을 해보는게 중요하니까
과연 여기에 들어갈것이 무엇일까 한번 찾아보면 자요 10011을 00을 두자리르 추가한것을 2의 두자리를 추가한것을 101 로 나눈다 이거임 
M을 나눈것이 아니라 2의 n승의 m을 g로 나눈 나머지를 구하는것이다.
이렇게 두자리가 추가된것이다. 자 1 101 
이거 어떻게 계산하죠 여기 
여기까지는 같죠 ? 여기가 1이 나오지 자 0 여기 같고 (what..?) 1 1 1 이죠 그러면 101 이거 모듈 2 연산을 이렇게 여러번 해봐야 한다. 이거 헷갈려져 
1 0 0 이죠 그러면 여기에 1 0 1 여기에 이제 차이가 난다. 여기 0 이고 10이 나온다. 여기 까지는 0이고 
이게 몫이고 나머지가 더이상 나눌 수가 없다. 나눠지가 않죠 그럼 말그대로 10이 나올것이고 10 
10이 이거 나머지를 저 자리에 집어넣는다. 이게 나머지를 넣었다. 좀 작게 그려야 하겠네 이것을 
그럼 저기에 그대로 이제 목적지로간다. 
저 저 저렇게 나눠진 값이다. 나머지를 추가시킨 값이 그대로 목적지로 간다. 목적지에서 이게 왔다 그러면 에러가 없다라고하면 정말 나눠지는지 한번 보자.
10001 을 나누기 작게 그려야겠네 똑같은 디바이저로 나눈다 101 
이거 안나눠지면 곤란한데
101 자 여기는 여기까지는 없고 
이제 111이죠 그럼 1101 
자 101 여기에 1 
101 
뭐 0이네 없죠 내용아 0 이고 더이상 없다. 나눠진다 이검 101로 나눠진다 이거임 그렇죠 여기 000 여기는 쭉 내려온값이 다 0이죠 나눠지는데 가령 여기에 어 에러가 이 발생했다 라고 하면 에러 패턴을 어 어떻게 얘기하냐면 우리가 이 받은값 속에 에러가 발생했다 +  에러다. 에러는 어떤 자리에든 발생할 수있다. 가령 에러가 여기도 발생하고 여기도 발생하고 두군데 발생했다 라고 치죠 그러면 
여기가 0 이 아니고 1이 왔고 맨마지막 자리도 혹시 0 이아니고 1이왔다. 자 이런식으로 했을떄 일종에 나눠지느냐 당연히 안나눠져요 안나눠져야하는데 나눠질수도 있다. 지금 내가 여기 표현 한게 바로 2의 n*m 더하기 r + e 이렇게 되는거죠 이렇게
내가 지금 어디어디 에러가 발생했었냐면 원래 00 이었는데 여기에 에러가 발생했다라는건 여기에 11 이된거다. 그럼 에러패턴은 10001 이렇게 표현할수있다. 요놈이 나누기 G를 했을때 Q+ e/G 남는데 이 놈이 이놈으로 나눠지느냐 이게 광건이다. 에러가 발생을했죠? 에러가 
내가 지금 요기도 발생하고 요기도 발생했는데 에러의 에러 표현하는 방식은 10001 이렇게 표현되요 그러면 나의 관심은 과연 10001 에러가 101로 나눠지느냐? 나눠져 여기서 나눠져 운이 나쁘게 나눠진다 하면 여기서는 나머지가 없기때문에 에러가 없다라고 판단 
CRC도 에러를 100% 체크할 수 있는게아니라 발생한 에러패턴이 운좋게도 나눠지면 디바이저로 나눠지면 에러를 판독할 방법이 없다.
에러가 없다고 판독한다. 
받아들이게 된다. 요 경우에 한번 계산을 해보면 이경우는 과연 체크를 할 수있을까 
10001 , 101을 
자 101 
이거 에러 안나눠진다. 나눠진다. 이거죠 
이경우에는 완벽하게 에러검출이 안되는 케이스
내가 운좋게 만들었는데 여기 
7비트를 보낼떄 요비트와 요비트의 에러가 발생하는 경우에는 내가 디바이저를 이걸 쓰고있으면 101 
에러검출이 안되는 에러검출이 안되는 독특한 에러 패턴이 되는것이다.
어떻게 우연히 만들었는데 이게 정말 에러가 이게 정확히 검출이 안된다. 이런 케이스는 드문 케이스인데 우연히 만들었는데 그렇게 됬다.
그래서 이렇게 되는 경우를 확률적으로 따져봐야되 
과연 이렇게 나누어질 수있는 케이스는 확률적으로 뭐 몇분에 1이냐 이런값들을 살펴봐야겠쬬 그런 내용이 우리책에 따라가다 보면 뒤에 있다. 
자 이 그내용을 한번 살펴보자 CRC 인제 큰 그림은 전체 알앗죠 
## 정리
이렇게 쉬프트 시켜서 나누는 디바이저 보다 한 비트적은 자리만큼 새로 집어넣는데 그 자리에 집어넣을것은 바로 얘로 나눴을떄 나머지를 넣어서 보낸다. 
받은쪽에서도 받은것을 나누는데 에러가 없으면 나머지가 없어야 하는데 에러가 발생했을떄 바로 이 텀이 생기는데 이 텀이 나눠지면 운나쁘게도 나눠지면 에러 없다고 생각하게 되는거고 안나눠지면 결국 이 전체 계산에서 나머지가 생기기 떄문에 아 이건 에러가 발생했다 라고 한놈 을 뺴야한다. 전체적인 CRC 에 큰그림이 이것이다.
이렇게 미리 설명하고 나면은 CRC에 대한 얘기가 쉽다. CRC에 대한 얘기를 해봅시다. 이것을 큰 그림으로 표현하면 이것이다. 4비트를 보내는데 4비트를 자 여기 디바이저로 4비트를 쓰고있다. 
## Figure 10.16 Division in the CRC decoder for two cases
G 내가 우린 이제 3비트를 썻는데 여기는 4비트를 쓰고있다. 4비트를 쓰고 있다면 리던던씨를 붙일 자리가 얘보다 하나작은 3자리가 생긴다. 그래서 이게 전체 7비트를 보내는것이다. 7비트를 보내면 받은쪽에서 역시 무슨일을 하느냐? 체커 이 디바이저로 이거를 나눈다. 나눴을때 신드롬이 나오죠 나머지가 나오지.
나머지
이게 나머지다
이 나머지가 없다 라고하면 데이터를 사용할수있는거고 나머지가 있다라는것은 버리고 
지금 crc는 그런 큰틀을 가지고 있다.
어 여기 지금 사례가 있다. 모듈러 2연산 여러번 해봐야 한다고 했는데 여러분들 한번 봐요 
지금 1001 보내는데 디바이저 1011  이렇게 4비트 짜리를 썻다. 그래서 이렇게 나눠보는거죠 지금 
근데 뭘 나누느냐? 얘보다 하나 작은 작은수만큼 000 붙인 수 내가 보내고자 하는 데이터 뒤에 세자리를 더 붙여서 그 수를 1011로 나누면 쭉 계산해보면 나머지가 110 이라는게 나온다. 110을 붙여서 보낸다. 이거를 
3비트를 4비트에 붙여서 7비트를 보낸다.
그러면 저 7비트를 받은쪽에서 에러가 없었으면 그대로 왔으면 이와같이 쭉 나눠보면 나머지가 0다. 이게 신드롬이다. 
나머지라는게 신드롬 여기서는 신드롬이 나머지다.
자 여기에 에러가 없다 얘기임.
에러가 없으면 요놈만 갔으니까 그러면 당연히 나눠질수밖에 없다 이거임 우리가 모듈러 2 연산에 의해서 그런데 이와같이 에러가 발생했죠? 여기 
요놈이 1이 아니라 0
그러면 또 우리 모듈러 2연산을 나눗셈을 쭉해보면 당연히 에러가 안나눠질수도있고 나눠질수도있는데 
우리가 앞에 이케이스 했는데 안나눠지는 케이스 가 어떻게 우연히 나왔는데 나눠지는 케이스가 
지금 여기 안나눠지는 케이스가 되는거죠 
지금 나눠보면은 
보다싶이 나머지가 000이아니라 다른 값이 나왔다.
자 신드롬이 0 이 아니다. 그러면 버린다. 디스카드 한다. 
이 케이스 에는 에러패턴이 바로 4번째 자리에 에러가 발생한것이다. 저기서 에러비트는 결국 저놈은 뭐냐하면 에러를 1001 로 표현할 수있다. 1000으로 표현할수있다. 
왼쪽에 오른쪽에서부터 4번쨰 자리에 에러가 발생했으니까 에러가 이거다 이것이지 
그렇죠 이 어떤 있는 수에 이걸 더하면은 바로 요놈 요놈이 지금 여기가 1이면 0이 되버리고 0이면 1이 되고 따라서 에러패턴은 요렇게 표현할 수있다. 저식에서 
그럼 바로 이에러 패턴이 저기서 얘기하는 디바이저 1011로 안나눠지는거지 
저 케이스에서 안나눠지는거지 
그러다 보니까 이와 같이 그 버릴수있게 된것이다. 이게 기본적인 crc 고 
crc로 이 문장이 이제 내가 추가시킨 기본원리다 이것이야 crc의 기본원리
자 이런것은 넘어가고 


## Figure 10.22 CRC division using polynomials
이런 연산을 좀 그 우리가 그 폴리노미얼로 바꾸면 좀 연산이 수월하다 그런 의미에서 폴리노미얼을 소개하고 있다. 이렇게 바이너리 넘버를 쓸게 아니라 
아까 방금에 내가 에러패턴이 아까 저 이 에러패턴이 이렇게 표현했죠 그 앞에 이 예로부터 나온 에러패턴 4번째 자리에 에러가 발생했다. 이런표현을 이렇게 쓰는거 도 있지만 자 여기에 x의 0승 x의 1승 x의 2승 ...x의 3승 에 해당하는 ??? 생각하면은 
자 이 케이스는 x의 3승으로 표현하것이다. 
아까 디바이저는 1011 이다. 이거는 뭐죠? x의 0승 1승 2승 3승 x의 3승 더하기 x 더하기 1이죠
얘 표현은 폴리노미얼로 바꾸면 이런식으로 표현이 된다. 그러니까 이앞에 여기 계수가 1
여기에 x의 3승에 대한 계수 x 4승에 대한 계수 x의 오른쪽부터 x의 0 승 1승 2승 3승에 대한 계수들을 생각하면 0이 계수인놈은 없어지고 1인 계수인 놈만 살아남는다. 그러면 x에 대한 3차식에 모양이 나온다.우리가 수학에서 이런 x에 대한 함수로 표현했을때 나누거나 곱하거나 이런게 좀 수월하니까 한번 이렇게 표현해서 어 얘기를 하자는것이다. 에러패턴은 x의 3승이고 디바이저는 x의 3승 더하기 x더하기 1이라고 하는 폴리노미얼 형태를 보는것이다.
그럼 x의 3승이 당연히 이런 폴리노미얼로 나눠지지 않을수있다는것은 알수있다. 
이 로테이션을 앞으로 좀 사용을 해요, 편리하기 떄문에 
단순히 어.. 바이너리 넘버를 바이너리 스피드??(스트림) 라고해야죠 1 과 0 으로 이루어진 바이너리 스트림을 폴리노미얼로 한번 바꿔서 표현해보자 하는것이다. 여기 계수가 0인놈은 없이고 계수가 1인놈들만 살아남아서 어 폴리노미얼로 표현하면 x의 6승더하기 x + 1 이게 더 색다르다 이거다. 이거보다는 더 간단하다. 

그래서 앞에 있었던 그 이 모듈러 2연산을 이연산을 이렇게 하지말고 폴리노미얼로 바꿔서 계산해보면 
x의 6승 더하기 x의 3승 
6승 더하기 3승을 x 제곱 더하기 x 3승더하기 x 더하기 1 로 나눈 식으로 바꿔서 어 한번 계산할 수있죠 바로 그게 폴리노미얼로 바꾼다음에 앞에 했던 연산을 또하기 연산을 한것이다 ?? 
이것봐요 이게 더 간단하다. 포리노미얼로 표현해서 이게 나오면 자 
x의 3승 요놈이 3승만 동들어갈수있죠 
x 3승하면 이렇게 되죠 
역시 모듈러 2연산이라서 빈자리에 x의 4승이 내려오고 그러면 여기는 x의 3승이니까 x만 곱하면 x의 4승 롱간에서? 얘가 나온거죠? 
얘가 리메인드다. 당연히 이 나머지는 디바이저 보다차수가 하나 가 최소한 하나가 작아야 한다.
역시 x 3승이 또있다 그러면 또 나눌수있잔아 나머지는 당연히 디바이저 보다 차수가 하나 이상은 낮어야 하는 그런놈이 나오게 된다. 그러면 얘를 붙여서 보낸다. 아까 안에 바이너리 넘버 계산한것과 똑같은 모양인데 요렇게 간단하게 표현할수가 있다. 이해하죠 ? 포리노미얼로 바꿔서 표현한다 이거임 연산을 쉽게 하기 위해서 다른게 아니라 
그리고 이런 뒤에 이제 crc가 어떤 에러체크 확률을 갖느냐를 얘기할때도 저런 폴리노미얼로 사용하는게 훨씬 얘기가 쉽다. 
그래서 저 폴리노미얼 지금 소개하고 있는것이다. 
crc가 ???
자 그럼 지금부터는 어 과연 이 막강하다고 하는 crc 방식이 어떤 능력을 갖느냐? 이 G라고하는놈이 있었죠 디바이저 
얘가 굉장히 중요한 요소다. 이 디바이저가 디바이저가 무엇이냐에 따라서 이 CRC가 다른 에러 체크하는 능력이 얼마나 되는지를 어 좌우한다. 그래서 여기에 디바이저가 바로 이 나누는놈 나누는 놈을 뭘 선택할까 지금 어떻게 선택할까 이런 얘기를 할려고 하는것이다.

사이클링 코드에서 디바이저는 제너레이터 폴리노미얼 제너레이터 라고 한다면 우리 이미 제너레이터 했어요

이 신드롬이 0이 아니면 나머지가 0이 아니면 당연히 에러가 있다. 에러가 없다면 신드롬이 0라고 하면 정말 에러가 없거나 또는 에러가 있음에도 불구하고 이 디바이저로 나누어지는 바람에 내가 에러가 없다고 놓쳐버리게 되는 케이스가 되는것이다. 바로 b 저 b번 문제에 때문에 우리가 이제 살펴봐야될 사연이 있다 이거임 

바로 내가 얘기했죠 에러 패턴이 G로 나누어지면 어쩔수없이 에러가 잡혀지지 않는다. 에러를 놓칠수밖에 없다. 그럼 과연 나누어질 이가 별로 나타나지 않을 패턴의G를 찾아내는게 우리가 어 할일이다. 자 제너레이터가 이거 앞부분에서 제너레이터가 갖여야될 조건들을 쭉 찾아보는거죠 
제너레이터는 어 하나 이상의 more than one 
하나 보다 많은 텀을 갖는다. 가령 제너레이터가 가령 x의 2승이다. 다시말해서 100 이다. 텀이 하나밖에 없다. 얘는 
110 이다 제너레이터가 110이다 텀이 2개가 있는것이다. 텀이 계수 이 바이너리로 표현했을때 0이 아닌놈이 0이 아닌놈을 지금 텀이라고 얘기하고 있다. 
그리고 자 0이 텀이 여러개있고 하나보다 많고 그리고 and 조건 x0에 계수가 1이면 다시말해서 x0는 바로 맨마지막 텀이죠. 
맨 아랫자리죠 따라서 저 저조건을 만족하는것들은 이런것이다.
가령 101 이거를 만족하는거야 그런데 100은 만족안한다. 이거죠
3개 그 
2개 의 템을 11 
텀이 지금 3개가 있죠, 만족하고 동시에 맨아랫자리가 x의 0승에 해당하는 자리가 1이면 저 아랫조건을 만족한다. 그런데 얘는 텀은 2개 하나보다 낮지만 맨 아랫자리가 0이에요 그럼 여기를 만족안한다. 그래서 지금 이 조건은 뭐냐 1이 하나이상이고 맨아랫자리가 1이면 
맨 아랫자리가 1이란 조건만 만족하면 여기 중요한 서능이 있다. 이 디바이저는 어떤 한 비트 짜리 에러도 다 찾아낼 수있다. 이거임 그게 무슨얘기냐? 어떤 한 비트 에러든 다찾아낼 수있다. 에러패턴은 내가 보낸값이 1100110 
이와같은 7자리인데 에러가 어디에 발생하든 에러도 역시 폴리노미얼로 표현한다.
가령 얘가 에러가 발생해서 1이됬다. 그러면 이 에러를 표현하기를 얘는 x의 0승 1승 2승 3승 4승 이거를 x의 4승으로 우리가 폴리노미얼 표현해요 아니면 1 0 0 0 0 이 들어가지 이렇게 표현하거나 아니면 x 4승이다. 이거죠 에러패턴이 지금 
이x라는 놈이 에러패턴이 이것이다. 
자 에러패턴이 내가 갖고있는 이 디바이저 의 패턴으로 디바이저 패턴으로 가령 101이다 라고하면 이게 x제곱 더하기 + 1 이다. 이렇게 표현한다. x의 좌승이 x의 제곱 더하기 1이라는 조건으로 나눠 지느냐? 절대 나눠질수없다 이거임
이렇게 한비트 에러가 어느 자리에 발생하던간에 
다시말해서 어느자리에 발생했던 어 하나만 발생하면은 에러는 x의 n승이 된다. 한 비트만 발생했으니까 텀이 하나밖에 없다. x의 n승은 x뭐 제곱더하기 1이라고 하는 디바이저로 나눠질수가 없다. 뭐 이런 얘기를 하는것이다. 저런 얘기가 어떻게 나왔을까 이제 수학적으로 들어가야 한다. 이런게 안나눠진다. 
이런 위에 분자가 x에 대한 한텀이고 분모가 적어도 x제로승에 대한 계수가 1이고 하나더 항이 더있으면 이렇게 좌승이든 삼승이든 오승이든 하나 더있으면 요 한텀은 나눠질수없다 이런 얘기가 된다.
나눠진다는 게 뭐죠?
나눠진다는건 이속에 얘와 인수분할 햇을떄 인수분할했을때 얘가 이속에 들어가 있어야한다. (분모가 분자를 의미하는듯)
이 x의 n승이라는놈이 저거로 나눠진단 얘기는 x의 n승이라는 놈이 적어도 x에 제곱 더하기 1 과 뭐 이런식으로 되면은 얘는 이걸로 나누면 나눠지는거죠 
얘가 몫이고 
다시말해서 x의 n승이 얘를 요런 인수분해했을때 얘가 그 인수분해 중에 한 요소가 되야 나눠진다. 
근데 수학적으로 봤을때 이속에는 얘가 있을수가 없다. 왜그럴까? 왜그럴까 이런식으로 x의 어 항이 하나밖에 없으면 x제곱 더하기 1이라고 하는 이 값이 나올수 없단 얘기임 
이 인수가 이속에 없다. 이 속에 없단 얘기임 
이걸 수학적으로 증명해야 할텐데 나도 증명을 이런 케이스 한번 볼까요?

## 케이스
가령 x의 3승 이다. 
요케이스를 보자 지금 x의 3승인데 이승이 또 어쨋든 이속에 이게 들어갈 수 없단 얘긴데 이런 그 그냥 이 증명은 아니지만 어 맞다 라는 걸 보여줄수있다. x의 n승은 가령 내가 지금 x 3승 더하기 1이라는 디바이저를 갖고 있다. 라고 했을때 과연 이렇게 이게 나눠지느냐 내가 디바이저를 이걸 가지고 있을떄 나눠지느냔 얘기는 이렇게 인수분해가 될수있느냐 이런얘기다. 이게 될수없는게 간단하게 됨
x에 -1을 한번 넣어보자 x에 -1 
이게 equal이 된단 얘기는 양쪽이 어떤 값을 넣어도 만족시켜된다. x에 -1을 집어넣으면 여기는 얼마죠? 여긴 0지 0로
여기 근데 -1을 넣으면 -1의 n승이야 0가 될수가 없다 이거임 따라서 이런 인수분해는 될수가 없다 이말임 
저 텀이 하나밖에 없으면 그래서 지금 디바이저가 이 x 제로승에 해당되는 계수가 1이고 한 텀 적어도 최소한 하나 더 있으면 모든 싱글에러는 다 잡아낼수 있다. 다시 말해서 안나눠 진다. 
얘기를 하고있다. 굉장히 중요한 한 비트에러가 무조건 무조건 다잡아야 된다는 얘기죠?? 
그뒤에 한 비트 에러갖고는 부족하다 여러가지 얘기가 있다. 이제 5분만 쉬고 crc에 더 나갈 수있도록한다.

## Example 10.15
자 다시 
자 우리가 계속 디바이저 에 조건을 찾는 일이다. 디바이저의 조건 제일 먼저 나오는게 G라는 디바이저 조건 G 
어떤 조건을 가져야 되느냐? 두개이상의 어 텀을 갖고 맨 아랫자리 x의 0승에 해당하는 자리는 반드시 1이 있으면 한 비트는 에러는 반드시 찾아낼수있다 라는 조건은 우리가 갖고있다 이말임
예를들어서 G를 이와같은 형태 이같은 형태 
이런 선택을 했을떄 과연 어떤 능력이 있을까를 보면 얘는 지금 우리가 본 조건을 만족한다. 만족하는 조건이죠 두개이상이고 어 맨 아래 항이 1이고 이경우에는 어떤 한비트 싱글에러든 다 잘 잡아낼수있다.
반면에 이 항이없고 얘만 갖고 있다 가령 G를 x 3승이라고 한다. 라고 하면은 얘는 어떤 어떤 문제가 있쬬 G가 x의 3승이다. 이게 없단 얘기임 
이게 맨 아랫자리에 없고 한텀으로 한다는것
그리고 G를 x의 3승이라고 하면 무슨 문제가 발생할까? x의 3승으로 가지면 이걸로 나눠질 수있는 에러 패턴은 무궁무진하다. 무궁무진하지 x의 6승 ,x의 3승 당연히 x 나눠지잔아, 몫이 나눠지잔아 x의 4승도 나눠지는거야? 나눠지죠 x의 
그러니까 자기보다 x의 3승이면 에러패턴이 한 비트 에러임에도 불구하고 x 3승 도 나눠지니까 안되고 x 4승부터 쭉해서 뭐 모든 에러 패턴이 다 얘로 나눠진다 얘기임 
그럼 에러 체크가 안된다 굉장히 무성의한 디바이저의 선택임 
무성의한 디바이저의 선택임 
나눠지는거 한번 x의4승이 x의 3승으로 나눠진다 얘기하나요? 어 x의 4승이 x의 3승으로 나눠지냐? 4승이 3승으로 나눠지나?  x*x^3/x^3 
x의 x의 4승 음? 0 
나눠지는것이다. 몫이 x고 나머지는 0다. 
저거를 바이너리로표현하면 오히려 1, 0승 1승 2승 3승 4승 우리가 x하기를 0승 1승 2승 3승 
자 나눠지나 보자 이거죠
1000 해서 0이네 나눠진다 이거임 
그럼 몫은 어떻게 표현할까? 몫이 1이 의미하는 바는 10 이어야 하는데 아 여기에 이만큼이 있고 요 자리가 요자리에 와야 된다. 요자리에 0000이니까 0으로 10이 몫이 된다. 그래서 x가 몫이 된다.
x가 몫이고 나머지가 요 항은 없어지는거고 음 
나머지가 이 0가 된다. 
텀이 하나밖에 없으면 G는 싱글 비트에러를 뭐 잡을 방법이 없다. 이경우에는 가장 바보스러운 선택 왜냐하면 모든것이 다 나눠지잔아 G를 1로, 1이라는 값으로선택하는건 말도안된다 저거는 모든게 나눠지니까 선택이 안되고 

자 그럼 싱글비트 에러가 아니라 이제 이게 뚝떨어져있는 2비트에러가 발생하는 케이스를 과연 이 그 crc는 어떻게 체크할까 저거를 잡아내기 위한 조건은 뭘까를 한번 살펴보자 저게 중요하다 뭐 몇비트를 보냈는데 그중에 한 비트 만 딱 어느자리에 에러가 발생했다 이것도 물론 발생할 수 케이스 일수있겠지만 뚝떨어져있는 두 자리에 걸쳐서 에러가 발생했을 경우에 과연 저거를 잡아낼수있느냐 이게 중요한 관건이다. 이게 burst error 가 되는거죠 뚝떨어져 있는 여기 지금 두비트 , 두개의 서로 떨어져있는 십육인?? 에러. 자 요놈

## Figure 10.23 Representation of two isolated single-bit errors using polynomials
우리가 이런걸 폴리노미얼로 표현하면은 어 좀 쉬워요 가령 이 x의 0부터 시작해서 x의 i승 요자리에 에러가 하나 발생하고 x의 j승에 또 에러가 발생하면 에러 패턴은 x 의 j승 에러를 우리가 폴리노미얼로 표현하면 x의 j승 더하기 x의 i승이 되는것이지 
그렇죠 맞아요?
이렇게 표현하죠 이거는 분명히 차수가 j가 높은거죠 j가 더 크다 i가 작고 따라서 x의 i로 포괄?? 하면 x의 j-i 더하기 1 이런 모양이 에러패턴이 된다. 왜구지 인수분해를 왜하느냐 
자얘를 지금 내가 G(x), 어떤 내가 이 걸 나누어질 디바이저로 나누고자 한다이거임 그럼 내가 관심이 어딨냐면 과연 얘가 나눠질까를 보는데 우리가 요고를 딱 끼워서?? 생각할수있다. 요놈은 싱글 비트 에러 하나로 ??? 시킬수있다. 자 싱글 비트 에러 하나를 체크하기 위해서는 걸러내기 위한 조건이 뭐였냐? 이 아까 조건이 뭐였어? 싱글 비트 에러를 
여기 싱글비트에러가 다없잔아 i라는 자리에 하나 에러가 발생한거를 나타내는것이다. 그럼 얘의 조건은 더하기 1 

x 제로 승에 대한 자리가 1이고 여기에 텀하나가 최소한 하나 더있으면 얘는 안나눠진다 이거임 우리가 G(x)가 이조건만 만족하면 이거는 볼필요가없고 과연 얘를 나눌수있느냐 이게 이제 관심이 되는거다 이제부터는 얘는 버려도되 얘는 잊어버려도 된다. 얘가 나눠지느냐 이거임 
이 G로 싱글 비트 에러 이 조건 
이거는 두비트만 해당되는게 아니죠 
가령 저기에 두비트만 얘기했는데 이 중간에 이 i와 j사이에 다른 자리에 또 있었다. 그러면 역시 이걸 계속 더하는거죠 
여기에 x의 k승도 있고 뭐 x의 L승도 있고 어쩃든 그렇다 해도 제일 작은 텀인 x의 i승으로 빼면 요속에 어떤 폴리노미얼 항이 더해질 뿐이다. 그렇죠 여기에 x의 k-i 승 더하기 x의 뭐 L-i승 요놈들이 더있다그러면 에러가 더있다면 저 사이에 쪼개서 이 폴리노미얼 차수 이 항만 많아질 뿐이지 
이와같이 이걸 인수분해 포괄해도 마찬가지라 이말임??
제일 작은 차수의 항으로 일단 뽑아낸다음에 이렇게 표현할수있쬬

자 여기 슬라이드 에 두개만 있으니까 무시하고 
없다 생각하고 이렇게 투표하면?? 우린 바로 관건은 얘라 이거임 얘가 과연 나눠질 수있는 조건이 뭘까 를 살펴본다.

## 
당연히 이 디바이저가 제너레이터, 이 디바이저가 요 j-i 라고 하는 이 값을 일반적인 여기 지금 뭐라고 하죠, t 승 
이런 다항식이 G로 나눠지지 않는다면 그럼 당연히 두개 떨어져 있는 i와 j자리에 떨어져있는 두개의 이 떨어져있는 더블에러는 당연히 디텍션이 될수있다. 
이게 나눠질 소지가 있다. 가령 이게 j가 뭐 요 값이 x의 5승 더하기 1이다. 뭐 예를들어서 이값이 5다. 이거임 
그러면 x의 5승 더하기 +1 이 x 제곱 더하기 1 
과연 이걸로 나눠질까 안나눠질까를 한번 생각해보는것이다. 
그러면 이 얘기해서는 얘가 이걸로 안나눠지면 당연히 에러를 디텍션할수가 있다.
6자리가 떨어져있는 에러를 디텍션 할수있다.(j=6 i=1)

## Example 10.16
나눠질수있는 조건이 뭘까? 
나눠질수있는 조건 어 뭐 좀 더 상세한 내용은 뒤에 
여기 지금 순서대로 보죠 책에 있는대로 
제너레이터를 다음과 같은 이런 4가지 상태가 있을때 과연 어떤 능력이 있는가를 본다. 
제너레이터를 x+1 아주 간단한 폼이다. 
우리가 지금 얻어낼 수있는 가장 간단하고 이 상수항이 1이고 더하기 한텀이 더있는것 근데 그걸 x로 받았다. 
이거임 이것은 좀 너무 빈약한 표현이다. 상태이다. 이거임
왜냐하면 이런 식으로 표현하면 서로 붙어있는 에러는 찾아낼 방법이 다 나눠지는것이다. 
우리가 에러패턴이 지금 여기 떨어져있는 j자리와 i자리 이븐 ?? 패턴을 얘기했는데 혹시 붙어있으면 j가 여기 붙어있으면 어떻게 되냐? 
이자리가 아니라 서로 j가 바로 붙어있으면 이렇게 
그럼 여기 x에 뭐 j승 더하기 x의 i승은 x의 i승을 빼면은 x 더하기 1 
x 더하기 1이 된다. (붙어있으니까)
이거 붙어있으면 차수가 1차 밖에 차이가 안난다.

그래서 인수분해 하면은 이모양이 나와야하는데 이게 근데 x 플러스 1을 우리가 제너레이터로 갖고있으면 나눠지잔아. 
x+1 은 굉장히 안좋은선택이다. 바로 이웃한 두개의 에러는 나눠지기 떄문에 거취??할수없다 이말이다.

근데 x에 이제 차수를 높여서 x의 t승 + 1 이다. 
자 4승이다. 음 x에 4승 더하기 일

얘는 최소한 내가 보장하는데 
x에 4승 더하기 1 최소한 x의 t승 더하기 1인데 요놈이 4보다 작으면 
다시 말해서 3승 2승 1승 0 승 안나눠진다.
분모가 더 차수가 크니까 안나눠진다. 
여러분들이 얘기하는바가 내가 제너레이터를 x의4승 더하기 1을 받으면 
적어도 이 x의 3승이 나올자리는 뭐죠? 
이 값이 3이될 3 2 1 까지는 안나눠진다. 
이게 의미하는바가 뭐야? 서로 떨어진 자리 어 자리 죠
j와 i가 지금 발생된 어 이 차이 = 이게 중요함

j-i 가령 여기가 지금 어 j-i를 요개수 보다 하나더 큰 것이다. 예를들어보면 서로 이웃한게 있으면 j
이웃한게있으면 빼기 1 을 하면 1이죠 
그런데 그 사이에 아무것도 없잔아 바로 옆에 있는거잖아 바로 몇자리 떨어져있는게아니라 바로 옆자리니까 
그러니까 j-i-1 자리만큼 떨어져있는 이런얘기가 된다. 

j-i 가 이 두개 에러가 몇자리 떨어져있느냐? j-i-1 자리 만큼 떨어져있는것이다.
그렇게 얘기를한다. 두자리 떨어져있다는 얘기는 뭐야 두자리 떨어져있으면 
이거 뺴기 이거는 1승 2승 3승이나까 3승 

j-i-1 다시말해서 
다시 말해서 x의 4승 +1 이면 x의 3승 부터 다 분할?? 할수있으니까 지금 뭐야 이 4 포지션 이거 4포지션 떨어져있는것은 찾아 낼수없다. (여기서부터 이유가 나온다)
 
당연한 얘기아니야 x의 4승 더하기 1 
4포인트잔아 x의 4승 더하기 일이 x의 4승 더하기 1 하고 당연히 나눠지니까 안된다 이말임 그렇죠 저거는 나눠질수없는데 적어도 그거보다 적은 차수는 다?? 안나눠지니까 이 에러를 디텍션할 수있는것이고 자 이런 형식이 있을수있다.

3 텀이 있어요 이거 굉장히 굿 초이스다.
그거를 더 많아서?? 차수를 훨씬 높이면 이와같이 높이면 더 좋은 선택이 된다. 그래서 여기지금 우리 굳이 계산을 하진 않지만 가령 비교를 해보자 이거임 이 러한 식으로 우리가 디바이저를 우리가 갖고 있으면 이것은 어 

가령 두자리 떨어져있는 숫자들 t가 32768 이 숫자보다 작으면 다 안나눠진다 얘기임 
이 폴리노미얼은 두 비트 에러가 발생했는데 두비트 에러 사이가 32768 이내에 있는놈들은 다 걸러낸다. 거의 2비트 에러는 다 차지한다. 이거임 
이거 계산을 해봐야 겠찌만 이러한 것들이 나왔고 
다시말해서 에러가 발생했는데 그 에러 간격이 32768 개 이내면 다 걸러낼수있다.
자 이게 뭐야 얘는 굿초이스라고만 얘기했는데 얘는 이렇게 확률적으로 얘기를 보여주고 있다. 
우리가 결국 비용을 더 낸다. 얘기임
점점 차수가 올라간다. 
얘를 바이너리 넘버로 바꾸면은 15승 자리에 1, 14승 자리에 1, 13승 12 10 9 8 7 6 5 4 3 2 1 이 디바이저를 이걸 쓴다 얘기임 이걸 쓴다임

몇 비트를 쓰는거야? 16비트를 쓰는거야 
디바이저를 무려 16비트 짜리를 디바이저로 쓴다.
내가 가령 보내는 데이터가 2비트인데 이런것을 쓸리가 없다.
이 물론 데이터를 많이 보내는데 이정도 디바이저를 쓰면 그러면 16비트를 디바이저를 쓰면 리던던씨는 15비트가 된다. 디바이저가 16비트니까 리던던씨는 15비트다. 
그럼 내가 보내고자 하는 데이터뒤에 리던던씨를 15비트씩 붙여서 보낸다. 15비트는 나머지다. 이걸로 보내고자 하는 메시지를 나눈 나머지를 붙여서 보낸다. (crc원리를 조금 생각해보면 쉬움)
비용은 굉장히 많이 든다. 패리티 체크는 한 비트 한 비트 하나 보내는거였다. 
짝수냐 홀수냐 알아보기 위해서 한비트 그거에 비해서 16비트나 붙여서 보내는것이 능력이 굉장히 뛰어날것이다. 보여주고있다.

## 메모
또 두번째 재미난 특성은 제너레이터인데 x+1이란 놈을 인수분해 했을때 저 텀을 가지고 있으면 모든 홀수개 에러는 다 체크할수있다. 
이건 또 어디서 나올얘길까 저게 다시 저게 무슨말이냐
G(x)가 crc를 이렇게 G(X)란 놈이
G(x)가 인수분해했을때 x+1 을 갖고 또 여기 뒤에 무슨 항이 있는 이런 케이스 라고 하면 이렇다고 하면 이놈은 이위에 나눌떄 분자에 어떤 수식이 있던간에 이 수식이 무슨얘기에요? 
홀수개의 에러는 다 잡아 낼수있다. 여기 텀이 홀수개 있딴얘기임 

텀이 홀수개 에러가 발생한 개수가 홀수개 
그럼 이 에러패턴이 에러패턴에 텀의 개수가홀수개다. 홀수개 여기에 예를들어서 x의 3승 더하기 x 더하기 1 이런식으로 홀수개가 있다면 G(X)가 이텀만 가지고있으면 모든 홀수개는 다 사용할 수있다. 에러가 발생한 
다시말해서 안나눠진다.
이놈이 이런형태라고 한다면 나눠지지 않는다.

왜 ? 한번 생각해볼까? 이게 어떻게 
좀 저런 장담을 할수있을까? 수학적으로 증명을 해야할텐데 얘는 절대 이텀을 안나눠진다. 
다시말해서 얘는 인수분해를 해보면 얘가 있을수없다. 이말임 

이속에 얘가 있을수가 없다.
홀수개면 얘가 있을수가 없다.
얘가 있으면 없어지잔아 그럼 이거 있으나 없으나 소용없는거죠 얘는 이속에는 이 텀이 없다 이거죠 
자 이것도 증명을 못하겠지만 수긍 할수있다 왜냐하면 내가 얘가 결코 얘텀을 안갖고 있다는것을 보여줄수있다 가령 이거 더하기 1이 가령 X+1 곱하기 뭐뭐라고 인수분해 될수있느냐? 될수없다. 
아까 즈이반?? 요게 
X의 -1을 넣어보면 안다
X의 -1을 넣어보면 얘는 제로지 
얘는 제로야 그러면 여기도 X에 -1 넣었을때 제로로 나와야 이 equality가 되는데 어떤 함수이든간에 x의 텀이 홀수개가 있으면 x-1 을 넣으면 0 가 안된다. 0가 안된다. 그래서 이텀을 갖을 수없다.
이텀이 인수분해 해봐야 이속에 없다라는거임 (분모가 x+1이고 분자가 x-1인것을 의미하는건가)

이렇게 뭐 내가 입증을 할수있지만 증명은 못하겠다. 요 수학을 들어가봐야한다. 지금 점점 G에 대한 조건이 중요한게 하나 생긴것이다 이텀을 반드시 가져야 하는데 아까는 있었던 조건이 뭐였냐면 x0에 대한 인수가 1 이고 텀이 하나 더있으면 되는데 

지금은 그것을 다 떠나서 이런 항을 갖고있고 뭐 그걸로 끝이면 너무 약한것이다. 이것만 갖고있으면 아까 아까 	
앞에 슬라이드에서 서로 이웃한 두개의 연속해서 발생한느 에러는 검출 안되 나눠지기 때문에 이것만 갖고있는게 아니라 더 그거와 또다른 텀이 또이렇게 인수분해 된 텀이 있어야 되는 되겠구나 라고 우리가 생각할수가 있다. 그렇죠 (x+1만 가지고는 단순히 나눠지는게 가까이 있는것은 에러를 찾을 수없음 하지만 이런식으로 x+1을 포함하고 있을경우는 모든 홀수 수에 대한 에러를 디텍션하는것이 가능한 이론에서는 x+1이라는 특정 텀에 대한 언급을 하면서 그 기능을 생각해볼 수있는것이다.)

자그러면 인제 최종적인 그 결론, 이제 그 적어도 g(x) 가 가져야될 조건은 이래야겠다 라고했는데 그다음에 이제 이런 저런 조건 과연 에러를 검출하지 못하는 확률이 뭔가를 샐펴보는 얘기가 있다.

## 필기
일반적으로 그 이 에러 패턴을 본다면 내가 데이터를 쭉 보내면 어느자리에든 에러가 발생할수있따. 
그러면 에러가 발생한 자리를 가령 여기 아무자리나 막 생각하자 이거다. 에러
이런식으로 에러가 발생했으면 과연 이 어떤 내가 갖고있는 디바이저가 쟤를 체크할수있을까 라는 확률적으로 살펴본다
자 이 경우에 에러에 대한 폴리노미얼을 표현하고 나서 
이제 저 나머지 이런 수식 x에 대한 폴리노미얼로 수식
수식 나눠지는지 안나눠지는지 확률적으로 표현할려고한다. 

여기에 0 1 2 이렇게 첫번째 자리로 0승
0 1 2 3 4 5 이게 x의 5승 더하기 6 7 8 9 10 
x의 10승 더하기 x의 12승 더하기 3 4 5 7 x의 15더하기 x의 17 이란거죠

이게 어떤 모양이 되든간에 최소 가장 작은 차수로 인수분해하면 항상 어떤 모양이 나오냐면 x에 0
고차수부터 쓰면 x의 12승 x의 10승 더하기 x의 7승 더하기 x의 5승 더하기 1 
항상 에러에 대한, 에러패턴이 어떻게 발생하든간에 에러 패턴을 폴리노미얼 을 쓰면 작은 차수로 인수분해하면 항상 이런 모양이 나온다. 그렇죠 여기 제일 작은 차수 그리고 나머지 묶은모양 
관심은 G(x)가 최소한 이 모양을 갖고있으면 이모양만 추가해서 갖고있으면 얘는 뭘할 수 있냐 이놈은 무조건 디텍션할 수있다. (x^5+...+1)
안나눠진다. 하나, 에러 한텀 하나는 안나눠진다. 그래서 얘는 무시하고 우리의 관심은 과연 얘가 내가 임의로 갖고있는 어떤 G(x)라는 이 디바이저를 과연 나눠질 확률이 어떻게 되는가를 살펴보는것이다. 
그게 저 표에 있다. 우리 목적은 이것은 얘는 무시하고 어떤 패턴이든간에 에러패턴은 바로 이런 수식을 갖는다. 이거죠 
두개든 세개든 네개든 몇개든 과연 내가 갖고 있는 G(x)로 나눠질 수있는 확률
확률을 찾는것이다. 
자 그거를 3가지로 지금 접근을 나눠서 얘기를 하고있다.
사실 이부분을 여러분들이 좀 스스로 공부해보고 어려운 내용을 확실히 자신이 고민하고 난 다음에 다음시간에 내가 설명을 해야 이게 더 의미가 있어보여서 여러분들에게 이 주제를 제시만 한다. 숙제는 안해 
이부분은 확실히 이해하고 나면은 여러분들이 먼저 고민을 해봐야 이거임 문제는 뭐냐하면 내가 명확하게 얘기할 수 있느냐 
이렇게 에러는 몇비트가 발생하든간에 

## 중요한 내용
에러는 몇비트가 발생하든 간에 최소항으로 인수분해 하면  요런 모양이 나온다. 요식이 과연 내가 갖고있는 G에 대한 식으로 나눠질 수있느냐? 자 여기 L이 머고 r이 뭐고 자 이런거 있죠 이 burst error 
burst error 가 바로 여기 서 여기까지 burst length 는 여기서부터 여기까지 burst length 이 바로 L이다 여기서 
여기서 여기까지 이 차이 이게 지금 우리 burst error 라는건 burst length 라는걸 가지고 있는데 에러가 발생한 전체길이가 burst length 이다. 이게 L이다 
저기서 얘기하는 L이 이것이다. r? r은 G, G(x)가 갖던 최고차항
G의 r 승 + 쭉해서 + 1 과연 이 G가 갖는 최고차항의 r이다.
이 L과 r과의 관계를 갖고 뭐 이런 확률값이 나온다. 
여러분들 책을 한번 보고 저 얘기를 반드시 자습해 보면서 한번 그 말로만 설명하면 L이 r이 차수가 높으면 
분모가 얘보다 분모의 차수가 높으면 당연히 안나눠진다.
분모의 차수가 분자보다 높으면 당연히 안나눠진다. 
너무 간단한 얘기다. 
여기 equal 이있는것은 같은 차수면은 왜 되느냐? 같은 차수가 
이 거리가 애매해 여기에 가령 
여기가 5번째고 여기가 지금 10번째 그러면 이 차이가 머야? 뺴기하면은 12죠 
그런데 자릿수로는 13개야 
자릿수로는 13임 
뺴면은 12인데 차수는 12인데 자릿수는 이와 같다. 그러면 이게 아마 
이 자리수가 L이 되나 
여러분들 책에서 한번 봐라
이 폴리노미얼 안에 이 최고차항이 L
equal이면 나눠질수있기때문에 저얘기는 어쩃든 이 폴리노미얼의 최고차수가 나누는 수의 최고차수보다 더 적은 조건으로 얘기한다 라는거임 
L에 대한 명확한 정의는 책을 통해서 봐라 
당연히 안나눠지니까 얘기가 되는데 그런데 문제는 이 두개는 바로 이놈이 이 차수가 얘보다 더 크면 나누어 봐야 할것아냐 
이 분모가 분모가 차수가 더 크다. 이거임 여기에 가령 
x의 7승더하기 x의 5승 더하기 1일때 여기 나눈놈을 x에 더하기 x 5승 더하기 x 4승 더하기 1이다. 나눠 봐야 될것아니냐 
이거는 나머지는 뗴고 몫이 나올수가 있다. 얘가 차수가 더 크니까 이런 경우에도 확률적으로 어떤 어떤 어떻ㄱ ㅔ얘기할수있느냐 이 조건들이 이런 경우에 a 이 차수가 얘와의 차이가 뭐 이런경우 이런 경우 확률이 이렇다. 

고민을 좀 해서 이게 어 이 내용을 좀 스스로 터득하기를 바라고 그렇다면은 그렇다면 어 그앞에 본 그게 거기에 따라서 이러한 폴리노미얼을 우리가 어떤 능력을 갖느냐 정리한것이다.

폴리노미얼을 x의 6승 더하기 1이다. 자 x의 6승 더하기 1이면 이 폴리노미얼은 쓰면은 G
당연히 x의 6승이니까 burst length가 6보다 작거나 같은놈은 다 걸러낼 수가 있다. 다시말해서 분자 차수가 x의 6승 보다 작은 차수가 나오는건 다 걸러낼 수가있다. 
그렇고 그리고 또 뭐 여기 음 확률 3/100 으로 burst length가 7인 어 에러는 걸러내지 못한다 이거임 
걸러내지 못하고 또 여기 계속 나오죠 확률 16/1000 으로 burst length가 8 또는 그거보다 더큰거 이 간격이 burst length가 8보다 같거나 더 큰 놈들에 burst error가 발생하면 요 폴리노미얼을 갖고는 확률이 16/1000 을 확률은 ???이다 이거임 나눠지드라 
자 이런 얘기를 할수있는것이다. 앞에 이걸 우리가 이해를 하고 나면 앞에 
저 얘기를 할수가 있다. 점점 폴리노미얼들이 복잡해 지죠 
b라는 놈을 갖고 있으면 폴리노미얼에 이런 이런 능력을 갖고있으면 쭉 따라가보면은 뭐 음 burst length가 18이내는 몽땅 다 잡아낼수가있고 100만 분에 8 만큼의 에러 손실 이 있을수있다.
burst length 가 19이면 burst length가 20보다 크거나 같은경우는 100만분에 4 만큼 놓칠 수있다. 
세번째 선택 이런 이런 이거는 지금 어 .. 32승이나 나왔죠 무려 여기 18승 까지 갔는데 이거는 32승까지 
제너레이터 차수가 훨씬 높아졌다 그러면 당연히 걸러낼 수있는 능력이 어마어마하다. 능력을 살펴보면은 n 버스트랭스가 32 비트이내 여기서 부터 여기까지가 거리가 32비트 이내 면은 다보낼수있고 이것도 굉장히 큰것이다. 
다보낼수있고 텐 빌리언 이면은 100억이다. 100억 분에 5만큼 놓칠게 있을 수있고 여기는 뭐야 100억 분에 3 의 확률로 100억 분에 3의 확률로 또 그 버스트 랭스가 33이상인 놈을 놓칠수있다. 100억 분에 3 정도 되면은 이거 받아들일수밖에 없지 않냐?
0의 확률로 모든 에러를 체크할 확률은 체크할 기술은 없다.

결국 나눠질 수있다. 이놈이 이놈과 나눠질 수있을 확률을 찾는것이다. 얘가 32승이 되면은 여기에 들어올 함수가 이걸로 나누어질 확률이 100억분에 5정도 되는 함수들이 있다 라는거임 
대단한것이다. 에러 놓칠 확률이 100억분에 5 정도 된다. 32비트 짜리 제너레이터를 쓰면 

## 메모
그래서 폴리노미얼 그 제너레이터에 조건을 여기다 쭉 정리를 했어 
지금까지 본것중에 쭉 정리를 해놓으면 적어도 제너레이터는 G라는 이 함수는 최소한 두개포함 포함 이산을 가져야하는데? 두개 텀을 가져야 되고 X0, 맨 오른쪽 자리에 항은 반드시 계수가 1이어야 되는 조건이 있어야 하고 그러니까 이 1이 지금 앞에 예를든거에 다있다.
맨 뒤에 항이 다 1이다.
여기는 여기도 1 여기도 1
+1이 항상 따라다닌다.
그리고 두개 이상이고
자 두개 이상이고 그리고 또 다른 조건이 있다.
어 X+1이라는 어 인수분해 텀을 가져야 하고 그리고 뭐 그런 조건들을 갖도록 우리가 이G(x)를 만들어야 한다.

## 표준다항식
실제 현장에서 쓰는 제너레이터 들의 모양들을 여기다 제공하고 있따 
이 표준 어 우리가 가령 crc를 어 crc 라는 그 헤더를 
crc라는 식을 쓰는데 8비트 짜리를 쓴다고 하면 표준이 되어있다. 8비트 짜리면 요런 요런 8차 제너레이터 라고 하면은 요런 유형의 제너레이터를 쓰자 어 
10비트 짜리 제너레이터라고하면은 요런 규격을 쓰자고 되어있고
16비트 짜리 이게 
32비트짜리는 이런거
이런거 쓰자고 되어있고 실제 어디에 쓰이느냐 
우리 데이터 링크레이어 에서 이 프레임 만들때 프레임 만들때 에러 체크용 필드를 주는데 그 에러 필드용 체크가 요만큼이 들어가게 되어있다.  HDLC라는 프로토콜 은 이자리만큼 만들어준다 이거임 
이 CRC를쓴다 이거임 요걸 이용해서 
LAN 에서는 32비트짜리 이런 CRC 제너레이터를 쓰고 
실제로 쓰고 있는 표준을 얘기하고있다. 어마어마한 검출 능력들이 있곘죠 이정도 되면은

## 체크썸
체크썸은 합을 내가 보낼 메시지들에 그 가령 8비트 또는 12비트로 쪼개도 얘를 쭉 더한 값을 같이 넣어서 보내면 받은 쪽에서는 똑같은 합산을 해봤을때 같은 합이 나오는 이거
지난번에 얘기했었다ㅣ 이거는 굉장히 좀 에러 발생될 확률이 
놓칠 확률이 좀 크다.
합 이 유지되는, 에러가 발생했음에도 합은 똑같이 유지될수있는 경우는 너무 많이 만들수있기 떄문에
중요한 부분은 아닌데 여기저기서 이걸 쓰고 있다.

## Figure 10.24 
내가 보낼 데이터 가 11뭐뭐뭐 이건데 자이런 썸이 36이다. 그런데 지금 보내고자 하는 이 값이 너무 크잔아 그러면 이것을 실제로 어떻게 보내냐면 
? 이렇게 바꿔서 보낸다. 원리가 뭐야 ? 36이 이거다 . 얘들을 7+10 뭐 이거 다 더하면 36이다. 바이너리 정보를 여기서 바꾸면 요런데 이 다 4비트 짜리 지금 그 워드 들인데 썸 도 4비트로 바꾸고 싶어 그러면 실제 16비트 의 지금 6비트죠 
따라서 위에 있는 2비트 를 아예 맨 아랫자리 두비트로 바꿔버려 
그리고 더해 그러면 0110 이 된다.
6이 된다. 실제 썸을 실제 썸을 보내는게 아니라 이런 후처리 한다음에 만들어진 이런 숫자를 썸에 자리에 넣어서 보낸다, 그런데 그것의 또 1의 보수를 취해서 보낸다. 
지금 이게 1의 보수를 취한건데 이 숫자 가 잘몼썼다 1001 이다.
넣어서 보내면 자 결국 하나 둘 셋 넷 다섯 개의 숫자와 요길이를 하나 집어넣을 자리가 체크섬이라고 해서 지금 제너레이션 을 통해서 만들어진 숫자를 집어넣는다. 그러면 여기는 받은쪽에서는 다 더하면된다. 이거까지 합해서 
다더하면 연산을 해보면 이거 얼마야 지금? 
이 연산이 지금 여기 뭐 원스 컴플리먼트 취하면 뭐 이러면서 뭐 헷갈리기도 하는데 취했을떄 몽땅 0이나오면 
얘들을 몽땅 더했을때 0000이 나오면 에러가 없는것이다. 뭐 이 로직을 여기 왜 넣어라고 
이놈들이 일로 가지고 오고 또 컴플리 먼트 다시 시키고 이게 엉망이다. 15인데 0110이야 1111이지 
이거의 컴플리먼트 시키면 0000이고 이게 검산하는 과정에 요 오타가 많다. 지금 오타가 많다. 
저 검산 제너레이션 하고 검산 체킹하는 그 과정에 뭐 어디서 원스 컴플리먼트 취하고 이런거는 살펴봐라 
예제가 계속 있으니까 쳌썸에 대한 것
10장을 끝낼려고 했는데 


## Forward Error Correction
crc까지는 디텍션이고 이제 포워딩 에러 커렉션 
에러 수정하는 어 부분은 우리가 이 에러 수정하는 부분은 지난번에 봤듯이 이런 방식에 해밍 디스턴스와 내가 수정할수있는 능력과의 관계가 바로 여기서 이 그림에서 나왔죠 이미 본 얘기를 다시 복습 하는것이다. 에러 커렉션 
한 비트 에러 커렉션 을 하기위해서는 적어도 두개보다 큰 자릿수 만큼의 해밍 디스턴스가 되어야 한다. 
자 이거 복습하는것이다. 이게 이 재미있는 익스클루시브 오알잉을 통해서 하는건데 자 에러 커렉션 방법으로 또 다른 방법을 하나 보여주고 있다.
요 아이디어만 우리 얘기를 하고 끝내죠 

자 내가 보낼 데이터가 가령 굉장히 큰데 굉장히 큰데 그거를 n개로 쪼개서 보냈다고 치자 
이 내가 보낼 데이터는 이만큼인데 이거를 쪼개서 
p1부터 pn까지 자 이거를 블락, 나눠서 보내는것이다. 나눠서 여기서 목적은 뭐냐? 가다가 이 중에 어느 블락 하나가 에러 가 발생했다 이거죠 여기에 에러가 발생헀으면 자 이놈이 에러가 발생헀어요 에러가 그러면 과연 이놈을 다른 놈들을 사용해서 저 에러 디텍션 된 이후에 복구해 낼수있을까 라를 얘끼하는것이다. 이 몇블락이야 이 요 원래값을 찾아낼 수있느냐 exclusive oring 하면 굉장히 재밌게 이거를 찾아낼수있다. 
무엇을 보내냐 면 여기다가 추가해서 뭘 하나 보내 냐면은 바로 이놈을 
r이라고 하는 모듈??? r이라는 하는 놈은 어떻게 만들어지느냐? 이놈들을 다 exlcuisve oring 했다.
이거죠 p1 eo(exclusive or) p2 or ... pn 모든 놈을 다 exclusive or한놈을 r이라고 해요 이놈을 여기 넣어서 보낸다. 
1011과 1101 자 exclusive or 하면 뭐죠 같은 자리는 0고 다른자리는 다른 비트는 0이고 이거야 
exclusive oring 한다는게 이런식으로 해서 여러개를 쭈욱 계속 exclusive oring 하면은 계속 저 만들어질수있다. 그래서 만들어진 이 i라는 놈을 같이 넣어서 보낸다. 그래서 받은쪽에서 봤떠니 디텍션해보니까 어 이놈이 pi가 에러 가 발생했더라 
과연 커렉션할수있을까? 저 놈 커렉션 가능할까? 커렉션 할수있다.
굉장히 재미있는 아이디어 다. 어떻게 커렉션 하느냐? 얘를 뺴고 나머지를 다 exclusive oring 하는거야 자 r을 포함해서 p1부터 다시 쭉 p2 ,,, pn 에러가 발생한 pi는 뺴고 pn까지 exclusive oring 하면 이게 pi다. 이게 ?? 야 
내가 받은 거 중에 에러가 발생한 요부분만 뺴고 나머지를 이 r까지 포함해서 exclusive oring하면은 그때 나온값이 pi다 . 
pi의 원래값 이 에러 발생하기 전의 원래값이 라는 얘기지 
어떻게 이럴 수있어? 커렉션 한거야 이거
어 고놈만 뺴고 나머지를 다 exclusive oring 하면은 원래의 pi를 찾아낼수있다.
어떻게가능해 이수식으로 설명할수있을까? 
이수식으로 이수식으로 증명할수있다. 
그럼 pi가 나온다. 얘가 뭐죠 r이 (얘지 얘쬬) 여기를 여기다 집어넣는다고 생각해보자 그러면 p1 도 두번더하고 2도 두번더하고 그렇죠 pn도 두번더하고 어 근데 두번 아닌 놈이 딱 하나 있죠 여기에 pi가 분명이 있음 여기에 pi
저놈들을 다 더해서 r을 구한다고 했으니까 근데 이 속에는 pi가 없다.
piㄱ ㅏ없다. 이속에는 여기로 가지고 오면은 이속에 pi가 없다. 내가 에러 발생한거는 뺑? 놓았다고 했다.이속에는 나머지들은 다 두개씩있는데 exclusive or는 똑같은 거 를 exclsuive or하면은 다 0다. 다 0로 없어져 자 여기만 있고 여기에만 없는 pi만 남는다. pi만 남는다. 결국 이연산을 하면 piㄱ ㅏ나온다 이거임 원래 pi 그래서 에러 커렉션이 된다. 
저 수식을 따라가면된다. 여기까지 
